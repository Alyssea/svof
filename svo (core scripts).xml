<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
    <TriggerPackage/>
    <TimerPackage/>
    <AliasPackage/>
    <ActionPackage/>
    <ScriptPackage>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>svo</name>
            <packageName></packageName>
            <script>svo = svo or {
  autopause_on_def = function() end,
  balanceless = {},
  disable_seek = function() end,
}

ndb = ndb or {}

createBuffer(&quot;svo_prompt&quot;)
</script>
            <eventHandlerList/>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo Internals</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>3rdparty</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>double_queue</name>
                        <packageName></packageName>
                        <script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;

-- This file is part of LuaNotify.

-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.

-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name ordered_set
-- @description DoubleQueue Class.
-- @author &lt;a href=&quot;mailto:tiagokatcipis@gmail.com&quot;&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href=&quot;mailto:paulo.pizarro@gmail.com&quot;&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local setmetatable = setmetatable
local pairs = pairs
local display = display

module(&quot;notify.double_queue&quot;)

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local DoubleQueue = {}

------------------------------------
-- Metamethods goes on this table --
------------------------------------
local DoubleQueue_mt = { __index = DoubleQueue }


--------------------------
-- Constructor function --
--------------------------

function new ()
    local object = {}
    -- set the metatable of the new object as the DoubleQueue_mt table (inherits DoubleQueue).
    setmetatable(object, DoubleQueue_mt)

    -- create all the instance state data.
    object.data          = {}
    object.data_position = {}
    object.first         = 1 
    object.last          = 0
    return object
end

---------------------------
-- Class private methods --
---------------------------
local function refresh_first(self)
    while(self.first &lt;= self.last) do
        if(self.data[self.first]) then
            return true
        end
        self.first = self.first + 1
    end
end


--------------------------
-- Class public methods --
--------------------------
function DoubleQueue:is_empty()
    return self.first &gt; self.last
end

function DoubleQueue:push_front(data)
    if(self.data_position[data]) then
        return
    end
    self.first = self.first - 1
    self.data[self.first]    = data
    self.data_position[data] = self.first
end

function DoubleQueue:push_back(data)
    if(self.data_position[data]) then
        return
    end
    self.last = self.last + 1
    self.data[self.last]     = data
    self.data_position[data] = self.last
end

function DoubleQueue:get_iterator()
    local first = self.first
    local function iterator()
        while(first &lt;= self.last) do
            local data = self.data[first]
            first = first + 1
            if(data) then
                return data
            end
        end    
    end 
    return iterator
end

function DoubleQueue:contains(data)
	return self.data_position[data] and true or false
end

function DoubleQueue:remove(data)
    if(not self.data_position[data]) then
        return 
    end
    self.data[self.data_position[data]] = nil
    self.data_position[data]            = nil
    refresh_first(self)
end

local function removeByValue(tbl, valueToRemove)
	for key, value in pairs(tbl) do
			if value == valueToRemove then
			  tbl[key] = nil
				return tbl
			end
	end
	
	return tbl
end

function DoubleQueue:removeIndex(position)
		if not self.data[position] then
			return
		end
		
    self.data[position] = nil		
    self.data_position  = removeByValue(self.data_position, position)
    refresh_first(self)
end

function DoubleQueue:position(data)
	return self.data_position[data]
end
</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>signal</name>
                        <packageName></packageName>
                        <script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
 
-- This file is part of LuaNotify.
 
-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
 
-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
 
-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name signal
-- @description Signal Class.
-- @author &lt;a href=&quot;mailto:tiagokatcipis@gmail.com&quot;&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href=&quot;mailto:paulo.pizarro@gmail.com&quot;&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local require = require
local setmetatable = setmetatable
local display = display

module(&quot;notify.signal&quot;)

local queue = require &quot;notify.double_queue&quot;

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local Signal = {} 


------------------------------------
-- Metamethods goes on this table --
------------------------------------
local Signal_mt = { __index = Signal }


--------------------------
-- Constructor function --
--------------------------
function new ()
    local object = {}      
    -- set the metatable of the new object as the Signal_mt table (inherits Signal).
    setmetatable(object, Signal_mt)

    -- create all the instance state data.
    object.handlers_block  = {}
    object.handlers        = queue.new()
    object.handler_names   = queue.new()
    object.pre_emit_funcs  = queue.new()
    object.post_emit_funcs = queue.new()
    object.signal_stopped = false
    return object
end


----------------------------------
-- Class definition and methods --
----------------------------------


---
-- Disconnects a handler function from this signal, the function will no longer be called.
-- @param handler_function – The function that will be disconnected.
function Signal:disconnect(handler_function)
    self.handlers:remove(handler_function)
    self.handlers_block[handler_function] = nil
end


---
-- Connects a handler function on this signal, all handlers connected will be called 
-- when the signal is emitted with a FIFO  behaviour (The first connected will be the first called).
-- @param handler_function – The function that will be called when this signal is emitted.
function Signal:connect(handler_function, handler_name)
    if(not self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = 0
				
				local position = self.handler_names:position(handler_name)
    		if position then
					self.handlers:removeIndex(position)
					self.handler_names:remove(handler_name)
					-- handlers_block table will keep growing as there's no way to find out what key to
					-- remove, but that is OK and should not affect anything
				end
		
        self.handlers:push_back(handler_function)
        self.handler_names:push_back(handler_name or &quot;&quot;)
    end
end


---
-- Does not execute the given handler function when the signal is emitted until it is unblocked. 
-- It can be called several times for the same handler function.
-- @param handler_function – The handler function that will be blocked.
function Signal:block(handler_function)
    if(self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = self.handlers_block[handler_function] + 1
    end
end


---
-- Unblocks the given handler function, this handler function will be executed on 
-- the order it was previously connected, and it will only be unblocked when 
-- the calls to unblock are equal to the calls to block.
-- @param handler_function – The handler function that will be unblocked.
function Signal:unblock(handler_function)
    if(self.handlers_block[handler_function]) then
        if(self.handlers_block[handler_function] &gt; 0) then
            self.handlers_block[handler_function] = self.handlers_block[handler_function] - 1
        end
    end
end


---
-- Emits a signal calling the handler functions connected to this signal passing the given args.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit(...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            handler(...)
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Typical signal emission discards handler return values completely. 
-- This is most often what you need: just inform the world about something. 
-- However, sometimes you need a way to get feedback. For instance, 
-- you may want to ask: “is this value acceptable, eh?”
-- This is what accumulators are for. Accumulators are specified to signals at emission time. 
-- They can combine, alter or discard handler return values, post-process them or even stop emission. 
-- Since a handler can return multiple values, accumulators can receive multiple args too, following 
-- Lua flexible style we give the user the freedom to do whatever he wants with accumulators.
-- @param accumulator – Function that will accumulate handlers results.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit_with_accumulator(accumulator, ...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            accumulator(handler(...))
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Adds a pre_emit func, pre_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, will not receive any data passed 
-- on the emission and they are always called before ANY handler is called. 
-- This is useful when you want to perform some global task before handling an event, 
-- like opening a socket that the handlers might need to use or a database, pre_emit functions 
-- can make sure everything is ok before handling an event, reducing the need to do this check_ups 
-- inside the handler function. They are called on a queue (FIFO) policy based on the order they added.
-- @param pre_emit_func – The pre_emit function.
function Signal:add_pre_emit(pre_emit_func)
    self.pre_emit_funcs:push_back(pre_emit_func)
end


---
-- Removes the pre_emit function
-- @param pre_emit_func – The pre_emit function.
function Signal:remove_pre_emit(pre_emit_func)
    self.pre_emit_funcs:remove(pre_emit_func)
end


---
-- Adds a post_emit function, post_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, they will not receive any data 
-- passed on the emission and they are always called after ALL handlers where called. 
-- This is useful when you want to perform some global task after handling an event, 
-- like closing a socket that the handlers might need to use or a database or do some cleanup. 
-- post_emit functions can make sure everything is released after handling an event, 
-- reducing the need to do this check_ups inside some handler function, since some resources 
-- can be shared by multiple handlers. They are called on a stack (LIFO) policy based on the order they added.
-- @param post_emit_func – The post_emit function.
function Signal:add_post_emit(post_emit_func)
    self.post_emit_funcs:push_front(post_emit_func)
end

---
-- Removes the post_emit function
-- @param post_emit_func – The post_emit function.
function Signal:remove_post_emit(post_emit_func)
    self.post_emit_funcs:remove(post_emit_func)
end


---
-- Stops the current emission, if there is any handler left to be called by the signal it wont be called.
function Signal:stop()
    self.signal_stopped = true
end

</script>
                        <eventHandlerList/>
                    </Script>
                </ScriptGroup>
                <Script isActive="yes" isFolder="no">
                    <name>Setup</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

svo.version = 'development'

if Logger and not svo.systemloaded then
  Logger:LogSection('svof', {'timestamp', split = 5000, 'keepOpen'})
end

local luanotify = {}
luanotify.signal = require(&quot;notify.signal&quot;)

local lfs = require 'lfs'

local debug = require 'debug'

-- !!
svo.pl = svo.pl or {}
local pl = svo.pl

pl.pretty     = require &quot;pl.pretty&quot;
pl.config     = require &quot;pl.config&quot;
pl.dir        = require &quot;pl.dir&quot;
pl.string     = require &quot;pl.stringx&quot;
pl.OrderedMap = require &quot;pl.OrderedMap&quot;
pl.tablex     = require &quot;pl.tablex&quot;

svo.phpTable = function (...) -- abuse to: http://richard.warburton.it
  local newTable,keys,values={},{},{}
  newTable.pairs=function(self) -- pairs iterator
    local count=0
    return function()
      count=count+1
      return keys[count],values[keys[count]]
    end
  end
  setmetatable(newTable,{
    __newindex=function(self,key,value)
      if not self[key] then table.insert(keys,key)
      elseif value==nil then -- Handle item delete
        local count=1
        while keys[count]~=key do count = count + 1 end
        table.remove(keys,count)
      end
      values[key]=value -- replace/create
    end,
    __index=function(self,key) return values[key] end
  })
  local arg = {...}
  for x=1,#arg do
    for k,v in pairs(arg[x]) do newTable[k]=v end
  end
  return newTable
end

function svo.ripairs(t)
  local function ripairs_it(t,i)
    i=i-1
    local v=t[i]
    if v==nil then return v end
    return i,v
  end
  return ripairs_it, t, #t+1
end

function svo.deepcopy(object)
  local lookup_table = {}
  local function _copy(object)
      if type(object) ~= 'table' then
          return object
      elseif lookup_table[object] then
          return lookup_table[object]
      end
      local new_table = {}
      lookup_table[object] = new_table
      for index, value in pairs(object) do
          new_table[_copy(index)] = _copy(value)
      end
      return setmetatable(new_table, getmetatable(object))
  end
  return _copy(object)
end

svo.affs             = svo.affs or {}
local affs           = svo.affs
svo.balanceless      = svo.balanceless or {}
svo.cp               = svo.cp or {}
svo.cpp              = svo.cpp or {}
svo.defences         = svo.defences or {}
local defences       = svo.defences
svo.lifevision       = svo.lifevision or {}
svo.signals          = svo.signals or {}
local signals        = svo.signals
svo.sps              = svo.sps or {}
svo.sys              = svo.sys or {}
local sys            = svo.sys
svo.conf             = svo.conf or {}
svo.empty            = svo.empty or {}
local conf           = svo.conf
svo.config           = svo.config or {}
svo.defc             = svo.defc or {} -- current defences
local defc           = svo.defc
svo.defs             = svo.defs or {}
svo.dragonheal       = svo.dragonheal or {} -- stores dragonheal curing strats
svo.lifep            = svo.lifep or {}
svo.lifevision.l     = pl.OrderedMap()
svo.paragraph_length = 0
svo.restore          = svo.restore or {}
svo.shrugging        = svo.shrugging or {} -- stores shrugging curing strats
svo.sp               = svo.sp or {} -- parry
svo.sp_config        = svo.sp_config or {}
svo.stats            = svo.stats or {}
local stats          = svo.stats
svo.tree             = svo.tree or {}
svo.rage             = svo.rage or {}
svo.fitness          = svo.fitness or {}
svo.valid            = svo.valid or {}
svo.watch            = svo.watch or {}
svo.gaffl            = svo.gaffl or {}
local gaffl          = svo.gaffl
svo.gdefc            = svo.gdefc or {}
svo.me               = svo.me or {}
local me             = svo.me
svo.sk               = svo.sk or {}
local sk             = svo.sk
svo.vm               = svo.vm or {}
svo.cn               = svo.cn or {}
svo.cnrl             = svo.cnrl or {}
svo.bals             = svo.bals or {}
-- table to keep original functions for when
-- we override Mudlet defaults
svo.ofs              = svo.ofs or {}
svo.actions          = svo.actions or pl.OrderedMap()

svo.reset            = svo.reset or {}
svo.prio             = svo.prio or {}
svo.defdefup = svo.defdefup or {
  basic  = {},
  combat = {},
  empty  = {},
}
svo.defkeepup = svo.defkeepup or {
  basic  = {},
  combat = {},
  empty  = {},
}


local affmt = {
  __tostring = function (self)
      local result = {}
      for i,k in pairs(self) do
        if k.p.count then
          result[#result+1] = i .. &quot;: &quot; ..getStopWatchTime(k.sw)..&quot;s (&quot; .. k.p.count .. &quot;)&quot;
        else
          result[#result+1] = i .. &quot;: &quot; ..getStopWatchTime(k.sw)..'s'
        end
      end

      return table.concat(result, &quot;, &quot;)
  end
}
setmetatable(svo.affs, affmt)

svo.affl = svo.affl or {}
svo.serverignore = svo.serverignore or {}
svo.ignore = svo.ignore or {}
svo.dict = svo.dict or {}

local oldecho = svo.conf.commandecho
signals.aeony = signals.aeony or luanotify.signal.new()
signals.sync = signals.sync or luanotify.signal.new()
signals.dragonform = signals.dragonform or luanotify.signal.new()

local haddragonform = false
signals.dragonform:add_post_emit(function()
  if svo.defc.dragonform and not haddragonform then
    raiseEvent&quot;svo got dragonform&quot;
    haddragonform = true
  elseif not svo.defc.dragonform and haddragonform then
    raiseEvent&quot;svo lost dragonform&quot;
    haddragonform = false
  end
end)

signals.canoutr = signals.canoutr or luanotify.signal.new()
signals.canoutr:connect(function()
  if (affs.webbed or affs.bound or affs.transfixed or affs.roped or affs.impale or
    ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and
      (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) then
    svo.sys.canoutr = false
    svo.me.canoutr = false
  else
    svo.sys.canoutr = true
    svo.me.canoutr = true
  end
end, 'update canoutr')


signals.removed_from_rift = signals.removed_from_rift or luanotify.signal.new()
signals.moved = signals.moved or luanotify.signal.new()
signals.systemstart = signals.systemstart or luanotify.signal.new()
signals.systemstart:connect(function() signals.canoutr:emit() end, 'setup canoutr on start')
signals.quit = signals.quit or luanotify.signal.new()
signals.connected = signals.connected or luanotify.signal.new()
signals.quit:connect(function ()
  if Logger then Logger:CloseLog('svo') end
end, 'stop the logger on quit')
signals.quit:add_pre_emit(function () signals.saveconfig:emit() end)
signals.quit:add_pre_emit(function () raiseEvent &quot;svo quit&quot; end)
signals.systemend = signals.systemend or luanotify.signal.new()

signals.donedefup = signals.donedefup or luanotify.signal.new()

-- gmcp ones
signals.gmcpcharname = signals.gmcpcharname or luanotify.signal.new()
signals.gmcpcharname:connect(function ()
  signals.enablegmcp:emit()
end, 'emit enablegmcp')
signals.gmcproominfo = signals.gmcproominfo or luanotify.signal.new()
signals.gmcpcharstatus = signals.gmcpcharstatus or luanotify.signal.new()
signals.gmcpcharitemslist = signals.gmcpcharitemslist or luanotify.signal.new()
signals.gmcpcharitemslist:connect(function()
  if not gmcp.Char.Items.List.location then
    svo.debugf(&quot;(GMCP problem) location field is missing from Achaea's response.&quot;)
    return
  end
  if gmcp.Char.Items.List.location ~= 'inv' then return end
  me.inventory = svo.deepcopy(gmcp.Char.Items.List.items)
end, 'update gmcpcharitemslist')
signals.gmcpcharitemsadd = signals.gmcpcharitemsadd or luanotify.signal.new()
signals.gmcpcharitemsadd:connect(function()
  if not gmcp.Char.Items.Add.location then
    svo.debugf(&quot;(GMCP problem) location field is missing from Achaea's response.&quot;)
    return
  end
  if gmcp.Char.Items.Add.location ~= 'inv' then return end
  me.inventory[#me.inventory + 1] = svo.deepcopy(gmcp.Char.Items.Add.item)
end, 'update gmcpcharitemsadd')
signals.gmcpcharskillsinfo = signals.gmcpcharskillsinfo or luanotify.signal.new()
signals.gmcpcharskillslist = signals.gmcpcharskillslist or luanotify.signal.new()
signals.gmcpcharitemsupdate = signals.gmcpcharitemsupdate or luanotify.signal.new()
signals.gmcpcharitemsupdate:connect(function()
  if not gmcp.Char.Items.Update.location then
    svo.debugf(&quot;(GMCP problem) location field is missing from Achaea's response.&quot;)
    return
  end
  if gmcp.Char.Items.Update.location ~= 'inv' then return end
  local update = gmcp.Char.Items.Update.item
  for i, item in ipairs(me.inventory) do
    if item.id == update.id then
      me.inventory[i] = svo.deepcopy(gmcp.Char.Items.Update.item)
      break
    end
  end
end, 'update gmcpcharitemsupdate')
signals.gmcpcharitemsremove = signals.gmcpcharitemsremove or luanotify.signal.new()
signals.gmcpcharitemsremove:connect(function()
  if not gmcp.Char.Items.Remove.location then
    svo.debugf(&quot;(GMCP problem) location field is missing from Achaea's response.&quot;)
    return
  end
  if gmcp.Char.Items.Remove.location ~= 'inv' then return end
  local remove = gmcp.Char.Items.Remove.item
  for i, item in ipairs(me.inventory) do
    if item.id == remove.id then
      table.remove(me.inventory, i)
      break
    end
  end
end, 'update gmcpcharitemsremove')
signals.gmcpcharvitals = signals.gmcpcharvitals or luanotify.signal.new()
signals.gmcpcharvitals:connect(function()
  if gmcp.Char.Vitals.charstats then
    for _, val in ipairs(gmcp.Char.Vitals.charstats) do
      local rage = val:match(&quot;^Rage: (%d+)$&quot;)
      if rage then
        stats.battlerage = tonumber(rage)
      else
        local bleed = val:match(&quot;^Bleed: (%d+)$&quot;)
        if bleed then
          if bleed == '0' then
            svo.rmaff('bleeding')
          else
            svo.dict.bleeding.aff.oncompleted(tonumber(bleed))
          end
        end
      end
    end
  end
  if not stats.battlerage then
    stats.battlerage = 0
  end
end, 'update gmcpcharvitals')

-- $(
-- local paths = {}; paths.oldpath = package.path; package.path = package.path..&quot;;./?.lua;./bin/?.lua;&quot;; local pretty = require &quot;pl.pretty&quot;; local stringx = require &quot;pl.stringx&quot;; local tablex = require &quot;pl.tablex&quot;; package.path = paths.oldpath

-- _put(string.format(&quot;me.class = \&quot;%s\&quot;\n&quot;, type(class) == 'string' and stringx.title(class) or table.concat(tablex.imap(stringx.title, class), &quot;, &quot;)))
-- _put(&quot;me.skills = &quot;.. pretty.write(skills))
-- )
me.class = 'Infernal'
me.skills = {
  weaponmastery = true,
  necromancy = true,
  chivalry = true
}

svo.knownskills = {
  alchemist    = {'transmutation', 'physiology', 'alchemy'},
  apostate     = {'evileye', 'necromancy', 'apostasy'},
  bard         = {'voicecraft', 'swashbuckling', 'harmonics'},
  blademaster  = {'twoarts', 'striking', 'shindo'},
  depthswalker = {'shadowmancy','aeonics','terminus'},
  druid        = {'groves', 'metamorphosis', 'reclamation'},
  infernal     = {'necromancy', 'chivalry', 'weaponmastery'},
  jester       = {'tarot', 'pranks', 'puppetry'},
  magi         = {'elementalism', 'crystalism', 'artificing'},
  monk         = {'tekura', 'kaido', 'telepathy', 'shikudo'},
  none         = {},
  occultist    = {'occultism', 'tarot', 'domination'},
  paladin      = {'chivalry', 'devotion', 'weaponmastery'},
  priest       = {'spirituality', 'devotion', 'healing'},
  runewarden   = {'runelore', 'chivalry', 'weaponmastery'},
  sentinel     = {'metamorphosis', 'woodlore', 'skirmishing'},
  serpent      = {'subterfuge', 'venom', 'hypnosis'},
  shaman       = {'runelore', 'curses', 'vodun'},
  sylvan       = {'weatherweaving', 'groves', 'propagation'},
}
-- optimised haveskillset, since it gets called often: compute a key-value table
-- with all of the skills we have.
do
  local available_skills = {}
  for _, skill in ipairs(svo.knownskills[svo.me.class:lower()]) do
    available_skills[skill] = true
  end

  function svo.haveskillset(skillset)
    return available_skills[skillset] and true or false
  end
end

if svo.haveskillset('groves') then
signals.gmcpcharvitals:connect(function()
  if gmcp.Char.Vitals.charstats then
    for _, val in ipairs(gmcp.Char.Vitals.charstats) do
      local sunlight = val:match(&quot;^Sunlight: (%d+)$&quot;)
      if sunlight then
        stats.sunlight = tonumber(sunlight)
        break
      end
    end
  end
  if not stats.sunlight then
    stats.sunlight = 0
  end
end, 'update sunlight')
end
if svo.haveskillset('metamorphosis') then
signals.gmcpcharvitals:connect(function()
  if gmcp.Char.Vitals.charstats then
    for _, val in ipairs(gmcp.Char.Vitals.charstats) do
      local morph = val:match(&quot;^Morph: (%w+)$&quot;)
      if morph then
        morph = morph:lower()
        me.morph = morph
        if not defc[morph] then
          sk.clearmorphs()
          if morph ~= 'none' then
            defences.got(morph)
          end
        end
        break
      end
    end
  end
  if not me.morph then
    me.morph = &quot;&quot;
  end
end, 'update morph')
end

if svo.me.class == 'Monk' then
signals.gmcpcharvitals:connect(function()
  if gmcp.Char.Vitals.charstats then
    for _, val in ipairs(gmcp.Char.Vitals.charstats) do
      local stance = val:match(&quot;^Stance: (%w+)$&quot;)
      local form = val:match(&quot;^Form: (%w+)$&quot;)

      if stance then
        me.path = 'tekura'
        me.form = nil
        me.stance = stance:lower()
        sk.ignored_defences['tekura'].status = false
        sk.ignored_defences['shikudo'].status = true

        break
      elseif form then
        me.path = 'shikudo'
        me.form = form:lower()
        me.stance = nil
        sk.ignored_defences['tekura'].status = true
        sk.ignored_defences['shikudo'].status = false

        break
      end
    end
  end

  if not me.path then
    me.path = 'tekura'
  end
end, 'update path and form')
end

signals.gmcpiretimelist = signals.gmcpiretimelist or luanotify.signal.new()
signals.gmcpiretimelist:connect(function()
  me.gametime = svo.deepcopy(gmcp.IRE.Time.List)
end, 'update gametime')
signals.gmcpiretimeupdate = signals.gmcpiretimeupdate or luanotify.signal.new()
signals.gmcpiretimeupdate:connect(function()
  me.gametime = me.gametime or {}
  for k, v in pairs(gmcp.IRE.Time.Update) do
    me.gametime[k] = v
  end
end, 'update gametime')

signals.gmcpcharafflictionslist = signals.gmcpcharafflictionslist or luanotify.signal.new()
signals.gmcpcharafflictionsremove = signals.gmcpcharafflictionsremove or luanotify.signal.new()
signals.gmcpcharafflictionsadd = signals.gmcpcharafflictionsadd or luanotify.signal.new()

signals.gmcpchardefenceslist = signals.gmcpchardefenceslist or luanotify.signal.new()
signals.gmcpchardefencesremove = signals.gmcpchardefencesremove or luanotify.signal.new()
signals.gmcpchardefencesadd = signals.gmcpchardefencesadd or luanotify.signal.new()


signals.gmcpcharafflictionsadd:connect(function()
  local thisaff = gmcp.Char.Afflictions.Add.name
  if thisaff:sub(-4) == &quot; (1)&quot; then thisaff = thisaff:sub(1, -5) end
  gaffl[thisaff] = true
  if conf.gmcpaffechoes then svo.echof(&quot;Gained aff %s&quot;, thisaff) end
  if svo.dict.sstosvoa[thisaff] then
    svo.addaffdict(svo.dict.sstosvoa[thisaff])
  end
end, 'track gained gmcp aff')

signals.gmcpcharafflictionsremove:connect(function()
  local thisaff = gmcp.Char.Afflictions.Remove[1]
  gaffl[thisaff] = nil
  if conf.gmcpdefechoes then svo.echof(&quot;Cured aff %s&quot;, thisaff) end
  if svo.dict.sstosvoa[thisaff] then
    svo.rmaff(svo.dict.sstosvoa[thisaff])
  end
end, 'track lost gmcp aff')

signals.gmcpcharafflictionslist:connect(function()
  svo.gaffl = {}
  local preaffl = {}
  for _, val in ipairs(svo.affl) do preaffl[val] = true end

  for _, val in ipairs(gmcp.Char.Afflictions.List) do
    local thisaff = val.name
    if thisaff:sub(-4) == &quot; (1)&quot; then thisaff = thisaff:sub(1, -5) end
    gaffl[thisaff] = true
    local svoAffliction = svo.dict.sstosvoa[thisaff]
    if svoAffliction then
      if preaffl[svoAffliction] then
        preaffl[svoAffliction] = false
      else
        svo.addaffdict(svoAffliction)
      end
    end
  end

  for key, val in pairs(preaffl) do
    if val then svo.rmaff(key) end
  end
end, 'update list of gmcp affs')


signals.gmcpchardefencesadd:connect(function()
  local thisdef = gmcp.Char.Defences.Add.name
  svo.gdefc[thisdef] = true
  if conf.gmcpdefechoes then svo.echof(&quot;Gained def &quot;..thisdef) end
  if svo.dict.sstosvod[thisdef] then
    if type(svo.defs['got_'..svo.dict.sstosvod[thisdef]]) == 'function' then
      svo.defs['got_'..svo.dict.sstosvod[thisdef]](true)
    else
      echoLink(&quot;(e!)&quot;,
        [[echo(&quot;The problem was: got_ function was ]]..type(svo.defs['got_'..svo.dict.sstosvod[thisdef]])..
        [[ for defence ]]..svo.dict.sstosvod[thisdef]..[[ (gmcp:]]..thisdef..[[)&quot;)]],
        'Oy - there was a problem. Click on this link and submit a bug report with what it says along with '
        ..'a copy/paste of what you saw.')
    end
  end
end, 'track gained gmcp def')

signals.gmcpchardefencesremove:connect(function()
  local thisdef = gmcp.Char.Defences.Remove[1]
  svo.gdefc[thisdef] = nil
  if conf.gmcpdefechoes then svo.echof(&quot;Lost def &quot;..thisdef) end
  if svo.dict.sstosvod[thisdef] then
    if type(svo.defs['lost_'..svo.dict.sstosvod[thisdef]]) == 'function' then
      svo.defs['lost_'..svo.dict.sstosvod[thisdef]]()
    else
      echoLink(&quot;(e!)&quot;,
        [[echo(&quot;The problem was: lost_ function was ]]..type(svo.defs['lost_'..svo.dict.sstosvod[thisdef]])..
        [[ for defence ]]..svo.dict.sstosvod[thisdef]..[[ (gmcp:]]..thisdef..[[)&quot;)]],
        'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a '
        ..'copy/paste of what you saw.')
    end
  end
end, 'track lost gmcp def')

signals.gmcpchardefenceslist:connect(function()
  svo.gdefc = {}
  local predefs = svo.deepcopy(defc)
  for _, val in ipairs(gmcp.Char.Defences.List) do
    local thisdef = val.name
    svo.gdefc[thisdef] = true
    if svo.dict.sstosvod[thisdef] then
      if predefs[svo.dict.sstosvod[thisdef]] then
        predefs[svo.dict.sstosvod[thisdef]] = false
      elseif type(svo.defs['got_'..svo.dict.sstosvod[thisdef]]) == 'function' then
        svo.defs['got_'..svo.dict.sstosvod[thisdef]](true)
      else
        echoLink(&quot;(e!)&quot;,
          [[echo(&quot;The problem was: got_ function was ]]..type(svo.defs['got_'..svo.dict.sstosvod[thisdef]])..
          [[ for defence ]]..svo.dict.sstosvod[thisdef]..[[ (gmcp:]]..thisdef..[[)&quot;)]],
          'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a '
          ..'copy/paste of what you saw.')
      end
    end
  end
  for defname, val in pairs(predefs) do
    if val == true and svo.dict.sstosvod[defname] then
      if type(svo.defs['lost_'..svo.dict.sstosvod[defname]]) == 'function' then
        svo.defs['lost_'..svo.dict.sstosvod[defname]]()
      else
        echoLink(&quot;(e!)&quot;,
          [[echo(&quot;The problem was: lost_ function was ]]..type(svo.defs['lost_'..svo.dict.sstosvod[defname]])..
          [[ for defence ]]..svo.dict.sstosvod[defname]..[[ (gmcp:]]..defname..[[)&quot;)]],
          'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a '
          ..'copy/paste of what you saw.')
      end
    end
  end
end, 'update list of defs from gmcp')

-- make a 'signals bank' that remembers all gmcp events that happend before the prompt.
-- reset on prompt. check it for stuff when necessary.
-- have the herb out signal be remembers on it's own &amp; verified by the syste

do
  local oldnum, oldarea
  signals.gmcproominfo:connect(function ()
    if me then
        if table.contains(gmcp.Room.Info.details, 'underwater') then
            me.is_underwater = true
        else
            me.is_underwater = false
        end
    end

    if oldnum ~= gmcp.Room.Info.num then
      signals.newroom:emit(_G.gmcp.Room.Info.name)
      oldnum = gmcp.Room.Info.num
    end

    signals.anyroom:emit(_G.gmcp.Room.Info.name)

    if oldarea ~= gmcp.Room.Info.area then
      signals.newarea:emit(_G.gmcp.Room.Info.area)
      oldarea = gmcp.Room.Info.area
    end
  end, 'track underwater status')
end

-- atcp ones
signals.charname = signals.charname or luanotify.signal.new()
signals.roombrief = signals.roombrief or luanotify.signal.new()

do
  local oldnum
  signals.roombrief:connect(function (...)
    if oldnum ~= atcp.RoomNum then
      signals.newroom:emit(({...})[1])
      oldnum = atcp.RoomNum
    end

    signals.anyroom:emit(({...})[1])
  end, 'setup newroom tracking')
end

-- general ones
signals.relogin = signals.relogin or luanotify.signal.new()
signals.enablegmcp = signals.enablegmcp or luanotify.signal.new()
signals.enablegmcp:add_post_emit(function ()
  svo.logging_in = false
  if not sys.enabledgmcp then
    sys.enabledgmcp = true
  else
    signals.relogin:emit()
    svo.echof(&quot;Welcome back!&quot;)
    -- svo.defs.quietswitch('basic')
  end
  -- app('off', true) -- this triggers a svo.dict() run too early before login
  if svo.dont_unpause_login then svo.dont_unpause_login = nil
  else conf.paused = false end

  svo.innews = false
end)
tempBeginOfLineTrigger(&quot;Rapture Runtime Environment&quot;, [[svo.logging_in = true]])

signals.newroom = signals.newroom or luanotify.signal.new()
signals.newarea = signals.newarea or luanotify.signal.new()
signals.anyroom = signals.anyroom or luanotify.signal.new()
signals.changed_maxhealth = signals.changed_maxhealth or luanotify.signal.new()
signals.changed_maxhealth:connect(function (old, new) -- can't use add_post_emit, as that doesn't pass arguments down
  if not string.find(debug.traceback(), 'Alias', 1, true) then
    if not (old and new) or (old and old == 1) then
      svo.echof(&quot;Your max health changed to %dh.&quot;, stats.maxhealth)
    elseif old &gt; new then
      svo.echof(&quot;Your max health decreased by %dh/%d%% to %d.&quot;, (old-new), 100-math.floor((100/old)*new), new)
    else
      svo.echof(&quot;Your max health increased by %dh/%d%% to %d.&quot;, (new-old), (math.floor((100/old)*new)-100), new)

      -- track stain
      sk.gotmaxhealth = true
      svo.prompttrigger(&quot;check stain expiring&quot;, function()
        if svo.paragraph_length == 0 and sk.gotmaxhealth and sk.gotmaxmana and svo.affs.stain then
          svo.rmaff('stain')
          svo.echof(&quot;I think stain faded.&quot;)
        end
        sk.gotmaxhealth, sk.gotmaxmana = nil, nil
      end)
    end
  end
end, 'update maxhealth tracking')
signals.changed_maxmana = signals.changed_maxmana or luanotify.signal.new()
signals.changed_maxmana:connect(function (old, new)
  if not string.find(debug.traceback(), 'Alias', 1, true) then
    if not (old and new) or (old and old == 1) then
      svo.echof(&quot;Your max mana changed to %dm.&quot;, stats.maxmana)
    elseif old &gt; new then
      svo.echof(&quot;Your max mana decreased by %dm/%d%% to %d.&quot;, (old-new), 100-math.floor((100/old)*new), new)
    else
      svo.echof(&quot;Your max mana increased by %dm/%d%% to %d.&quot;, (new-old), (math.floor((100/old)*new)-100), new)

      sk.gotmaxmana = true
      svo.prompttrigger(&quot;check stain expiring&quot;, function()
        if svo.paragraph_length == 0 and sk.gotmaxhealth and sk.gotmaxmana and svo.affs.stain then
          svo.rmaff('stain')
          svo.echof(&quot;I think stain faded.&quot;)
        end
        sk.gotmaxhealth, sk.gotmaxmana = nil, nil
      end)
    end
  end
end, 'update maxmana tracking')

signals.before_prompt_processing = signals.before_prompt_processing or luanotify.signal.new()
signals.after_prompt_processing = signals.after_prompt_processing or luanotify.signal.new()
signals.after_lifevision_processing = signals.after_lifevision_processing or luanotify.signal.new()

signals.curedwith_focus = signals.curedwith_focus or luanotify.signal.new()
signals.curemethodchanged = signals.curemethodchanged or luanotify.signal.new()
signals.limbhit = signals.limbhit or luanotify.signal.new()
signals.loadconfig = signals.loadconfig or luanotify.signal.new()
signals.orgchanged = signals.orgchanged or luanotify.signal.new()
signals.saveconfig = signals.saveconfig or luanotify.signal.new()
signals.sysdatasendrequest = signals.sysdatasendrequest or luanotify.signal.new()
if svo.haveskillset('healing') then
signals.healingskillchanged = signals.healingskillchanged or luanotify.signal.new()
end
if svo.haveskillset('metamorphosis') then
signals.morphskillchanged = signals.morphskillchanged or luanotify.signal.new()
end

signals.saveconfig:add_post_emit(function ()
  echo&quot;\n&quot;
  svo.echof(&quot;Saved system settings.&quot;)
end)

signals.loadedconfig = signals.loadedconfig or luanotify.signal.new()
signals.svogotaff = signals.svogotaff or luanotify.signal.new()
signals.svolostaff = signals.svolostaff or luanotify.signal.new()
signals.sysexitevent = signals.sysexitevent or luanotify.signal.new()
signals[&quot;mmapper updated pdb&quot;]       = luanotify.signal.new()
signals[&quot;svo config changed&quot;]        = luanotify.signal.new()
signals[&quot;svo defup changed&quot;]         = luanotify.signal.new()
signals[&quot;svo got balance&quot;]           = luanotify.signal.new()
signals[&quot;svo ignore changed&quot;]        = luanotify.signal.new()
signals[&quot;svo keepup changed&quot;]        = luanotify.signal.new()
signals[&quot;svo lost balance&quot;]          = luanotify.signal.new()
signals[&quot;svo prio changed&quot;]          = luanotify.signal.new()
signals[&quot;svo serverignore changed&quot;]  = luanotify.signal.new()
signals[&quot;svo switched defence mode&quot;] = luanotify.signal.new()
signals[&quot;svo system loaded&quot;]         = luanotify.signal.new()
signals[&quot;svo done defup&quot;]            = luanotify.signal.new()


if not svo.systemloaded then
  conf.siphealth            = 80
  conf.sipmana              = 70
  conf.mosshealth           = 60
  conf.mossmana             = 60
  conf.assumestats          = 15

  conf.ai_resetfocusbal     = 5
  conf.ai_resetsipbal       = 7 -- was 5 before, but started overrunning
  conf.ai_resetherbbal      = 2.5 -- normally at 1.6
  conf.ai_resetsalvebal     = 5
  conf.ai_resetmossbal      = 10  -- resets at 6
  if svo.haveskillset('healing') then
    -- resets at 2s for healing allies, near 4s for healing yourself, and offensive skills as inbetween
    conf.ai_resethealingbal        = 7
  end
  conf.ai_resetpurgativebal = 10 -- it's 7s for voyria
  conf.ai_resetdragonhealbal = 20 -- 20s for dragonheal
  conf.ai_resetsmokebal = 2 -- ~1.5s for smoking bal

  conf.ai_minherbbal        = 1.0
  conf.ai_restoreckless     = 0.4
  conf.ai_minrestorecure    = 3.5
  conf.tekura_delay         = 0.050

  conf.classattacksamount   = 3
  conf.classattackswithin   = 15
  conf.enableclassesfor     = 2

  conf.singlepromptsize     = 11

  conf.gagotherbreath       = true
  conf.gagbreath            = true

  conf.burrowpause          = true

  conf.changestype          = 'shortpercent'

  conf.paused               = false
  conf.lag                  = 0
  sys.wait                  = 0.7 -- for lag
  conf.aillusion            = true -- on by deafult, disable it if necessary
  conf.keepup               = true

  conf.burstmode            = 'empty'
  conf.slowcurecolour       = 'blue'
  conf.hinderpausecolour    = 'orange'

  conf.sacdelay             = 0.5 -- delay after which the systems curing should resume in sync mode

  conf.bleedamount          = 60
  conf.manableedamount      = 60
  conf.corruptedhealthmin   = 70
  conf.manause              = 35

  conf.fluiddelay           = 0.3
  conf.smallbleedremove     = 8

  conf.eventaffs            = true
  conf.autoarena            = true

  -- have skills?
  conf.commandecho          = true
  conf.blockcommands        = true
  conf.commandechotype      = 'fancy'
  conf.warningtype          = 'right'

  conf.autoreject           = 'white'
  conf.doubledo             = false

  conf.ridingskill          = 'mount'
  conf.ridingsteed          = 'pony'

  conf.screenwidth          = 100
  conf.refillat             = 1
  conf.waitherbai           = true
  conf.noeqtimeout          = 5

  conf.autoslick            = true
  conf.showbaltimes         = true
  conf.showafftimes         = true

  conf.steedfollow          = true
  conf.autoclasses          = true

  conf.ccto                 = 'pt'
  conf.repeatcmd            = 0

  if svo.haveskillset('healing') then
  conf.usehealing           = 'partial'
  end

  if svo.haveskillset('kaido') then
  conf.transmute            = 'supplement'
  conf.transmuteamount      = 70
  end

  if svo.haveskillset('devotion') then
  conf.bloodswornoff        = 30
  end

  conf.gagclot              = true
  conf.gagrelight           = false
  conf.relight              = true

  conf.passive_eqloss       = 10

  conf.highlightparryfg     = 'white'
  conf.highlightparrybg     = 'blue'

  conf.autotsc              = true
  conf.ignoresinglebites    = false

  conf.medprone             = false
  conf.unmed                = false

  conf.pagelength           = 20
  conf.treebalance          = 0

  conf.healthaffsabove      = 70

  conf.batch                = true

  conf.curemethod = 'conconly'
  signals.systemstart:add_post_emit(function()
    if not conf.curemethod or conf.curemethod == 'auto' then
      conf.curemethod = 'conconly'
    end
  end)

  conf.ninkharsag = true
end

sys.sync = false
sys.deffing = false
sys.balanceid = 0
sys.balancetick = 1
sys.lagcount, sys.lagcountmax = 0, 3
sys.actiontimeout = 3
sys.actiontimeoutid = false
sys.manause = 0
sys.sipmana, sys.siphealth, sys.mosshealth, sys.mossmana = 0, 0, 0, 0
sys.transmuteamount = 0

sys.sp_satisfied, sys.blockparry = false, false
sys.canoutr = true

-- the in-game custom prompt needs to show the game target and game target hp, since
-- that isn't available in GMCP at the moment, as well as any class-specific balances and values
if not svo.haveskillset('weaponmastery') then
sys.ingamecustomprompt =&quot;CONFIG PROMPT CUSTOM *hh, *mm, *ee, *ww *t*T *b*d*c-*r-s*s-&quot;
else
-- account for ferocity
sys.ingamecustomprompt =&quot;CONFIG PROMPT CUSTOM *hh, *mm, *ee, *ww *t*T *b*d*c-*r-k*k-s*s-&quot;
end
-- used in lyre actions to prevent doubledo from activating - since that'd destroy the lyre right away
sys.sendonceonly = false

-- a map that has possible commands linked to svo.dict.action.balance entries
sys.input_to_actions = {}
-- a map that stores svo.dict.action.balance.name
sys.last_used = {}

---

svo.danaeusaffs = {'agoraphobia', 'claustrophobia', 'dizziness', 'epilepsy', 'hypersomnia', 'vertigo'}
svo.nemesisaffs = {'agoraphobia', 'recklessness', 'confusion', 'masochism', 'loneliness'}
svo.scragaffs   = {'clumsiness', 'healthleech', 'lethargy', 'sensitivity', 'haemophilia', 'darkshade'}

---

stats.nextlevel,
stats.currenthealth, stats.maxhealth,
stats.currentmana, stats.maxmana,
stats.currentendurance, stats.maxendurance,
stats.currentwillpower, stats.maxwillpower = 1,1,1,1,1,1,1,1,1

if svo.haveskillset('kaido') then
stats.kai = 0
end

---
me.wielded = me.wielded or {}
me.oldhealth = 0

me.doqueue = {repeating = false}
me.dofreequeue = {}
me.dopaused = false
me.lustlist = {} -- list if names not to add lovers aff for
me.hoistlist = {} -- list if names not to add hoisted aff for
me.lasthitlimb = 'head' -- last hit limb
me.disableddragonhealfunc = {}
me.disabledrestorefunc    = {}
if svo.haveskillset('venom') then
me.disabledshruggingfunc  = {}
end
me.disabledtreefunc       = {}
me.disabledragefunc       = {}
me.disabledfitnessfunc       = {}
me.unparryables = {}
me.focusedknights = {}
me.locks = {}
me.curelist = {
  ash         = 'ash',
  bayberry    = 'bayberry',
  bellwort    = 'bellwort',
  bloodroot   = 'bloodroot',
  caloric     = 'caloric',
  cohosh      = 'cohosh',
  echinacea   = 'echinacea',
  elm         = 'elm',
  epidermal   = 'epidermal',
  frost       = 'frost',
  ginger      = 'ginger',
  ginseng     = 'ginseng',
  goldenseal  = 'goldenseal',
  hawthorn    = 'hawthorn',
  health      = 'health',
  immunity    = 'immunity',
  irid        = 'irid',
  kelp        = 'kelp',
  kola        = 'kola',
  levitation  = 'levitation',
  lobelia     = 'lobelia',
  mana        = 'mana',
  mass        = 'mass',
  mending     = 'mending',
  myrrh       = 'myrrh',
  pear        = 'pear',
  restoration = 'restoration',
  sileris     = 'sileris',
  skullcap    = 'skullcap',
  speed       = 'speed',
  valerian    = 'valerian',
  venom       = 'venom',
}


me.cadmusaffs = me.cadmusaffs or {
  ['agoraphobia']    = false,
  ['anorexia']       = true,
  ['claustrophobia'] = false,
  ['confusion']      = false,
  ['dizziness']      = false,
  ['epilepsy']       = false,
  ['fear']           = false,
  ['generosity']     = false,
  ['loneliness']     = false,
  ['masochism']      = false,
  ['pacifism']       = false,
  ['recklessness']   = true,
  ['shyness']        = false,
  ['stupidity']      = true,
  ['unknownmental']  = false,
  ['vertigo']        = false,
  ['weakness']       = false,
}

me.inventory = {}

me.getitem = function(name)
  for _, thing in ipairs(me.inventory) do
    if thing.name == name then
      return thing
    end
  end
end
---

if not svo.haveskillset('shindo') then
disableTrigger(&quot;Shindo defences&quot;)
else
enableTrigger(&quot;Shindo defences&quot;)
end

if not svo.haveskillset('kaido') then
disableTrigger(&quot;Kaido defences&quot;)
else
enableTrigger(&quot;Kaido defences&quot;)
end

if not svo.haveskillset('tekura') then
disableTrigger(&quot;Tekura balances&quot;)
else
enableTrigger(&quot;Tekura balances&quot;)
end

if svo.me.class == 'Druid' then
enableTrigger(&quot;Hydra balance&quot;)
else
disableTrigger(&quot;Hydra balance&quot;)
end

if svo.haveskillset('voicecraft') then
enableTrigger(&quot;Voice balance&quot;)
else
disableTrigger(&quot;Voice balance&quot;)
end

if svo.haveskillset('chivalry') or svo.haveskillset('shindo') or svo.haveskillset('kaido')
  or svo.haveskillset('metamorphosis') then
enableTrigger(&quot;Fitness balance&quot;)
else
disableTrigger(&quot;Fitness balance&quot;)
end

if svo.haveskillset('chivalry') then
enableTrigger(&quot;Rage balance&quot;)
else
disableTrigger(&quot;Rage balance&quot;)
end

if svo.haveskillset('weaponmastery') then
enableTrigger(&quot;Two-hander recover footing&quot;)
else
disableTrigger(&quot;Two-hander recover footing&quot;)
end

if svo.haveskillset('domination') then
enableTrigger(&quot;Domination entities balance&quot;)
else
disableTrigger(&quot;Domination entities balance&quot;)
end

if svo.haveskillset('venom') then
enableTrigger(&quot;Shrugging balance&quot;)
else
disableTrigger(&quot;Shrugging balance&quot;)
end

if svo.haveskillset('healing') or svo.haveskillset('elementalism') then
enableTrigger(&quot;Healing + Elementalism channels&quot;)
else
disableTrigger(&quot;Healing + Elementalism channels&quot;)
end

if svo.haveskillset('elementalism') then
enableAlias(&quot;Elementalism aliases&quot;)
else
disableAlias(&quot;Elementalism aliases&quot;)
end

if svo.haveskillset('spirituality') then
enableTrigger(&quot;Spirituality defences&quot;)
enableAlias(&quot;Spirituality aliases&quot;)
else
disableTrigger(&quot;Spirituality defences&quot;)
disableAlias(&quot;Spirituality aliases&quot;)
end

if svo.haveskillset('propagation') then
enableTrigger(&quot;Propagation defences&quot;)
else
disableTrigger(&quot;Propagation defences&quot;)
end

if svo.haveskillset('necromancy') then
enableTrigger(&quot;Necromancy defences&quot;)
else
disableTrigger(&quot;Necromancy defences&quot;)
end

if not svo.haveskillset('occultism') then
disableTrigger(&quot;Occultism defences&quot;)
else
enableTrigger(&quot;Occultism defences&quot;)
end

if not svo.haveskillset('alchemy') then
disableTrigger(&quot;Alchemy defences&quot;)
else
enableTrigger(&quot;Alchemy defences&quot;)
end

if not svo.haveskillset('groves') then
disableTrigger(&quot;Groves defences&quot;)
else
enableTrigger(&quot;Groves defences&quot;)
end

if not svo.haveskillset('harmonics') then
disableTrigger(&quot;Harmonics defences&quot;)
else
enableTrigger(&quot;Harmonics defences&quot;)
end

if not svo.haveskillset('healing') then
disableTrigger(&quot;Healing balance&quot;)
else
enableTrigger(&quot;Healing balance&quot;)
end

if not svo.haveskillset('physiology') then
disableTrigger(&quot;Humour balance&quot;)
else
enableTrigger(&quot;Humour balance&quot;)
end

if svo.haveskillset('terminus') then
enableTrigger(&quot;Word balance&quot;)
else
disableTrigger(&quot;Word balance&quot;)
end

if svo.haveskillset('aeonics') then
enableTrigger(&quot;Age tracking&quot;)
else
disableTrigger(&quot;Age tracking&quot;)
end

-- local oldsend
-- local defupfinish, process_defs
-- local wait_tbl

svo.index_map = pl.tablex.index_map

-- local addaff, rmaff, checkanyaffs, updateaffcount

-- lostbal_focus, lostbal_herb, lostbal_salve, lostbal_purgative, lostbal_sip
sk.salvetick, sk.herbtick, sk.focustick, sk.teatick = 0, 0, 0, 0
sk.purgativetick, sk.siptick, sk.mosstick, sk.dragonhealtick = 0, 0, 0, 0
sk.smoketick, sk.voicetick, sk.wordtick =  0, 0, 0

if svo.haveskillset('healing') then
sk.healingtick = 0
end
if svo.haveskillset('venom') then
sk.shruggingtick = 0
end
if svo.haveskillset('chivalry') or svo.haveskillset('shindo') or svo.haveskillset('kaido')
  or svo.haveskillset('metamorphosis') then
sk.fitnesstick = 0
end
if svo.haveskillset('chivalry') then
sk.ragetick = 0
end
if svo.haveskillset('weaponmastery') then
sk.didfootingattack = false
end

sk.diag_list = {}
sk.priosbeforechange = {}
 -- caches prio changes, so none need to happen on holes in svo's prios
sk.priochangecache = { special = {} }
-- queue of commands to batch into a serverside alias for curing
sk.sendqueue = {}
-- keep track of the length of the command - max command length in Achaea is 2048
sk.sendqueuel = 18 -- 'setalias multicmd ' is 24 characters
sk.achaea_command_max_length = 2048

-- a buffer to keep track of the commands the system has sent
sk.systemscommands = {}

svo.promptcount, svo.lastpromptnumber = 0, 0
svo.send = _G.send

-- possible afflictions that need to go through a check first
svo.affsp               = svo.affsp or {}
svo.rift                = svo.rift or {}
svo.pipes               = svo.pipes or {}
svo.install             = svo.install or {}
svo.life                = svo.life or {}
svo.echos               = svo.echos or {}
svo.echosd              = svo.echosd or {}
sk.ignored_defences     = sk.ignored_defences or {}
sk.ignored_defences_map = sk.ignored_defences_map or {}
sk.zeromana             = false
svo.pflags              = svo.pflags or {}

--[=[
uncommented for now: Makes svof prone to illusions with server side turned on
signals.svogotaff:connect(function(isloki)
  if svo.dict.svotossa[isloki] and not gaffl[svo.dict.svotossa[isloki]] and conf.serverside then
    svo.echof(&quot;Svo caught &quot;..isloki..&quot; (&quot;..svo.dict.svotossa[isloki]..&quot;), predicting for serverside.&quot;)
    send(&quot;CURING PREDICT &quot;..svo.dict.svotossa[isloki])
  end
end)
--]=]

function svo.assert(condition, msg, extra)
  if not condition then
    if extra then
      extra(msg)
    else
      error(msg)
    end
  end
end

sk.checkaeony = function()
  if (affs.aeon or affs.retardation) and not sys.sync then
    oldecho = conf.commandecho
    conf.commandecho = true
    sys.sync = true
    signals.sync:emit()
    signals.sysdatasendrequest:unblock(svo.cnrl.processcommand)

    -- kill actions prior to this, so we can do aeon
    local to_kill = {}
    for _,v in svo.actions:iter() do
      if v.p.balance ~= 'waitingfor' and v.p.balance ~= 'aff' and v.p.balance ~= 'gone' and
        v.p.name ~= 'aeon_smoke' and v.p.name ~= 'checkslows_misc' and v.p.name ~= 'touchtree_misc' then
      -- don't kill aeon_smoke: if we do, we double-smoke. instead, since smoke is started before sync is set:
      -- add a customwait delay. Don't kill tree touching either, could help for asthma
        to_kill[#to_kill+1] = svo.dict[v.p.action_name][v.p.balance]
      end
    end

    local killaction = svo.killaction
    for _, action in ipairs(to_kill) do
      killaction(action)
    end

    echo(&quot;\n&quot;)
    svo.echof(&quot;%s mode enabled.&quot;, (math.random(1, 20) == 20 and 'Matrix' or &quot;Slow curing&quot;))

    if conf.autotsc then
      if affs.retardation then
        conf.blockcommands = false -- bypass config.set, because that calls gnomes for us
        echo&quot;\n&quot; svo.echof(&quot; (autotsc) - command overrides enabled.&quot;)
      elseif affs.aeon then
        conf.blockcommands = true
        echo&quot;\n&quot; svo.echof(&quot; (autotsc) - command denies enabled.&quot;)
      end
    end
  elseif sys.sync and not (affs.aeon or affs.retardation) then
    conf.commandecho = oldecho
    sys.sync = false
    signals.sync:emit()
    signals.sysdatasendrequest:block(svo.cnrl.processcommand)
    echo(&quot;\n&quot;)
    svo.echof(&quot;Slow curing mode disabled.&quot;)
  end
end

signals.systemstart:connect(function ()
  (tempExactMatchTrigger or tempTrigger)(&quot;You open your mouth but say nothing.&quot;,
    [[svo.valid.saidnothing()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You are not fallen or kneeling.&quot;,
    [[svo.valid.nothingtowield()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You stand up and stretch your arms out wide.&quot;,
    [[svo.valid.nothingtowield()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;What do you want to eat?&quot;,
    [[svo.valid.nothingtoeat()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You inhale deeply and begin holding your breath.&quot;,
    [[svo.valid.lungsokay()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;Sticky strands of webbing cling to you, making that impossible.&quot;,
    [[svo.valid.symp_webbed()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You are too tangled up to do that.&quot;,
    [[svo.valid.symp_roped()]]);
  (tempExactMatchTrigger or tempTrigger)(&quot;Your legs are tangled in a mass of rope and you cannot move.&quot;,
    [[svo.valid.symp_roped()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;Your lungs are too weak to hold your breath.&quot;,
    [[svo.valid.weakbreath()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You are impaled and must writhe off before you may do that.&quot;,
    [[svo.valid.symp_impaled()]]);
  (tempExactMatchTrigger or tempTrigger)(&quot;The weapon that transfixes your gut makes leaving impossible.&quot;,
    [[svo.valid.symp_impaled()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You move sluggishly into action.&quot;,
    [[svo.valid.webeslow()]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You are transfixed and cannot do that. You must writhe to escape.&quot;,
    [[svo.valid.symp_transfixed()]]);
end, 'setup anti-illusion triggers');

if svo.haveskillset('metamorphosis') then
  (tempExactMatchTrigger or tempTrigger)(
    &quot;You take a deep breath and realise your error - you sputter and engulf yourself in fire!&quot;,
    [[svo.valid.simpleablaze()]]);

  tempRegexTrigger([[^Your soul quakes and shifts as the spirits depart, leaving you .+ once more\.$]],
    [[
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor',
        'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla',
         'icewyrm', 'wyvern', 'hydra'} do
        if svo.defc[morph] then svo.defs['lost_'..morph]() end
      end
    ]]);

  tempRegexTrigger([[^You remain in .+ form, dolt\.$]],
    [[
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor',
        'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla',
        'icewyrm', 'wyvern', 'hydra'} do
        if svo.defc[morph] then svo.defs['lost_'..morph]() end
      end
    ]]);

  tempRegexTrigger([[^You are already in .+ form\.$]],
    [[
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor',
        'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla',
        'icewyrm', 'wyvern', 'hydra'} do
        if svo.defc[morph] then svo.defs['lost_'..morph]() end
      end
    ]]);

  tempRegexTrigger(
    [[^You writhe in spiritual torment as the creature spirit is torn from your soul \- you are .+ once more\.$]],
    [[
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor',
        'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla',
        'icewyrm', 'wyvern', 'hydra'} do
        if svo.defc[morph] then svo.defs['lost_'..morph]() end
        svo.valid.simplecantmorph()
      end
    ]]);

  (tempExactMatchTrigger or tempTrigger)(&quot;You cannot possibly morph again so soon.&quot;, &quot;svo.valid.simplecantmorph()&quot;);

  (tempExactMatchTrigger or tempTrigger)(
    &quot;You feel your bond with the animal spirits strengthen, allowing you to morph once again.&quot;,
    [[svo.valid.cantmorph_woreoff()]]);
end

color_table.a_darkred     = {128, 0, 0}
color_table.a_darkgreen   = {0, 179, 0}
color_table.a_brown       = {128, 128, 0}
color_table.a_darkblue    = {0, 0, 128}
color_table.a_darkmagenta = {128, 0, 128}
color_table.a_darkcyan    = {0, 128, 128}
color_table.a_grey        = {192, 192, 192}
color_table.a_darkgrey    = {128, 128, 128}
color_table.a_red         = {255, 0, 0}
color_table.a_green       = {0, 255, 0}
color_table.a_yellow      = {255, 255, 0}
color_table.a_blue        = {0, 85, 255}
color_table.a_magenta     = {255, 0, 255}
color_table.a_cyan        = {0, 255, 255}
color_table.a_white       = {255, 255, 255}
color_table.a_darkwhite   = {192, 192, 192}
color_table.a_darkyellow  = {179, 179, 0}
-- 2D2E2E, 676562, 433020, 28BA28, 398C39, 0D790D
color_table.a_onelevel    = {45, 46, 46}
color_table.a_twolevel    = {103, 101, 98}
color_table.a_threelevel  = {67, 48, 32}
color_table.a_fourlevel   = {40, 186, 40}
color_table.a_fivelevel   = {57, 140, 57}
color_table.a_sixlevel    = {13, 121, 13}
color_table.blaze_orange  = {255, 102, 0}


-- check if the person imported the xml many times by accident
signals.systemstart:connect(function ()
  local toomany, types = {}, {'alias', 'trigger'} -- add scripts when exists() function supports it

  for _, type in ipairs(types) do
    if exists('svo', type) &gt; 1 then
      toomany[#toomany+1] = type
    end
  end

  if #toomany == 0 then return end

  tempTimer(10, function ()
    svo.echof(&quot;Warning! You have multiple %s svo folders while you only should have one per aliases, triggers, etc.&quot;
      ..&quot; Delete the extra ones.&quot;, table.concat(toomany, &quot;, &quot;)) end)
end, 'check for multiple svos')

-- table.save() before Mudlet 3.7.1 didn't return the error, so we have a patched copy
-- fix has been contributed upstream
function svo.tablesave( sfile, t )
    local tables = {}
    table.insert( tables, t )
    local lookup = { [t] = 1 }
    local file, msg = io.open( sfile, 'w' )
    if not file then return nil, msg end

    file:write( &quot;return {&quot; )
    for _,v in ipairs( tables ) do
        table.pickle( v, file, tables, lookup )
    end
    file:write( &quot;}&quot; )
    file:close()

    return true
end

-- load the lust list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/lustlist&quot;

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    svo.update(me.lustlist, t)
  end
end, 'load lust list')

signals.saveconfig:connect(function () svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/lustlist&quot;, me.lustlist) end, 'save lust list')

-- load the hoist list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/hoistlist&quot;

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    svo.update(me.hoistlist, t)
  end
end, 'load hoist list')

signals.saveconfig:connect(function () svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/hoistlist&quot;, me.hoistlist) end, 'save hoist list')

-- load the ignore list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/ignore&quot;

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    svo.update(svo.ignore, t)
  end

  svo.ignore.checkparalysis = true
end, 'load ignore list')

signals.saveconfig:connect(function () svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/ignore&quot;, svo.ignore) end, 'save ignore list')

-- load the locatelist
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/locatelist&quot;

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    me.locatelist = me.locatelist or {} -- make sure it's initialized
    svo.update(me.locatelist, t)
  end
end, 'load locate list')
signals.saveconfig:connect(function () me.locatelist = me.locatelist or {}
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/locatelist&quot;, me.locatelist)
end, 'save locate list')

-- load the watchfor list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/watchfor&quot;

  if lfs.attributes(conf_path) then
    local t = {}
    table.load(conf_path, t)
    me.watchfor = me.watchfor or {} -- make sure it's initialized
    svo.update(me.watchfor, t)
  end
end, 'load watchfor list')
signals.saveconfig:connect(function () me.watchfor = me.watchfor or {}
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/watchfor&quot;, me.watchfor)
end, 'save watchfor list')

-- load the tree list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/tree&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledtreefunc)
  end

  if not conf.disabledtreedefaults then
    conf.disabledtreedefaults = true

    me.disabledtreefunc.any2affs = true
    me.disabledtreefunc.any3affs = true
  end
end, 'load tree list')
-- save the tree func list
signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/tree&quot;, me.disabledtreefunc)
end, 'save tree list')

-- load the fitness list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/fitness&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledfitnessfunc)
  end

  if not conf.disabledfitnessdefaults then
    conf.disabledfitnessdefaults = true
  end
end, 'load fitness data')
-- save the fitness func list
signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/fitness&quot;, me.disabledfitnessfunc)
end, 'save fitness data')

-- load the rage list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/rage&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledragefunc)
  end

  if not conf.disabledragedefaults then
    conf.disabledragedefaults = true
  end
end, 'load rage data')
-- save the rage func list
signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/rage&quot;, me.disabledragefunc)
end, 'save rage data')

-- load the restore func list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/restore&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disabledrestorefunc)
  else
    tempTimer(0, function () me.disabledrestorefunc.anylimb = true; me.disabledrestorefunc.anyoneortwolimbs = true; end)
  end
end, 'load restore data')
-- save the restore func list
signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/restore&quot;, me.disabledrestorefunc)
end, 'save restore data')

-- load the dragonheal func list
signals.systemstart:connect(function ()
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/dragonheal&quot;

  if lfs.attributes(conf_path) then
    table.load(conf_path, me.disableddragonhealfunc)
  else
    tempTimer(0, function () me.disableddragonhealfunc.anylimb = true end)
  end
end, 'load dragonheal data')
-- save the dragonheal func list
signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/dragonheal&quot;, me.disableddragonhealfunc)
end, 'save dragonheal data')

for _, config in ipairs{
 {location = 'serverignore', localtable = svo.serverignore, errormsg = &quot;re-set all of the server ignore strats&quot;},
 {location = 'cadmusaffs', localtable = svo.me.cadmusaffs, errormsg = &quot;re-set all of the cadmus affs&quot;},
 {location = 'prefercustom', localtable = svo.me.curelist, errormsg = &quot;re-set all of the custom curelist&quot;},
} do
  -- load the config.location list
  signals.systemstart:connect(function ()
    local conf_path = getMudletHomeDir() .. &quot;/svo/config/&quot;..config.location

    if lfs.attributes(conf_path) then
      local ok, msg = pcall(table.load, conf_path, config.localtable)
      if not ok then
        os.remove(conf_path)
        tempTimer(10, function()
          svo.echof(&quot;Your %s serverignore file got corrupted for some reason - &quot;
            ..&quot;I've deleted it so the system can load other stuff OK. You'll need to %s, though. (%q)&quot;,
            config.location, config.errormsg, msg)
        end)
      end
    end
  end, 'load server/casmus/custom data')
  -- save the config.location list
  signals.saveconfig:connect(function ()
    svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/&quot;..config.location, config.localtable)
  end, 'save server/casmus/custom data')
end


if svo.haveskillset('venom') then
  -- load the shrugging func list
  signals.systemstart:connect(function ()
    local conf_path = getMudletHomeDir() .. &quot;/svo/config/shrugging&quot;

    if lfs.attributes(conf_path) then
      local ok, msg = pcall(table.load,conf_path, me.disabledshruggingfunc)
      if not ok then
        os.remove(conf_path)
        tempTimer(10, function()
          svo.echof(&quot;Your shrugging strats file got corrupted for some reason - &quot;
            ..&quot;I've deleted it so the system can load other stuff OK. &quot;
            ..&quot;You'll need to re-set all of the shrugging strats again, though. (%q)&quot;, msg)
        end)
      end
    else
      tempTimer(0, function () me.disabledshruggingfunc.any2affs = true end)
    end
  end, 'load shrugging data')
  -- save the shrugging func list
  signals.saveconfig:connect(function ()
    svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/shrugging&quot;, me.disabledshruggingfunc)
  end, 'save shrugging data')
end

-- data for normal/trans sipping
svo.es_categories = {
  [&quot;a caloric salve&quot;]         = 'salve',
  [&quot;a salve of mass&quot;]         = 'salve',
  [&quot;a salve of mending&quot;]      = 'salve',
  [&quot;a salve of restoration&quot;]  = 'salve',
  [&quot;an elixir of frost&quot;]      = 'elixir',
  [&quot;an elixir of health&quot;]     = 'elixir',
  [&quot;an elixir of immunity&quot;]   = 'elixir',
  [&quot;an elixir of levitation&quot;] = 'elixir',
  [&quot;an elixir of mana&quot;]       = 'elixir',
  [&quot;an elixir of speed&quot;]      = 'elixir',
  [&quot;an elixir of venom&quot;]      = 'elixir',
  [&quot;an epidermal salve&quot;]      = 'salve',
  ['empty']                   = 'empty',
  [&quot;the venom aconite&quot;]       = 'venom',
  [&quot;the venom camus&quot;]         = 'venom',
  [&quot;the venom colocasia&quot;]     = 'venom',
  [&quot;the venom curare&quot;]        = 'venom',
  [&quot;the venom darkshade&quot;]     = 'venom',
  [&quot;the venom delphinium&quot;]    = 'venom',
  [&quot;the venom digitalis&quot;]     = 'venom',
  [&quot;the venom epseth&quot;]        = 'venom',
  [&quot;the venom epteth&quot;]        = 'venom',
  [&quot;the venom euphorbia&quot;]     = 'venom',
  [&quot;the venom eurypteria&quot;]    = 'venom',
  [&quot;the venom gecko&quot;]         = 'venom',
  [&quot;the venom kalmia&quot;]        = 'venom',
  [&quot;the venom larkspur&quot;]      = 'venom',
  [&quot;the venom loki&quot;]          = 'venom',
  [&quot;the venom monkshood&quot;]     = 'venom',
  [&quot;the venom nechamandra&quot;]   = 'venom',
  [&quot;the venom notechis&quot;]      = 'venom',
  [&quot;the venom oculus&quot;]        = 'venom',
  [&quot;the venom oleander&quot;]      = 'venom',
  [&quot;the venom prefarar&quot;]      = 'venom',
  [&quot;the venom scytherus&quot;]     = 'venom',
  [&quot;the venom selarnia&quot;]      = 'venom',
  [&quot;the venom slike&quot;]         = 'venom',
  [&quot;the venom sumac&quot;]         = 'venom',
  [&quot;the venom vardrax&quot;]       = 'venom',
  [&quot;the venom vernalius&quot;]     = 'venom',
  [&quot;the venom voyria&quot;]        = 'venom',
  [&quot;the venom xentio&quot;]        = 'venom',
}
svo.es_shortnames = {
  aconite        = &quot;the venom aconite&quot;,
  caloric        = &quot;a caloric salve&quot;,
  camus          = &quot;the venom camus&quot;,
  colocasia      = &quot;the venom colocasia&quot;,
  curare         = &quot;the venom curare&quot;,
  darkshade      = &quot;the venom darkshade&quot;,
  delphinium     = &quot;the venom delphinium&quot;,
  digitalis      = &quot;the venom digitalis&quot;,
  epidermal      = &quot;an epidermal salve&quot;,
  epseth         = &quot;the venom epseth&quot;,
  epteth         = &quot;the venom epteth&quot;,
  euphorbia      = &quot;the venom euphorbia&quot;,
  eurypteria     = &quot;the venom eurypteria&quot;,
  frost          = &quot;an elixir of frost&quot;,
  gecko          = &quot;the venom gecko&quot;,
  health         = &quot;an elixir of health&quot;,
  immunity       = &quot;an elixir of immunity&quot;,
  kalmia         = &quot;the venom kalmia&quot;,
  larkspur       = &quot;the venom larkspur&quot;,
  levitation     = &quot;an elixir of levitation&quot;,
  loki           = &quot;the venom loki&quot;,
  mana           = &quot;an elixir of mana&quot;,
  mass           = &quot;a salve of mass&quot;,
  mending        = &quot;a salve of mending&quot;,
  monkshood      = &quot;the venom monkshood&quot;,
  nechamandra    = &quot;the venom nechamandra&quot;,
  notechis       = &quot;the venom notechis&quot;,
  oculus         = &quot;the venom oculus&quot;,
  oleander       = &quot;the venom oleander&quot;,
  prefarar       = &quot;the venom prefarar&quot;,
  restoration    = &quot;a salve of restoration&quot;,
  scytherus      = &quot;the venom scytherus&quot;,
  selarnia       = &quot;the venom selarnia&quot;,
  slike          = &quot;the venom slike&quot;,
  speed          = &quot;an elixir of speed&quot;,
  sumac          = &quot;the venom sumac&quot;,
  vardrax        = &quot;the venom vardrax&quot;,
  venom          = &quot;an elixir of venom&quot;,
  vernalius      = &quot;the venom vernalius&quot;,
  voyria         = &quot;the venom voyria&quot;,
  xentio         = &quot;the venom xentio&quot;,
  empty          = 'empty', -- so changing desired amounts knows what to use
}
svo.es_shortnamesr = {}
for k,v in pairs(svo.es_shortnames) do svo.es_shortnamesr[v] = k end

-- initialize this for the sipping tracking (the thing that decides what to fallback to)
svo.es_potions = svo.es_potions or {}
local es_potions = svo.es_potions

-- load defaults
for thing, category in pairs(svo.es_categories) do
  es_potions[category] = es_potions[category] or {}
  -- consider 1 so we don't drink the aternative on prefer* right away
  if category == 'venom' then
    es_potions[category][thing] = es_potions[category][thing] or {sips = 0, vials = 0, decays = 0}
  else
    es_potions[category][thing] = es_potions[category][thing] or {sips = 2, vials = 2, decays = 0}
  end
end

sk.arena_areas = {
  -- mhaldor
  [&quot;the Desolate Towers&quot;]              = true,
  [&quot;the Skeletal Forest&quot;]              = true,
  [&quot;the Abandoned Catacombs&quot;]          = true,
  [&quot;the Volcanic Warrens&quot;]             = true,
  -- shallam
  [&quot;the Shallam Caverns&quot;]              = true,
  [&quot;the Hunter's Path&quot;]                = true,
  [&quot;the Hunting Grounds&quot;]              = true,
  [&quot;an Old Shack&quot;]                     = true,
  [&quot;the Catacombs&quot;]                    = true,
  [&quot;the Tower of Light&quot;]               = true,
  -- cyrene
  [&quot;the Forest of Solitude&quot;]           = true,
  [&quot;Muurn Falls&quot;]                      = true,
  [&quot;the Pantheon&quot;]                     = true,
  [&quot;some Dank Caverns&quot;]                = true,
  [&quot;the Matsuhama Arena&quot;]              = true,
  [&quot;the Caves in the Matsuhama Arena&quot;] = true,
  -- hashan
  [&quot;Damballah Lake&quot;]                   = true,
  [&quot;the Lisigia Village&quot;]              = true,
  [&quot;the Wealds of Lisigia&quot;]            = true,
  [&quot;the Lisigia Palace&quot;]               = true,
  [&quot;the Darkshade River&quot;]              = true,
  [&quot;the Lisigian Wastelands&quot;]          = true,
  -- ashtan
  [&quot;the Tomb Grounds&quot;]                 = true,
  [&quot;an underground river&quot;]             = true,
  [&quot;the Tomb of Glanos&quot;]               = true,
  [&quot;the Tomb Catacombs&quot;]               = true,
  -- eleusis
  [&quot;an unspoiled forest&quot;]              = true,
  [&quot;the endless wastelands&quot;]           = true,
  [&quot;a forgotten jungle&quot;]               = true,
  [&quot;the uncharted mountains&quot;]          = true,
  -- delos
  [&quot;the Central Arena&quot;]                = true,
  [&quot;the Modi River&quot;]                   = true,
  [&quot;the Gaian Forest&quot;]                 = true,
  [&quot;the Caverns of the Beasts&quot;]        = true,
  [&quot;the Gladiator Pit&quot;]                = true,
  -- targ
  [&quot;The Stadium&quot;]                      = true,
  [&quot;The Stands&quot;]                       = true,
  [&quot;The Pits&quot;]                         = true,
}
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Miscellaneous functions</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local signals, sk, deepcopy, echos, echosd = svo.signals, svo.sk, svo.deepcopy, svo.echos, svo.echosd
local conf, affs, me, cp = svo.conf, svo.affs, svo.me, svo.cp

svo.vecho = function(newline, what)
  decho(&quot;&lt;206,222,215&gt;(&lt;214,206,221&gt;svof&lt;206,222,215&gt;)&lt;252,251,254&gt;: &lt;249,244,254&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echos.Eleusis(newline, what)
  decho(&quot;&lt;157,60,60&gt;(&lt;55,145,55&gt;svof&lt;157,60,60&gt;)&lt;212,245,112&gt;: &lt;62,245,62&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Eleusis()
  return &quot;&lt;62,245,62&gt;&quot;
end

function svo.echos.LightGreen(newline, what)
  decho(&quot;&lt;255,231,179&gt;(&lt;170,154,118&gt;svof&lt;255,231,179&gt;)&lt;255,241,210&gt;: &lt;255,219,140&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.LightGreen()
  return &quot;&lt;255,219,140&gt;&quot;
end

function svo.echos.Mhaldor(newline, what)
  decho(&quot;&lt;157,60,60&gt;(&lt;255,0,0&gt;svof&lt;157,60,60&gt;)&lt;255,65,65&gt;: &lt;255,117,117&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Mhaldor()
  return &quot;&lt;255,117,117&gt;&quot;
end

function svo.echos.Ashtan(newline, what)
  decho(&quot;&lt;80,66,80&gt;(&lt;107,79,125&gt;svof&lt;80,66,80&gt;)&lt;87,85,89&gt;: &lt;159,128,180&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Ashtan()
  return &quot;&lt;159,128,180&gt;&quot;
end

function svo.echos.Shallam(newline, what)
  decho(&quot;&lt;32,128,94&gt;(&lt;53,213,157&gt;svof&lt;32,128,94&gt;)&lt;53,213,157&gt;: &lt;0,171,111&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Shallam()
  return &quot;&lt;0,171,111&gt;&quot;
end

function svo.echos.Targossas(newline, what)
  decho(&quot;&lt;32,128,94&gt;(&lt;53,213,157&gt;svof&lt;32,128,94&gt;)&lt;53,213,157&gt;: &lt;0,171,111&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Targossas()
  return &quot;&lt;0,171,111&gt;&quot;
end

function svo.echos.Hashan(newline, what)
  decho(&quot;&lt;206,222,215&gt;(&lt;170,175,175&gt;svof&lt;206,222,215&gt;)&lt;252,251,254&gt;: &lt;237,244,244&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Hashan()
  return &quot;&lt;237,244,244&gt;&quot;
end

function svo.echos.Cyrene(newline, what)
  decho(&quot;&lt;253,63,73&gt;(&lt;251,0,13&gt;svof&lt;253,63,73&gt;): &lt;253,114,121&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.Cyrene()
  return &quot;&lt;253,114,121&gt;&quot;
end

function svo.echos.default(newline, what)
  decho(&quot;&lt;206,222,215&gt;(&lt;214,206,221&gt;svof&lt;206,222,215&gt;)&lt;252,251,254&gt;: &lt;249,244,254&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

function svo.echosd.default()
  return &quot;&lt;249,244,254&gt;&quot;
end

function svo.updatevecho()
  svo.vecho = echos[conf.echotype] or echos[conf.org] or echos.default
  svo.getDefaultColor = echosd[conf.echotype] or echosd[conf.org] or echosd.default

  -- create an r,g,b table that we can setFgColor(unpack(getDefaultColorNums)) later
  svo.getDefaultColorNums = {
    ((echosd[conf.echotype] and echosd[conf.echotype]())
      or (echosd[conf.org] and echosd[conf.org]()) or
      echosd.default()
    ):match(&quot;&lt;(%d+),(%d+),(%d+)&gt;&quot;)}
end
signals.systemstart:connect(svo.updatevecho, &quot;setup svo.getDefaultColorNums&quot;)
signals.orgchanged:connect(svo.updatevecho, &quot;update svo.getDefaultColorNums&quot;)
if svo.systemloaded then svo.updatevecho() end


function svo.updateloggingconfig()
  if svo.conf.log == 'off' then
    svo.debugf = function() end
  elseif svo.conf.log == 'file' then
    svo.debugf = function(...)
      if not Logger then return end

      local args = {...}
      if #args &lt; 2 and args[1] and args[1]:find(&quot;%&quot;, 1, true) then
        Logger:Log('svof', &quot;not enough args to debugf: &quot;..debug.traceback())
        return
      end
      Logger:Log('svof', string.format(...))
    end
  elseif svo.conf.log == 'echo' then
    svo.debugf = function(...)
      local args = {...}
      if #args &lt; 2 and args[1] and args[1]:find(&quot;%&quot;, 1, true) then
        svo.echof(&quot;not enough args to debugf: &quot;..debug.traceback())
        return
      end
      svo.echof(string.format(...))
    end
  else
    svo.debugf = function(...)
      if not Logger then return end

      local args = {...}
      if #args &lt; 2 and args[1] and args[1]:find(&quot;%&quot;, 1, true) then
        Logger:Log('svof', &quot;not enough args to debugf: &quot;..debug.traceback())
        return
      end
      Logger:Log('svof', string.format(...))
    end
  end
end
svo.updateloggingconfig()

function svo.showprompt()
  if conf.singleprompt then clearWindow'bottomprompt' end

  -- https://bugs.launchpad.net/mudlet/+bug/982720 disallows (conf.singleprompt and 'bottomprompt' or 'main')
  -- if conf.paused then
  --   if conf.singleprompt then
  --     decho('bottomprompt', &quot;&lt;255,0,0&gt;(&lt;128,128,128&gt;p&lt;255,0,0&gt;)&lt;0,0,0&gt; &quot;)
  --   else
  --     decho(&quot;&lt;255,0,0&gt;(&lt;128,128,128&gt;p&lt;255,0,0&gt;)&lt;0,0,0&gt; &quot;)
  --   end
  -- end

  if not conf.customprompt or affs.blackout or svo.innews then
    moveCursor('svo_prompt',0,getLastLineNumber('svo_prompt')-1)
    selectCurrentLine('svo_prompt')
    copy('svo_prompt')

    if conf.singleprompt then
      clearWindow('bottomprompt')

      if conf.paused then
        cecho('bottomprompt', &quot;&lt;a_red&gt;(&lt;a_darkgrey&gt;p&lt;a_red&gt;)&lt;black&gt; &quot;)
      end
      appendBuffer('bottomprompt')
    else
      if conf.paused then
        local currentline = getLineCount()
        deselect()
        moveCursor('main', 0, currentline)
        setFgColor(255, 0, 0)
        insertText(&quot;(&quot;)
        moveCursor('main', 1, currentline)
        setFgColor(128, 128, 128)
        insertText('p')
        moveCursor('main', 2, currentline)
        setFgColor(255, 0, 0)
        insertText(&quot;)&quot;)
        moveCursor('main', 3, currentline)
        setFgColor(0,0,0)
        insertText(&quot; &quot;)
        moveCursorEnd()
        resetFormat()
      end

      appendBuffer()
    end
  else
    if conf.singleprompt then
      cecho('bottomprompt', cp.display() or &quot;&quot;)
    else
      cecho(cp.display() or &quot;&quot;)
    end
  end
end

local ofs = svo.ofs
ofs.origdecho = decho
function ofs.windowdecho(text)
  if sk.echofwindow == 'main' then -- workaround for https://github.com/vadi2/mudlet-lua/issues/1
    ofs.origdecho(text)
  else ofs.origdecho(sk.echofwindow, text) end
end

ofs.origecho = echo
function ofs.windowecho(text)
  if sk.echofwindow == 'main' then -- workaround for https://github.com/vadi2/mudlet-lua/issues/1
    ofs.origecho(text)
  else ofs.origecho(sk.echofwindow, text) end
end

function svo.echof(...)
  local t = {...}
  -- see if we want this to go to a window!
  local sfind = string.find
  if t[1] and t[2] and sfind(t[1], &quot;^%w+$&quot;) and not sfind(t[1], &quot;%&quot;, 1, true) then
    sk.echofwindow = t[1]
    local olddecho, oldecho = decho, echo
    decho, echo = ofs.windowdecho, ofs.windowecho

    moveCursorEnd(t[1])
    svo.vecho(true, string.format(select(2, ...)))

    decho, echo = olddecho, oldecho
  else
    moveCursorEnd('main')
    local successful, s = pcall(string.format, ...)
    if successful then
      svo.vecho(true, s)
    else
      error(s, 2)
    end
  end
end

function svo.echofn(...)
  moveCursorEnd('main')
  svo.vecho(false, string.format(...) or &quot;&quot;)
end

function svo.echon(...)
  echo(string.format(...))
end

function svo.itf(...)
  dinsertText(
    (
      (echosd[conf.echotype] and echosd[conf.echotype]()) or
      (echosd[conf.org] and echosd[conf.org]())or echosd.default()
    ) .. string.format(...) or &quot;&quot;)
  -- debugf((echosd[conf.echotype] and echosd[conf.echotype]() or echosd.default()) .. string.format(...) or &quot;&quot;)
end

function svo.errorf(...)
   error(string.format(...))
end

-- used in public API to allow $'s
function svo.snd(what, show)
  for _,w in ipairs(string.split(what, &quot;%$&quot;)) do
    _G.send(w, show or false)
    if (affs.seriousconcussion or (conf.doubledo and affs.stupidity)) and not svo.sys.sync then
      _G.send(w, show or false)
    end
  end
end

-- given a table of keys and values as integers, return the key with highest value
function svo.getHighestKey(tbl)
  local result
  local highest = -1
  for i,j in pairs(tbl) do
    if j &gt; highest then
      highest = j
      result = i
    end
  end

  return result
end

function svo.getLowestKey(tbl)
  local result = select(1, next(tbl))
  local lowest = select(2, next(tbl))
  for i,j in pairs(tbl) do
    if j &lt; lowest then
      lowest = j
      result = i
    end
  end

  return result
end

function svo.getHighestValue(tbl)
  local highest = 0
  for _,j in pairs(tbl) do
    if j &gt; highest then
      highest = j
    end
  end

  return highest
end

function svo.getBoundary(tbl)
  local highest, lowest = 0, select(2, next(tbl))
  for _,j in pairs(tbl) do
    if j &gt; highest then
      highest = j
    elseif j &lt; lowest then
      lowest = j
    end
  end

  return highest, lowest
end

function svo.oneconcat(tbl)
  svo.assert(type(tbl) == 'table', &quot;svo.oneconcat wants a table as an argument.&quot;)
  local result = {}
  for i,_ in pairs(tbl) do
    result[#result+1] = i
  end

  return table.concat(result, &quot;, &quot;)
end

function svo.oneconcatwithval(tbl)
  svo.assert(type(tbl) == 'table', &quot;svo.oneconcatwithval wants a table as an argument.&quot;)
  local result = {}
  local sformat = string.format
  for i,v in pairs(tbl) do
    result[#result+1] = sformat(&quot;%s(%s)&quot;, i, v)
  end

  return table.concat(result, &quot;, &quot;)
end

function svo.concatand(t)
  svo.assert(type(t) == 'table', &quot;svo.concatand: argument must be a table&quot;)

  if #t == 0 then return &quot;&quot;
  elseif #t == 1 then return t[1]
  else
    return table.concat(t, &quot;, &quot;, 1, #t-1) .. &quot; and &quot;..t[#t]
  end
end

function svo.concatandf(t, f)
  svo.assert(type(t) == 'table', &quot;svo.concatandf: argument must be a table&quot;)

  return svo.concatand(svo.pl.tablex.map(f, t))
end

function svo.keystolist(t)
  local r = {}

  for k,_ in pairs(t) do
    r[#r+1] = k
  end

  return r
end

-- table -&gt; number
-- given a shallow key-value table of items, returns the length of the biggest string value in it
function svo.longeststring(input)
  local longest, found = 0

  local type = type
  for _,v in pairs(input) do
    if type(v) == 'string' then
      found = true
      local length = #v

      if length &gt; longest then longest = length end
    end
  end

  if found then return longest else return nil, &quot;no strings found in the given table&quot; end
end

function svo.safeconcat(t, separator)
  svo.assert(type(t) == 'table', &quot;svo.safeconcat: argument must be a table&quot;)

  if #t == 0 then return &quot;&quot;
  elseif #t == 1 then return tostring(t[1])
  else
    local temp = {}
    for i = 1, #t do
      temp[#temp+1] = tostring(t[i])
    end
    return table.concat(temp, separator or '')
  end
end

function svo.deleteLineP()
  deleteLine()
  svo.gagline = true -- used for not echoing things on lines that'll be deleted
  svo.sk.onprompt_beforeaction_add('deleteLine', function()
    svo.gagline = false
  end)

  -- if not on shipmode, or in shipmode but didn't actually see the ship prompt...
  if not conf.shipmode or not svo.me.shippromptn then
    tempLineTrigger(1,1,[[
      if isPrompt() then
        deleteLine()
      end
    ]])
  else
    -- remember when the deletion was requested, to work out if we should delete the prompt or not
    sk.requested_deletelineP = getLineCount()
    sk.onprompt_beforeaction_add(&quot;deleteLineP shipmode&quot;, function()
      if svo.conf.shipmode and svo.me.shippromptn and sk.requested_deletelineP+1 == svo.me.shippromptn then
        local from, to = svo.me.shippromptn , getLineCount()
        for i = from, to-1 do
          moveCursor(0, i) deleteLine()
        end
        moveCursorEnd()
         -- wrapLine(to) deleteLine()
        tempLineTrigger(0, 1, [[deleteLine()]]) -- cover the customprompt over after
      end
    end)
  end
end

function svo.deleteAllP(count)
  if not count then deleteLine() end
  tempLineTrigger(count or 1,1,[[
  deleteLine()
  if not isPrompt() then
    svo.deleteAllP()
  end
]])
end

function svo.containsbyname(t, value)
  svo.assert(type(t) == 'table', &quot;svo.containsbyname wants a table!&quot;)
  for k, v in pairs(t) do
    if v == value then return k end
  end

  return false
end

function svo.contains(t, value)
  svo.assert(type(t) == 'table', &quot;svo.contains wants a table!&quot;)
  for k, v in pairs(t) do
    if v == value then
      return true
    elseif k == value then
      return true
    elseif type(v) == 'table' then
      if svo.contains(v, value) then return true end
    end
  end

  return false
end

-- longer priorities take the first order
function svo.syncdelay()
  if not svo.sys.sync then
    return 0
  elseif affs.aeon or affs.retardation then
    return 1
  else return 0 -- failsafe
  end
end

function svo.events(event, ...)
  local name = event:lower()
  if signals[name] then signals[name]:emit(...) end
end

function svo.gevents(_, key)
  local name = key:gsub(&quot;%.&quot;,&quot;&quot;):lower()
  if signals[name] then signals[name]:emit() end
end

local yes = {'yes', 'yep', 'yup', 'oui', 'on', 'y', 'da'}
local no = {'no', 'nope', 'non', 'off', 'n', 'net'}
function svo.convert_string(which)
  if svo.contains(yes, which) or which == true then return true end
  if svo.contains(no, which) or which == false then return false end

  return nil
end
svo.toboolean = svo.convert_string

function svo.convert_boolean(which)
  if which == true then return 'on'
  else return 'off' end
end

-- this should also cache to prevent a lot of getLines() calls from the tekura function
-- warning, wrapped lines -will- be split up here
function svo.find_until_last_paragraph (pattern, type)
  local t = getLines(svo.lastpromptnumber, getLastLineNumber('main'))

  local find = string.find
  for i = 1, #t do
    local line = t[i]

    if type == 'exact' and line == pattern then return true
    elseif type == 'pattern' and find(line, pattern) then return true
    elseif type == 'substring' and find(line, pattern, 1, true) then return true end
  end

  return false
end

-- returns the count of matches from the current line until the start of the paragraph
function svo.count_until_last_paragraph (pattern, type)
  local t = getLines(svo.lastpromptnumber, getLastLineNumber('main'))

  local find, count = string.find, 0
  for i = 1, #t do
    local line = t[i]

    if type == 'exact' and line == pattern then count = count + 1
    elseif type == 'pattern' and find(line, pattern) then count = count + 1
    elseif type == 'substring' and find(line, pattern, 1, true) then count = count + 1 end
  end

  return count
end

-- merge table2 into table1
svo.update = function (t1, t2)
  for k,v in pairs(t2) do
    if type(v) == 'table' then
      t1[k] = svo.update(t1[k] or {}, v)
    else
      t1[k] = v
    end
  end
  return t1
end

-- assumes two table are of same length and does not recurse
-- Returns the value-key list of differences as the values are in t2
svo.basictableindexdiff = function (t1, t2)
  local diff = {}
  -- have to use pairs to cover holes
  for k,v in pairs(t1) do
    if v ~= t2[k] then diff[#diff+1] = v end
  end
  for k,v in pairs(t2) do
    if v ~= t1[k] then diff[#diff+1] = v end
  end

  return diff
end

svo.oldsend = _G.send
local fancy_send_commands = {}

function svo.fancysend(what, store)
  if conf.batch then svo.sendc(what); sk.systemscommands[what] = true else svo.oldsend(what, false) end

  if (affs.seriousconcussion or (conf.doubledo and affs.stupidity)) and not svo.sys.sync and
    not svo.sys.sendonceonly then
    if conf.batch then svo.sendc(what); sk.systemscommands[what] = true else svo.oldsend(what, false) end
  end

  if conf.repeatcmd &gt; 0 then
    for _ = 1, conf.repeatcmd do
      if conf.batch then svo.sendc(what); sk.systemscommands[what] = true else svo.oldsend(what, false) end
    end
  end

  if not store then return end

  fancy_send_commands[#fancy_send_commands+1] = what
end

function svo.fancysendall()
  if #fancy_send_commands == 0 then return end

  if conf.commandechotype == 'fancynewline' then echo'\n' end
  decho(string.format(&quot;&lt;51,0,255&gt;(&lt;242,234,233&gt;%s&lt;51,0,255&gt;)&quot;,
    table.concat(fancy_send_commands, &quot;&lt;102,98,97&gt;|&lt;242,234,233&gt;&quot;))
  )
  fancy_send_commands = {}
end

function svo.yep ()
  return &quot;&lt;0,250,0&gt;Yep&quot; .. svo.getDefaultColor()
end

function svo.nope ()
  return &quot;&lt;250,0,0&gt;Nope&quot; .. svo.getDefaultColor()
end

function svo.red (what)
  return &quot;&lt;250,0,0&gt;&quot; .. what .. svo.getDefaultColor()
end

function svo.green (what)
  return &quot;&lt;0,250,0&gt;&quot; .. what .. svo.getDefaultColor()
end

function svo.sk.reverse(a)
  return (a:gsub(&quot;().&quot;, function (p)
    return a:sub(#a-p+1,#a-p+1);
  end))
end

function svo.sk.anytoshort(exit)
  local t = {
    n = 'north',
    e = 'east',
    s = 'south',
    w = 'west',
    ne = 'northeast',
    se = 'southeast',
    sw = 'southwest',
    nw = 'northwest',
    u = 'up',
    d = 'down',
    ['in'] = 'in',
    out = 'out'
  }
  local rt = {}
  for s,l in pairs(t) do
    rt[l] = s; rt[s] = s
  end

  return rt[exit]
end

-- rewielding
--[[
basis:
  we re-wield items only we know we had wielded, that we unwielded involuntarily

  received items.update - if it doesn't have an 'l' or an 'r' attribute, then it means we unwielded it, or picked it up,
  or whatever. So, check if we had it wielded - if we did, then this was unwielded. needs rewielding.

  received items.updateif it does have an 'l' or an 'r' attribute, remember this as wielded - save in
  svo.me.wielding_left or svo.me.wielding_right.
]]

signals.gmcpcharname:connect(function ()
  sendGMCP(&quot;Char.Items.Inv&quot;)
  send(&quot;\n&quot;)
end, &quot;check gmcp inv on login&quot;)

signals.gmcpcharitemslist:connect(function()
  -- catch what is wielded
  local t = gmcp.Char.Items.List
  if t.location ~= 'inv' then return end

  me.wielded = {}

  for _, item in pairs(t.items) do
    if item.id and item.attrib then
      local lefthand, righthand = string.find(item.attrib, 'l', 1, true), string.find(item.attrib, 'L', 1, true)

      if (lefthand or righthand) then
        me.wielded[item.id] = deepcopy(item)

        if lefthand and righthand then
          me.wielded[item.id].hand = 'both'
        elseif lefthand then
          me.wielded[item.id].hand = 'left'
        else
          me.wielded[item.id].hand = 'right'
        end
      end
    end
  end

  raiseEvent(&quot;svo me.wielded updated&quot;)
end, &quot;update svo.me.wielded&quot;)

function svo.ceased_wielding(what)
  for itemid, item in pairs(me.wielded) do
    if item.name and item.name == what then
      me.wielded[itemid] = nil
      raiseEvent(&quot;svo me.wielded updated&quot;)
      return
    end
  end
end

function svo.unwielded(itemid, name)
  sk.rewielddables = sk.rewielddables or {}
  if not (sk.rewielddables[1] and sk.rewielddables[1].id == itemid) then
    sk.rewielddables[#sk.rewielddables+1] = {id = itemid, name = name}
  end

  if conf.autorewield then
    signals.before_prompt_processing:connect(sk.checkrewield, &quot;run checkrewield&quot;)
  end

  me.wielded[itemid] = nil
  raiseEvent(&quot;svo me.wielded updated&quot;)
end

signals.gmcpcharitemsupdate:connect(
function ()
  local t = gmcp.Char.Items.Update

  if t.location ~= 'inv' or type(me.wielded) ~= 'table' then return end

  -- unwielded?
  if t.item.id and me.wielded[t.item.id] and t.item.name and
    (not t.item.attrib or (not string.find(t.item.attrib, 'l', 1, true) and
      not string.find(t.item.attrib, 'L', 1, true))) then
    svo.unwielded(t.item.id, t.item.name)

  -- wielded? allow for a re-update on the wielding data as well
  elseif t.item.attrib and t.item.id and (string.find(t.item.attrib, 'l', 1, true) or
    string.find(t.item.attrib, 'L', 1, true)) then
    local lefthand, righthand = string.find(t.item.attrib, 'l', 1, true), string.find(t.item.attrib, 'L', 1, true)

    me.wielded[t.item.id] = deepcopy(t.item)

    if lefthand and righthand then
      me.wielded[t.item.id].hand = 'both'
    elseif lefthand then
      me.wielded[t.item.id].hand = 'left'
    else
      me.wielded[t.item.id].hand = 'right'
    end

    svo.checkaction(svo.dict.rewield.physical)
    if svo.actions.rewield_physical then
      svo.lifevision.add(svo.actions.rewield_physical.p, nil, t.item.id)
    end
    raiseEvent(&quot;svo me.wielded updated&quot;)
  end
end, &quot;update svo.me.wielded off gmcp update&quot;)

signals.gmcpcharitemsremove:connect(function ()
  local t = gmcp.Char.Items.Remove
  if t.location ~= 'inv' or type(me.wielded) ~= 'table' then return end
  local itemid = tostring(t.item.id)
  if me.wielded[itemid] then
    svo.unwielded(itemid, me.wielded[itemid].name or &quot;&quot;)
  end
end, &quot;update svo.me.wielded off gmcp remove&quot;)

function svo.setdefaultprompt()
  if svo.haveskillset('shindo') then
    svo.config.set('customprompt',
      [[^1@healthh, ^2@manam, ^5@endurancee, ^4@willpowerw @promptstringorig@affs^6@shin^w-]], false)
  elseif svo.haveskillset('kaido') then
    svo.config.set('customprompt',
      [[^1@healthh, ^2@manam, ^5@endurancee, ^4@willpowerw @promptstringorig@affs^6@kai^W-]], false)
  else
    svo.config.set('customprompt',
      [[^1@healthh, ^2@manam, ^5@endurancee, ^4@willpowerw @promptstringorig@affs^W-]], false)
  end
end

signals.enablegmcp:connect(function()
  sendGMCP([[Core.Supports.Add [&quot;IRE.Time 1&quot;] ]])
  sendGMCP(&quot;IRE.Time.Request&quot;)
end, &quot;enable and check time&quot;)

function svo.setignore(k,v)
  -- default to true, use unsetignore to clear
  if v == nil then v = true end

  svo.ignore[k] = v
  raiseEvent(&quot;svo ignore changed&quot;, k)
end

function svo.unsetignore(k)
  svo.ignore[k] = nil
  raiseEvent(&quot;svo ignore changed&quot;, k)
end

function svo.setserverignore(k)
  svo.serverignore[k] = true
  raiseEvent(&quot;svo serverignore changed&quot;, k)
end

function svo.unsetserverignore(k)
  svo.serverignore[k] = nil
  raiseEvent(&quot;svo serverignore changed&quot;, k)
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Empty cure handling</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local empty = svo.empty

local affs = svo.affs

local madness_affs = {'addiction', 'confusion', 'dementia', 'hallucinations', 'hypersomnia', 'illness', 'impatience',
'lethargy', 'loneliness', 'madness', 'masochism', 'paranoia', 'recklessness', 'stupidity', 'vertigo'}

for herbname, herbaffs in pairs({
  goldenseal = {'dissonance', 'impatience', 'stupidity', 'dizziness', 'epilepsy', 'shyness', 'depression',
   'shadowmadness'},
  kelp = {'asthma', 'hypochondria', 'healthleech', 'sensitivity', 'clumsiness', 'weakness'},
  lobelia = {'claustrophobia', 'recklessness', 'agoraphobia', 'loneliness', 'masochism', 'vertigo', 'spiritdisrupt',
  'airdisrupt', 'waterdisrupt', 'earthdisrupt', 'firedisrupt'},
  ginseng = {'haemophilia', 'darkshade', 'relapsing', 'addiction', 'illness', 'lethargy'},
  ash = {'hallucinations', 'hypersomnia', 'confusion', 'paranoia', 'dementia'},
  bellwort = {'generosity', 'pacifism', 'justice', 'inlove', 'peace', 'retribution', 'timeloop'}
}) do
  empty['eat_'..herbname] = function()
    svo.lostbal_herb()

    if not affs.madness then
      svo.rmaff(herbaffs)
    else
      svo.rmaff(table.n_complement(herbaffs, madness_affs))
    end

  end
end

-- handle affs with madness separately

empty.eat_bloodroot = function()
  svo.lostbal_herb()
  svo.rmaff('paralysis')

  if not affs.stain then svo.rmaff('slickness') end
end

empty.degenerateaffs = {'weakness', 'clumsiness', 'lethargy', 'illness', 'asthma', 'paralysis'}
-- expose publicly
svo.degenerateaffs = empty.degenerateaffs

empty.deteriorateaffs = {'stupidity', 'confusion', 'hallucinations', 'depression', 'shadowmadness', 'vertigo',
'masochism', 'agoraphobia', 'claustrophobia'}
-- expose publicly
svo.deteriorateaffs = empty.deteriorateaffs

empty.focuscurables = {'claustrophobia', 'masochism', 'dizziness', 'confusion', 'stupidity', 'generosity',
'loneliness', 'agoraphobia', 'recklessness', 'epilepsy', 'pacifism', 'anorexia', 'shyness', 'vertigo', 'unknownmental',
'airdisrupt', 'earthdisrupt', 'waterdisrupt', 'firedisrupt', 'paranoia', 'hallucinations', 'dementia'}

-- expose publicly
svo.focuscurables = empty.focuscurables
empty.focus = function()
  if affs.madness then return end

  svo.rmaff(empty.focuscurables)
end

-- you /can/ cure hamstring, dissonance with tree
empty.treecurables = {'ablaze', 'addiction', 'aeon', 'agoraphobia', 'anorexia', 'asthma', 'blackout', 'claustrophobia',
'clumsiness', 'confusion', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'darkshade',
'deadening', 'dementia', 'disloyalty', 'disrupt', 'dissonance', 'dizziness', 'epilepsy', 'fear', 'generosity',
'haemophilia', 'hallucinations', 'healthleech',  'hellsight', 'hypersomnia', 'hypochondria', 'illness', 'impatience',
'inlove', 'itching', 'justice', 'lethargy', 'loneliness', 'madness', 'masochism', 'pacifism', 'paralysis', 'paranoia',
'peace', 'recklessness', 'relapsing', 'selarnia', 'sensitivity', 'shyness', 'slickness', 'stupidity', 'stuttering',
'unknownany', 'unknowncrippledarm', 'unknowncrippledleg', 'unknownmental', 'vertigo', 'voyria', 'weakness', 'hamstring',
'shivering', 'frozen', 'skullfractures', 'crackedribs', 'wristfractures', 'torntendons', 'depression', 'parasite',
'retribution', 'shadowmadness', 'timeloop', 'degenerate', 'deteriorate'}
empty.treeblocks = {
  madness = {'madness', 'dementia', 'stupidity', 'confusion', 'hypersomnia', 'paranoia', 'hallucinations', 'impatience',
  'addiction', 'agoraphobia', 'inlove', 'loneliness', 'recklessness', 'masochism'},
  hypothermia = {'frozen', 'shivering'},
}
-- expose publicly
svo.treecurables = empty.treecurables

svo.gettreeableaffs = function(getall)
  local a = svo.deepcopy(empty.treecurables)
  for blockaff, blocked in pairs(empty.treeblocks) do
    if affs[blockaff] then
      for _, remaff in ipairs(blocked) do
        table.remove(a, table.index_of(a, remaff))
      end
    end
  end
  if not getall then
    local i = 1
    while #a &gt;= i do
      if not affs[a[i]] then
        table.remove(a, i)
      else
        i = i + 1
      end
    end
  end
  return a
end

empty.tree = function ()
  local a = svo.gettreeableaffs()
  svo.debugf(&quot;Tree cured nothing, removing: &quot;..table.concat(a, &quot;, &quot;))
  svo.rmaff(a)
  svo.dict.unknownmental.count = 0
  svo.dict.unknownany.count = 0
end

empty.dragonheal = empty.tree
-- this includes weakness - but if shrugging didn't cure anything, it still means we didn't have weakness as we can't
-- use shrugging with weakness
empty.shrugging  = empty.tree

empty.smoke_elm = function()
  svo.rmaff({'deadening', 'madness', 'aeon'})
end

empty.smoke_valerian = function()
  svo.rmaff({'disloyalty', 'manaleech', 'slickness', 'hellsight'})
end


empty.writhe = function()
  svo.rmaff({'impale', 'bound', 'webbed', 'roped', 'transfixed', 'hoisted'})
end

empty.apply_epidermal_head = function ()
  svo.rmaff({'anorexia', 'itching', 'stuttering', 'slashedthroat', 'blindaff', 'deafaff', 'scalded'})
  svo.defences.lost('blind')
  svo.defences.lost('deaf')
end

empty.apply_epidermal_body = function ()
  svo.rmaff({'anorexia', 'itching'})
end

empty.apply_mending = function()
  svo.dict.unknowncrippledlimb.count = 0
  svo.dict.unknowncrippledarm.count = 0
  svo.dict.unknowncrippledleg.count = 0
  svo.rmaff({'selarnia', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'ablaze',
    'severeburn', 'extremeburn', 'charredburn', 'meltingburn', 'unknowncrippledarm', 'unknowncrippledleg',
    'unknowncrippledlimb'})
end

empty.noeffect_mending_arms = function()
  svo.rmaff({'crippledrightarm', 'crippledleftarm', 'unknowncrippledarm'})
  svo.dict.unknowncrippledarm.count = 0
end

empty.noeffect_mending_legs = function()
  svo.rmaff({'crippledrightleg', 'crippledleftleg', 'unknowncrippledleg'})
  svo.dict.unknowncrippledleg.count = 0
end

empty.apply_health_head = function()
  svo.rmaff({'skullfractures'})
  svo.dict.skullfractures.count = 0
end

empty.apply_health_torso = function()
  svo.rmaff({'crackedribs'})
  svo.dict.crackedribs.count = 0
end

empty.apply_health_arms = function()
  svo.rmaff({'wristfractures'})
  svo.dict.wristfractures.count = 0
end

empty.apply_health_legs = function()
  svo.rmaff({'torntendons'})
  svo.dict.torntendons.count = 0
end

empty.sip_immunity = function ()
  svo.rmaff('voyria')
end

empty.eat_ginger = function ()
  svo.rmaff({'cholerichumour', 'melancholichumour', 'phlegmatichumour', 'sanguinehumour'})
  svo.dict.cholerichumour.count = 0
  svo.dict.melancholichumour.count = 0
  svo.dict.phlegmatichumour.count = 0
  svo.dict.sanguinehumour.count = 0
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Dictionary of actions (affs/defs/misc)</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

--[[
spriority: global async priority. In use when curing in sync mode.
aspriority: inter-balance sync priority. In use when curing in async mode.
isadvisable: determines if it is possible to cure this aff. some things that
  block bals might not block a single aff
]]

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local deepcopy, conf, sk, me, defs, defc = svo.deepcopy, svo.conf, svo.sk, svo.me, svo.defs, svo.defc
local defences, stats, empty, cnrl, rift = svo.defences, svo.stats, svo.empty, svo.cnrl, svo.rift
local bals, pipes = svo.bals, svo.pipes

-- these lists are checked by curing functions in the skeleton
svo.dict_balanceful = {}
svo.dict_balanceless = {}
svo.dict_balanceful_def = {}
svo.dict_balanceless_def = {}
svo.dict_herb = {}
svo.dict_misc = {}
svo.dict_misc_def = {}
svo.dict_purgative = {}
svo.dict_salve_def = {}
svo.dict_smoke_def = {}

svo.codepaste = svo.codepaste or {}
local codepaste = svo.codepaste

local tekura_ability_isadvisable = function (new_stance)
  return (
    (
      (
        sys.deffing
        and defdefup[defs.mode][new_stance]
        and not defc[new_stance]
      )
      or (
        conf.keepup
        and defkeepup[defs.mode][new_stance]
        and not defc[new_stance]
      )
    )
    and me.path == 'tekura'
    and not codepaste.balanceful_defs_codepaste()
    and not defc.riding
  ) or false
end

local shikudo_ability_isadvisable = function (new_form)
  return (
    (
      (
        sys.deffing
        and defdefup[defs.mode][new_form]
        and not defc[new_form]
      )
      or (
        conf.keepup
        and defkeepup[defs.mode][new_form]
        and not defc[new_form]
      )
    )
    and me.path == 'shikudo'
    and not codepaste.balanceful_defs_codepaste()
    and not defc.riding
  ) or false
end

local tekura_stance_oncompleted = function (new_stance)
  local stances = {
    'horse',
    'eagle',
    'cat',
    'bear',
    'rat',
    'scorpion',
    'dragon'
  }

  for _, stance in ipairs(stances) do
    defences.lost(stance)
  end

  defences.got(new_stance)
end

local shikudo_form_oncompleted = function (new_form)
  local shikudo_forms = {
    'tykonos',
    'willow',
    'rain',
    'oak',
    'gaital',
    'maelstrom'
  }

  for _, form in ipairs(shikudo_forms) do
    defences.lost(form)
  end

  defences.got(new_form)
end

-- used to check if we're writhing from something already
--impale stacks below other writhes
codepaste.writhe = function()
  return (
    not svo.doingaction('curingtransfixed') and not svo.doingaction('transfixed') and
    not svo.doingaction('curingimpale') and not svo.doingaction('impale') and
    not svo.doingaction('curingbound') and not svo.doingaction('bound') and
    not svo.doingaction('curingwebbed') and not svo.doingaction('webbed') and
    not svo.doingaction('curingroped') and not svo.doingaction('roped') and
    not svo.doingaction('curinghoisted') and not svo.doingaction('hoisted') and
    not svo.doingaction('dragonflex'))
end

-- gives a warning if we're having too many reaves
codepaste.checkreavekill = function()
  -- count up all humours, if three - warn of nearly, if four - warn of reaveability
  local c = 0
  if affs.cholerichumour then c = c + 1 end
  if affs.melancholichumour then c = c + 1 end
  if affs.phlegmatichumour then c = c + 1 end
  if affs.sanguinehumour then c = c + 1 end

  if c == 4 then
    sk.warn 'reavable'
  elseif c == 3 then
    sk.warn 'nearlyreavable'
  elseif c == 2 then
    sk.warn 'somewhatreavable'
  end
end

codepaste.checkdismemberkill = function()
  if not svo.enabledclasses.sentinel then return end

  if affs.bound and affs.impale then
    sk.warn 'dismemberable'
  end
end

codepaste.badaeon = function()
  -- if we're in a poor aeon situation, warn to gtfo
  if not affs.aeon then return end

  local c = 0
  if affs.asthma then c = c + 1 end
  if affs.stupidity then c = c + 1 end
  if affs.voided then c = c + 1 end
  if affs.asthma and affs.anorexia then c = c + 1 end

  if c &gt;= 1 then sk.warn 'badaeon' end
end

codepaste.addrestobreakleg = function(aff, oldhp, tekura)
  local leg = aff:find('right') and 'right' or 'left'

  if not conf.aillusion or ((not oldhp or oldhp &gt; stats.currenthealth) or svo.paragraph_length &gt;= 3 or
    (affs.recklessness and getStopWatchTime(affs[aff].sw) &gt;= conf.ai_restoreckless))
    -- accept it when it was a tremolo hit that set us up for a break as well
    or (sk.tremoloside and sk.tremoloside[leg])
  then

    -- clear sk.tremoloside for the leg, so tremolo later on can know when it /didn't/ break a leg
    if sk.tremoloside and sk.tremoloside[leg] then
      sk.tremoloside[leg] = nil
    end

    if not tekura then
      svo.addaffdict(svo.dict[aff])
    else
      if not sk.delaying_break then
        -- from the first hit, it's approximately getNetworkLatency() time until the second -
        -- add the conf.tekura_delay to allow for variation in ping
        sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function()
          sk.delaying_break = nil

          for _, tekuraaff in ipairs(sk.tekura_mangles) do
            svo.addaffdict(svo.dict[tekuraaff])
          end
          sk.tekura_mangles = nil
          svo.make_gnomes_work()
        end)
      end

      sk.tekura_mangles = sk.tekura_mangles or {}
      sk.tekura_mangles[#sk.tekura_mangles+1] = aff
    end
  end
end

codepaste.addrestobreakarm = function(aff, oldhp, tekura)
  if not conf.aillusion or ((not oldhp or oldhp &gt; stats.currenthealth) or svo.paragraph_length &gt;= 3 or
    (affs.recklessness and getStopWatchTime(affs[aff].sw) &gt;= conf.ai_restoreckless)) then

    if not tekura then
      svo.addaffdict(svo.dict[aff])
      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      signals.canoutr:emit()

    else
      if not sk.delaying_break then
         -- from the first hit, it's approximately getNetworkLatency() time until the second - add the conf.tekura_delay
         -- to allow for variation in ping
        sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function()
          sk.delaying_break = nil

          for _, tekuraaff in ipairs(sk.tekura_mangles) do
            svo.addaffdict(svo.dict[tekuraaff])
          end
          sk.tekura_mangles = nil

          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          signals.canoutr:emit()

          svo.make_gnomes_work()
        end)
      end

      sk.tekura_mangles = sk.tekura_mangles or {}
      sk.tekura_mangles[#sk.tekura_mangles+1] = aff
    end

  end
end

codepaste.remove_focusable = function ()
  if not affs.unknownmental then return end
  affs.unknownmental.p.count = affs.unknownmental.p.count - 1
  if affs.unknownmental.p.count &lt;= 0 then
    svo.rmaff('unknownmental')
    svo.dict.unknownmental.count = 0
  else
    svo.updateaffcount(svo.dict.unknownmental)
  end
end

-- keep argument is used when the aff is still on you
codepaste.remove_stackableaff = function (aff, keep)
  if not affs[aff] then return end
  svo.dict[aff].count = svo.dict[aff].count - 1

  if keep and svo.dict[aff].count &lt;= 0 then svo.dict[aff].count = 1 end

  if svo.dict[aff].count &lt;= 0 then
    svo.rmaff(aff)
    svo.dict[aff].count = 0
  else
    svo.updateaffcount(svo.dict[aff])
  end
end

-- -&gt; boolean
-- returns true if we're using some non-standard cure - tree, restore, class skill...
codepaste.nonstdcure = function()
  if svo.haveskillset('venom') then
    return svo.doingaction'shrugging'
  end
  if svo.haveskillset('healing') then
    return svo.doingaction'usehealing'
  end

  return (svo.doingaction'touchtree' or svo.doingaction'restore')
end

if svo.haveskillset('metamorphosis') then
  codepaste.nonmorphdefs = function ()
    for _, def in ipairs{'flame', 'lyre', 'nightsight', 'rest', 'resistance', 'stealth', 'temperance', 'elusiveness'} do
      if ((sys.deffing and defdefup[defs.mode][def]) or (not sys.deffing and conf.keepup and defkeepup[defs.mode][def])) and not defc[def] then return false end
    end

    -- local def = 'vitality'
    -- if ((sys.deffing and defdefup[defs.mode][def]) or (conf.keepup and defkeepup[defs.mode][def])) and not svo.doingaction'cantvitality' then return false end
    return true
  end
end

codepaste.smoke_elm_pipe = function()
  if pipes.elm.id == 0 then sk.warn 'noelmid' end
  if not (pipes.elm.lit or pipes.elm.arty) then
    sk.forcelight_elm = true
  end

  return (not (pipes.elm.id == 0) and
    (pipes.elm.lit or pipes.elm.arty) and
    not (pipes.elm.puffs == 0))
end

codepaste.smoke_valerian_pipe = function()
  if pipes.valerian.id == 0 then sk.warn 'novalerianid' end
  if not (pipes.valerian.lit or pipes.valerian.arty) then
    sk.forcelight_valerian = true
  end

  return (not (pipes.valerian.id == 0) and
    (pipes.valerian.lit or pipes.valerian.arty) and
    not (pipes.valerian.puffs == 0))
end

codepaste.smoke_skullcap_pipe = function()
  if pipes.skullcap.id == 0 then sk.warn 'noskullcapid' end
  if not (pipes.skullcap.lit or pipes.skullcap.arty) then
    sk.forcelight_skullcap = true
  end

  return (not (pipes.skullcap.id == 0) and
    (pipes.skullcap.lit or pipes.skullcap.arty) and
    not (pipes.skullcap.puffs == 0))
end

codepaste.balanceful_defs_codepaste = function()
  for k,_ in pairs(svo.dict_balanceful_def) do
    if svo.doingaction(k) then return true end
  end
end

-- adds the unknownany aff or increases the count by 1 or specified amount
codepaste.addunknownany = function(amount)
  local count = svo.dict.unknownany.count
  svo.addaffdict(svo.dict.unknownany)

  svo.dict.unknownany.count = (count or 0) + (amount or 1)
  svo.updateaffcount(svo.dict.unknownany)
end

sk.burns = {'ablaze', 'severeburn', 'extremeburn', 'charredburn', 'meltingburn'}
-- removes all burning afflictions except for the optional specified one
codepaste.remove_burns = function(skipaff)
  local burns = deepcopy(sk.burns)
  if skipaff then
    table.remove(burns, table.index_of(burns, skipaff))
  end

  svo.rmaff(burns)
end

sk.next_burn = function()
  for i,v in ipairs(sk.burns) do
    if affs[v] then return sk.burns[i+1] or sk.burns[#sk.burns] end
  end
end

sk.current_burn = function()
  for _,v in ipairs(sk.burns) do
    if affs[v] then return v end
  end
end

sk.previous_burn = function(howfar)
  for i,v in ipairs(sk.burns) do
    if affs[v] then return sk.burns[i-(howfar and howfar or 1)] or nil end
  end
end

codepaste.serversideahealthmanaprio = function()
  local healhealth_prio = svo.prio.getnumber('healhealth', 'sip')
  local healmana_prio   = svo.prio.getnumber('healmana'  , 'sip')

  -- swap using curing system commands as appropriate
  -- setup special balance in cache mentioning which is first, so it is remembered
  sk.priochangecache.special = sk.priochangecache.special or { healthormana = &quot;&quot;}

  if healhealth_prio &gt; healmana_prio and sk.priochangecache.special.healthormana ~= 'health' then
    svo.sendcuring(&quot;priority health&quot;)
    sk.priochangecache.special.healthormana = 'health'
  elseif healmana_prio &gt; healhealth_prio and sk.priochangecache.special.healthormana ~= 'mana' then
    svo.sendcuring(&quot;priority mana&quot;)
    sk.priochangecache.special.healthormana = 'mana'
  end
end

--[[ dict is to NEVER be iterated over fully by prompt checks; so isadvisable functions can
      typically expect not to check for the common things because pre-
      filtering is done.
  ]]

svo.dict = {
  -- (string) what serverside calls this by - names can be different as they were revealed years after Svof was made
  gamename = nil,
  onservereignore = nil, -- (function) a function which'll return true if this needs to be ignored serverside
  healhealth = {
    description = &quot;heals health with health/vitality or moss/potash&quot;,
    sip = {
      name = false, --'healhealth_sip',
      balance = false, --'sip',
      action_name = false, --'healhealth'
      aspriority = 0,
      spriority = 0,

      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        -- should healhealth be prioritised above health affs, don't apply if above healthaffsabove% and have an aff
        local function shouldntsip()
          local crackedribs    = svo.prio.getnumber('crackedribs', 'sip')
          local healhealth     = svo.prio.getnumber('healhealth', 'sip')
          local skullfractures = svo.prio.getnumber('skullfractures', 'sip')
          local torntendons    = svo.prio.getnumber('torntendons', 'sip')
          local wristfractures = svo.prio.getnumber('wristfractures', 'sip')

          if stats.hp &gt;= conf.healthaffsabove and ((healhealth &gt; crackedribs and affs.crackedribs) or
            (healhealth &gt; skullfractures and affs.skullfractures) or (healhealth &gt; torntendons and affs.torntendons) or
             (healhealth &gt; wristfractures and affs.wristfractures)) then
            return true
          end

          return false
        end

if not svo.haveskillset('kaido') then
        return ((stats.currenthealth &lt; sys.siphealth or (sk.gettingfullstats and stats.currenthealth &lt; stats.maxhealth))
         and not svo.actions.healhealth_sip and not shouldntsip())
else
        return ((stats.currenthealth &lt; sys.siphealth or (sk.gettingfullstats and stats.currenthealth &lt; stats.maxhealth))
         and not svo.actions.healhealth_sip  and not shouldntsip() and
          (defc.dragonform or -- sip health if we're in dragonform, can't use Kaido
            not svo.can_usemana() or -- or we don't have enough mana (should be an option). The downside of this is that we
            -- won't get mana back via sipping, only moss, the time to being able to transmute will approach slower than
            -- straight sipping mana
            (affs.prone and not conf.transsipprone) or -- or we're prone and sipping while prone is off (better for
            --bashing, not so for PK)
            (conf.transmute ~= 'replaceall' and conf.transmute ~= 'replacehealth' and not svo.doingaction'transmute')
            -- or we're not in a replacehealth/replaceall mode, so we can still sip
          )
        )
end
      end,

      oncompleted = function ()
        svo.lostbal_sip()
      end,

      noeffect = function()
        svo.lostbal_sip()
      end,

      onprioswitch = function()
        codepaste.serversideahealthmanaprio()
      end,

      sipcure = {'health', 'vitality'},

      onstart = function ()
        svo.sip(svo.dict.healhealth.sip)
      end
    },
    moss = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
if not svo.haveskillset('kaido') then
        return ((stats.currenthealth &lt; sys.mosshealth) and (not svo.doingaction('healhealth') or (stats.currenthealth &lt; (sys.mosshealth-600)))) or false
else
        return ((stats.currenthealth &lt; sys.mosshealth) and (not svo.doingaction('healhealth') or (stats.currenthealth &lt; (sys.mosshealth-600))) and (defc.dragonform or not svo.can_usemana() or affs.prone or (conf.transmute ~= 'replaceall' and not svo.doingaction'transmute'))) or false
end
      end,

      oncompleted = function ()
        svo.lostbal_moss()
      end,

      noeffect = function()
        svo.lostbal_moss()
      end,

      eatcure = {'irid', 'potash'},
      actions = {&quot;eat moss&quot;, &quot;eat irid&quot;, &quot;eat potash&quot;},
      onstart = function ()
        svo.eat(svo.dict.healhealth.moss)
      end
    },
  },
  healmana = {
    description = &quot;heals mana with mana/mentality or moss/potash&quot;,
    sip = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        return ((stats.currentmana &lt; sys.sipmana or (sk.gettingfullstats and stats.currentmana &lt; stats.maxmana)) and not svo.doingaction('healmana')) or false
      end,

      oncompleted = function ()
        svo.lostbal_sip()
      end,

      noeffect = function()
        svo.lostbal_sip()
      end,

      onprioswitch = function()
        codepaste.serversideahealthmanaprio()
      end,

      sipcure = {'mana', 'mentality'},

      onstart = function ()
        svo.sip(svo.dict.healmana.sip)
      end
    },
    moss = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priority lists
      irregular = true,

      isadvisable = function ()
        return ((stats.currentmana &lt; sys.mossmana) and (not svo.doingaction('healmana') or (stats.currentmana &lt; (sys.mossmana-600)))) or false
      end,

      oncompleted = function ()
        svo.lostbal_moss()
      end,

      noeffect = function()
        svo.lostbal_moss()
      end,

      eatcure = {'irid', 'potash'},
      actions = {&quot;eat moss&quot;, &quot;eat irid&quot;, &quot;eat potash&quot;},
      onstart = function ()
        svo.eat(svo.dict.healmana.moss)
      end
    },
  },
  skullfractures = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.skullfractures and stats.hp &gt;= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        svo.lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = svo.dict.skullfractures.count
        codepaste.remove_stackableaff('skullfractures', true)
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('skullfractures', true)
        end
      end,

      cured = function()
        svo.lostbal_sip()
        svo.rmaff('skullfractures')
        svo.dict.skullfractures.count = 0
      end,

      fizzled = function ()
        svo.lostbal_sip()
        empty.apply_health_head()
      end,

      noeffect = function ()
        svo.lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {&quot;apply health to head&quot;},
      onstart = function ()
        send(&quot;apply health to head&quot;, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = svo.dict.skullfractures.count
        svo.addaffdict(svo.dict.skullfractures)

        svo.dict.skullfractures.count = (count or 0) + (number or 1)
        if svo.dict.skullfractures.count &gt; 7 then
          svo.dict.skullfractures.count = 7
        end
        svo.updateaffcount(svo.dict.skullfractures)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('skullfractures')
        svo.dict.skullfractures.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = svo.dict.skullfractures.count
        for _ = 1, (amount or 1) do
          codepaste.remove_stackableaff('skullfractures', not dontkeep)
        end
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('skullfractures', not dontkeep)
        end
      end,

      general_cured = function(_)
        svo.rmaff('skullfractures')
        svo.dict.skullfractures.count = 0
      end,
    }
  },
  crackedribs = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crackedribs and stats.hp &gt;= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        svo.lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = svo.dict.crackedribs.count
        codepaste.remove_stackableaff('crackedribs', true)
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('crackedribs', true)
        end
      end,

      cured = function()
        svo.lostbal_sip()
        svo.rmaff('crackedribs')
        svo.dict.crackedribs.count = 0
      end,

      fizzled = function ()
        svo.lostbal_sip()
        empty.apply_health_torso()
      end,

      noeffect = function ()
        svo.lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {&quot;apply health to torso&quot;},
      onstart = function ()
        send(&quot;apply health to torso&quot;, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = svo.dict.crackedribs.count
        svo.addaffdict(svo.dict.crackedribs)

        svo.dict.crackedribs.count = (count or 0) + (number or 1)
        if svo.dict.crackedribs.count &gt; 7 then
          svo.dict.crackedribs.count = 7
        end
        svo.updateaffcount(svo.dict.crackedribs)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('crackedribs')
        svo.dict.crackedribs.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = svo.dict.crackedribs.count
        for _ = 1, (amount or 1) do
          codepaste.remove_stackableaff('crackedribs', not dontkeep)
        end
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('crackedribs', not dontkeep)
        end
      end,

      general_cured = function()
        svo.rmaff('crackedribs')
        svo.dict.crackedribs.count = 0
      end,
    }
  },
  wristfractures = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.wristfractures and stats.hp &gt;= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        svo.lostbal_sip()
        -- two counts are cured if you're above 5
        local howmany = svo.dict.wristfractures.count
        codepaste.remove_stackableaff('wristfractures', true)
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('wristfractures', true)
        end
      end,

      cured = function()
        svo.lostbal_sip()
        svo.rmaff('wristfractures')
        svo.dict.wristfractures.count = 0
      end,

      fizzled = function ()
        svo.lostbal_sip()
        empty.apply_health_arms()
      end,

      noeffect = function ()
        svo.lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {&quot;apply health to arms&quot;},
      onstart = function ()
        send(&quot;apply health to arms&quot;, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = svo.dict.wristfractures.count
        svo.addaffdict(svo.dict.wristfractures)

        svo.dict.wristfractures.count = (count or 0) + (number or 1)
        if svo.dict.wristfractures.count &gt; 7 then
          svo.dict.wristfractures.count = 7
        end
        svo.updateaffcount(svo.dict.wristfractures)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('wristfractures')
        svo.dict.wristfractures.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = svo.dict.wristfractures.count
        for _ = 1, (amount or 1) do
          codepaste.remove_stackableaff('wristfractures', not dontkeep)
        end
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('wristfractures', not dontkeep)
        end
      end,

      general_cured = function()
        svo.rmaff('wristfractures')
        svo.dict.wristfractures.count = 0
      end,
    }
  },
  torntendons = {
    count = 0,
    sip = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.torntendons and stats.hp &gt;= conf.healthaffsabove) or false
      end,

      oncompleted = function ()
        svo.lostbal_sip()
                -- two counts are cured if you're above 5
        local howmany = svo.dict.torntendons.count
        codepaste.remove_stackableaff('torntendons', true)
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('torntendons', true)
        end
      end,

      cured = function()
        svo.lostbal_sip()
        svo.rmaff('torntendons')
        svo.dict.torntendons.count = 0
      end,

      fizzled = function ()
        svo.lostbal_sip()
        empty.apply_health_legs()
      end,

      noeffect = function ()
        svo.lostbal_sip()
      end,

      -- in case an unrecognised message is shown, don't error
      empty = function()
      end,

      actions = {&quot;apply health to legs&quot;},
      onstart = function ()
        send(&quot;apply health to legs&quot;, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (number)
        -- double kngiht affs from precision strikes
        if sk.doubleknightaff then number = (number or 0) + 1 end

        local count = svo.dict.torntendons.count
        svo.addaffdict(svo.dict.torntendons)

        svo.dict.torntendons.count = (count or 0) + (number or 1)
        if svo.dict.torntendons.count &gt; 7 then
          svo.dict.torntendons.count = 7
        end
        svo.updateaffcount(svo.dict.torntendons)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('torntendons')
        svo.dict.torntendons.count = 0
      end,

      general_cure = function(amount, dontkeep)
        -- two counts are cured if you're above 5
        local howmany = svo.dict.torntendons.count
        for _ = 1, (amount or 1) do
          codepaste.remove_stackableaff('torntendons', not dontkeep)
        end
        if howmany &gt; 5 then
          codepaste.remove_stackableaff('torntendons', not dontkeep)
        end
      end,

      general_cured = function()
        svo.rmaff('torntendons')
        svo.dict.torntendons.count = 0
      end,
    }
  },
  cholerichumour = {
    gamename = 'temperedcholeric',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.cholerichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        svo.lostbal_herb()
        codepaste.remove_stackableaff('cholerichumour', true)
      end,

      empty = function()
        empty.eat_ginger()
        svo.lostbal_herb()
      end,

      cured = function()
        svo.lostbal_herb()
        svo.rmaff('cholerichumour')
        svo.dict.cholerichumour.count = 0
      end,

      noeffect = function()
        svo.lostbal_herb()
      end,

      -- does damage based on humour count
      inundated = function()
        svo.rmaff('cholerichumour')
        svo.dict.cholerichumour.count = 0
      end,

      eatcure = {'ginger', 'antimony'},

      onstart = function ()
        svo.eat(svo.dict.cholerichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = svo.dict.cholerichumour.count
        svo.addaffdict(svo.dict.cholerichumour)

        svo.dict.cholerichumour.count = (count or 0) + (number or 1)
        if svo.dict.cholerichumour.count &gt; 8 then
          svo.dict.cholerichumour.count = 8
        end
        svo.updateaffcount(svo.dict.cholerichumour)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('cholerichumour')
        svo.dict.cholerichumour.count = 0
      end
    }
  },
  melancholichumour = {
    gamename = 'temperedmelancholic',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.melancholichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        svo.lostbal_herb()
        codepaste.remove_stackableaff('melancholichumour', true)
      end,

      empty = function()
        empty.eat_ginger()
        svo.lostbal_herb()
      end,

      cured = function()
        svo.lostbal_herb()
        svo.rmaff('melancholichumour')
        svo.dict.melancholichumour.count = 0
      end,

      noeffect = function()
        svo.lostbal_herb()
      end,

      -- does mana damage based on humour count
      inundated = function()
        svo.rmaff('melancholichumour')
        svo.dict.melancholichumour.count = 0
      end,

      eatcure = {'ginger', 'antimony'},

      onstart = function ()
        svo.eat(svo.dict.melancholichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = svo.dict.melancholichumour.count
        svo.addaffdict(svo.dict.melancholichumour)

        svo.dict.melancholichumour.count = (count or 0) + (number or 1)
        if svo.dict.melancholichumour.count &gt; 8 then
          svo.dict.melancholichumour.count = 8
        end
        svo.updateaffcount(svo.dict.melancholichumour)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('melancholichumour')
        svo.dict.melancholichumour.count = 0
      end
    }
  },
  phlegmatichumour = {
    gamename = 'temperedphlegmatic',
    count = 0,
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.phlegmatichumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        svo.lostbal_herb()
        codepaste.remove_stackableaff('phlegmatichumour', true)
      end,

      empty = function()
        empty.eat_ginger()
        svo.lostbal_herb()
      end,

      cured = function()
        svo.lostbal_herb()
        svo.rmaff('phlegmatichumour')
        svo.dict.phlegmatichumour.count = 0
      end,

      noeffect = function()
        svo.lostbal_herb()
      end,

      -- gives various afflictions, amount of which depends on your humour level
      --[[
        1-2: 1 affliction
        3-6: 2 afflictions
        7-9: 3 afflictions
        10: 4 afflictions

        Above information is roughly accurate.
        Gives between one and four afflictions from the following: lethargy, slickness, anorexia, weariness.
        Afflictions not hidden by gmcp, so removed from the inundated function.
      ]]
      inundated = function()
        svo.rmaff('phlegmatichumour')
        svo.dict.phlegmatichumour.count = 0
      end,

      eatcure = {'ginger', 'antimony'},

      onstart = function ()
        svo.eat(svo.dict.phlegmatichumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = svo.dict.phlegmatichumour.count
        svo.addaffdict(svo.dict.phlegmatichumour)

        svo.dict.phlegmatichumour.count = (count or 0) + (number or 1)
        if svo.dict.phlegmatichumour.count &gt; 8 then
          svo.dict.phlegmatichumour.count = 8
        end
        svo.updateaffcount(svo.dict.phlegmatichumour)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('phlegmatichumour')
        svo.dict.phlegmatichumour.count = 0
      end
    }
  },
  sanguinehumour = {
    gamename = 'temperedsanguine',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sanguinehumour) or false
      end,

      -- this is called when you still have some left
      oncompleted = function ()
        svo.lostbal_herb()
        codepaste.remove_stackableaff('sanguinehumour', true)
      end,

      empty = function()
        empty.eat_ginger()
        svo.lostbal_herb()
      end,

      cured = function()
        svo.lostbal_herb()
        svo.rmaff('sanguinehumour')
        svo.dict.sanguinehumour.count = 0
      end,

      noeffect = function()
        svo.lostbal_herb()
      end,

      -- gives bleeding depending on your sanguine humour level, from 250 for first to 2500 for last
      inundated = function()
        local min = 250
        -- local max = 2500
        if not affs.sanguinehumour then return end

        local bledfor = svo.dict.sanguinehumour.count * min

        svo.addaffdict(svo.dict.bleeding)
        svo.dict.bleeding.count = bledfor
        svo.updateaffcount(svo.dict.bleeding)

        svo.rmaff('sanguinehumour')
        svo.dict.sanguinehumour.count = 0
      end,

      eatcure = {'ginger', 'antimony'},

      onstart = function ()
        svo.eat(svo.dict.sanguinehumour.herb)
      end
    },
    aff = {
      oncompleted = function (number)
        local count = svo.dict.sanguinehumour.count
        svo.addaffdict(svo.dict.sanguinehumour)

        svo.dict.sanguinehumour.count = (count or 0) + (number or 1)
        if svo.dict.sanguinehumour.count &gt; 8 then
          svo.dict.sanguinehumour.count = 8
        end
        svo.updateaffcount(svo.dict.sanguinehumour)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('sanguinehumour')
        svo.dict.sanguinehumour.count = 0
      end
    }
  },
  waterbubble = {
    gamename = 'airpocket',
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return not defc.waterbubble and ((sys.deffing and defdefup[defs.mode].waterbubble) or (conf.keepup and defkeepup[defs.mode].waterbubble)) and not affs.anorexia and me.is_underwater
      end,

      eatcure = {'pear', 'calcite'},

      onstart = function ()
        svo.eat(svo.dict.waterbubble.herb)
      end,

      oncompleted = function ()
        defences.got('waterbubble')
      end,

      empty = function()
      end
    }
  },
  pacifism = {
    gamename = 'pacified',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.pacifism and
          not svo.doingaction('pacifism') and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('pacifism')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.pacifism.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.pacifism and
          not svo.doingaction('pacifism') and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('pacifism')
        svo.lostbal_focus()
      end,

      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.pacifism)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('pacifism')
        codepaste.remove_focusable()
      end,
    }
  },
  peace = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.peace and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('peace')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.peace.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.peace)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('peace')
      end,
    }
  },
  inlove = {
    gamename = 'lovers',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.inlove and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('inlove')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.inlove.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.inlove)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('inlove')
      end,
    }
  },
  dissonance = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dissonance and not svo.usingbal('focus')) or false
      end,

      oncompleted = function ()
        svo.rmaff('dissonance')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.dissonance.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.dissonance)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('dissonance')
      end,
    }
  },
  dizziness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dizziness and
          not svo.doingaction('dizziness') and not svo.usingbal('focus')) or false
      end,

      oncompleted = function ()
        svo.rmaff('dizziness')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.dizziness.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dizziness and
          not svo.doingaction('dizziness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('dizziness')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.dizziness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('dizziness')
        codepaste.remove_focusable()
      end,
    }
  },
  shyness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shyness and
          not svo.doingaction('shyness') and not svo.usingbal('focus')) or false
      end,

      oncompleted = function ()
        svo.rmaff('shyness')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.shyness.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shyness and
          not svo.doingaction('shyness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('shyness')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.shyness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('shyness')
        codepaste.remove_focusable()
      end,
    }
  },
  epilepsy = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.epilepsy and
          not svo.doingaction('epilepsy') and not svo.usingbal('focus')) or false
      end,

      oncompleted = function ()
        svo.rmaff('epilepsy')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.epilepsy.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.epilepsy and
          not svo.doingaction('epilepsy')) or false
      end,

      oncompleted = function ()
        svo.rmaff('epilepsy')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.epilepsy)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('epilepsy')
        codepaste.remove_focusable()
      end,
    }
  },
  impatience = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing impatience before hypochondria will make it get re-applied
        return (affs.impatience and not affs.madness and not svo.usingbal('focus')  and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        svo.rmaff('impatience')
        svo.lostbal_herb()

        -- if serverside cures impatience before we can even validate it, cancel it
        svo.affsp.impatience = nil
        svo.killaction(svo.dict.checkimpatience.misc)
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.impatience.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.impatience)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('impatience')
      end,
    }
  },
  stupidity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stupidity and
          not svo.doingaction('stupidity') and not svo.usingbal('focus')) or false
      end,

      oncompleted = function ()
        svo.rmaff('stupidity')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.stupidity.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stupidity and
          not svo.doingaction('stupidity') and not affs.madness) or false
      end,

      oncompleted = function ()
        svo.rmaff('stupidity')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.stupidity)
        sk.stupidity_count = 0
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('stupidity')
        codepaste.remove_focusable()
      end,
    }
  },
  masochism = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.masochism and not affs.madness and
          not svo.doingaction('masochism')) or false
      end,

      oncompleted = function ()
        svo.rmaff('masochism')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.masochism.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.masochism and not affs.madness and
          not svo.doingaction('masochism')) or false
      end,

      oncompleted = function ()
        svo.rmaff('masochism')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.masochism)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('masochism')
        codepaste.remove_focusable()
      end,
    }
  },
  recklessness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.recklessness and not affs.madness and
          not svo.doingaction('recklessness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('recklessness')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.recklessness.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.recklessness and not affs.madness and
          not svo.doingaction('recklessness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('recklessness')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function (data)
        if data and data.attacktype and data.attacktype == 'domination' and (data.atline+1 == getLastLineNumber('main')
          or (data.atline+1 == getLastLineNumber('main') and
            svo.find_until_last_paragraph(&quot;The gremlin races between your legs, throwing you off-balance.&quot;, 'exact'))) then
          svo.addaffdict(svo.dict.recklessness)
        elseif not conf.aillusion or
          (stats.maxhealth == stats.currenthealth and stats.maxmana == stats.currentmana) then
          svo.addaffdict(svo.dict.recklessness)
        end
      end,

      -- used for addaff to skip all checks
      forced = function ()
        svo.addaffdict(svo.dict.recklessness)
      end
    },
    gone = {
      oncompleted = function()
        svo.rmaff('recklessness')
        codepaste.remove_focusable()
      end,
    },
    onremoved = function ()
      svo.check_generics()
      if not affs.blackout then
        svo.killaction(svo.dict.nomana.waitingfor)
      end
      signals.before_prompt_processing:block(svo.valid.check_recklessness)
    end,
    onadded = function()
      signals.before_prompt_processing:unblock(svo.valid.check_recklessness)
    end,
  },
  justice = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.justice and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('justice')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.justice.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.justice)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('justice')
      end,
    }
  },
  generosity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.generosity and
          not svo.doingaction('generosity') and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('generosity')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.generosity.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.generosity and
          not svo.doingaction('generosity') and (not svo.haveskillset('chivalry') or not svo.dict.rage.misc.isadvisable())) or false
      end,

      oncompleted = function ()
        svo.rmaff('generosity')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.generosity)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('generosity')
        codepaste.remove_focusable()
      end,
    }
  },
  weakness = {
    gamename = 'weariness',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.weakness and
          not svo.doingaction('weakness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('weakness')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.weakness.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.weakness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('weakness')
        codepaste.remove_focusable()
      end,
    }
  },
  vertigo = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.vertigo and not affs.madness and
          not svo.doingaction('vertigo')) or false
      end,

      oncompleted = function ()
        svo.rmaff('vertigo')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.vertigo.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.vertigo and not affs.madness and
          not svo.doingaction('vertigo')) or false
      end,

      oncompleted = function ()
        svo.rmaff('vertigo')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.vertigo)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('vertigo')
        codepaste.remove_focusable()
      end,
    }
  },
  loneliness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.loneliness and not affs.madness and not svo.doingaction('loneliness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('loneliness')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.loneliness.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.loneliness and not affs.madness and not svo.doingaction('loneliness')) or false
      end,

      oncompleted = function ()
        svo.rmaff('loneliness')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.loneliness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('loneliness')
        codepaste.remove_focusable()
      end,
    }
  },
  dementia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dementia and not affs.madness and not svo.doingaction('dementia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('dementia')
        svo.lostbal_herb()
      end,

      eatcure = {'ash', 'stannum'},
      onstart = function ()
        svo.eat(svo.dict.dementia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.dementia and not affs.madness and not svo.doingaction('dementia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('dementia')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.dementia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('dementia')
      end,
    }
  },
  paranoia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.paranoia and not affs.madness and not svo.doingaction('paranoia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('paranoia')
        svo.lostbal_herb()
      end,

      eatcure = {'ash', 'stannum'},
      onstart = function ()
        svo.eat(svo.dict.paranoia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.paranoia and not affs.madness and not svo.doingaction('paranoia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('paranoia')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.paranoia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('paranoia')
      end,
    }
  },
  hypersomnia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypersomnia and not affs.madness) or false
      end,

      oncompleted = function ()
        svo.rmaff('hypersomnia')
        svo.lostbal_herb()
      end,

      eatcure = {'ash', 'stannum'},
      onstart = function ()
        svo.eat(svo.dict.hypersomnia.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hypersomnia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hypersomnia')
      end,
    }
  },
  hallucinations = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hallucinations and not affs.madness and not svo.doingaction('hallucinations')) or false
      end,

      oncompleted = function ()
        svo.rmaff('hallucinations')
        svo.lostbal_herb()
      end,

      eatcure = {'ash', 'stannum'},
      onstart = function ()
        svo.eat(svo.dict.hallucinations.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hallucinations and not affs.madness and not svo.doingaction('hallucinations')) or false
      end,

      oncompleted = function ()
        svo.rmaff('hallucinations')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hallucinations)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hallucinations')
      end,
    }
  },
  confusion = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.confusion and
          not svo.doingaction('confusion') and not affs.madness) or false
      end,

      oncompleted = function ()
        svo.rmaff('confusion')
        svo.lostbal_herb()
      end,

      eatcure = {'ash', 'stannum'},
      onstart = function ()
        svo.eat(svo.dict.confusion.herb)
      end,

      empty = function()
        empty.eat_ash()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.confusion and
          not svo.doingaction('confusion') and not affs.madness) or false
      end,

      oncompleted = function ()
        svo.rmaff('confusion')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.confusion)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('confusion')
        codepaste.remove_focusable()
      end,
    }
  },
  agoraphobia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.agoraphobia and
          not svo.doingaction('agoraphobia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('agoraphobia')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.agoraphobia.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.agoraphobia and
          not svo.doingaction('agoraphobia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('agoraphobia')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.agoraphobia)
        codepaste.remove_focusable()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('agoraphobia')
      end,
    }
  },
  claustrophobia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.claustrophobia and
          not svo.doingaction('claustrophobia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('claustrophobia')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.claustrophobia.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.claustrophobia and
          not svo.doingaction('claustrophobia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('claustrophobia')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.claustrophobia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('claustrophobia')
        codepaste.remove_focusable()
      end,
    }
  },
  paralysis = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.paralysis) or false
      end,

      oncompleted = function ()
        svo.rmaff('paralysis')
        svo.lostbal_herb()
        svo.killaction(svo.dict.checkparalysis.misc)
      end,

      eatcure = {'bloodroot', 'magnesium'},
      onstart = function ()
        svo.eat(svo.dict.paralysis.herb)
      end,

      empty = function()
        empty.eat_bloodroot()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.paralysis)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('paralysis')
      end,
    },
    onremoved = function () svo.affsp.paralysis = nil svo.donext() end
  },
  asthma = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.asthma) or false
      end,

      oncompleted = function ()
        svo.rmaff('asthma')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.asthma.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.asthma)
        local r = svo.findbybal('smoke')
        if r then
          svo.killaction(svo.dict[r.action_name].smoke)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('asthma')
      end,
    }
  },
  clumsiness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.clumsiness) or false
      end,

      oncompleted = function ()
        svo.rmaff('clumsiness')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.clumsiness.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.clumsiness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('clumsiness')
      end,
    }
  },
  sensitivity = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sensitivity) or false
      end,

      oncompleted = function ()
        svo.rmaff('sensitivity')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.sensitivity.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.sensitivity)
      end,

      -- used by AI to check if we're deaf when we got sensi
      checkdeaf = function()
        -- if deafness was stripped, then prompt flags would have removed it at this point and defc.deaf wouldn't be set
        -- also check back to see if deafness went instead, like from bloodleech:
        -- A bloodleech leaps at you, clamping with teeth onto exposed flesh and secreting some foul toxin into your bloodstream. You stumble as you are afflicted with sensitivity.$Your hearing is suddenly restored.
        -- or dragoncurse: A sudden sense of panic overtakes you as the draconic curse manifests, afflicting you with sensitivity.$Your hearing is suddenly restored.
        -- however, don't go off on dstab: Bob pricks you twice in rapid succession with her dirk.$Your hearing is suddenly restored.$A prickly, stinging sensation spreads through your body.
        if svo.find_until_last_paragraph(&quot;Your hearing is suddenly restored.&quot;, 'exact') and not svo.find_until_last_paragraph(&quot;A prickly, stinging sensation spreads through your body.&quot;, 'exact') then return end

        if not conf.aillusion or (not defc.deaf and not affs.deafaff) then
          svo.addaffdict(svo.dict.sensitivity)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('sensitivity')
      end,
    }
  },
  healthleech = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.healthleech) or false
      end,

      oncompleted = function ()
        svo.rmaff('healthleech')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.healthleech.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.healthleech)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('healthleech')
      end,
    }
  },
  relapsing = {
    -- if it's an aff that can be checked, remove it's action and add an appropriate checkaff. Then if the checkaff succeeds, add the relapsing too.
    saw_with_checkable = false,
    gamename = 'scytherus',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.relapsing) or false
      end,

      oncompleted = function ()
        svo.rmaff('relapsing')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.relapsing.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    --[[
      relapsing:  ai off, accept everything
                  ai on, accept everything only if we do have relapsing, or it's a checkable symptom -&gt; undeaf/unblind, blind/deaf, camus, else -&gt; ignore

      implementation: generic affs get called to aff.oncompleted, otherwise specialities deal with aff.&lt;func&gt;
    ]]
    aff = {
      -- this goes off when there is no AI or we got a generic affliction that doesn't mean much
      oncompleted = function ()
        -- don't mess with anything special if we have it confirmed
        if affs.relapsing then return end

        if not conf.aillusion or svo.lifevision.l.diag_physical then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        else
          if svo.actions.checkparalysis_aff then
            svo.dict.relapsing.saw_with_checkable = 'paralysis'
          elseif not svo.pl.tablex.find_if(svo.actions:keys(), function (key) return string.find(key, 'check', 1, true) end) then
            -- don't process the rest of the affs it gives if it's not checkable and we don't have relapsing already
            sk.stopprocessing = true
          end
        end
        svo.dict.relapsing.aff.hitvitality = nil
      end,

      forced = function ()
        svo.addaffdict(svo.dict.relapsing)
      end,

      camus = function (oldhp)
        if not conf.aillusion or
          ((not affs.recklessness and stats.currenthealth &lt; oldhp) -- health went down without recklessness
           or (svo.dict.relapsing.aff.hitvitality and ((100/stats.maxhealth)* stats.currenthealth) &lt;= 60)) then -- or we're above due to vitality
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.aff.hitvitality = nil
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      sumac = function (oldhp)
        if not conf.aillusion or
          ((not affs.recklessness and stats.currenthealth &lt; oldhp) -- health went down without recklessness
           or (svo.dict.relapsing.aff.hitvitality and ((100/stats.maxhealth)* stats.currenthealth) &lt;= 60)) then -- or we're above due to vitality
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.aff.hitvitality = nil
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      oleander = function (hadblind)
        if not conf.aillusion or (not hadblind and (defc.blind or affs.blindaff)) then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      colocasia = function (hadblindordeaf)
        if not conf.aillusion or (not hadblindordeaf and (defc.blind or affs.blindaff or defc.deaf or affs.deafaff)) then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      oculus = function (hadblind)
        if not conf.aillusion or (hadblind and not (defc.blind or affs.blindaff)) then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      prefarar = function (haddeaf)
        if not conf.aillusion or (haddeaf and not (defc.deaf or affs.deafaff)) then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        end
      end,

      asthma = function ()
        if not conf.aillusion or svo.lifevision.l.diag_physical then
          svo.addaffdict(svo.dict.relapsing)
          svo.dict.relapsing.saw_with_checkable = nil
        else
          if svo.actions.checkasthma_aff then
            svo.dict.relapsing.saw_with_checkable = 'asthma'
          elseif not svo.pl.tablex.find_if(svo.actions:keys(), function (key) return string.find(key, 'check', 1, true) end) then
            -- don't process the rest of the affs it gives.
            sk.stopprocessing = true
          end
        end
        svo.dict.relapsing.aff.hitvitality = nil
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('relapsing')
        svo.dict.relapsing.saw_with_checkable = nil
      end,
    }
  },
  darkshade = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.darkshade) or false
      end,

      oncompleted = function ()
        svo.rmaff('darkshade')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.darkshade.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or (not oldhp or stats.currenthealth &lt; oldhp) then
          svo.addaffdict(svo.dict.darkshade)
        end
      end,

      forced = function ()
        svo.addaffdict(svo.dict.darkshade)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('darkshade')
      end,
    }
  },
  lethargy = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing lethargy before hypochondria or torntendons will make it get re-applied
        return (affs.lethargy and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        svo.rmaff('lethargy')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.lethargy.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.lethargy)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('lethargy')
      end,
    }
  },
  illness = {
    gamename = 'nausea',
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing illness before hypochondria will make it get re-applied
        return (affs.illness and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        svo.rmaff('illness')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.illness.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        if not svo.find_until_last_paragraph(&quot;Your enhanced constitution allows you to shrug off the nausea.&quot;, 'exact') then
          svo.addaffdict(svo.dict.illness)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('illness')
      end,
    }
  },
  addiction = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        -- curing addiction before hypochondria or skullfractures will make it get re-applied
        return (affs.addiction and not affs.madness and not affs.hypochondria) or false
      end,

      oncompleted = function ()
        svo.rmaff('addiction')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.addiction.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.addiction)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('addiction')
      end,
    },
    onremoved = function ()
      rift.checkprecache()
    end
  },
  haemophilia = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.haemophilia) or false
      end,

      oncompleted = function ()
        svo.rmaff('haemophilia')
        svo.lostbal_herb()
      end,

      eatcure = {'ginseng', 'ferrum'},
      onstart = function ()
        svo.eat(svo.dict.haemophilia.herb)
      end,

      empty = function()
        empty.eat_ginseng()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.haemophilia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('haemophilia')
      end,
    }
  },
  hypochondria = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypochondria) or false
      end,

      oncompleted = function ()
        svo.rmaff('hypochondria')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.hypochondria.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hypochondria)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hypochondria')
      end,
    }
  },

-- smoke cures
  aeon = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.aeon and codepaste.smoke_elm_pipe()) or false
      end,

      oncompleted = function ()
        svo.rmaff('aeon')
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {'elm', 'cinnabar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.aeon)
        svo.affsp.aeon = nil
        defences.lost('speed')
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        sk.checkaeony()
        signals.aeony:emit()
        codepaste.badaeon()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('aeon')
      end,
    },
    onremoved = function ()
      svo.affsp.aeon = nil
      sk.retardation_count = 0
      sk.checkaeony()
      signals.aeony:emit()
    end
  },
  hellsight = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hellsight and not affs.inquisition and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        svo.rmaff('hellsight')
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {'valerian', 'realgar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      inquisition = function ()
        svo.addaffdict(svo.dict.inquisition)
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hellsight)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hellsight')
      end,
    }
  },
  deadening = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.deadening and codepaste.smoke_elm_pipe()) or false
      end,

      oncompleted = function ()
        svo.rmaff('deadening')
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {'elm', 'cinnabar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.deadening)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('deadening')
      end,
    }
  },
  madness = {
    gamename = 'whisperingmadness',
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.madness and codepaste.smoke_elm_pipe() and not affs.hecate) or false
      end,

      oncompleted = function ()
        svo.rmaff('madness')
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end,

      smokecure = {'elm', 'cinnabar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.elm.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_elm()
        svo.lostbal_smoke()
        sk.elm_smokepuff()
      end,

      hecate = function()
        sk.elm_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.madness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('madness')
      end,
    }
  },
  -- valerian cures
  slickness = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slickness and codepaste.smoke_valerian_pipe() and not svo.doingaction'slickness') or false
      end,

      oncompleted = function ()
        svo.rmaff('slickness')
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {'valerian', 'realgar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slickness and not affs.anorexia and not svo.doingaction'slickness' and not affs.stain) or false -- anorexia is redundant, but just in for now
      end,

      oncompleted = function ()
        svo.rmaff('slickness')
        svo.lostbal_herb()
      end,

      eatcure = {'bloodroot', 'magnesium'},
      onstart = function ()
        svo.eat(svo.dict.slickness.herb)
      end,

      empty = function()
        empty.eat_bloodroot()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.slickness)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('slickness')
      end,
    }
  },
  disloyalty = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.disloyalty and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        svo.rmaff('disloyalty')
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {'valerian', 'realgar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.disloyalty)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('disloyalty')
      end,
    }
  },
  manaleech = {
    smoke = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.manaleech and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        svo.rmaff('manaleech')
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end,

      smokecure = {'valerian', 'realgar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.valerian.id, conf.commandecho)
      end,

      empty = function ()
        empty.smoke_valerian()
        svo.lostbal_smoke()
        sk.valerian_smokepuff()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.manaleech)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('manaleech')
      end,
    }
  },


  -- restoration cures
  heartseed = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.heartseed and not affs.mildtrauma) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingheartseed.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to torso&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to torso&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.heartseed.salve, &quot; to torso&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.heartseed.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.heartseed)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('heartseed')
      end,
    }
  },
  curingheartseed = {
    spriority = 0,
    waitingfor = {
      customwait = 6, -- 4 to cure

      oncompleted = function ()
        svo.rmaff('heartseed')
      end,

      ontimeout = function ()
        svo.rmaff('heartseed')
      end,

      noeffect = function ()
        svo.rmaff('heartseed')
      end,

      onstart = function ()
    -- add blocking of the cure coming too early if it'll become necessary.
      end,
    }
  },
  hypothermia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.hypothermia and not affs.mildtrauma) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curinghypothermia.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to torso&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to torso&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.hypothermia.salve, &quot; to torso&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.hypothermia.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hypothermia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hypothermia')
      end,
    }
  },
  curinghypothermia = {
    spriority = 0,
    waitingfor = {
      customwait = 6, -- 4 to cure

      oncompleted = function ()
        svo.rmaff('hypothermia')
      end,

      ontimeout = function ()
        svo.rmaff('hypothermia')
      end,

      noeffect = function ()
        svo.rmaff('hypothermia')
      end,

      onstart = function ()
        -- add blocking of the cure coming too early if it'll become necessary.
      end,
    }
  },

  mutilatedrightleg = {
    gamename = 'mangledrightleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedrightleg) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmutilatedrightleg.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to legs&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to legs&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mutilatedrightleg.salve, &quot; to legs&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mutilatedrightleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          svo.dict.mutilatedrightleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg('mutilatedrightleg', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg('mutilatedrightleg', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mutilatedrightleg')
      end,
    }
  },
  curingmutilatedrightleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mutilatedrightleg')
        svo.addaffdict(svo.dict.mangledrightleg)

        local result = svo.checkany(svo.dict.curingmutilatedleftleg.waitingfor, svo.dict.curingmangledrightleg.waitingfor, svo.dict.curingmangledleftleg.waitingfor, svo.dict.curingparestolegs.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedrightleg then
          svo.rmaff('mutilatedrightleg')
          svo.addaffdict(svo.dict.mangledrightleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mutilatedrightleg')
        svo.addaffdict(svo.dict.mangledrightleg)
      end,

      noeffect = function ()
        svo.rmaff('mutilatedrightleg')
      end
    }
  },
  parestolegs = {
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      customwaitf = function()
        return not affs.blackout and 0 or 4 -- can't see applies in blackout
      end,

      isadvisable = function ()
        return (affs.parestolegs) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingparestolegs.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to legs&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to legs&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.parestolegs.salve, &quot; to legs&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.parestolegs.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.parestolegs)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('parestolegs')
      end,
    }
  },
  curingparestolegs = {
    waitingfor = {
      customwait = 4,

      oncompleted = function ()
        svo.rmaff('parestolegs')

        local result = svo.checkany(svo.dict.curingmutilatedrightleg.waitingfor, svo.dict.curingmutilatedleftleg.waitingfor, svo.dict.curingmangledrightleg.waitingfor, svo.dict.curingmangledleftleg.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      onstart = function ()
      end,

      ontimeout = function ()
        svo.rmaff('parestolegs')
      end,

      noeffect = function ()
        svo.rmaff('parestolegs')
      end
    }
  },
  mangledrightleg = {
    gamename = 'damagedrightleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledrightleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmangledrightleg.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to legs&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to legs&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mangledrightleg.salve, &quot; to legs&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mangledrightleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          svo.dict.mangledrightleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg('mangledrightleg', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg('mangledrightleg', oldhp, true)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mangledrightleg')
      end,
    }
  },
  curingmangledrightleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('parestolegs')
        svo.rmaff('mangledrightleg')
        svo.addaffdict(svo.dict.crippledrightleg)

        local result = svo.checkany(svo.dict.curingmutilatedrightleg.waitingfor, svo.dict.curingmutilatedleftleg.waitingfor, svo.dict.curingmangledleftleg.waitingfor, svo.dict.curingparestolegs.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledrightleg then
          svo.rmaff('mangledrightleg')
          svo.addaffdict(svo.dict.crippledrightleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mangledrightleg')
        svo.addaffdict(svo.dict.crippledrightleg)
      end,

      noeffect = function ()
        svo.rmaff('mangledrightleg')
      end
    }
  },
  crippledrightleg = {
    gamename = 'brokenrightleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledrightleg and not (affs.mutilatedrightleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('crippledrightleg')

        if affs.unknowncrippledlimb then
          svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count - 1
          if svo.dict.unknowncrippledlimb.count &lt;= 0 then svo.rmaff'unknowncrippledlimb' else svo.updateaffcount(svo.dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledleg then return end
        svo.dict.unknowncrippledleg.count = svo.dict.unknowncrippledleg.count - 1
        if svo.dict.unknowncrippledleg.count &lt;= 0 then svo.rmaff'unknowncrippledleg' else svo.updateaffcount(svo.dict.unknowncrippledleg) end
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to legs&quot;, &quot;apply mending&quot;, &quot;apply renewal to legs&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.crippledrightleg.salve, &quot; to legs&quot;)
      end,

      fizzled = function ()
        svo.lostbal_salve()
        svo.addaffdict(svo.dict.mangledrightleg)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      -- sometimes restoration can lag out and hit when this goes - ignore
      empty = function() end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.crippledrightleg)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('crippledrightleg')
      end,
    }
  },
  mutilatedleftleg = {
    gamename = 'mangledleftleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedleftleg) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmutilatedleftleg.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to legs&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to legs&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mutilatedleftleg.salve, &quot; to legs&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mutilatedleftleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          svo.dict.mutilatedleftleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg('mutilatedleftleg', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg('mutilatedleftleg', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mutilatedleftleg')
      end,
    }
  },
  curingmutilatedleftleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mutilatedleftleg')
        svo.addaffdict(svo.dict.mangledleftleg)

        local result = svo.checkany(svo.dict.curingmutilatedrightleg.waitingfor, svo.dict.curingmangledrightleg.waitingfor, svo.dict.curingmangledleftleg.waitingfor, svo.dict.curingparestolegs.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedleftleg then
          svo.rmaff('mutilatedleftleg')
          svo.addaffdict(svo.dict.mangledleftleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mutilatedleftleg')
        svo.addaffdict(svo.dict.mangledleftleg)
      end,

      noeffect = function ()
        svo.rmaff('mutilatedleftleg')
      end
    }
  },
  mangledleftleg = {
    gamename = 'damagedleftleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledleftleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmangledleftleg.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to legs&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to legs&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mangledleftleg.salve, &quot; to legs&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mangledleftleg.salve.oncompleted()
      end,

      -- in blackout, this goes through quietly
      ontimeout = function()
        if affs.blackout then
          svo.dict.mangledleftleg.salve.oncompleted()
        end
      end,
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakleg('mangledleftleg', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakleg('mangledleftleg', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mangledleftleg')
      end,
    }
  },
  curingmangledleftleg = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('parestolegs')
        svo.rmaff('mangledleftleg')
        svo.addaffdict(svo.dict.crippledleftleg)

        local result = svo.checkany(svo.dict.curingmutilatedrightleg.waitingfor, svo.dict.curingmutilatedleftleg.waitingfor, svo.dict.curingmangledrightleg.waitingfor, svo.dict.curingparestolegs.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledleftleg then
          svo.rmaff('mangledleftleg')
          svo.addaffdict(svo.dict.crippledleftleg)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mangledleftleg')
        svo.addaffdict(svo.dict.crippledleftleg)
      end,

      noeffect = function ()
        svo.rmaff('mangledleftleg')
      end
    }
  },
  crippledleftleg = {
    gamename = 'brokenleftleg',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledleftleg and not (affs.mutilatedleftleg or affs.mangledleftleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('crippledleftleg')

        if affs.unknowncrippledlimb then
          svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count - 1
          if svo.dict.unknowncrippledlimb.count &lt;= 0 then svo.rmaff'unknowncrippledlimb' else svo.updateaffcount(svo.dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledleg then return end
        svo.dict.unknowncrippledleg.count = svo.dict.unknowncrippledleg.count - 1
        if svo.dict.unknowncrippledleg.count &lt;= 0 then svo.rmaff'unknowncrippledleg' else svo.updateaffcount(svo.dict.unknowncrippledleg) end
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to legs&quot;, &quot;apply mending&quot;, &quot;apply renewal to legs&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.crippledleftleg.salve, &quot; to legs&quot;)
      end,

      fizzled = function ()
        svo.lostbal_salve()
        svo.addaffdict(svo.dict.mangledleftleg)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      -- sometimes restoration can lag out and hit when this goes - ignore
      empty = function() end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.crippledleftleg)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('crippledleftleg')
      end,
    }
  },
  parestoarms = {
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      customwaitf = function()
        return not affs.blackout and 0 or 4 -- can't see applies in blackout
      end,

      isadvisable = function ()
        return (affs.parestoarms) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingparestoarms.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to arms&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to arms&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.parestoarms.salve, &quot; to arms&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.parestoarms.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.parestoarms)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('parestoarms')
      end,
    }
  },
  curingparestoarms = {
    waitingfor = {
      customwait = 4,

      oncompleted = function ()
        svo.rmaff('parestoarms')

        local result = svo.checkany(svo.dict.curingmutilatedrightarm.waitingfor, svo.dict.curingmutilatedleftarm.waitingfor, svo.dict.curingmangledrightarm.waitingfor, svo.dict.curingmangledleftarm.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      onstart = function ()
      end,

      ontimeout = function ()
        svo.rmaff('parestoarms')
      end,

      noeffect = function ()
        svo.rmaff('parestoarms')
      end
    }
  },
  mutilatedleftarm = {
    gamename = 'mangledleftarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedleftarm) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmutilatedleftarm.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to arms&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to arms&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mutilatedleftarm.salve, &quot; to arms&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mutilatedleftarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm('mutilatedleftarm', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm('mutilatedleftarm', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mutilatedleftarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmutilatedleftarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mutilatedleftarm')
        svo.addaffdict(svo.dict.mangledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = svo.checkany(svo.dict.curingmutilatedrightarm.waitingfor, svo.dict.curingmangledrightarm.waitingfor, svo.dict.curingmangledleftarm.waitingfor, svo.dict.curingparestoarms.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedleftarm then
          svo.rmaff('mutilatedleftarm')
          svo.addaffdict(svo.dict.mangledleftarm)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mutilatedleftarm')
        svo.addaffdict(svo.dict.mangledleftarm)
      end,

      noeffect = function ()
        svo.rmaff('mutilatedleftarm')
      end
    }
  },
  mangledleftarm = {
    gamename = 'damagedleftarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledleftarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmangledleftarm.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to arms&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to arms&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mangledleftarm.salve, &quot; to arms&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mangledleftarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm('mangledleftarm', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm('mangledleftarm', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mangledleftarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmangledleftarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('parestoarms')
        svo.rmaff('mangledleftarm')
        svo.addaffdict(svo.dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = svo.checkany(svo.dict.curingmutilatedrightarm.waitingfor, svo.dict.curingmutilatedleftarm.waitingfor, svo.dict.curingmangledrightarm.waitingfor, svo.dict.curingparestoarms.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledleftarm then
          svo.rmaff('mangledleftarm')
          svo.addaffdict(svo.dict.crippledleftarm)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mangledleftarm')
        svo.addaffdict(svo.dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      noeffect = function ()
        svo.rmaff('mangledleftarm')
      end
    }
  },
  crippledleftarm = {
    gamename = 'brokenleftarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledleftarm and not (affs.mutilatedleftarm or affs.mangledleftarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('crippledleftarm')

        if affs.unknowncrippledlimb then
          svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count - 1
          if svo.dict.unknowncrippledlimb.count &lt;= 0 then svo.rmaff'unknowncrippledlimb' else svo.updateaffcount(svo.dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledarm then return end
        svo.dict.unknowncrippledarm.count = svo.dict.unknowncrippledarm.count - 1
        if svo.dict.unknowncrippledarm.count &lt;= 0 then svo.rmaff'unknowncrippledarm' else svo.updateaffcount(svo.dict.unknowncrippledarm) end
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to arms&quot;, &quot;apply mending&quot;, &quot;apply renewal to arms&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.crippledleftarm.salve, &quot; to arms&quot;)
      end,

      fizzled = function ()
        svo.lostbal_salve()
        svo.addaffdict(svo.dict.mangledleftarm)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_arms()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('crippledleftarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  mutilatedrightarm = {
    gamename = 'mangledrightarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mutilatedrightarm) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmutilatedrightarm.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to arms&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to arms&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mutilatedrightarm.salve, &quot; to arms&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mutilatedrightarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm('mutilatedrightarm', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm('mutilatedrightarm', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mutilatedrightarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmutilatedrightarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mutilatedrightarm')
        svo.addaffdict(svo.dict.mangledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = svo.checkany(svo.dict.curingmutilatedleftarm.waitingfor, svo.dict.curingmangledrightarm.waitingfor, svo.dict.curingmangledleftarm.waitingfor, svo.dict.curingparestoarms.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mutilatedrightarm then
          svo.rmaff('mutilatedrightarm')
          svo.addaffdict(svo.dict.mangledrightarm)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mutilatedleftarm')
        svo.addaffdict(svo.dict.mangledleftarm)
      end,

      noeffect = function ()
        svo.rmaff('mutilatedrightarm')
      end
    }
  },
  mangledrightarm = {
    gamename = 'damagedrightarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mangledrightarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmangledrightarm.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to arms&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to arms&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mangledrightarm.salve, &quot; to arms&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mangledrightarm.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        codepaste.addrestobreakarm('mangledrightarm', oldhp)
      end,

      tekura = function (oldhp)
        codepaste.addrestobreakarm('mangledrightarm', oldhp, true)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mangledrightarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingmangledrightarm = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mangledrightarm')
        svo.rmaff('parestoarms')
        svo.addaffdict(svo.dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        local result = svo.checkany(svo.dict.curingmutilatedrightarm.waitingfor, svo.dict.curingmutilatedleftarm.waitingfor, svo.dict.curingmangledleftarm.waitingfor, svo.dict.curingparestoarms.waitingfor)

        if result then
          svo.killaction(svo.dict[result.action_name].waitingfor)
        end
      end,

      ontimeout = function ()
        if affs.mangledrightarm then
          svo.rmaff('mangledrightarm')
          svo.addaffdict(svo.dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      onstart = function ()
      end,

      oncuredleft = function()
        svo.rmaff('mangledleftarm')
        svo.addaffdict(svo.dict.crippledleftarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      noeffect = function ()
        svo.rmaff('mangledrightarm')
      end
    }
  },
  crippledrightarm = {
    gamename = 'brokenrightarm',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.crippledrightarm and not (affs.mutilatedrightarm or affs.mangledrightarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('crippledrightarm')

        if affs.unknowncrippledlimb then
          svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count - 1
          if svo.dict.unknowncrippledlimb.count &lt;= 0 then svo.rmaff'unknowncrippledlimb' else svo.updateaffcount(svo.dict.unknowncrippledlimb) end
        end

        if not affs.unknowncrippledarm then return end
        svo.dict.unknowncrippledarm.count = svo.dict.unknowncrippledarm.count - 1
        if svo.dict.unknowncrippledarm.count &lt;= 0 then svo.rmaff'unknowncrippledarm' else svo.updateaffcount(svo.dict.unknowncrippledarm) end
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to arms&quot;, &quot;apply mending&quot;, &quot;apply renewal to arms&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.crippledrightarm.salve, &quot; to arms&quot;)
      end,

      fizzled = function ()
        svo.lostbal_salve()
        svo.addaffdict(svo.dict.mangledrightarm)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_arms()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.crippledrightarm)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('crippledrightarm')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  laceratedthroat = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.laceratedthroat) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curinglaceratedthroat.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to head&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to head&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.laceratedthroat.salve, &quot; to head&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.laceratedthroat.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.laceratedthroat)
      end,

      -- separated, so we can use it normally if necessary - another class might get it
      sylvanhit = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth &lt; oldhp) then
          svo.addaffdict(svo.dict.laceratedthroat)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('laceratedthroat')
      end,
    }
  },
  curinglaceratedthroat = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('laceratedthroat')
        svo.addaffdict(svo.dict.slashedthroat)
      end,

      onstart = function ()
      end,

      noeffect = function()
        svo.rmaff('laceratedthroat')
        svo.addaffdict(svo.dict.slashedthroat)
      end
    }
  },
  slashedthroat = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.slashedthroat) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('slashedthroat')
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to head&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to head&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.slashedthroat.salve, &quot; to head&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.slashedthroat)
      end,

      -- separated, so we can use it normally if necessary - another class might get it
      sylvanhit = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth &lt; oldhp) then
          svo.addaffdict(svo.dict.slashedthroat)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('slashedthroat')
      end,
    }
  },
  serioustrauma = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.serioustrauma) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingserioustrauma.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to torso&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to torso&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.serioustrauma.salve, &quot; to torso&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.serioustrauma.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp &gt; stats.currenthealth or svo.paragraph_length &gt;= 3 then
          if affs.mildtrauma then svo.rmaff('mildtrauma') end
          svo.addaffdict(svo.dict.serioustrauma)
        end
      end,

      forced = function ()
        if affs.mildtrauma then svo.rmaff('mildtrauma') end
        svo.addaffdict(svo.dict.serioustrauma)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('serioustrauma')
      end,
    }
  },
  curingserioustrauma = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('serioustrauma')
        svo.addaffdict(svo.dict.mildtrauma)
      end,

      ontimeout = function ()
        if affs.serioustrauma then
          svo.rmaff('serioustrauma')
          svo.addaffdict(svo.dict.mildtrauma)
        end
      end,

      onstart = function ()
      end,

      noeffect = function ()
        svo.rmaff('serioustrauma')
        svo.rmaff('mildtrauma')
      end
    }
  },
  mildtrauma = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mildtrauma) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmildtrauma.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to torso&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to torso&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mildtrauma.salve, &quot; to torso&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mildtrauma.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp &gt; stats.currenthealth or svo.paragraph_length &gt;= 3 then
          svo.addaffdict(svo.dict.mildtrauma)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mildtrauma')
      end,
    }
  },
  curingmildtrauma = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mildtrauma')
      end,

      ontimeout = function ()
        svo.rmaff('mildtrauma')
      end,

      onstart = function ()
      end,

      noeffect = function ()
        svo.rmaff('mildtrauma')
      end
    }
  },
  seriousconcussion = {
    gamename = 'mangledhead',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.seriousconcussion) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingseriousconcussion.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to head&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to head&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.seriousconcussion.salve, &quot; to head&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.seriousconcussion.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp &gt; stats.currenthealth or svo.paragraph_length &gt;= 3 then
          if affs.mildconcussion then svo.rmaff('mildconcussion') end
          svo.addaffdict(svo.dict.seriousconcussion)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      forced = function ()
        if affs.mildconcussion then svo.rmaff('mildconcussion') end
        svo.addaffdict(svo.dict.seriousconcussion)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('seriousconcussion')
      end,
    },
    onadded = function()
      if affs.prone and affs.seriousconcussion then
        sk.warn 'pulpable'
      end
    end
  },
  curingseriousconcussion = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('seriousconcussion')
        svo.addaffdict(svo.dict.mildconcussion)
      end,

      ontimeout = function ()
        if affs.seriousconcussion then
          svo.rmaff('seriousconcussion')
          svo.addaffdict(svo.dict.mildconcussion)
        end
      end,

      onstart = function ()
      end,

      noeffect = function ()
        svo.rmaff('seriousconcussion')
        svo.rmaff('mildconcussion')
      end
    }
  },
  mildconcussion = {
    gamename = 'damagedhead',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.mildconcussion) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()

        svo.doaction(svo.dict.curingmildconcussion.waitingfor)
      end,

      applycure = {'restoration', 'reconstructive'},
      actions = {&quot;apply restoration to head&quot;, &quot;apply restoration&quot;, &quot;apply reconstructive to head&quot;, &quot;apply reconstructive&quot;},
      onstart = function ()
        svo.apply(svo.dict.mildconcussion.salve, &quot; to head&quot;)
      end,

      -- we get no msg from an application of this
      empty = function ()
        svo.dict.mildconcussion.salve.oncompleted()
      end
    },
    aff = {
      oncompleted = function (oldhp)
        if not conf.aillusion or not oldhp or oldhp &gt; stats.currenthealth or svo.paragraph_length &gt;= 3 then
          svo.addaffdict(svo.dict.mildconcussion)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end
      end,

      forced = function ()
        svo.addaffdict(svo.dict.mildconcussion)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mildconcussion')
      end,
    }
  },
  curingmildconcussion = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('mildconcussion')
      end,

      ontimeout = function ()
        svo.rmaff('mildconcussion')
      end,

      onstart = function ()
      end,

      noeffect = function ()
        svo.rmaff('mildconcussion')
      end
    }
  },


-- salve cures
  anorexia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.anorexia and not svo.doingaction'anorexia') or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('anorexia')
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_epidermal_body()
      end,

      empty = function ()
        empty.apply_epidermal_body()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to body&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to body&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.anorexia.salve, &quot; to body&quot;)
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.anorexia and
          not svo.doingaction('anorexia')) or false
      end,

      oncompleted = function ()
        svo.rmaff('anorexia')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.anorexia)
        codepaste.badaeon()
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('anorexia')
        codepaste.remove_focusable()
      end,
    }
  },
  ablaze = {
    gamename = 'burning',
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.ablaze) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('ablaze')
      end,

      all = function()
        svo.lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.ablaze.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns('ablaze')
        svo.addaffdict(svo.dict.ablaze)
      end,
    },
    gone = {
      oncompleted = function ()
        local currentburn = sk.current_burn()
        svo.rmaff(currentburn)
      end,

      -- used in blackout and passive curing where multiple levels could be cured at once
      generic_reducelevel = function(amount)
        -- if no amount is specified, find the current level and take it down a notch
        if not amount then
          local reduceto, currentburn = sk.previous_burn(), sk.current_burn()

          svo.rmaff(currentburn)
          svo.addaffdict(svo.dict[reduceto])
        else -- amount is specified
          local reduceto, currentburn = sk.previous_burn(amount), sk.current_burn()
          svo.rmaff(currentburn)

          if not reduceto then reduceto = 'ablaze' end
          svo.addaffdict(svo.dict[reduceto])
        end
      end
    }
  },
  severeburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.severeburn) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('severeburn')
        svo.addaffdict(svo.dict.ablaze)
      end,

      all = function()
        svo.lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.severeburn.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns('severeburn')
        svo.addaffdict(svo.dict.severeburn)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('severeburn')
      end,
    }
  },
  extremeburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.extremeburn) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('extremeburn')
        svo.addaffdict(svo.dict.severeburn)
      end,

      all = function()
        svo.lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.extremeburn.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns('extremeburn')
        svo.addaffdict(svo.dict.extremeburn)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('extremeburn')
      end,
    }
  },
  charredburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.charredburn) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('charredburn')
        svo.addaffdict(svo.dict.extremeburn)
      end,

      all = function()
        svo.lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.charredburn.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns('charredburn')
        svo.addaffdict(svo.dict.charredburn)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('charredburn')
      end,
    }
  },
  meltingburn = {
    salve = {
      aspriority = 0,
      spriority = 0,
      irregular = true,

      isadvisable = function ()
        return (affs.meltingburn) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('meltingburn')
        svo.addaffdict(svo.dict.charredburn)
      end,

      all = function()
        svo.lostbal_salve()
        codepaste.remove_burns()
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.meltingburn.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        codepaste.remove_burns('meltingburn')
        svo.addaffdict(svo.dict.meltingburn)

        sk.warn 'golemdestroyable'
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('meltingburn')
      end,
    }
  },
  selarnia = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.selarnia) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('selarnia')
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      empty = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending to body&quot;, &quot;apply mending&quot;, &quot;apply renewal to body&quot;, &quot;apply renewal&quot;, &quot;apply mending to torso&quot;, &quot;apply renewal to torso&quot;},
      onstart = function ()
        svo.apply(svo.dict.selarnia.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.selarnia)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('selarnia')
      end,
    }
  },
  itching = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.itching) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('itching')
      end,

      noeffect = function ()
        empty.apply_epidermal_body()
      end,

      empty = function ()
        empty.apply_epidermal_body()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to body&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to body&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.itching.salve, &quot; to body&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.itching)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('itching')
      end,
    }
  },
  stuttering = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.stuttering) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('stuttering')
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to head&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to head&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.stuttering.salve, &quot; to head&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.stuttering)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('stuttering')
      end,
    }
  },
  scalded = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.scalded and not defc.blind and not affs.blindaff) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('scalded')
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to head&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to head&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.scalded.salve, &quot; to head&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.scalded)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('scalded')
      end,
    }
  },
  numbedleftarm = {
    waitingfor = {
      customwait = 15, -- lasts 15s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('numbedleftarm')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('numbedleftarm')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.numbedleftarm)
        if not svo.actions.numbedleftarm_waitingfor then svo.doaction(svo.dict.numbedleftarm.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('numbedleftarm')
        svo.killaction(svo.dict.numbedleftarm.waitingfor)
      end,
    }
  },
  numbedrightarm = {
    waitingfor = {
      customwait = 8, -- lasts 8s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('numbedrightarm')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('numbedrightarm')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.numbedrightarm)
        if not svo.actions.numbedrightarm_waitingfor then svo.doaction(svo.dict.numbedrightarm.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('numbedrightarm')
        svo.killaction(svo.dict.numbedrightarm.waitingfor)
      end,
    }
  },
  blindaff = {
    gamename = 'blind',
    onservereignore = function()
      return not svo.dict.blind.onservereignore()
    end,
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.blindaff or (defc.blind and not ((sys.deffing and defdefup[defs.mode].blind) or
          (conf.keepup and defkeepup[defs.mode].blind))) or affs.scalded) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('blindaff')
        defences.lost('blind')

        local restoreaff, restoredef
        if affs.deafaff then restoreaff = true end
        if defc.deaf then restoredef = true end

        empty.apply_epidermal_head()

        if restoreaff then svo.addaffdict(svo.dict.deafaff) end
        if restoredef then defences.got('deaf') end
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to head&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to head&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.blindaff.salve, &quot; to head&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        if (defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind) or
          (svo.me.class == 'Apostate' or defc.mindseye) then
          defences.got('blind')
        else
          svo.addaffdict(svo.dict.blindaff)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('blindaff')
        defences.lost('blind')
      end,
    }
  },
  deafaff = {
    gamename = 'deaf',
    onservereignore = function()
      return not svo.dict.deaf.onservereignore()
    end,
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.deafaff or defc.deaf and not ((sys.deffing and defdefup[defs.mode].deaf) or
          (conf.keepup and defkeepup[defs.mode].deaf))) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('deafaff')
        defences.lost('deaf')
      end,

      noeffect = function ()
        empty.apply_epidermal_head()
      end,

      empty = function ()
        empty.apply_epidermal_head()
      end,

      applycure = {'epidermal', 'sensory'},
      actions = {&quot;apply epidermal to head&quot;, &quot;apply epidermal&quot;, &quot;apply sensory to head&quot;, &quot;apply sensory&quot;},
      onstart = function ()
        svo.apply(svo.dict.deafaff.salve, &quot; to head&quot;)
      end
    },
    aff = {
      oncompleted = function ()
        if (defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye then
          defences.got('deaf')
        else
          svo.addaffdict(svo.dict.deafaff)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('deafaff')
        defences.lost('deaf')
      end,
    }
  },

  shivering = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.shivering and not affs.frozen and not affs.hypothermia) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('shivering')
      end,

      noeffect = function()
        svo.lostbal_salve()
      end,

      gotcaloricdef = function (hypothermia)
        if not hypothermia then svo.rmaff({'frozen', 'shivering'}) end
        svo.dict.caloric.salve.oncompleted ()
      end,

      applycure = {'caloric', 'exothermic'},
      actions = {&quot;apply caloric to body&quot;, &quot;apply caloric&quot;, &quot;apply exothermic to body&quot;, &quot;apply exothermic&quot;},
      onstart = function ()
        svo.apply(svo.dict.shivering.salve, &quot; to body&quot;)
      end,

      empty = function ()
        svo.lostbal_salve()
        svo.rmaff('shivering')
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.shivering)
        defences.lost('caloric')
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('shivering')
      end,
    }
  },
  frozen = {
    salve = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.frozen and not affs.hypothermia) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('frozen')
        svo.addaffdict(svo.dict.shivering)
      end,

      noeffect = function()
        svo.lostbal_salve()
      end,

      gotcaloricdef = function (hypothermia)
        if not hypothermia then svo.rmaff({'frozen', 'shivering'}) end
        svo.dict.caloric.salve.oncompleted ()
      end,

      applycure = {'caloric', 'exothermic'},
      actions = {&quot;apply caloric to body&quot;, &quot;apply caloric&quot;, &quot;apply exothermic to body&quot;, &quot;apply exothermic&quot;},
      onstart = function ()
        svo.apply(svo.dict.frozen.salve, &quot; to body&quot;)
      end,

      empty = function ()
        svo.lostbal_salve()
        svo.rmaff('frozen')
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.frozen)
        defences.lost('caloric')
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('frozen')
      end
    }
  },

-- purgatives
  voyria = {
    purgative = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.voyria) or false
      end,

      oncompleted = function ()
        svo.lostbal_purgative()
        svo.rmaff('voyria')
      end,

      sipcure = {'immunity', 'antigen'},
      onstart = function ()
        svo.sip(svo.dict.voyria.purgative)
      end,

      noeffect = function()
        svo.rmaff('voyria')
        svo.lostbal_purgative()
      end,

      empty = function ()
        svo.lostbal_purgative()
        empty.sip_immunity()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.voyria)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('voyria')
      end
    }
  },


-- misc
  lovers = {
    map = {},
    tempmap = {},
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.lovers and not svo.doingaction('lovers')) or false
      end,

      oncompleted = function (whom)
        svo.dict.lovers.map[whom] = nil
        if not next(svo.dict.lovers.map) then
          svo.rmaff('lovers')
        end
      end,

      onclear = function ()
        svo.dict.lovers.tempmap = {}
      end,

      nobody = function ()
        if svo.dict.lovers.rejecting then
          svo.dict.lovers.map[svo.dict.lovers.rejecting] = nil
          svo.dict.lovers.rejecting = nil
        end

        if not next(svo.dict.lovers.map) then
          svo.rmaff('lovers')
        end
      end,

      onstart = function ()
        svo.dict.lovers.rejecting = next(svo.dict.lovers.map)
        if not svo.dict.lovers.rejecting then -- if we added it via some manual way w/o a name, this failsafe will catch &amp; remove it
          svo.rmaff('lovers')
          return
        end

        send(&quot;reject &quot; .. svo.dict.lovers.rejecting, conf.commandecho)
      end
    },
    aff = {
      oncompleted = function (whom)
        if not svo.dict.lovers.tempmap and not whom then return end

        svo.addaffdict(svo.dict.lovers)
        for _, name in ipairs(svo.dict.lovers.tempmap) do
          svo.dict.lovers.map[name] = true
        end
        svo.dict.lovers.tempmap = {}

        if whom then
          svo.dict.lovers[whom] = true
        end

        svo.affl.lovers = {names = svo.dict.lovers.map}
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('lovers')
        svo.dict.lovers.map = {}
      end,
    }
  },
  fear = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.fear and not svo.doingaction('fear')) or false
      end,

      oncompleted = function ()
        svo.rmaff('fear')
      end,

      action = 'compose',
      onstart = function ()
        send('compose', conf.commandecho)
      end
    },
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return false
        --[[return (affs.fear and
          not svo.doingaction('fear')) or false]]
      end,

      oncompleted = function ()
        svo.rmaff('fear')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.fear)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('fear')
        codepaste.remove_focusable()
      end
    }
  },
  sleep = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.sleep and
          not svo.doingaction('curingsleep') and not svo.doingaction('sleep')) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingsleep.waitingfor)
      end,

      actions = {'wake', &quot;wake up&quot;},
      onstart = function ()
        send(&quot;wake up&quot;, conf.commandecho)
      end,

      -- ???
      empty = function ()
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.sleep then svo.addaffdict(svo.dict.sleep) defences.lost('insomnia') end
      end,

      symptom = function()
        if not affs.sleep then svo.addaffdict(svo.dict.sleep) defences.lost('insomnia') end
        svo.addaffdict(svo.dict.prone)

        -- reset non-wait things we were doing, because they got cancelled by the stun
        if affs.sleep or svo.actions.sleep_aff then
          for _,v in svo.actions:iter() do
            if v.p.balance ~= 'waitingfor' and v.p.balance ~= 'aff' and v.p.name ~= 'sleep_misc' then
              svo.killaction(svo.dict[v.p.action_name][v.p.balance])
            end
          end
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('sleep')
      end,
    }
  },
  curingsleep = {
    spriority = 0,
    waitingfor = {
      customwait = 999,

      oncompleted = function ()
        svo.rmaff('sleep')

        -- reset sleep so we try waking up again after being awoken and slept at once (like in a dsl or a delph snipe)
        if svo.actions.sleep_misc then
          svo.killaction(svo.dict.sleep.misc)
        end
      end,

      onstart = function () end
    }
  },
  bleeding = {
    count = 0,
    -- affs.bleeding.spammingbleed is used to throttle bleed spamming so it doesn't get out of control
    misc = {
      aspriority = 0,
      spriority = 0,
      -- managed outside priorities
      uncurable = true,

      isadvisable = function ()
        if affs.bleeding and not svo.doingaction('bleeding') and not affs.bleeding.spammingbleed and not affs.haemophilia and not affs.sleep and svo.can_usemana() and conf.clot then
          if (not affs.corrupted and svo.dict.bleeding.count &gt;= conf.bleedamount) then
            return true
          elseif (affs.corrupted and svo.dict.bleeding.count &gt;= conf.manableedamount) then
            if stats.currenthealth &gt;= sys.corruptedhealthmin then
              return true
            else
              sk.warn 'cantclotmana'
              return false
            end
          end
        else return false end
      end,

      -- by default, oncompleted means a clot went through okay
      oncompleted = function ()
        svo.dict.bleeding.saw_haemophilia = nil
      end,

      -- oncured in this case means that we actually cured it; don't have any more bleeding
      oncured = function ()
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
        svo.rmaff('bleeding')
        svo.dict.bleeding.count = 0
        svo.dict.bleeding.saw_haemophilia = nil
      end,

      nomana = function ()
        if not svo.actions.nomana_waitingfor and stats.currentmana ~= 0 then
          svo.echof(&quot;Seems we're out of mana.&quot;)
          svo.doaction(svo.dict.nomana.waitingfor)
        end

        svo.dict.bleeding.saw_haemophilia = nil
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
      end,

      haemophilia = function()
        if svo.dict.bleeding.saw_haemophilia then
          svo.addaffdict(svo.dict.haemophilia)
          svo.echof(&quot;Seems like we do have haemophilia for real.&quot;)
        else
          svo.dict.bleeding.saw_haemophilia = true
        end
        if affs.bleeding and affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
      end,

      action = 'clot',
      onstart = function ()
        local show = conf.commandecho and not conf.gagclot
        send('clot', show)

        -- don't optimize with corruption for now (but do if need need be)
        if not sys.sync and ((not affs.corrupted and svo.stats.mp &gt;= 70 and (svo.dict.bleeding.count and svo.dict.bleeding.count &gt;= 200))
            or (affs.corrupted and stats.currenthealth+500 &gt;= sys.corruptedhealthmin)) then
          send('clot', show)
          send('clot', show)

          -- after sending a bunch of clots, wait a bit before doing it again
          if affs.bleeding then
            if affs.bleeding.spammingbleed then killTimer(affs.bleeding.spammingbleed); affs.bleeding.spammingbleed = nil end
            affs.bleeding.spammingbleed = tempTimer(svo.getping(), function () affs.bleeding.spammingbleed = nil; svo.make_gnomes_work() end)
          end
        end
      end
    },
    aff = {
      oncompleted = function (amount)
        svo.addaffdict(svo.dict.bleeding)
        -- TODO: affs.count vs svo.dict.count?
        affs.bleeding.p.count = amount or (affs.bleeding.p.count + 200)
        svo.updateaffcount(svo.dict.bleeding)

        -- remove bleeding if we've had it for a while and didn't clot it up
        if sk.smallbleedremove then killTimer(sk.smallbleedremove) end
        sk.smallbleedremove = tempTimer(conf.smallbleedremove or 8, function()
          sk.smallbleedremove = nil
          if not affs.bleeding then return end

          if svo.dict.bleeding.count &lt;= conf.bleedamount or svo.dict.bleeding.count &lt;= conf.manableedamount then
            svo.rmaff('bleeding')
          end
        end)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('bleeding')
      end,
    },
    onremoved = function()
      svo.dict.bleeding.count = 0
      if sk.smallbleedremove then
        killTimer(sk.smallbleedremove)
        sk.smallbleedremove = nil
      end
    end
  },
  touchtree = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not bals.tree or svo.doingaction('touchtree') or affs.sleep or not conf.tree or affs.stun
         or affs.unconsciousness or affs.numbedrightarm or affs.numbedleftarm or affs.paralysis or affs.webbed
          or affs.bound or affs.transfixed or affs.roped or affs.impale or ((affs.crippledleftarm or affs.mangledleftarm
           or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
            or codepaste.nonstdcure() then return false end

        for name, func in pairs(svo.tree) do
          if not me.disabledtreefunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function (aff)
        -- small heuristic - shivering can be upgraded to frozen
        if aff == 'shivering' and not affs.shivering and affs.frozen then
          svo.rmaff('frozen')
        -- handle levels of burns

        elseif aff == &quot;all burns&quot; then
          codepaste.remove_burns()

        elseif aff == 'burn' then
          local previousburn, currentburn = sk.previous_burn(), sk.current_burn()

          if not currentburn then
            codepaste.remove_burns()
          else
            svo.rmaff(currentburn)
            svo.addaffdict(svo.dict[previousburn])
          end

        elseif aff == 'skullfractures' then
          -- two counts are cured if you're above 5
          local howmany = svo.dict.skullfractures.count
          codepaste.remove_stackableaff('skullfractures', true)
          if howmany &gt; 5 then
            codepaste.remove_stackableaff('skullfractures', true)
          end

        elseif aff == &quot;skullfractures cured&quot; then
          svo.rmaff('skullfractures')
          svo.dict.skullfractures.count = 0

        elseif aff == 'crackedribs' then
          -- two counts are cured if you're above 5
          local howmany = svo.dict.crackedribs.count
          codepaste.remove_stackableaff('crackedribs', true)
          if howmany &gt; 5 then
            codepaste.remove_stackableaff('crackedribs', true)
          end

        elseif aff == &quot;crackedribs cured&quot; then
          svo.rmaff('crackedribs')
          svo.dict.crackedribs.count = 0

        elseif aff == 'wristfractures' then
          -- two counts are cured if you're above 5
          local howmany = svo.dict.wristfractures.count
          codepaste.remove_stackableaff('wristfractures', true)
          if howmany &gt; 5 then
            codepaste.remove_stackableaff('wristfractures', true)
          end

        elseif aff == &quot;wristfractures cured&quot; then
          svo.rmaff('wristfractures')
          svo.dict.wristfractures.count = 0

        elseif aff == 'torntendons' then
          -- two counts are cured if you're above 5
          local howmany = svo.dict.torntendons.count
          codepaste.remove_stackableaff('torntendons', true)
          if howmany &gt; 5 then
            codepaste.remove_stackableaff('torntendons', true)
          end

        elseif aff == &quot;torntendons cured&quot; then
          svo.rmaff('torntendons')
          svo.dict.torntendons.count = 0

        else
          svo.rmaff(aff)
        end

        svo.lostbal_tree()
      end,

      action = &quot;touch tree&quot;,
      onstart = function ()
        send(&quot;touch tree&quot;, conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_tree()
        empty.tree()
      end,

      offbal = function ()
        svo.lostbal_tree()
      end
    }
  },
  restore = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not conf.restore or svo.usingbal('salve') or codepaste.balanceful_codepaste() or
          codepaste.nonstdcure() then return false end

        for name, func in pairs(svo.restore) do
          if not me.disabledrestorefunc[name] then
            local s,m = pcall(func[1])
            if s and m then svo.debugf(&quot;restore: %s strat went off&quot;, name) return true end
          end
        end
      end,

      oncompleted = function (number)
        if number then
          -- empty
          if number+1 == getLineNumber() then
            svo.dict.unknowncrippledlimb.count = 0
            svo.dict.unknowncrippledarm.count = 0
            svo.dict.unknowncrippledleg.count = 0
            svo.rmaff({'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'unknowncrippledarm', 'unknowncrippledleg', 'unknowncrippledlimb'})
          end
        end
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      action = 'restore',
      onstart = function ()
        send('restore', conf.commandecho)
      end
    }
  },
  dragonheal = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not defc.dragonform or not conf.dragonheal or not bals.dragonheal or codepaste.balanceful_codepaste() or codepaste.nonstdcure() or (affs.recklessness and affs.weakness) then return false end

        for name, func in pairs(svo.dragonheal) do
          if not me.disableddragonhealfunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function (number)
        if number then
          -- empty
          if number+1 == getLineNumber() then
            empty.dragonheal()
          end
        end

        svo.lostbal_dragonheal()
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      nobalance = function ()
        svo.lostbal_dragonheal()
      end,

      action = 'dragonheal',
      onstart = function ()
        send('dragonheal', conf.commandecho)
      end
    }
  },
  defcheck = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (bals.balance and bals.equilibrium and me.manualdefcheck and not svo.doingaction('defcheck')) or false
      end,

      oncompleted = function ()
        me.manualdefcheck = false
        svo.process_defs()
      end,

      ontimeout = function ()
        me.manualdefcheck = false
      end,

      action = 'def',
      onstart = function ()
        send('def', conf.commandecho)
      end
    },
  },
  diag = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return ((sys.manualdiag or (affs.unknownmental and affs.unknownmental.p.count &gt;= conf.unknownfocus) or (affs.unknownany and affs.unknownany.p.count &gt;= conf.unknownany)) and bals.balance and bals.equilibrium and not svo.doingaction('diag')) or false
      end,

      oncompleted = function ()
        sys.manualdiag = false
        sk.diag_list = {}
        svo.rmaff('unknownmental')
        svo.rmaff('unknownany')
        svo.dict.unknownmental.count = 0
        svo.dict.unknownany.count = 0
        svo.dict.bleeding.saw_haemophilia = nil
        svo.dict.relapsing.saw_with_checkable = nil

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end,

      actions = {'diag', 'diagnose', &quot;diag me&quot;, &quot;diagnose me&quot;},
      onstart = function ()
        send('diag', conf.commandecho)
      end
    },
  },
  block = {
    gamename = 'blocking',
    physical = {
      blockingdir = &quot;&quot;,
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        if defc.block and ((conf.keepup and not defkeepup[defs.mode].block and not sys.deffing) or (sys.deffing and not defdefup[defs.mode].block)) and not svo.doingaction'block' then return true end

        return (
          ((sys.deffing and defdefup[defs.mode].block) or (conf.keepup and defkeepup[defs.mode].block and not sys.deffing))
          and (not defc.block or svo.dict.block.physical.blockingdir ~= conf.blockingdir)
          and not svo.doingaction'block'
          and (not sys.enabledgmcp or (gmcp.Room and gmcp.Room.Info.exits[conf.blockingdir]))
          and not codepaste.balanceful_codepaste()
          and not affs.prone
          and (not svo.haveskillset('metamorphosis') or (defc.riding or defc.elephant or defc.dragonform or defc.hydra))
          and (not svo.haveskillset('subterfuge') or not defc.phase)
        ) or false
      end,

      oncompleted = function (dir)
        if dir then
          svo.dict.block.physical.blockingdir = sk.anytoshort(dir)
        else --workaround for looping
          svo.dict.block.physical.blockingdir = conf.blockingdir
        end
        defences.got('block')
      end,

      -- in case of failing to block, register that the action has been completed
      failed = function()
      end,

      onstart = function ()
        if (not defc.block or svo.dict.block.physical.blockingdir ~= conf.blockingdir) then
          send(&quot;block &quot;..tostring(conf.blockingdir), conf.commandecho)
        else
          send('unblock', conf.commandecho)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        defences.lost('block')
        svo.dict.block.physical.blockingdir = &quot;&quot;

        if svo.actions.block_physical then
          svo.killaction(svo.dict.block.physical)
        end
      end
    }
  },
  doparry = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (not sys.sp_satisfied and not sys.blockparry and not affs.paralysis
          and not svo.doingaction'doparry' and ((svo.haveskillset('tekura') and conf.guarding) or conf.parry) and not codepaste.balanceful_codepaste()
          -- blademasters can parry with their sword sheathed, and monks don't need to wield anything
          and ((svo.haveskillset('tekura') or svo.me.class == 'Blademaster') or ((not sys.enabledgmcp or defc.dragonform) or (next(me.wielded) and sk.have_parryable())))
          and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function (limb)
        local t = svo.sps.parry_currently
        for currentlimb, _ in pairs(t) do t[currentlimb] = false end
        t[limb] = true
        svo.check_sp_satisfied()
      end,

      onstart = function ()
        if svo.sps.something_to_parry() then
          for name, limb in pairs(svo.sp_config.parry_shouldbe) do
            if limb and limb ~= svo.sps.parry_currently[name] then
if not svo.haveskillset('tekura') then
              send(string.format(&quot;%sparry %s&quot;, (not defc.dragonform and &quot;&quot; or 'claw'), name), conf.commandecho)
else
              send(string.format(&quot;%s %s&quot;, (not defc.dragonform and 'guard' or 'clawparry'), name), conf.commandecho)
end
              return
            end
          end
        elseif type(svo.sp_config.parry) == 'string' and svo.sp_config.parry == 'manual' then
          -- check if we need to unparry in manual
          for limb, status in pairs(svo.sps.parry_currently) do
            if status ~= svo.sp_config.parry_shouldbe[limb] then
if not svo.haveskillset('tekura') then
             send(string.format(&quot;%sparry nothing&quot;, (not defc.dragonform and &quot;&quot; or 'claw')), conf.commandecho)
else
             send(string.format(&quot;%s nothing&quot;, (not defc.dragonform and 'guard' or 'clawparry')), conf.commandecho)
end
             return
            end
          end

          -- got here? nothing to do...
          svo.sys.sp_satisfied = true
        elseif svo.sp_config.priority[1] and not svo.sps.parry_currently[svo.sp_config.priority[1]] then
if not svo.haveskillset('tekura') then
          send(string.format(&quot;%sparry %s&quot;, (not defc.dragonform and &quot;&quot; or 'claw'), svo.sp_config.priority[1]), conf.commandecho)
else
          send(string.format(&quot;%s %s&quot;, (not defc.dragonform and 'guard' or 'clawparry'), svo.sp_config.priority[1]), conf.commandecho)
end
        else -- got here? nothing to do...
          svo.sys.sp_satisfied = true end
      end,

      none = function ()
        for limb, _ in pairs(svo.sps.parry_currently) do
          svo.sps.parry_currently[limb] = false
        end

        svo.check_sp_satisfied()
      end
    }
  },
  doprecache = {
    misc = {
      aspriority = 0,
      spriority = 0,
      -- not a curable in-game affliction? mark it so priority doesn't get set
      uncurable = true,

      isadvisable = function ()
        return (rift.doprecache and not sys.blockoutr and not svo.findbybal'herb' and not svo.doingaction'doprecache' and sys.canoutr) or false
      end,

      oncompleted = function ()
        -- check if we still need to precache, and if not, clear rift.doprecache
        rift.checkprecache()

        if rift.doprecache then
          -- allow other outrs to catch up, then re-check again
          if sys.blockoutr then killTimer(sys.blockoutr); sys.blockoutr = nil end
          sys.blockoutr = tempTimer(sys.wait + svo.syncdelay(), function () sys.blockoutr = nil
            svo.debugf(&quot;sys.blockoutr expired&quot;) svo.make_gnomes_work()
            end)
          svo.debugf(&quot;sys.blockoutr setup: &quot;, debug.traceback())
        end
      end,

      ontimeout = function ()
        rift.checkprecache()
      end,

      onstart = function ()
        for herb, _ in pairs(rift.precache) do
          if rift.precache[herb] ~= 0 and rift.riftcontents[herb] ~= 0 and (rift.invcontents[herb] &lt; rift.precache[herb]) then
            send(string.format(&quot;outr %s%s&quot;, (affs.addiction and &quot;&quot; or (rift.precache[herb] - rift.invcontents[herb]..&quot; &quot;)), herb), conf.commandecho)
            if sys.sync then return end
          end
        end
      end
    }
  },
  prone = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.prone and (not affs.paralysis or svo.doingaction'paralysis')
          and (svo.haveskillset('weaponmastery') and (sk.didfootingattack or (bals.balance and bals.equilibrium and bals.leftarm and bals.rightarm)) or (bals.balance and bals.equilibrium and bals.leftarm and bals.rightarm))
          and not svo.doingaction('prone') and not affs.sleep
          and not affs.impale
          and not affs.transfixed
          and not affs.webbed and not affs.bound and not affs.roped
          and not affs.crippledleftleg and not affs.crippledrightleg
          and not affs.mangledleftleg and not affs.mangledrightleg
          and not affs.mutilatedleftleg and not affs.mutilatedrightleg) or false
      end,

      oncompleted = function ()
        svo.rmaff('prone')
      end,

      onstart = function ()
if svo.haveskillset('weaponmastery') then
        if sk.didfootingattack and conf.recoverfooting then
          send(&quot;recover footing&quot;, conf.commandecho)
          if affs.blackout then send(&quot;recover footing&quot;, conf.commandecho) end
        else
          send('stand', conf.commandecho)
          if affs.blackout then send('stand', conf.commandecho) end
        end
else
        send('stand', conf.commandecho)
        if affs.blackout then send('stand', conf.commandecho) end
end
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.prone then svo.addaffdict(svo.dict.prone) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('prone')
      end
    },
    onremoved = function () svo.donext() end,
    onadded = function()
      if affs.prone and affs.seriousconcussion then
        sk.warn 'pulpable'
      end
    end
  },
  disrupt = {
    gamename = 'disrupted',
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.disrupt and not svo.doingaction('disrupt')
          and not affs.confusion and not affs.sleep) or false
      end,

      oncompleted = function ()
        svo.rmaff('disrupt')
      end,

      oncured = function ()
        svo.rmaff('disrupt')
      end,

      action = 'concentrate',
      onstart = function ()
        send('concentrate', conf.commandecho)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.disrupt)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('disrupt')
      end
    }
  },
  lightpipes = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return ((not pipes.valerian.arty and not pipes.valerian.lit and pipes.valerian.puffs &gt; 0 and not (pipes.valerian.id == 0)
          or (not pipes.elm.arty and not pipes.elm.lit and pipes.elm.puffs &gt; 0 and not (pipes.elm.id == 0))
          or (not pipes.skullcap.arty and not pipes.skullcap.lit and pipes.skullcap.puffs &gt; 0 and not (pipes.skullcap.id == 0))
          or (not pipes.elm.arty2 and not pipes.elm.lit2 and pipes.elm.puffs2 &gt; 0 and not (pipes.elm.id2 == 0))
          or (not pipes.valerian.arty2 and not pipes.valerian.lit2 and pipes.valerian.puffs2 &gt; 0 and not (pipes.valerian.id2 == 0))
          or (not pipes.skullcap.arty2 and not pipes.skullcap.lit2 and pipes.skullcap.puffs2 &gt; 0 and not (pipes.skullcap.id2 == 0))
          )
        and (conf.relight or sk.forcelight_valerian or sk.forcelight_skullcap or sk.forcelight_elm)
        and not (svo.doingaction('lightskullcap') or svo.doingaction('lightelm') or svo.doingaction('lightvalerian') or svo.doingaction('lightpipes'))) or false
      end,

      oncompleted = function ()
        pipes.valerian.lit = true
        pipes.valerian.lit2 = true
        sk.forcelight_valerian = false
        pipes.elm.lit = true
        pipes.elm.lit2 = true
        sk.forcelight_elm = false
        pipes.skullcap.lit = true
        pipes.skullcap.lit2 = true
        sk.forcelight_skullcap = false

        svo.lastlit('valerian')
      end,

      actions = {&quot;light pipes&quot;},
      onstart = function ()
        if conf.gagrelight then
          send(&quot;light pipes&quot;, false)
        else
          send(&quot;light pipes&quot;, conf.commandecho) end
      end
    }
  },
  fillskullcap = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = 'skullcap',
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.skullcap.puffs &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.skullcap.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.skullcap.puffs2 &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.skullcap.id2 == 0)
      end,

      isadvisable = function ()
        return ((svo.dict.fillskullcap.physical.mainpipeout() or svo.dict.fillskullcap.physical.secondarypipeout()) and not svo.doingaction('fillskullcap') and not svo.doingaction('fillelm') and not svo.doingaction('fillvalerian') and not svo.will_take_balance() and not (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed)) or false
      end,

      oncompleted = function ()
        if svo.dict.fillskullcap.fillingid == pipes.skullcap.id then
          pipes.skullcap.puffs = pipes.skullcap.maxpuffs or 10
          pipes.skullcap.lit = false
          rift.invcontents.skullcap = rift.invcontents.skullcap - 1
          if rift.invcontents.skullcap &lt; 0 then rift.invcontents.skullcap = 0 end
        else
          pipes.skullcap.puffs2 = pipes.skullcap.maxpuffs2 or 10
          pipes.skullcap.lit2 = false
          rift.invcontents.skullcap = rift.invcontents.skullcap - 1
          if rift.invcontents.skullcap &lt; 0 then rift.invcontents.skullcap = 0 end
        end
      end,

      onstart = function ()
        if svo.dict.fillskullcap.physical.mainpipeout() then
          svo.fillpipe('skullcap', pipes.skullcap.id)
          svo.dict.fillskullcap.fillingid = pipes.skullcap.id
        else
          svo.fillpipe('skullcap', pipes.skullcap.id2)
          svo.dict.fillskullcap.fillingid = pipes.skullcap.id2
        end
      end
    }
  },
  fillelm = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = 'elm',
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.elm.puffs &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.elm.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.elm.puffs2 &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.elm.id2 == 0)
      end,

      isadvisable = function ()
        return ((svo.dict.fillelm.physical.mainpipeout() or svo.dict.fillelm.physical.secondarypipeout()) and not svo.doingaction('fillskullcap') and not svo.doingaction('fillelm') and not svo.doingaction('fillvalerian') and not svo.will_take_balance()  and not (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed)) or false
      end,

      oncompleted = function ()
        if svo.dict.fillelm.fillingid == pipes.elm.id then
          pipes.elm.puffs = pipes.elm.maxpuffs or 10
          pipes.elm.lit = false
          rift.invcontents.elm = rift.invcontents.elm - 1
          if rift.invcontents.elm &lt; 0 then rift.invcontents.elm = 0 end
        else
          pipes.elm.puffs2 = pipes.elm.maxpuffs2 or 10
          pipes.elm.lit2 = false
          rift.invcontents.elm = rift.invcontents.elm - 1
          if rift.invcontents.elm &lt; 0 then rift.invcontents.elm = 0 end
        end
      end,

      onstart = function ()
        if svo.dict.fillelm.physical.mainpipeout() then
          svo.fillpipe('elm', pipes.elm.id)
          svo.dict.fillelm.fillingid = pipes.elm.id
        else
          svo.fillpipe('elm', pipes.elm.id2)
          svo.dict.fillelm.fillingid = pipes.elm.id2
        end
      end
    }
  },
  fillvalerian = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      herb = 'valerian',
      uncurable = true,
      fillingid = 0,

      mainpipeout = function()
        return (pipes.valerian.puffs &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.valerian.id == 0)
      end,

      secondarypipeout = function()
        return (pipes.valerian.puffs2 &lt;= ((sys.sync or defc.selfishness) and 0 or conf.refillat)) and not (pipes.valerian.id2 == 0)
      end,

      isadvisable = function ()
        if (svo.dict.fillvalerian.physical.mainpipeout() or svo.dict.fillvalerian.physical.secondarypipeout()) and not svo.doingaction('fillskullcap') and not svo.doingaction('fillelm') and not svo.doingaction('fillvalerian') and not svo.will_take_balance() then

          if (affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm or affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm or affs.paralysis or affs.transfixed) then
            sk.warn 'emptyvalerianpipenorefill'
            return false
          else
            return true
          end
        end
      end,

      oncompleted = function ()
        if svo.dict.fillvalerian.fillingid == pipes.valerian.id then
          pipes.valerian.puffs = pipes.valerian.maxpuffs or 10
          pipes.valerian.lit = false
          rift.invcontents.valerian = rift.invcontents.valerian - 1
          if rift.invcontents.valerian &lt; 0 then rift.invcontents.valerian = 0 end
        else
          pipes.valerian.puffs2 = pipes.valerian.maxpuffs2 or 10
          pipes.valerian.lit2 = false
          rift.invcontents.valerian = rift.invcontents.valerian - 1
          if rift.invcontents.valerian &lt; 0 then rift.invcontents.valerian = 0 end
        end
      end,

      onstart = function ()
        if svo.dict.fillvalerian.physical.mainpipeout() then
          svo.fillpipe('valerian', pipes.valerian.id)
          svo.dict.fillvalerian.fillingid = pipes.valerian.id
        else
          svo.fillpipe('valerian', pipes.valerian.id2)
          svo.dict.fillvalerian.fillingid = pipes.valerian.id2
        end
      end
    }
  },
  rewield = {
    rewieldables = false,
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (conf.autorewield and svo.dict.rewield.rewieldables and not svo.doingaction'rewield' and not affs.impale and not affs.webbed and not affs.transfixed and not affs.roped and not affs.transfixed and sys.canoutr and not affs.mutilatedleftarm and not affs.mutilatedrightarm and not affs.mangledrightarm and not affs.mangledleftarm and not affs.crippledrightarm and not affs.crippledleftarm) or false
      end,

      oncompleted = function (id)
        if not svo.dict.rewield.rewieldables then return end

        for count, item in ipairs(svo.dict.rewield.rewieldables) do
          if item.id == id then
            table.remove(svo.dict.rewield.rewieldables, count)
            break
          end
        end

        if #svo.dict.rewield.rewieldables == 0 then
          svo.dict.rewield.rewieldables = false
        end
      end,

      failed = function ()
        svo.dict.rewield.rewieldables = false
      end,

      clear = function ()
        svo.dict.rewield.rewieldables = false
      end,

      onstart = function ()
        for _, t in pairs(svo.dict.rewield.rewieldables) do
          send(&quot;wield &quot;..t.id, conf.commandecho)
          if sys.sync then return end
        end
      end
    }
  },
  blackout = {
    waitingfor = {
      customwait = 60,

      onstart = function ()
      end,

      oncompleted = function ()
        svo.rmaff('blackout')
      end,

      ontimeout = function ()
        svo.rmaff('blackout')
      end
    },
    aff = {
      oncompleted = function ()
        if affs.blackout then return end

        svo.addaffdict(svo.dict.blackout)
        svo.check_generics()

        tempTimer(4.5, function() if affs.blackout then svo.addaffdict(svo.dict.disrupt) svo.make_gnomes_work() end end)

        -- prevent leprosy in blackout
        if svo.enabledskills.necromancy then
          svo.echof(&quot;Fighting a Necromancer - going to assume crippled limbs every now and then.&quot;)
          tempTimer(3, function() if affs.blackout then svo.addaffdict(svo.dict.unknowncrippledlimb) svo.make_gnomes_work() end end)
          tempTimer(5, function() if affs.blackout then svo.addaffdict(svo.dict.unknowncrippledlimb) svo.make_gnomes_work() end end)
        end

        if svo.enabledskills.curses then
          svo.echof(&quot;Fighting a Shaman - going to check for asthma/anorexia.&quot;)
          tempTimer(3, function() if affs.blackout then svo.affsp.anorexia = true; svo.affsp.asthma = true; svo.make_gnomes_work() end end)
          tempTimer(5, function() if affs.blackout then svo.affsp.anorexia = true; svo.affsp.asthma = true; svo.make_gnomes_work() end end)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('blackout')
      end,
    },
    onremoved = function ()
      svo.check_generics()
      if sk.sylvan_eclipse then
        sys.manualdiag = true
      end

      if not affs.recklessness then
        svo.killaction(svo.dict.nomana.waitingfor)
      end

      if svo.dict.blackout.check_lust then
        svo.echof(&quot;Checking allies for potential lust...&quot;)
        send('allies', conf.commandecho)
        svo.dict.blackout.check_lust = nil
      end

      tempTimer(0.5, function()
        if not bals.equilibrium and not conf.serverside then svo.addaffdict(svo.dict.disrupt) end

        if stats.currenthealth == 0 and conf.assumestats ~= 0 then
          svo.reset.affs()
          svo.reset.general()
          svo.reset.defs()
          conf.paused = true
          echo&quot;\n&quot;svo.echof(&quot;We died.&quot;)
          raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      end)

      -- if we came out with full health and mana out of blackout, assume we've got recklessness meanwhile. don't do it in serverside curing though, because that doesn't assume the same
      if (not svo.dict.blackout.addedon or svo.dict.blackout.addedon ~= os.time()) and stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana then
        svo.addaffdict(svo.dict.recklessness)
        svo.echof(&quot;suspicious full stats out of blackout - going to assume reckless.&quot;)
        if conf.serverside then
          svo.sendcuring(&quot;predict recklessness&quot;)
        end
      end
    end,
    onadded = function()
      svo.dict.blackout.addedon = os.time()
    end
  },
  unknownany = {
    count = 0,
    reckhp = false, reckmana = false,
    waitingfor = {
      customwait = 999,

      onstart = function ()
      end,

      empty = function ()
      end
    },
    aff = {
      oncompleted = function (number)

        if ((svo.dict.unknownany.reckhp and stats.currenthealth == stats.maxhealth) or
          (svo.dict.unknownany.reckmana and stats.currentmana == stats.maxmana)) then
            svo.addaffdict(svo.dict.recklessness)

            if conf.serverside then
              svo.sendcuring(&quot;predict recklessness&quot;)
            end

            if number and number &gt; 1 then
              -- take one off because one affliction is recklessness
              codepaste.addunknownany(number-1)
            end
        else
          codepaste.addunknownany(number)
        end

        svo.dict.unknownany.reckhp = false; svo.dict.unknownany.reckmana = false
      end,

      wrack = function()
        -- if 3, then it was not hidden, ignore - affliction triggers will watch the aff
        if svo.paragraph_length &gt;= 3 then return end

        if ((svo.dict.unknownany.reckhp and stats.currenthealth == stats.maxhealth) or
          (svo.dict.unknownany.reckmana and stats.currentmana == stats.maxmana)) then
            svo.addaffdict(svo.dict.recklessness)

            if conf.serverside then
              svo.sendcuring(&quot;predict recklessness&quot;)
            end
        else
          codepaste.addunknownany()
        end

        svo.dict.unknownany.reckhp = false; svo.dict.unknownany.reckmana = false
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('unknownany')
        svo.dict.unknownany.count = 0
      end,

      -- to be used when you lost one unknown (for example, you saw a symptom for something else)
      lost_level = function()
        if not affs.unknownany then return end
        affs.unknownany.p.count = affs.unknownany.p.count - 1
        if affs.unknownany.p.count &lt;= 0 then
          svo.rmaff('unknownany')
          svo.dict.unknownany.count = 0
        else
          svo.updateaffcount(svo.dict.unknownany)
        end
      end
    }
  },
  unknownmental = {
    count = 0,
    reckhp = false, reckmana = false,
    focus = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknownmental) or false
      end,

      oncompleted = function ()
        -- special: gets called on each focus mind cure, but we most of
        -- the time don't have an unknown aff
        if not affs.unknownmental then return end
        affs.unknownmental.p.count = affs.unknownmental.p.count - 1
        if affs.unknownmental.p.count &lt;= 0 then
          svo.rmaff('unknownmental')
          svo.dict.unknownmental.count = 0
        else
          svo.updateaffcount(svo.dict.unknownmental)
        end

        svo.lostbal_focus()
      end,

      onstart = function ()
        send(&quot;focus mind&quot;, conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        svo.rmaff('unknownmental')
      end
    },
    aff = {
      oncompleted = function (number)
        if ((svo.dict.unknownmental.reckhp and stats.currenthealth == stats.maxhealth) or
          (svo.dict.unknownmental.reckmana and stats.currentmana == stats.maxmana)) then
            svo.addaffdict(svo.dict.recklessness)

            if conf.serverside then
              svo.sendcuring(&quot;predict recklessness&quot;)
            end

            if number and number &gt; 1 then
              local count = svo.dict.unknownany.count
              svo.addaffdict(svo.dict.unknownany)
              -- take one off because one affliction is recklessness
              affs.unknownany.p.count = (count or 0) + (number - 1)
              svo.updateaffcount(svo.dict.unknownany)
            end
        else
          local count = svo.dict.unknownmental.count
          svo.addaffdict(svo.dict.unknownmental)

          svo.dict.unknownmental.count = (count or 0) + (number or 1)
          svo.updateaffcount(svo.dict.unknownmental)
        end

        svo.dict.unknownmental.reckhp = false; svo.dict.unknownmental.reckmana = false
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('unknownmental')
        svo.dict.unknownmental.count = 0
      end,

      -- to be used when you lost one focusable (for example, you saw a symptom for something else)
      lost_level = function()
        if not affs.unknownmental then return end
        affs.unknownmental.p.count = affs.unknownmental.p.count - 1
        if affs.unknownmental.p.count &lt;= 0 then
          svo.rmaff('unknownmental')
          svo.dict.unknownmental.count = 0
        else
          svo.updateaffcount(svo.dict.unknownmental)
        end
      end
    }
  },
  unknowncrippledlimb = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledlimb and not (affs.mutilatedrightarm or affs.mutilatedleftarm or affs.mangledleftarm or affs.mangledrightarm or affs.parestoarms) and not (affs.mutilatedrightleg or affs.mutilatedleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('unknowncrippledlimb')
      end,

      applycure = {'mending', 'renewal'},
      actions = {&quot;apply mending&quot;, &quot;apply renewal&quot;},
      onstart = function ()
        svo.apply(svo.dict.unknowncrippledlimb.salve)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.apply_mending()
      end,

      fizzled = function ()
        svo.lostbal_salve()
        -- if it fizzled, then it means we've got a resto break on arms or legs
        -- applying resto without targetting a limb doesn't work, so try mending on both, see what happens
        svo.rmaff('unknowncrippledlimb')
        svo.addaffdict(svo.dict.unknowncrippledarm)
        svo.addaffdict(svo.dict.unknowncrippledleg)
        tempTimer(0, function() svo.show_info(&quot;some limb broken?&quot;, &quot;It would seem an arm or a leg of yours is broken (the salve fizzled), not just crippled - going to work out which is it and fix it&quot;) end)
      end,
    },
    aff = {
      oncompleted = function (amount)
        svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count + (amount or 1)
        if svo.dict.unknowncrippledlimb.count &gt; 4 then svo.dict.unknowncrippledlimb.count = 4 end
        svo.addaffdict(svo.dict.unknowncrippledlimb)
        svo.updateaffcount(svo.dict.unknowncrippledlimb)
      end
    },
    gone = {
      oncompleted = function ()
        svo.dict.unknowncrippledlimb.count = 0
        svo.rmaff('unknowncrippledlimb')
      end,
    },
    onremoved = function ()
      if svo.dict.unknowncrippledlimb.count &lt;= 0 then return end

      svo.dict.unknowncrippledlimb.count = svo.dict.unknowncrippledlimb.count - 1
      if svo.dict.unknowncrippledlimb.count &lt;= 0 then return end
      svo.addaffdict(svo.dict.unknowncrippledlimb)
      svo.updateaffcount(svo.dict.unknowncrippledlimb)
    end,
  },
  unknowncrippledarm = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledarm and not (affs.mutilatedrightarm or affs.mutilatedleftarm or affs.mangledleftarm or affs.mangledrightarm or affs.parestoarms)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('unknowncrippledarm')
      end,

      actions = {&quot;apply mending to arms&quot;, &quot;apply mending&quot;, &quot;apply renewal to arms&quot;, &quot;apply renewal&quot;},
      applycure = {'mending', 'renewal'},
      onstart = function ()
        svo.apply(svo.dict.unknowncrippledarm.salve, &quot; to arms&quot;)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_arms()
      end,

      fizzled = function (limb)
        svo.lostbal_salve()
        if limb and svo.dict['mangled'..limb] then svo.addaffdict(svo.dict['mangled'..limb]) end
      end,
    },
    aff = {
      oncompleted = function (amount)
        svo.dict.unknowncrippledarm.count = svo.dict.unknowncrippledarm.count + (amount or 1)
        if svo.dict.unknowncrippledarm.count &gt; 2 then svo.dict.unknowncrippledarm.count = 2 end
        svo.addaffdict(svo.dict.unknowncrippledarm)
        svo.updateaffcount(svo.dict.unknowncrippledarm)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.dict.unknowncrippledarm.count = 0
        svo.rmaff('unknowncrippledarm')
      end,
    },
    onremoved = function ()
      if svo.dict.unknowncrippledarm.count &lt;= 0 then return end

      svo.dict.unknowncrippledarm.count = svo.dict.unknowncrippledarm.count - 1
      if svo.dict.unknowncrippledarm.count &lt;= 0 then return end
      svo.addaffdict(svo.dict.unknowncrippledarm)
      svo.updateaffcount(svo.dict.unknowncrippledarm)
    end,
  },
  unknowncrippledleg = {
    count = 0,
    salve = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.unknowncrippledleg and not (affs.mutilatedrightleg or affs.mutilatedleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.parestolegs)) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        svo.rmaff('unknowncrippledleg')
      end,

      actions = {&quot;apply mending to legs&quot;, &quot;apply mending&quot;, &quot;apply renewal to legs&quot;, &quot;apply renewal&quot;},
      applycure = {'mending', 'renewal'},
      onstart = function ()
        svo.apply(svo.dict.unknowncrippledleg.salve, &quot; to legs&quot;)
      end,

      noeffect = function ()
        svo.lostbal_salve()
        empty.noeffect_mending_legs()
      end,

      fizzled = function (limb)
        svo.lostbal_salve()
        if limb and svo.dict['mangled'..limb] then svo.addaffdict(svo.dict['mangled'..limb]) end
      end,
    },
    aff = {
      oncompleted = function (amount)
        svo.dict.unknowncrippledleg.count = svo.dict.unknowncrippledleg.count + (amount or 1)
        if svo.dict.unknowncrippledleg.count &gt; 2 then svo.dict.unknowncrippledleg.count = 2 end
        svo.addaffdict(svo.dict.unknowncrippledleg)
        svo.updateaffcount(svo.dict.unknowncrippledleg)
      end
    },
    gone = {
      oncompleted = function ()
        svo.dict.unknowncrippledleg.count = 0
        svo.rmaff('unknowncrippledleg')
      end,
    },
    onremoved = function ()
      if svo.dict.unknowncrippledleg.count &lt;= 0 then return end

      svo.dict.unknowncrippledleg.count = svo.dict.unknowncrippledleg.count - 1
      if svo.dict.unknowncrippledleg.count &lt;= 0 then return end
      svo.addaffdict(svo.dict.unknowncrippledleg)
      svo.updateaffcount(svo.dict.unknowncrippledleg)
    end,
  },
  unknowncure = {
    count = 0,
    waitingfor = {
      customwait = 999,

      onstart = function ()
      end,

      empty = function ()
      end
    },
    aff = {
      oncompleted = function (number)
        local count = svo.dict.unknowncure.count
        svo.addaffdict(svo.dict.unknowncure)

        svo.dict.unknowncure.count = (count or 0) + (number or 1)
        svo.updateaffcount(svo.dict.unknowncure)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('unknowncure')
        svo.dict.unknowncure.count = 0
      end
    }
  },


-- writhes
  bound = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.bound and codepaste.writhe()) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingbound.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        send('writhe', conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.bound)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('bound')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingbound = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('bound')
      end,

      onstart = function ()
      end
    }
  },
  webbed = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.webbed and codepaste.writhe() and not (bals.balance and bals.rightarm and bals.leftarm and svo.dict.dragonflex.misc.isadvisable()) and (not svo.haveskillset('voicecraft') or (not conf.dwinnu or not svo.dict.dwinnu.misc.isadvisable()))) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingwebbed.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        if math.random(1, 30) == 1 then
          send(&quot;writhe wiggle wiggle&quot;, conf.commandecho)
        else
          send('writhe', conf.commandecho)
        end
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        affs.webbed = nil
        svo.addaffdict(svo.dict.webbed)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('webbed')
      end,
    },
    onremoved = function () signals.canoutr:emit() svo.donext() end
  },
  curingwebbed = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('webbed')
      end,

      onstart = function ()
      end
    }
  },
  roped = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.roped and codepaste.writhe() and not (bals.balance and bals.rightarm and bals.leftarm and svo.dict.dragonflex.misc.isadvisable()) and (not svo.haveskillset('voicecraft') or (not conf.dwinnu or not svo.dict.dwinnu.misc.isadvisable()))) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingroped.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        send('writhe', conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.roped)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('roped')
      end,
    },
    onremoved = function () signals.canoutr:emit() svo.donext() end
  },
  curingroped = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('roped')
      end,

      onstart = function ()
      end
    }
  },
  hoisted = {
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,
      uncurable = true,

      isadvisable = function ()
        return (affs.hoisted and codepaste.writhe() and bals.balance and bals.rightarm and bals.leftarm) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curinghoisted.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        send('writhe', conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hoisted)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hoisted')
      end,
    }
  },
  curinghoisted = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('hoisted')
      end,

      onstart = function ()
      end
    }
  },
  transfixed = {
    gamename = 'transfixation',
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,

      isadvisable = function ()
        return (affs.transfixed and codepaste.writhe()) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingtransfixed.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        send('writhe', conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      impale = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        if not conf.aillusion or ((not affs.blindaff and not defc.blind) or svo.lifevision.l.blindaff_aff or svo.lifevision.l.blind_herb or svo.lifevision.l.blind_misc) then
          svo.affsp.transfixed = nil
          svo.addaffdict(svo.dict.transfixed)
        end

        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('transfixed')
      end,
    },
    onremoved = function () signals.canoutr:emit() svo.donext() end
  },
  curingtransfixed = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('transfixed')
      end,

      onstart = function ()
      end
    }
  },
  impale = {
    gamename = 'impaled',
    misc = {
      aspriority = 0,
      spriority = 0,
      dontbatch = true,


      isadvisable = function ()
        return (affs.impale and not svo.doingaction('curingimpale') and not svo.doingaction('impale') and bals.balance and bals.rightarm and bals.leftarm) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.curingimpale.waitingfor)
      end,

      action = 'writhe',
      onstart = function ()
        send('writhe', conf.commandecho)
      end,

      helpless = function ()
        empty.writhe()
      end,

      dragged = function()
        svo.rmaff('impale')
      end,
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.impale)
        signals.canoutr:emit()
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('impale')
      end,
    },
    onremoved = function () signals.canoutr:emit() end
  },
  curingimpale = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        svo.rmaff('impale')
      end,

      withdrew = function ()
        svo.rmaff('impale')
      end,

      dragged = function()
        svo.rmaff('impale')
      end,

      onstart = function ()
      end
    }
  },
  dragonflex = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (conf.dragonflex and ((affs.webbed and not svo.ignore.webbed) or (affs.roped and not svo.ignore.roped)) and codepaste.writhe() and not affs.paralysis and defc.dragonform and bals.balance and not svo.doingaction'impale') or false
      end,

      oncompleted = function ()
        svo.rmaff{'webbed', 'roped'}
      end,

      action = 'dragonflex',
      onstart = function ()
        send('dragonflex', conf.commandecho)
      end
    },
  },

  -- anti-illusion checks, grouped by symptom similarity
  checkslows = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (next(svo.affsp) and (svo.affsp.retardation or svo.affsp.aeon or svo.affsp.truename)) or false
      end,

      oncompleted = function () end,

      sluggish = function ()
        if svo.affsp.retardation then
          svo.affsp.retardation = nil
          svo.addaffdict(svo.dict.retardation)
          signals.newroom:unblock(sk.check_retardation)
        elseif svo.affsp.aeon then
          svo.affsp.aeon = nil

          svo.addaffdict(svo.dict.aeon)
          defences.lost('speed')
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        elseif svo.affsp.truename then
          svo.affsp.truename = nil

          svo.addaffdict(svo.dict.aeon)
          defences.lost('speed')
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        end

        sk.checkaeony()
        signals.aeony:emit()
        codepaste.badaeon()
      end,

      onclear = function ()
        if svo.affsp.retardation then
          svo.affsp.retardation = nil
        elseif svo.affsp.aeon then
          svo.affsp.aeon = nil
        elseif svo.affsp.truename then
          svo.affsp.truename = nil
        end
      end,

      onstart = function ()
        send('say', false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (which)
      if svo.paragraph_length &gt; 2 or svo.ignore.checkslows then
          if which == 'truename' then which = 'aeon' end

          svo.addaffdict(svo.dict[which])
          svo.killaction(svo.dict.checkslows.misc)

          if which == 'aeon' then defences.lost('speed') end
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)

          sk.checkaeony()
          signals.aeony:emit()
          codepaste.badaeon()

          if which == 'retardation' then
            signals.newroom:unblock(sk.check_retardation)
          end
        else
          svo.affsp[which] = true
        end
      end,

      truename = function()
        svo.affsp.truename = true
      end,
    },
  },

  checkanorexia = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.anorexia) or false
      end,

      oncompleted = function () end,

      blehfood = function ()
        svo.addaffdict(svo.dict.anorexia)
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        svo.affsp.anorexia = nil
      end,

      onclear = function ()
        svo.affsp.anorexia = nil
      end,

      onstart = function ()
        send(&quot;eat something&quot;, false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function ()
        if svo.paragraph_length &gt; 2 then
          svo.addaffdict(svo.dict.anorexia)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          svo.killaction(svo.dict.checkanorexia.misc)
        else
          svo.affsp.anorexia = true
        end

        -- register it as a possible hypochondria symptom
        if svo.paragraph_length == 1 then
          sk.hypochondria_symptom()
        end
      end
    },
  },

  checkparalysis = {
    description = &quot;anti-illusion check for paralysis&quot;,
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return false -- hardcoded to be off, as there's no known solution currently that works
        --return (svo.affsp.paralysis and not affs.sleep and (not conf.waitparalysisai or (bals.balance and bals.equilibrium)) and not affs.roped) or false
      end,

      oncompleted = function () end,

      paralysed = function ()
        svo.addaffdict(svo.dict.paralysis)

        if svo.dict.relapsing.saw_with_checkable == 'paralysis' then
          svo.dict.relapsing.saw_with_checkable = nil
          svo.addaffdict(svo.dict.relapsing)
        end

        if type(svo.affsp.paralysis) == 'string' then
          svo.addaffdict(svo.dict[svo.affsp.paralysis])
        end
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        svo.affsp.paralysis = nil
      end,

      onclear = function ()
        svo.affsp.paralysis = nil
      end,

      onstart = function ()
        send(&quot;fling paralysis&quot;, false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (withaff) -- ie, 'darkshade' - add the additional aff if we have paralysis
        -- disabled, as fling no longer works and illusions are not so prevalent
        if true then
        -- if svo.paragraph_length &gt; 2 or (not (bals.balance and bals.equilibrium) and not conf.waitparalysisai) then -- if it's not an illusion for sure, or if we have waitparalysisai off and don't have both balance/eq, accept it as paralysis right now
          svo.addaffdict(svo.dict.paralysis)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          svo.killaction(svo.dict.checkparalysis.misc)
          if withaff then svo.addaffdict(svo.dict[withaff]) end
        -- else -- else, it gets added to be checked later if we have waitparalysisai on and don't have balance or eq
        --   svo.affsp.paralysis = withaff or true
        end
      end
    },
  },

  checkimpatience = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.impatience and not affs.sleep and bals.focus and conf.focus) or false
      end,

      oncompleted = function () end,

      impatient = function ()
        if not affs.impatience then
          svo.addaffdict(svo.dict.impatience)
          svo.echof(&quot;Looks like the impatience is real.&quot;)
        end

        svo.affsp.impatience = nil
      end,

      -- if serverside cures impatience before we can even validate it, cancel it
      oncancel = function ()
        svo.affsp.impatience = nil
        svo.killaction(svo.dict.checkimpatience.misc)
      end,

      onclear = function ()
        if svo.affsp.impatience then
          svo.lostbal_focus()
          if svo.affsp.impatience ~= 'quiet' then
            svo.echof(&quot;The impatience earlier was actually an illusion, ignoring it.&quot;)
          end
          svo.affsp.impatience = nil
        end
      end,

      onstart = function ()
        send('focus', false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (option)
        if svo.paragraph_length &gt; 2 then
          svo.addaffdict(svo.dict.impatience)
          svo.killaction(svo.dict.checkimpatience.misc)
        else
          svo.affsp.impatience = option and option or true
        end
      end
    },
  },

  checkasthma = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.asthma and conf.breath and bals.balance and bals.equilibrium) or false
      end,

      oncompleted = function () end,

      weakbreath = function ()
        svo.addaffdict(svo.dict.asthma)
        local r = svo.findbybal('smoke')
        if r then
          svo.killaction(svo.dict[r.action_name].smoke)
        end

        if svo.dict.relapsing.saw_with_checkable == 'asthma' then
          svo.dict.relapsing.saw_with_checkable = nil
          svo.addaffdict(svo.dict.relapsing)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        svo.affsp.asthma = nil
        codepaste.badaeon()
      end,

      onclear = function ()
        svo.affsp.asthma = nil
      end,

      onstart = function ()
        send(&quot;hold breath&quot;, conf.commandecho)
      end
    },
    smoke = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.asthma and not svo.dict.checkasthma.misc.isadvisable() and codepaste.smoke_valerian_pipe()) or false
      end,

      oncompleted = function ()
        svo.lostbal_smoke()
      end,

      badlungs = function ()
        svo.addaffdict(svo.dict.asthma)
        local r = svo.findbybal('smoke')
        if r then
          svo.killaction(svo.dict[r.action_name].smoke)
        end

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        svo.affsp.asthma = nil
      end,

      -- mucous can hit when we aren't even afflicted, so it's moot. Have to wait for it to clear up
      mucous = function()
      end,

      onclear = function ()
        svo.affsp.asthma = nil
        svo.lostbal_smoke()
      end,

      empty = function()
        svo.affsp.asthma = nil
        svo.lostbal_smoke()
      end,

      smokecure = {'valerian', 'realgar'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.valerian.id, conf.commandecho)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (oldhp)
      if svo.paragraph_length &gt; 2 or (oldhp and stats.currenthealth &lt; oldhp) or (svo.paragraph_length == 2 and svo.find_until_last_paragraph(&quot;aura of weapons rebounding disappears&quot;, 'substring')) then
          svo.addaffdict(svo.dict.asthma)
          local r = svo.findbybal('smoke')
          if r then
            svo.killaction(svo.dict[r.action_name].smoke)
          end

          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          svo.killaction(svo.dict.checkasthma.misc)

          -- if we were checking and we got a verified aff, kill verification
          if svo.actions.checkasthma_smoke then
            svo.killaction(svo.dict.checkasthma.smoke)
          end
        else
          svo.affsp.asthma = true
        end
      end
    },
  },

  checkhypersomnia = {
    description = &quot;anti-illusion check for hypersomnia&quot;,
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.hypersomnia and not affs.sleep) or false
      end,

      oncompleted = function () end,

      hypersomnia = function ()
        svo.addaffdict(svo.dict.hypersomnia)

        svo.affsp.hypersomnia = nil
      end,

      onclear = function ()
        svo.affsp.hypersomnia = nil
      end,

      onstart = function ()
        send('insomnia', conf.commandecho)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function ()
        -- can't check hypersomnia with insomina up - it'll give the insomnia
        -- def line
        if svo.paragraph_length &gt; 2 or defc.insomnia then
          svo.addaffdict(svo.dict.hypersomnia)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          svo.killaction(svo.dict.checkhypersomnia.misc)
        else
          svo.affsp.hypersomnia = true
        end
      end
    },
  },

  checkstun = {
    templifevision = false, -- stores the lifevision actions that will be wiped until confirmed
    tempactions = false, -- stores the actions queue items that will be wiped until confirmed
    time = 0,
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (svo.affsp.stun) or false
      end,

      oncompleted = function (data)
        -- 'fromstun' is given to us if we just had started checking for stun with checkstun_misc, and stun wore off before we could finish - for this rare scenario, we complete checkstun
        if data ~= 'fromstun' then svo.dict.stun.aff.oncompleted(svo.dict.checkstun.time) end
        svo.dict.checkstun.time = 0
        svo.affsp.stun = nil
        tempTimer(0, function ()
          if not svo.dict.checkstun.templifevision then return end

          svo.lifevision.l = deepcopy(svo.dict.checkstun.templifevision)
          svo.dict.checkstun.templifevision = nil

          if svo.lifevision.l.checkstun_aff then
            svo.lifevision.l:set('checkstun_aff', nil)
          end

          for k,v in svo.dict.checkstun.tempactions:iter() do
            if svo.actions[k] then
              svo.debugf(&quot;%s already exists, overwriting it&quot;, k)
            else
              svo.debugf(&quot;re-added %s&quot;, k)
            end

            svo.actions[k] = v
          end

          svo.dict.checkstun.tempactions = nil
          svo.send_in_the_gnomes()
        end)
      end,

      onclear = function ()
        svo.affsp.stun = nil
        svo.dict.checkstun.templifevision = nil
        svo.dict.checkstun.tempactions = nil
      end,

      onstart = function ()
        send(&quot;eat something&quot;, false)
      end
    },
    aff = {
      -- this is an affliction for svo's purposes, but not in the game. Although it would be best if the 'aff' balance was replaced with something else
      notagameaff = true,
      oncompleted = function (num)
      if svo.paragraph_length &gt; 2 then
          svo.dict.stun.aff.oncompleted()
          svo.killaction(svo.dict.checkstun.misc)
        elseif not affs.sleep and not conf.paused then -- let autodetection take care of after we wake up. otherwise, a well timed stun &amp; stun symptom on awake can trick us. if paused, let it through as well, because we don't want to kill affs
          svo.affsp.stun = true
          svo.dict.checkstun.time = num
          svo.dict.checkstun.templifevision = deepcopy(svo.lifevision.l)
          svo.dict.checkstun.tempactions = deepcopy(svo.actions)
          sk.stopprocessing = true
        end
      end
    },
  },

  checkwrithes = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (next(svo.affsp) and ((svo.affsp.impale and not affs.transfixed and not affs.webbed and not affs.roped) or (svo.affsp.webbed and not affs.transfixed and not affs.roped) or svo.affsp.transfixed)) or false
      end,

      oncompleted = function () end,

      webbily = function ()
        svo.affsp.webbed = nil
        svo.addaffdict(svo.dict.webbed)
        signals.canoutr:emit()
      end,

      impaly = function ()
        svo.affsp.impale = nil
        svo.addaffdict(svo.dict.impale)
        signals.canoutr:emit()
      end,

      transfixily = function ()
        svo.affsp.transfixed = nil
        svo.addaffdict(svo.dict.transfixed)
        signals.canoutr:emit()
      end,

      onclear = function ()
        svo.affsp.impale = nil
        svo.affsp.webbed = nil
        svo.affsp.transfixed = nil
      end,

      onstart = function ()
        send('outr', false)
      end
    },
    aff = {
      notagameaff = true,
      oncompleted = function (which)
        if svo.paragraph_length &gt; 2 then
          svo.addaffdict(svo.dict[which])
          svo.killaction(svo.dict.checkwrithes.misc)
        else
          svo.affsp[which] = true
        end
      end,

      impale = function (oldhp)
        if (oldhp and stats.currenthealth &lt; oldhp) then
          svo.addaffdict(svo.dict.impale)
          signals.canoutr:emit()
        else
          svo.affsp.impale = true
        end
      end
    }
  },
  amnesia = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (affs.amnesia) or false
      end,

      oncompleted = function ()
      end,

      onstart = function ()
        send(&quot;touch stuff&quot;, conf.commandecho)
        svo.rmaff('amnesia')
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.amnesia)

        -- cancel what we were doing, do it again
        if sys.sync then
          local result
          for balance,actions in pairs(svo.bals_in_use) do
            if balance ~= 'waitingfor' and balance ~= 'gone' and balance ~= 'aff' and next(actions) then result = select(2, next(actions)) break end
          end
          if result then
            svo.killaction(svo.dict[result.action_name][result.balance])
          end

          svo.conf.send_bypass = true
          send(&quot;touch stuff&quot;, conf.commandecho)
          svo.conf.send_bypass = false
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('amnesia')
      end,
    }
  },

  -- uncurable
  stun = {
    waitingfor = {
      customwait = 1,

      isadvisable = function ()
        return false
      end,

      ontimeout = function ()
        svo.rmaff('stun')

        if svo.dict.checkstun.templifevision then
          svo.debugf(&quot;stun timed out = restoring checkstun lifevisions&quot;)
          svo.dict.checkstun.misc.oncompleted('fromstun')
          svo.make_gnomes_work()
        end

      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('stun')

        if svo.dict.checkstun.templifevision then
          svo.debugf(&quot;stun finished = restoring checkstun lifevisions&quot;)
          svo.dict.checkstun.misc.oncompleted('fromstun')
        end
      end
    },
    aff = {
      oncompleted = function (num)
        if affs.stun then return end

        svo.dict.stun.waitingfor.customwait = (num and num ~= 0) and num or 1
        svo.addaffdict(svo.dict.stun)
        svo.doaction(svo.dict.stun.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('stun')
        svo.killaction(svo.dict.stun.waitingfor)
      end,
    },
    onremoved = function () svo.donext() end
  },
  unconsciousness = {
    waitingfor = {
      customwait = 7,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('unconsciousness')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('unconsciousness')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.unconsciousness)
        if not svo.actions.unconsciousness_waitingfor then svo.doaction(svo.dict.unconsciousness.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('unconsciousness')
        svo.killaction(svo.dict.unconsciousness.waitingfor)
      end,
    },
    onremoved = function () svo.donext() end
  },
  swellskin = { -- eating any herb cures it
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('swellskin')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.swellskin)
        if not svo.actions.swellskin_waitingfor then svo.doaction(svo.dict.swellskin.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('swellskin')
        svo.killaction(svo.dict.swellskin.waitingfor)
      end,
    }
  },
  pinshot = {
    waitingfor = {
      customwait = 20, -- lasts 18s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('pinshot')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('pinshot')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.pinshot)
        if not svo.actions.pinshot_waitingfor then svo.doaction(svo.dict.pinshot.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('pinshot')
        svo.killaction(svo.dict.pinshot.waitingfor)
      end,
    }
  },
  dehydrated = {
    waitingfor = {
      customwait = 45, -- lasts 45s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('dehydrated')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('dehydrated')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.dehydrated)
        if not svo.actions.dehydrated_waitingfor then svo.doaction(svo.dict.dehydrated.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('dehydrated')
        svo.killaction(svo.dict.dehydrated.waitingfor)
      end,
    }
  },
  timeflux = {
    waitingfor = {
      customwait = 50, -- lasts 50s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        svo.rmaff('timeflux')
        svo.make_gnomes_work()
      end,

      oncompleted = function ()
        svo.rmaff('timeflux')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.timeflux)
        if not svo.actions.timeflux_waitingfor then svo.doaction(svo.dict.timeflux.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('timeflux')
        svo.killaction(svo.dict.timeflux.waitingfor)
      end,
    }
  },
  inquisition = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('inquisition')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.inquisition)
        if not svo.actions.inquisition_waitingfor then svo.doaction(svo.dict.inquisition.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('inquisition')
        svo.killaction(svo.dict.inquisition.waitingfor)
      end,
    }
  },
  lullaby = {
    waitingfor = {
      customwait = 45, -- takes 45s

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('lullaby')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.lullaby)
        if not svo.actions.lullaby_waitingfor then svo.doaction(svo.dict.lullaby.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('lullaby')
        svo.killaction(svo.dict.lullaby.waitingfor)
      end,
    }
  },
  corrupted = {
    waitingfor = {
      customwait = 999, -- time increases

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('corrupted')
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.corrupted)
        if not svo.actions.corrupted_waitingfor then svo.doaction(svo.dict.corrupted.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('corrupted')
        svo.killaction(svo.dict.corrupted.waitingfor)
      end,
    }
  },
  mucous = {
    waitingfor = {
      customwait = 6,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('mucous')
      end,

      ontimeout = function()
        svo.rmaff('mucous')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.mucous)
        if not svo.actions.mucous_waitingfor then svo.doaction(svo.dict.mucous.waitingfor) end

        local r = svo.findbybal('smoke')
        if r then
          svo.killaction(svo.dict[r.action_name].smoke)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('mucous')
        svo.killaction(svo.dict.mucous.waitingfor)
      end,
    }
  },
  phlogistication = {
    waitingfor = {
      customwait = 999, -- time increases

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('phlogistication')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.phlogistication)
        if not svo.actions.phlogistication_waitingfor then svo.doaction(svo.dict.phlogistication.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('phlogistication')
        svo.killaction(svo.dict.phlogistication.waitingfor)
      end,
    }
  },
  vitrification = {
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('vitrification')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.vitrification)
        if not svo.actions.vitrification_waitingfor then svo.doaction(svo.dict.vitrification.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('vitrification')
        svo.killaction(svo.dict.vitrification.waitingfor)
      end,
    }
  },

  icing = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('icing')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.icing)
        if not svo.actions.icing_waitingfor then svo.doaction(svo.dict.icing.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('icing')
        svo.killaction(svo.dict.icing.waitingfor)
      end,
    }
  },
  burning = {
    waitingfor = {
      customwait = 30, -- ??

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('burning')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.burning)
        if not svo.actions.burning_waitingfor then svo.doaction(svo.dict.burning.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('burning')
        svo.killaction(svo.dict.burning.waitingfor)
      end,
    }
  },
  voided = {
    waitingfor = {
      customwait = 20, -- lasts 20s tops, 15s in some stances. out-times multiple pommelstrikes

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('voided')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.voided)
        codepaste.badaeon()
        if not svo.actions.voided_waitingfor then svo.doaction(svo.dict.voided.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('voided')
        svo.killaction(svo.dict.voided.waitingfor)
      end,
    }
  },
  hamstring = {
    waitingfor = {
      customwait = 10,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      ontimeout = function()
        if affs.hamstring then
          svo.rmaff('hamstring')
          svo.echof(&quot;Hamstring should have worn off by now, removing it.&quot;)
        end
      end,

      oncompleted = function ()
        svo.rmaff('hamstring')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hamstring)
        if not svo.actions.hamstring_waitingfor then svo.doaction(svo.dict.hamstring.waitingfor) end
      end,

      renew = function ()
        svo.addaffdict(svo.dict.hamstring)

        -- hamstrings timer gets renewed on hit
        if svo.actions.hamstring_waitingfor then
          svo.killaction(svo.dict.hamstring.waitingfor)
        end
        svo.doaction(svo.dict.hamstring.waitingfor)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hamstring')
        svo.killaction(svo.dict.hamstring.waitingfor)
      end,
    }
  },
  galed = {
    waitingfor = {
      customwait = 10,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('galed')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.galed)
        if not svo.actions.galed_waitingfor then svo.doaction(svo.dict.galed.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('galed')
        svo.killaction(svo.dict.galed.waitingfor)
      end,
    }
  },
  rixil = {
    -- will double the cooldown period of the next focus ability.
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('rixil')
        svo.killaction(svo.dict.rixil.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.rixil)
        if svo.actions.rixil_waitingfor then svo.killaction(svo.dict.rixil.waitingfor) end
        svo.doaction(svo.dict.rixil.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('rixil')
        svo.killaction(svo.dict.rixil.waitingfor)
      end,
    }
  },
  hecate = {
    waitingfor = {
      customwait = 22, -- seems to last at least 18s per log

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        svo.rmaff('hecate')
        svo.killaction(svo.dict.hecate.waitingfor)
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('hecate')
        svo.killaction(svo.dict.hecate.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hecate)
        if svo.actions.hecate_waitingfor then svo.killaction(svo.dict.hecate.waitingfor) end
        svo.doaction(svo.dict.hecate.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hecate')
        svo.killaction(svo.dict.hecate.waitingfor)
      end,
    }
  },
  palpatar = {
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('palpatar')
        svo.killaction(svo.dict.palpatar.waitingfor)
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.palpatar)
        if svo.actions.palpatar_waitingfor then svo.killaction(svo.dict.palpatar.waitingfor) end
        svo.doaction(svo.dict.palpatar.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('palpatar')
        svo.killaction(svo.dict.palpatar.waitingfor)
      end,
    }
  },
  -- extends tree balance by 10s now
  ninkharsag = {
    waitingfor = {
      customwait = 60, -- it lasts a minute

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        svo.rmaff('ninkharsag')
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('ninkharsag')
        svo.killaction(svo.dict.ninkharsag.waitingfor)
      end,

    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.ninkharsag)
        if svo.actions.ninkharsag_waitingfor then svo.killaction(svo.dict.ninkharsag.waitingfor) end
        svo.doaction(svo.dict.ninkharsag.waitingfor)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('ninkharsag')
        svo.killaction(svo.dict.ninkharsag.waitingfor)
      end,

      -- anti-illusion-checked aff hiding. in 'gone' because 'aff' resets the timer with checkaction, waitingfor has some other effect
      hiddencures = function (amount)
        local curableaffs = svo.gettreeableaffs()

        -- if we saw more ninkharsag lines than affs we've got, we can remove the affs safely
        if amount &gt;= #curableaffs then
          svo.rmaff(curableaffs)
        else
          -- otherwise add an unknown aff - so we eventually diagnose to see what is our actual aff status like.
          -- this does mess with the aff counts, but it is better than not diagnosing ever.
          codepaste.addunknownany()
        end
      end
    }
  },
  cadmus = {
    -- focusing will give one of: lethargy, clumsiness, haemophilia, healthleech, sensitivity, darkshade
    waitingfor = {
      customwait = 999,

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('cadmus')
        svo.killaction(svo.dict.cadmus.waitingfor)
      end
    },
    aff = {
      -- oldmaxhp is an argument
      oncompleted = function (_)
        svo.addaffdict(svo.dict.cadmus)
        if svo.actions.cadmus_waitingfor then svo.killaction(svo.dict.cadmus.waitingfor) end
        svo.doaction(svo.dict.cadmus.waitingfor)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('cadmus')
        svo.killaction(svo.dict.cadmus.waitingfor)
      end,
    }
  },
  spiritdisrupt = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.spiritdisrupt and not affs.madness and
          not svo.doingaction('spiritdisrupt')) or false
      end,

      oncompleted = function ()
        svo.rmaff('spiritdisrupt')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.spiritdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.spiritdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('spiritdisrupt')
        codepaste.remove_focusable()
      end,
    }
  },
  airdisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.airdisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        svo.rmaff('airdisrupt')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.airdisrupt and not svo.doingaction('airdisrupt')) or false
      end,

      oncompleted = function ()
        svo.rmaff('airdisrupt')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.airdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.airdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('airdisrupt')
        codepaste.remove_focusable()
      end,
    }
  },
  earthdisrupt = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.earthdisrupt and not svo.doingaction('earthdisrupt')) or false
      end,

      oncompleted = function ()
        svo.rmaff('earthdisrupt')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.earthdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.earthdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('earthdisrupt')
        codepaste.remove_focusable()
      end,
    }
  },
  waterdisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.waterdisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        svo.rmaff('waterdisrupt')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.waterdisrupt and not svo.doingaction('waterdisrupt')) or false
      end,

      oncompleted = function ()
        svo.rmaff('waterdisrupt')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.waterdisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.waterdisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('waterdisrupt')
        codepaste.remove_focusable()
      end,
    }
  },
  firedisrupt = {
    focus = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.firedisrupt and not affs.spiritdisrupt) or false
      end,

      oncompleted = function ()
        svo.rmaff('firedisrupt')
        svo.lostbal_focus()
      end,

      action = 'focus',
      onstart = function ()
        send('focus', conf.commandecho)
      end,

      empty = function ()
        svo.lostbal_focus()

        empty.focus()
      end
    },
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (affs.firedisrupt and not svo.doingaction('firedisrupt')) or false
      end,

      oncompleted = function ()
        svo.rmaff('firedisrupt')
        svo.lostbal_herb()
      end,

      eatcure = {'lobelia', 'argentum'},
      onstart = function ()
        svo.eat(svo.dict.firedisrupt.herb)
      end,

      empty = function()
        empty.eat_lobelia()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.firedisrupt)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('firedisrupt')
        codepaste.remove_focusable()
      end,
    }
  },
  stain = {
    waitingfor = {
      customwait = 60*2+20, -- lasts 2min, but varies, so let's go with 140s

      isadvisable = function ()
        return false
      end,

      ontimeout = function()
        svo.rmaff('stain')
        svo.echof(&quot;Taking a guess, I think stain expired by now.&quot;)
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('stain')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function (oldmaxhp)
        -- oldmaxhp doesn't come from diag, it is optional
        if (not conf.aillusion) or (oldmaxhp and (stats.maxhealth &lt; oldmaxhp)) then
          svo.addaffdict(svo.dict.stain)
          signals.after_lifevision_processing:unblock(cnrl.checkwarning)
          codepaste.badaeon()
          if svo.actions.stain_waitingfor then svo.killaction(svo.dict.stain.waitingfor) end
          svo.doaction(svo.dict.stain.waitingfor)
        end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('stain')
        svo.killaction(svo.dict.stain.waitingfor)
      end,
    }
  },
  depression = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return affs.depression or false
      end,

      oncompleted = function ()
        svo.rmaff('depression')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.depression.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.depression)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('depression')
      end,
    }
  },
  parasite = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return affs.parasite or false
      end,

      oncompleted = function ()
        svo.rmaff('parasite')
        svo.lostbal_herb()
      end,

      eatcure = {'kelp', 'aurum'},
      onstart = function ()
        svo.eat(svo.dict.parasite.herb)
      end,

      empty = function()
        empty.eat_kelp()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.parasite)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('parasite')
      end,
    }
  },
  retribution = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return affs.retribution or false
      end,

      oncompleted = function ()
        svo.rmaff('retribution')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.retribution.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.retribution)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('retribution')
      end,
    }
  },
  shadowmadness = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return affs.shadowmadness or false
      end,

      oncompleted = function ()
        svo.rmaff('shadowmadness')
        svo.lostbal_herb()
      end,

      eatcure = {'goldenseal', 'plumbum'},
      onstart = function ()
        svo.eat(svo.dict.shadowmadness.herb)
      end,

      empty = function()
        empty.eat_goldenseal()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.shadowmadness)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('shadowmadness')
      end,
    }
  },
  timeloop = {
    herb = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return affs.timeloop or false
      end,

      oncompleted = function ()
        svo.rmaff('timeloop')
        svo.lostbal_herb()
      end,

      eatcure = {'bellwort', 'cuprum'},
      onstart = function ()
        svo.eat(svo.dict.timeloop.herb)
      end,

      empty = function()
        empty.eat_bellwort()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.timeloop)
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('timeloop')
      end,
    }
  },
  degenerate = {
    waitingfor = {
      customwait = 0, -- seems to last 6 seconds per degenerate affliction when boosted, set below

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('degenerate')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        local timeout = 0
        for _, aff in ipairs(empty.degenerateaffs) do
          timeout = timeout + (affs[aff] and 7 or 0)
        end
        svo.dict.degenerate.waitingfor.customwait = timeout
        svo.addaffdict(svo.dict.degenerate)
        if not svo.actions.degenerate_waitingfor then svo.doaction(svo.dict.degenerate.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('degenerate')
        svo.killaction(svo.dict.degenerate.waitingfor)
      end,
    }
  },
  deteriorate = {
    waitingfor = {
      customwait = 0, -- seems to last 6 seconds per deteriorate affliction when boosted, set below

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('deteriorate')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        local timeout = 0
        for _, aff in ipairs(empty.deteriorateaffs) do
          timeout = timeout + (affs[aff] and 7 or 0)
        end
        svo.dict.deteriorate.waitingfor.customwait = timeout
        svo.addaffdict(svo.dict.deteriorate)
        if not svo.actions.deteriorate_waitingfor then svo.doaction(svo.dict.deteriorate.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('deteriorate')
        svo.killaction(svo.dict.deteriorate.waitingfor)
      end,
    }
  },
  hatred = {
    waitingfor = {
      customwait = 15,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('hatred')
        svo.make_gnomes_work()
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.hatred)
        if not svo.actions.hatred_waitingfor then svo.doaction(svo.dict.hatred.waitingfor) end
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('hatred')
        svo.killaction(svo.dict.hatred.waitingfor)
      end,
    }
  },
  paradox = {
    count = 0,
    blocked_herb = &quot;&quot;,
    boosted = {
      oncompleted = function ()
        svo.dict.paradox.aff.count = 10
        svo.updateaffcount(svo.dict.paradox)
      end
    },
    weakened = {
      oncompleted = function ()
        codepaste.remove_stackableaff('paradox', true)
      end
    },
    aff = {
      oncompleted = function (herb)
        svo.dict.paradox.count = 5
        svo.dict.paradox.blocked_herb = herb
        svo.addaffdict(svo.dict.paradox)
        svo.affl['paradox'].herb = herb
        svo.updateaffcount(svo.dict.paradox)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('paradox')
        svo.dict.paradox.count = 0
        svo.dict.paradox.blocked_herb = &quot;&quot;
      end,
    }
  },
  retardation = {
    waitingfor = {
      isadvisable = function ()
        return false
      end,

      onstart = function () end,

      oncompleted = function ()
        svo.rmaff('retardation')
      end
    },
    aff = {
      oncompleted = function ()
        if not affs.retardation then
          svo.addaffdict(svo.dict.retardation)
          sk.checkaeony()
          signals.aeony:emit()
          signals.newroom:unblock(sk.check_retardation)
        end
      end,
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('retardation')
      end,
    },
    onremoved = function ()
      svo.affsp.retardation = nil
      sk.checkaeony()
      signals.aeony:emit()
      signals.newroom:block(sk.check_retardation)
    end,
    onadded = function()
      signals.newroom:unblock(sk.check_retardation)
    end
  },
  nomana = {
    waitingfor = {
      customwait = 30,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,
      ontimeout = function ()
        echo&quot;\n&quot;svo.echof(&quot;Hm, maybe we have enough mana for mana skills now...&quot;)
        svo.killaction(svo.dict.nomana.waitingfor)
        svo.make_gnomes_work()
      end
    }
  },

  -- random actions that should be protected by AI
  givewarning = {
    happened = {
      oncompleted = function (tbl)
        if tbl and tbl.initialmsg then
          echo&quot;\n\n&quot;
          svo.echof(&quot;Careful: %s&quot;, tbl.initialmsg)
          echo&quot;\n&quot;
        end

        if tbl and tbl.prefixwarning then
          local duration = tbl.duration or 4
          local startin = tbl.startin or 0
          cnrl.warning = tbl.prefixwarning or &quot;&quot;

          -- timer for starting
          if not conf.warningtype then return end

          tempTimer(startin, function ()

            if cnrl.warnids[tbl.prefixwarning] then killTrigger(cnrl.warnids[tbl.prefixwarning]) end

              cnrl.warnids[tbl.prefixwarning] = tempRegexTrigger('^', [[
                if ((svo.conf.warningtype == 'prompt' and isPrompt()) or svo.conf.warningtype == 'all' or svo.conf.warningtype == 'right') and getCurrentLine() ~= &quot;&quot; and not svo.gagline then
                  svo.prefixwarning()
                end
              ]])
            end)

          -- timer for ending
          tempTimer(startin+duration, function () killTrigger(cnrl.warnids[tbl.prefixwarning]) end)
        end
      end
    }
  },
  stolebalance = {
    happened = {
      oncompleted = function (balance)
        svo['lostbal_'..balance]()
      end
    }
  },
  gotbalance = {
    happened = {
      tempmap = {},
      oncompleted = function ()
        for _, balance in ipairs(svo.dict.gotbalance.happened.tempmap) do
          if not bals[balance] then
            bals[balance] = true

            raiseEvent(&quot;svo got balance&quot;, balance)

            svo.endbalancewatch(balance)

            -- this concern should be separated into its own
            if balance == 'tree' then
              killTimer(sys.treetimer)
            end
          end
        end
        svo.dict.gotbalance.happened.tempmap = {}
      end,

      oncancel = function ()
        svo.dict.gotbalance.happened.tempmap = {}
      end
    }
  },
  gothit = {
    happened = {
      tempmap = {},
      oncompleted = function ()
        for name, class in pairs(svo.dict.gothit.happened.tempmap) do
          if name == '?' then
            raiseEvent(&quot;svo got hit by&quot;, class)
          else
            raiseEvent(&quot;svo got hit by&quot;, class, name)
          end
        end
        svo.dict.gothit.happened.tempmap = {}
      end,

      oncancel = function ()
        svo.dict.gothit.happened.tempmap = {}
      end
    }
  },

-- general defences
  rebounding = {
    blocked = false, -- we need to block off in blackout, because otherwise we waste sips
    smoke = {
      aspriority = 137,
      spriority = 261,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].rebounding and not defc.rebounding) or (conf.keepup and defkeepup[defs.mode].rebounding and not defc.rebounding)) and codepaste.smoke_skullcap_pipe() and not svo.doingaction('waitingonrebounding') and not svo.dict.rebounding.blocked) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingonrebounding.waitingfor)
        sk.skullcap_smokepuff()
        svo.lostbal_smoke()
      end,

      alreadygot = function ()
        defences.got('rebounding')
        sk.skullcap_smokepuff()
        svo.lostbal_smoke()
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        svo.dict.rebounding.blocked = true
        tempTimer(3, function () svo.dict.rebounding.blocked = false; svo.make_gnomes_work() end)
      end,

      smokecure = {'skullcap', 'malachite'},
      onstart = function ()
        send(&quot;smoke &quot; .. pipes.skullcap.id, conf.commandecho)
      end,

      empty = function ()
        svo.dict.rebounding.smoke.oncompleted()
      end
    }
  },
  waitingonrebounding = {
    spriority = 0,
    waitingfor = {
      customwait = 9,

      onstart = function () raiseEvent(&quot;svo rebounding start&quot;) end,

      oncompleted = function ()
        defences.got('rebounding')
      end,

      deathtarot = function () -- nothing happens! It just doesn't come up :/
      end,

      -- expend torso cancels rebounding coming up
      expend = function()
        if svo.actions.waitingonrebounding_waitingfor then
          svo.killaction(svo.dict.waitingonrebounding.waitingfor)
        end
      end,
    }
  },
  frost = {
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].frost and not defc.frost) or (conf.keepup and defkeepup[defs.mode].frost and not defc.frost)) or false
      end,

      oncompleted = function ()
        defences.got('frost')
        if svo.haveskillset('metamorphosis') then
          defences.got('temperance')
        end
      end,

      sipcure = {'frost', 'endothermia'},

      onstart = function ()
        svo.sip(svo.dict.frost.purgative)
      end,

      empty = function ()
        defences.got('frost')
      end,

      noeffect = function()
        defences.got('frost')
      end
    },
    gone = {
      oncompleted = function ()
        if svo.haveskillset('metamorphosis') then
          defences.lost('temperance')
        end
      end
    }
  },
  venom = {
    gamename = 'poisonresist',
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].venom and not defc.venom) or (conf.keepup and defkeepup[defs.mode].venom and not defc.venom)) or false
      end,

      oncompleted = function ()
        defences.got('venom')
      end,

      noeffect = function()
        defences.got('venom')
      end,

      sipcure = {'venom', 'toxin'},

      onstart = function ()
        svo.sip(svo.dict.venom.purgative)
      end,

      empty = function ()
        defences.got('venom')
      end
    }
  },
  levitation = {
    gamename = 'levitating',
    purgative = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].levitation and not defc.levitation) or (conf.keepup and defkeepup[defs.mode].levitation and not defc.levitation)) or false
      end,

      oncompleted = function ()
        defences.got('levitation')
      end,

      noeffect = function()
        defences.got('levitation')
      end,

      sipcure = {'levitation', 'hovering'},

      onstart = function ()
        svo.sip(svo.dict.levitation.purgative)
      end,

      empty = function ()
        defences.got('levitation')
      end
    }
  },
  speed = {
    blocked = false, -- we need to block off in blackout, because otherwise we waste sips
    purgative = {
      aspriority = 8,
      spriority = 265,
      def = true,

      isadvisable = function ()
        return (not defc.speed and ((sys.deffing and defdefup[defs.mode].speed) or (conf.keepup and defkeepup[defs.mode].speed)) and not svo.doingaction('curingspeed') and not svo.doingaction('speed') and not svo.dict.speed.blocked and not me.manualdefcheck) or false
      end,

      oncompleted = function (def)
        if def then defences.got('speed')
        else
          if affs.palpatar then
            svo.dict.curingspeed.waitingfor.customwait = 10
          else
            svo.dict.curingspeed.waitingfor.customwait = 7
          end

          svo.doaction(svo.dict.curingspeed.waitingfor)
        end
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        svo.dict.speed.blocked = true
        tempTimer(3, function () svo.dict.speed.blocked = false; svo.make_gnomes_work() end)
      end,

      noeffect = function()
        defences.got('speed')
      end,

      sipcure = {'speed', 'haste'},

      onstart = function ()
        svo.sip(svo.dict.speed.purgative)
      end,

      empty = function ()
        svo.dict.speed.purgative.oncompleted ()
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('speed')
      end
    }
  },
  curingspeed = {
    spriority = 0,
    waitingfor = {
      customwait = 7,

      oncompleted = function ()
        defences.got('speed')
      end,

      ontimeout = function ()
        if defc.speed then return end

        if (sys.deffing and defdefup[defs.mode].speed) or (conf.keepup and defkeepup[defs.mode].speed) then
          svo.echof(&quot;Warning - speed didn't come up in 7s, checking 'def'.&quot;)
          me.manualdefcheck = true
        end
      end,

      onstart = function () end
    }
  },
  sileris = {
    gamename = 'fangbarrier',
    applying = &quot;&quot;,
    misc = {
      aspriority = 8,
      spriority = 265,
      def = true,

      isadvisable = function ()
        return (not defc.sileris and ((sys.deffing and defdefup[defs.mode].sileris) or (conf.keepup and defkeepup[defs.mode].sileris)) and not svo.doingaction('waitingforsileris') and not svo.doingaction('sileris') and not affs.paralysis and not affs.slickness and not me.manualdefcheck) or false
      end,

      oncompleted = function (def)
        if def and not defc.sileris then defences.got('sileris')
        else svo.doaction(svo.dict.waitingforsileris.waitingfor) end
      end,

      slick = function()
        svo.addaffdict(svo.dict.slickness)
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        svo.dict.sileris.blocked = true
        tempTimer(3, function () svo.dict.sileris.blocked = false; svo.make_gnomes_work() end)
      end,

      -- special case for 'missing herb' trig
      eatcure = {'sileris', 'quicksilver'},
      applycure = {'sileris', 'quicksilver'},
      actions = {&quot;apply sileris&quot;, &quot;apply quicksilver&quot;},
      onstart = function ()
        local use = 'sileris'

        if conf.curemethod and conf.curemethod ~= 'conconly' and (

          conf.curemethod == 'transonly' or

          (conf.curemethod == 'preferconc' and
            -- we don't have in inventory, but do have alchemy in inventory, use alchemy
             (not (rift.invcontents.sileris &gt; 0) and (rift.invcontents.quicksilver &gt; 0)) or
              -- or if we don't have the conc cure in rift either, use alchemy
             (not (rift.riftcontents.sileris &gt; 0))) or

          (conf.curemethod == 'prefertrans' and
            (rift.invcontents.quicksilver &gt; 0
              or (not (rift.invcontents.sileris &gt; 0) and (rift.riftcontents.quicksilver &gt; 0)))) or

          -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
          (conf.curemethod == 'prefercustom' and (
            (me.curelist[use] == use and rift.riftcontents[use] &lt;= 0)
              or
            (me.curelist[use] == 'quicksilver' and rift.riftcontents['quicksilver'] &gt; 0)
          ))

          ) then
            use = 'quicksilver'
        end

        sys.last_used['sileris_misc'] = use

        svo.dict.sileris.applying = use
        if rift.invcontents[use] &gt; 0 then
          send(&quot;outr &quot;..use, conf.commandecho)
          send(&quot;apply &quot;..use, conf.commandecho)
        else
          send(&quot;outr &quot;..use, conf.commandecho)
          send(&quot;apply &quot;..use, conf.commandecho)
        end
      end,

      empty = function ()
        svo.dict.sileris.misc.oncompleted()
      end
    },
    gone = {
      oncompleted = function (line_spotted_on)
        if not conf.aillusion or not line_spotted_on or (line_spotted_on+1 == getLastLineNumber('main')) then
          defences.lost('sileris')
        end
      end,

      camusbite = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth &lt; oldhp) then
          defences.lost('sileris')
        end
      end,

      sumacbite = function (oldhp)
        if not conf.aillusion or (not affs.recklessness and stats.currenthealth &lt; oldhp) then
          defences.lost('sileris')
        end
      end,
    }
  },
  waitingforsileris = {
    spriority = 0,
    waitingfor = {
      customwait = 8,

      oncompleted = function ()
        defences.got('sileris')
      end,

      ontimeout = function ()
        if defc.sileris then return end

        if (sys.deffing and defdefup[defs.mode].sileris) or (conf.keepup and defkeepup[defs.mode].sileris) then
          svo.echof(&quot;Warning - sileris isn't back yet, we might've been tricked. Going to see if we get bitten.&quot;)
          local oldsileris = defc.sileris
          defc.sileris = 'unsure'
          if oldsileris ~= defc.sileris then raiseEvent(&quot;svo got def&quot;, 'sileris') end
        end
      end,

      onstart = function () end
    }
  },
  deathsight = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.deathsight and (not conf.deathsight or not svo.can_usemana()) and ((sys.deffing and defdefup[defs.mode].deathsight) or (conf.keepup and defkeepup[defs.mode].deathsight)) and not svo.doingaction('deathsight')) or false
      end,

      oncompleted = function ()
        defences.got('deathsight')
      end,

      eatcure = {'skullcap', 'azurite'},
      onstart = function ()
        svo.eat(svo.dict.deathsight.herb)
      end,

      empty = function()
        defences.got('deathsight')
      end
    },
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return (not defc.deathsight and conf.deathsight and svo.can_usemana() and not svo.doingaction('deathsight') and ((sys.deffing and defdefup[defs.mode].deathsight) or (conf.keepup and defkeepup[defs.mode].deathsight)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('deathsight')
      end,

      action = 'deathsight',
      onstart = function ()
        send('deathsight', conf.commandecho)
      end
    },
  },
  thirdeye = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].thirdeye and not defc.thirdeye) or (conf.keepup and defkeepup[defs.mode].thirdeye and not defc.thirdeye)) and not svo.doingaction('thirdeye') and not (conf.thirdeye and svo.can_usemana())) or false
      end,

      oncompleted = function ()
        defences.got('thirdeye')
      end,

      eatcure = {'echinacea', 'dolomite'},
      onstart = function ()
        svo.eat(svo.dict.thirdeye.herb)
      end,

      empty = function()
        defences.got('thirdeye')
      end
    },
    misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.thirdeye and svo.can_usemana() and not svo.doingaction('thirdeye') and ((sys.deffing and defdefup[defs.mode].thirdeye and not defc.thirdeye) or (conf.keepup and defkeepup[defs.mode].thirdeye and not defc.thirdeye))) or false
      end,

      -- by default, oncompleted means a clot went through okay
      oncompleted = function ()
        defences.got('thirdeye')
      end,

      action = 'thirdeye',
      onstart = function ()
        send('thirdeye', conf.commandecho)
      end
    },
  },
  insomnia = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].insomnia and not defc.insomnia) or (conf.keepup and defkeepup[defs.mode].insomnia and not defc.insomnia)) and not svo.doingaction('insomnia') and not (conf.insomnia and svo.can_usemana()) and not affs.hypersomnia) or false
      end,

      oncompleted = function ()
        defences.got('insomnia')
      end,

      eatcure = {'cohosh', 'gypsum'},
      onstart = function ()
        svo.eat(svo.dict.insomnia.herb)
      end,

      empty = function()
        defences.got('insomnia')
      end,

      hypersomnia = function ()
        svo.addaffdict(svo.dict.hypersomnia)
      end
    },
    misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.insomnia and svo.can_usemana() and not svo.doingaction('insomnia') and ((sys.deffing and defdefup[defs.mode].insomnia and not defc.insomnia) or (conf.keepup and defkeepup[defs.mode].insomnia and not defc.insomnia)) and not affs.hypersomnia) or false
      end,

      oncompleted = function ()
        defences.got('insomnia')
      end,

      hypersomnia = function ()
        svo.addaffdict(svo.dict.hypersomnia)
      end,

      action = 'insomnia',
      onstart = function ()
        send('insomnia', conf.commandecho)
      end
    },
    -- small cheat for insomnia being on diagnose
    aff = {
      oncompleted = function ()
        defences.got('insomnia')
      end
    },
    gone = {
      oncompleted = function(aff)
        defences.lost('insomnia')

        if aff and aff == 'unknownany' then
          svo.dict.unknownany.count = svo.dict.unknownany.count - 1
          if svo.dict.unknownany.count &lt;= 0 then
            svo.rmaff('unknownany')
            svo.dict.unknownany.count = 0
          else
            svo.updateaffcount(svo.dict.unknownany)
          end
        elseif aff and aff == 'unknownmental' then
          svo.dict.unknownmental.count = svo.dict.unknownmental.count - 1
          if svo.dict.unknownmental.count &lt;= 0 then
            svo.rmaff('unknownmental')
            svo.dict.unknownmental.count = 0
          else
            svo.updateaffcount(svo.dict.unknownmental)
          end
        end
      end,

      relaxed = function (line_spotted_on)
        if not conf.aillusion or not line_spotted_on or (line_spotted_on+1 == getLastLineNumber('main')) then
          defences.lost('insomnia')
        end
      end,
    }
  },
  myrrh = {
    gamename = 'scholasticism',
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].myrrh and not defc.myrrh) or (conf.keepup and defkeepup[defs.mode].myrrh and not defc.myrrh))) or false
      end,

      oncompleted = function ()
        defences.got('myrrh')
      end,

      noeffect = function ()
        svo.dict.myrrh.herb.oncompleted ()
      end,

      eatcure = {'myrrh', 'bisemutum'},
      onstart = function ()
        svo.eat(svo.dict.myrrh.herb)
      end,

      empty = function()
        defences.got('myrrh')
      end
    },
  },
  kola = {
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].kola and not defc.kola) or (conf.keepup and defkeepup[defs.mode].kola and not defc.kola))) or false
      end,

      oncompleted = function ()
        defences.got('kola')
      end,

      noeffect = function ()
        svo.dict.kola.herb.oncompleted ()
      end,

      eatcure = {'kola', 'quartz'},
      onstart = function ()
        svo.eat(svo.dict.kola.herb)
      end,

      empty = function()
        defences.got('kola')
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not svo.pflags.k then
          defences.lost('kola')
        end
      end
    }
  },
  mass = {
    gamename = 'density',
    salve = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].mass and not defc.mass) or (conf.keepup and defkeepup[defs.mode].mass and not defc.mass))) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        defences.got('mass')
      end,

      -- sometimes a salve cure can get misgiagnosed on a death (from a previous apply)
      noeffect = function() end,
      empty = function() end,

      applycure = {'mass', 'density'},
      actions = {&quot;apply mass to body&quot;, &quot;apply mass&quot;, &quot;apply density to body&quot;, &quot;apply density&quot;},
      onstart = function ()
        svo.apply(svo.dict.mass.salve, &quot; to body&quot;)
      end,
    },
  },
  caloric = {
    salve = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].caloric and not defc.caloric) or (conf.keepup and defkeepup[defs.mode].caloric and not defc.caloric))) or false
      end,

      oncompleted = function ()
        svo.lostbal_salve()
        defences.got('caloric')
      end,

      noeffect = function ()
        svo.lostbal_salve()
      end,

      -- called from shivering or frozen cure
      gotcaloricdef = function (hypothermia)
        if not hypothermia then svo.rmaff({'frozen', 'shivering'}) end
        svo.dict.caloric.salve.oncompleted ()
      end,

      applycure = {'caloric', 'exothermic'},
      actions = {&quot;apply caloric to body&quot;, &quot;apply caloric&quot;, &quot;apply exothermic to body&quot;, &quot;apply exothermic&quot;},
      onstart = function ()
        svo.apply(svo.dict.caloric.salve, &quot; to body&quot;)
      end,
    },
    gone = {
      oncompleted = function(aff)
        defences.lost('caloric')

        if aff and aff == 'unknownany' then
          svo.dict.unknownany.count = svo.dict.unknownany.count - 1
          if svo.dict.unknownany.count &lt;= 0 then
            svo.rmaff('unknownany')
            svo.dict.unknownany.count = 0
          end
        elseif aff and aff == 'unknownmental' then
          svo.dict.unknownmental.count = svo.dict.unknownmental.count - 1
          if svo.dict.unknownmental.count &lt;= 0 then
            svo.rmaff('unknownmental')
            svo.dict.unknownmental.count = 0
          end
        end
      end
    }
  },
  blind = {
    gamename = 'blindness',
    onservereignore = function()
      -- no blind skill: ignore serverside if it's not to be deffed up atm
      -- with blind skill: ignore serverside can use skill, or if it's not to be deffed up atm
      return
        (not svo.haveskillset('shindo') or (conf.shindoblind and not defc.dragonform)) or
        (not svo.haveskillset('kaido') or (conf.kaidoblind and not defc.dragonform)) or
        not ((sys.deffing and defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind))
    end,
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not affs.scalded and
          (not svo.haveskillset('shindo') or (defc.dragonform or (not conf.shindoblind))) and
          (not svo.haveskillset('kaido') or (defc.dragonform or (not conf.kaidoblind))) and
          ((sys.deffing and defdefup[defs.mode].blind and not defc.blind) or (conf.keepup and defkeepup[defs.mode].blind and not defc.blind)) and
          not svo.doingaction'waitingonblind') or false
      end,

      oncompleted = function ()
        defences.got('blind')
        svo.lostbal_herb()
      end,

      noeffect = function ()
        svo.dict.blind.herb.oncompleted()
      end,

      eatcure = {'bayberry', 'arsenic'},
      onstart = function ()
        svo.eat(svo.dict.blind.herb)
      end,

      empty = function()
        defences.got('blind')
        svo.lostbal_herb()
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not svo.pflags.b then
          defences.lost('blind')
        end
      end
    }
  },
  waitingonblind = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        defences.got('blind')
      end,

      onstart = function ()
      end
    }
  },
  deaf = {
    gamename = 'deafness',
    onservereignore = function()
      -- no deaf skill: ignore serverside if it's not to be deffed up atm
      -- with deaf skill: ignore serverside can use skill, or if it's not to be deffed up atm
      return (not svo.haveskillset('shindo') or (conf.shindodeaf and not defc.dragonform)) or
        (not svo.haveskillset('kaido') or (conf.kaidodeaf and not defc.dragonform)) or
        not ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf))
    end,
    herb = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.deaf and
          (not svo.haveskillset('shindo') or (defc.dragonform or not conf.shindodeaf)) and
          (not svo.haveskillset('kaido') or (defc.dragonform or not conf.kaidodeaf)) and
         ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf)) and not svo.doingaction('waitingondeaf')) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingondeaf.waitingfor)
        svo.lostbal_herb()
      end,

      eatcure = {'hawthorn', 'calamine'},
      onstart = function ()
        svo.eat(svo.dict.deaf.herb)
      end,

      empty = function()
        svo.dict.deaf.herb.oncompleted()
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not svo.pflags.d then
          defences.lost('deaf')
        end
      end
    }
  },
  waitingondeaf = {
    spriority = 0,
    waitingfor = {
      customwait = 6,

      oncompleted = function ()
        defences.got('deaf')
      end,

      onstart = function ()
      end
    }
  },


-- balance-related defences
  lyre = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.lyre and ((sys.deffing and defdefup[defs.mode].lyre) or (conf.keepup and defkeepup[defs.mode].lyre)) and not svo.will_take_balance() and not conf.lyre_step and not svo.doingaction('lyre') and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('lyre')

        if conf.lyre and not conf.paused then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,

      ontimeout = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum didn't happen - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.make_gnomes_work()
        end
      end,

      onkill = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum cancelled - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      end,

      action = &quot;strum lyre&quot;,
      onstart = function ()
        sys.sendonceonly = true
        -- small fix to make 'lyc' work and be in-order (as well as use batching)
        local send = send
        -- record in systemscommands, so it doesn't get killed later on in the controller and loop
        if conf.batch then send = function(what, ...) svo.sendc(what, ...) sk.systemscommands[what] = true end end

        if not conf.lyrecmd then
          send(&quot;strum lyre&quot;, conf.commandecho)
        else
          send(tostring(conf.lyrecmd), conf.commandecho)
        end
        sys.sendonceonly = false

        if conf.lyre and not conf.paused then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('lyre')

        -- as a special case for handling the following scenario:
        --[[(focus)
          Your prismatic barrier dissolves into nothing.
          You focus your mind intently on curing your mental maladies.
          Food is no longer repulsive to you. (7.548s)
          H: 3294 (50%), M: 4911 (89%) 28725e, 10294w 89.3% ex|cdk- 19:24:04.719(sip health|eat bayberry|outr bayberry|eat
          irid|outr irid)(+324h, 5.0%, -291m, 5.3%)
          You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.
          (p) H: 3294 (50%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:04.897
          Your prismatic barrier dissolves into nothing.
          You take a drink from a purple heartwood vial.
          The elixir heals and soothes you.
          H: 4767 (73%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:05.247(+1473h, 22.7%)
          You eat some bayberry bark.
          Your eyes dim as you lose your sight.
        ]]
        -- we want to kill lyre going up when it goes down and you're off balance, because you won't get it up off-bal

        -- but don't kill it if it is in lifevision - meaning we're going to get it:
        --[[
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
          (x) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}
          You have recovered equilibrium. (3.887s)
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
        ]]

        if not (bals.balance and bals.equilibrium) and svo.actions.lyre_physical and not svo.lifevision.l.lyre_physical then svo.killaction(svo.dict.lyre.physical) end

        -- unpause should we lose the lyre def for some reason - but not while we're doing lyc
        -- since we'll lose the lyre def and it'll come up right away
        if conf.lyre and conf.paused and not svo.actions.lyre_physical then conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,
    }
  },
  breath = {
    gamename = 'heldbreath',
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceless_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].breath and not defc.breath) or (conf.keepup and defkeepup[defs.mode].breath and not defc.breath)) and not svo.doingaction('breath') and not codepaste.balanceful_defs_codepaste() and not affs.aeon and not affs.asthma) or false
      end,

      oncompleted = function ()
        defences.got('breath')
      end,

      action = &quot;hold breath&quot;,
      onstart = function ()
        if conf.gagbreath and not sys.sync then
          send(&quot;hold breath&quot;, false)
        else
          send(&quot;hold breath&quot;, conf.commandecho) end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('breath')
      end,
    }
  },
  dragonform = {
    physical = {
      aspriority = 0,
      spriority = 0,
      unpauselater = false,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonform and not defc.dragonform) or (conf.keepup and defkeepup[defs.mode].dragonform and not defc.dragonform)) and not svo.doingaction('waitingfordragonform') and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingfordragonform.waitingfor)
      end,

      alreadyhave = function ()
        svo.dict.waitingfordragonform.waitingfor.oncompleted()
      end,

      actions = {'dragonform', &quot;dragonform red&quot;, &quot;dragonform black&quot;, &quot;dragonform silver&quot;, &quot;dragonform gold&quot;, &quot;dragonform blue&quot;, &quot;dragonform green&quot;},
      onstart = function ()
      -- user commands catching needs this check
        if not (bals.balance and bals.equilibrium) then return end

        if defc.flame and svo.haveskillset('metamorphosis') then
          send(&quot;relax flame&quot;, conf.commandecho)
        end
        send('dragonform', conf.commandecho)

        if not conf.paused then
          svo.dict.dragonform.physical.unpauselater = true
          conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Temporarily pausing for dragonform.&quot;)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('dragonform')
        svo.dict.dragonbreath.gone.oncompleted()
        svo.dict.dragonarmour.gone.oncompleted()
        signals.dragonform:emit()
      end,
    }
  },
  waitingfordragonform = {
    spriority = 0,
    waitingfor = {
      customwait = 20,

      oncompleted = function ()
        defences.got('dragonform')
        svo.dict.riding.gone.oncompleted()

        -- strip class defences that don't stay through dragon
        for def, deft in svo.defs_data:iter() do
          local skillset = deft.type
          if skillset ~= 'general' and skillset ~= 'enchantment' and skillset ~= 'dragoncraft' and not deft.staysindragon and defc[def] then
            defences.lost(def)
          end
        end

        -- lifevision, via artefact, has to be removed as well
        if defc.lifevision and not svo.haveskillset('necromancy') then
          defences.lost('lifevision')
        end

        signals.dragonform:emit()

        if conf.paused and svo.dict.dragonform.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')

          echo&quot;\n&quot;
          if math.random(1, 20) == 1 then
            svo.echof(&quot;ROOOAR!&quot;)
          else
            svo.echof(&quot;Obtained dragonform, unpausing.&quot;)
          end
        end
        svo.dict.dragonform.physical.unpauselater = false
      end,

      cancelled = function ()
        signals.dragonform:emit()
        if conf.paused and svo.dict.dragonform.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Unpausing.&quot;)
        end
        svo.dict.dragonform.physical.unpauselater = false
      end,

      ontimeout = function()
        svo.dict.waitingfordragonform.waitingfor.cancelled()
      end,

      onstart = function() end
    }
  },
  dragonbreath = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceless_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonbreath and not defc.dragonbreath) or (conf.keepup and defkeepup[defs.mode].dragonbreath and not defc.dragonbreath)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction('dragonbreath') and not svo.doingaction('waitingfordragonbreath') and defc.dragonform and not svo.dict.dragonbreath.blocked and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function (def)
        if def then defences.got('dragonbreath')
        else svo.doaction(svo.dict.waitingfordragonbreath.waitingfor) end
      end,

      ontimeout = function ()
        if not affs.blackout then return end

        svo.dict.dragonbreath.blocked = true
        tempTimer(3, function () svo.dict.dragonbreath.blocked = false; svo.make_gnomes_work() end)
      end,

      alreadygot = function ()
        defences.got('dragonbreath')
      end,

      onstart = function ()
        send(&quot;summon &quot;..(conf.dragonbreath and conf.dragonbreath or 'unknown'), conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        defences.lost('dragonbreath')
      end
    }
  },
  waitingfordragonbreath = {
    spriority = 0,
    waitingfor = {
      customwait = 2,

      onstart = function() end,

      oncompleted = function ()
        defences.got('dragonbreath')
      end
    }
  },
  dragonarmour = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dragonarmour and not defc.dragonarmour) or (conf.keepup and defkeepup[defs.mode].dragonarmour and not defc.dragonarmour)) and not codepaste.balanceful_defs_codepaste() and defc.dragonform) or false
      end,

      oncompleted = function ()
        defences.got('dragonarmour')
      end,

      action = &quot;dragonarmour on&quot;,
      onstart = function ()
        send(&quot;dragonarmour on&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        defences.lost('dragonarmour')
      end
    }
  },
  selfishness = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (
          ((sys.deffing and defdefup[defs.mode].selfishness and not defc.selfishness)
            or (not sys.deffing and conf.keepup and ((defkeepup[defs.mode].selfishness and not defc.selfishness) or (not defkeepup[defs.mode].selfishness and defc.selfishness))))
          and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('selfishness')
      end,

      onstart = function ()
        if (sys.deffing and defdefup[defs.mode].selfishness and not defc.selfishness) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].selfishness and not defc.selfishness) then
          send('selfishness', conf.commandecho)
        else
          send('generosity', conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('selfishness')

        -- if we've done sl off, _gone gets added, so _physical gets readded by action clear - kill physical here for that not to happen
        if svo.actions.selfishness_physical then
          svo.killaction(svo.dict.selfishness.physical)
        end
      end,
    }
  },
  riding = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (
          ((sys.deffing and defdefup[defs.mode].riding and not defc.riding)
            or (not sys.deffing and conf.keepup and ((defkeepup[defs.mode].riding and not defc.riding) or (not defkeepup[defs.mode].riding and defc.riding))))
          and not codepaste.balanceful_defs_codepaste() and not defc.dragonform and not affs.hamstring and (not affs.prone or svo.doingaction'prone') and not affs.crippledleftarm and not affs.crippledrightarm and not affs.mangledleftarm and not affs.mangledrightarm and not affs.mutilatedleftarm and not affs.mutilatedrightarm and not affs.unknowncrippledleg and not affs.parestolegs and not svo.doingaction'riding' and not affs.pinshot and not affs.paralysis) or false
      end,

      oncompleted = function ()
        if (not sys.deffing and conf.keepup and not defkeepup[defs.mode].riding and (defc.riding == true or defc.riding == nil)) then
          svo.dict.riding.gone.oncompleted()
        else
          defences.got('riding')
        end

        if bals.balance and not conf.freevault then
          svo.config.set('freevault', 'yep', true)
        elseif not bals.balance and conf.freevault then
          svo.config.set('freevault', 'nope', true)
        end
      end,

      alreadyon = function ()
        defences.got('riding')
      end,

      dragonform = function ()
        defences.got('dragonform')
        signals.dragonform:emit()
      end,

      hastring = function ()
        svo.dict.hamstring.aff.oncompleted()
      end,

      dismount = function ()
        defences.lost('riding')
        svo.dict.block.gone.oncompleted()
      end,

      onstart = function ()
        if (sys.deffing and defdefup[defs.mode].riding and not defc.riding) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].riding and not defc.riding) then
          send(string.format(&quot;%s %s&quot;, tostring(conf.ridingskill), tostring(conf.ridingsteed)), conf.commandecho)
        else
          send('dismount', conf.commandecho)
          if sys.sync or tostring(conf.ridingsteed) == 'giraffe' then return end
          if conf.steedfollow then send(string.format(&quot;order %s follow me&quot;, tostring(conf.ridingsteed), conf.commandecho)) end
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('riding')
        svo.dict.block.gone.oncompleted()
      end,
    }
  },
  meditate = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].meditate and not defc.meditate) or (conf.keepup and defkeepup[defs.mode].meditate and not defc.meditate)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'meditate' and (stats.currentwillpower &lt; stats.maxwillpower or stats.currentmana &lt; stats.maxmana)) or false
      end,

      oncompleted = function ()
        defences.got('meditate')
      end,

      actions = {'med', 'meditate'},
      onstart = function ()
        send('meditate', conf.commandecho)
      end
    }
  },

  mindseye = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.mindseye and ((sys.deffing and defdefup[defs.mode].mindseye) or (conf.keepup and defkeepup[defs.mode].mindseye)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('mindseye')

        -- check if we need to re-classify deaf
        if (defc.deaf or affs.deafaff) and (defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye then
          defences.got('deaf')
          svo.rmaff('deafaff')
        elseif (defc.deaf or affs.deafaff) then
          defences.lost('deaf')
          svo.addaffdict(svo.dict.deafaff)
        end

        -- check if we need to re-classify blind
        if (defc.blind or affs.blindaff) and (defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind) and (svo.me.class == 'Apostate' or defc.mindseye) then
          defences.got('blind')
          svo.rmaff('blindaff')
        elseif (defc.blind or affs.blindaff) then
          defences.lost('blind')
          svo.addaffdict(svo.dict.blindaff)
        end
      end,

      action = &quot;touch mindseye&quot;,
      onstart = function ()
        send(&quot;touch mindseye&quot;, conf.commandecho)
      end
    }
  },
  metawake = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.metawake and ((sys.deffing and defdefup[defs.mode].metawake) or (conf.keepup and defkeepup[defs.mode].metawake)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not svo.doingaction'metawake' and not affs.lullaby) or false
      end,

      oncompleted = function ()
        defences.got('metawake')
      end,

      action = &quot;metawake on&quot;,
      onstart = function ()
        send(&quot;metawake on&quot;, conf.commandecho)
      end
    }
  },
  cloak = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.cloak and ((sys.deffing and defdefup[defs.mode].cloak) or (conf.keepup and defkeepup[defs.mode].cloak)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('cloak')
      end,

      action = &quot;touch cloak&quot;,
      onstart = function ()
        send(&quot;touch cloak&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function()
        if not conf.aillusion or not svo.pflags.c then
          defences.lost('cloak')
        end
      end
    }
  },

  nightsight = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.nightsight and
          ((sys.deffing and defdefup[defs.mode].nightsight) or (conf.keepup and defkeepup[defs.mode].nightsight)) and
          not codepaste.balanceful_defs_codepaste() and
          sys.canoutr and
          not affs.prone and
          not svo.doingaction'nightsight'
          and (not svo.haveskillset('metamorphosis') or ((not affs.cantmorph and sk.morphsforskill.nightsight) or defc.dragonform))) or false
      end,

      oncompleted = function ()
        defences.got('nightsight')
      end,

      action = &quot;nightsight on&quot;,
      onstart = function ()
if not svo.haveskillset('metamorphosis') then
        send(&quot;nightsight on&quot;, conf.commandecho)
else
        if not defc.dragonform and (not conf.transmorph and sk.inamorph() and not sk.inamorphfor'nightsight') then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not defc.dragonform and not sk.inamorphfor'nightsight' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.nightsight[1], conf.commandecho)
        elseif defc.dragonform or sk.inamorphfor'nightsight' then
          send(&quot;nightsight on&quot;, conf.commandecho)
        end
end
      end
    },
  },
  shield = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].shield and not defc.shield) or (conf.keepup and defkeepup[defs.mode].shield and not defc.shield)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not (affs.mangledleftarm and affs.mangledlrightarm) and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('shield')
        if defkeepup[defs.mode].shield and conf.oldts then
          defs.keepup('shield', false)
        end
      end,

      actions = {&quot;touch shield&quot;, &quot;angel aura&quot;},
      onstart = function ()
if svo.haveskillset('spirituality') then
        if defc.dragonform or not defc.summon or stats.currentwillpower &lt;= 10 then
          send(&quot;touch shield&quot;, conf.commandecho)
        else
          send(&quot;angel aura&quot;, conf.commandecho)
        end
else
        send(&quot;touch shield&quot;, conf.commandecho)
end
      end
    },
    gone = {
      oncompleted = function()
        defences.lost('shield')
      end
    }
  },
  sstosvoa = {
    addiction = 'addiction',
    aeon = 'aeon',
    agoraphobia = 'agoraphobia',
    airdisrupt = 'airdisrupt',
    airfisted = 'galed',
    amnesia = 'amnesia',
    anorexia = 'anorexia',
    asthma = 'asthma',
    blackout = 'blackout',
    blindness = false,
    bound = 'bound',
    brokenleftarm = 'crippledleftarm',
    brokenleftleg = 'crippledleftleg',
    brokenrightarm = 'crippledrightarm',
    brokenrightleg = 'crippledrightleg',
    bruisedribs = false,
    burning = 'ablaze',
    cadmuscurse = 'cadmus',
    claustrophobia = 'claustrophobia',
    clumsiness = 'clumsiness',
    concussion = 'seriousconcussion',
    conflagration = false,
    confusion = 'confusion',
    corruption = 'corrupted',
    crackedribs = 'crackedribs',
    daeggerimpale = false,
    damagedhead = 'mildconcussion',
    damagedleftarm = 'mangledleftarm',
    damagedleftleg = 'mangledleftleg',
    damagedrightarm = 'mangledrightarm',
    damagedrightleg = 'mangledrightleg',
    darkshade = 'darkshade',
    dazed = false,
    dazzled = false,
    deadening = 'deadening',
    deafness = false,
    deepsleep = 'sleep',
    degenerate = 'degenerate',
    dehydrated = 'dehydrated',
    dementia = 'dementia',
    demonstain = 'stain',
    depression = 'depression',
    deteriorate = 'deteriorate',
    disloyalty = 'disloyalty',
    disrupted = 'disrupt',
    dissonance = 'dissonance',
    dizziness = 'dizziness',
    earthdisrupt = 'earthdisrupt',
    enlightenment = false,
    enmesh = false,
    entangled = 'roped',
    entropy = false,
    epilepsy = 'epilepsy',
    fear = 'fear',
    firedisrupt = 'firedisrupt',
    flamefisted = 'burning',
    frozen = 'frozen',
    generosity = 'generosity',
    haemophilia = 'haemophilia',
    hallucinations = 'hallucinations',
    hamstrung = 'hamstring',
    hatred = 'hatred',
    healthleech = 'healthleech',
    heartseed = 'heartseed',
    hecatecurse = 'hecate',
    hellsight = 'hellsight',
    hindered = false,
    homunculusmercury = false,
    hypersomnia = 'hypersomnia',
    hypochondria = 'hypochondria',
    hypothermia = 'hypothermia',
    icefisted = 'icing',
    impaled = 'impale',
    impatience = 'impatience',
    inquisition = 'inquisition',
    insomnia = false,
    internalbleeding = false,
    isolation = false,
    itching = 'itching',
    justice = 'justice',
    kaisurge = false,
    laceratedthroat = 'laceratedthroat',
    lapsingconsciousness = false,
    lethargy = 'lethargy',
    loneliness = 'loneliness',
    lovers = 'inlove',
    manaleech = 'manaleech',
    mangledhead = 'seriousconcussion',
    mangledleftarm = 'mutilatedleftarm',
    mangledleftleg = 'mutilatedleftleg',
    mangledrightarm = 'mutilatedrightarm',
    mangledrightleg = 'mutilatedrightleg',
    masochism = 'masochism',
    mildtrauma = 'mildtrauma',
    mindclamp = false,
    nausea = 'illness',
    numbedleftarm = 'numbedleftarm',
    numbedrightarm = 'numbedrightarm',
    pacified = 'pacifism',
    palpatarfeed = 'palpatar',
    paralysis = 'paralysis',
    paranoia = 'paranoia',
    parasite = 'parasite',
    peace = 'peace',
    penitence = false,
    petrified = false,
    phlogisticated = 'phlogistication',
    pinshot = 'pinshot',
    prone = 'prone',
    recklessness = 'recklessness',
    retribution = 'retribution',
    revealed = false,
    scalded = 'scalded',
    scrambledbrains = false,
    scytherus = 'relapsing',
    selarnia = 'selarnia',
    sensitivity = 'sensitivity',
    serioustrauma = 'serioustrauma',
    shadowmadness = 'shadowmadness',
    shivering = 'shivering',
    shyness = 'shyness',
    silver = false,
    skullfractures = 'skullfractures',
    slashedthroat = 'slashedthroat',
    sleeping = 'sleep',
    slickness = 'slickness',
    slimeobscure = 'ninkharsag',
    spiritdisrupt = 'spiritdisrupt',
    stupidity = 'stupidity',
    stuttering = 'stuttering',
    temperedcholeric = 'cholerichumour',
    temperedmelancholic = 'melancholichumour',
    temperedphlegmatic = 'phlegmatichumour',
    temperedsanguine = 'sanguinehumour',
    timeflux = 'timeflux',
    timeloop = 'timeloop',
    torntendons = 'torntendons',
    transfixation = 'transfixed',
    trueblind = false,
    unconsciousness = 'unconsciousness',
    vertigo = 'vertigo',
    vinewreathed = false,
    vitiated = false,
    vitrified = 'vitrification',
    voidfisted = 'voided',
    voyria = 'voyria',
    waterdisrupt = 'waterdisrupt',
    weakenedmind = 'rixil',
    weariness = 'weakness',
    webbed = 'webbed',
    whisperingmadness = 'madness',
    wristfractures = 'wristfractures'
  },
  sstosvod = {
    acrobatics = 'acrobatics',
    affinity = 'affinity',
    aiming = false,
    airpocket = 'waterbubble',
    alertness = 'alertness',
    antiforce = 'gaiartha',
    arctar = 'arctar',
    aria = 'aria',
    arrowcatching = 'arrowcatch',
    astralform = 'astralform',
    astronomy = 'empower',
    balancing = 'balancing',
    barkskin = 'barkskin',
    basking = 'bask',
    bedevilaura = 'bedevil',
    belltattoo = 'bell',
    blackwind = false,
    blademastery = 'mastery',
    blessingofthegods = false,
    blindness = 'blind',
    blocking = 'block',
    bloodquell = 'ukhia',
    bloodshield = false,
    blur = 'blur',
    boartattoo = false,
    bodyaugment = 'mainaas',
    bodyblock = 'bodyblock',
    boostedregeneration = 'boosting',
    chameleon = 'chameleon',
    chargeshield = 'chargeshield',
    circulate = 'circulate',
    clinging = 'clinging',
    cloak = 'cloak',
    coldresist = 'coldresist',
    consciousness = 'consciousness',
    constitution = 'constitution',
    curseward = 'curseward',
    deafness = 'deaf',
    deathaura = 'deathaura',
    deathsight = 'deathsight',
    deflect = 'deflect',
    deliverance = false,
    demonarmour = 'armour',
    demonfury = false,
    density = 'mass',
    devilmark = 'devilmark',
    diamondskin = 'diamondskin',
    disassociate = false,
    distortedaura = 'distortedaura',
    disperse = 'disperse',
    dodging = 'dodging',
    dragonarmour = 'dragonarmour',
    dragonbreath = 'dragonbreath',
    drunkensailor = 'drunkensailor',
    durability = 'tsuura',
    earthshield = 'earthblessing',
    eavesdropping = 'eavesdrop',
    electricresist = 'electricresist',
    elusiveness = 'elusiveness',
    enduranceblessing = 'enduranceblessing',
    enhancedform = false,
    evadeblock = 'evadeblock',
    evasion = false,
    extispicy = 'extispicy',
    fangbarrier = 'sileris',
    firefly = false,
    fireresist = 'fireresist',
    firstaid = 'firstaid',
    flailingstaff = 'flail',
    fleetness = 'fleetness',
    frenzied = false,
    frostshield = 'frostblessing',
    fury = false,
    ghost = 'ghost',
    golgothagrace = 'golgotha',
    gripping = 'grip',
    groundwatch = 'groundwatch',
    harmony = 'harmony',
    haste = false,
    heartsfury = 'heartsfury',
    heldbreath = 'breath',
    heresy = 'heresy',
    hiding = 'hiding',
    hypersense = 'hypersense',
    hypersight = 'hypersight',
    immunity = 'immunity',
    insomnia = 'insomnia',
    inspiration = 'inspiration',
    insuflate = false,
    insulation = false,
    ironform = false,
    ironwill = 'qamad',
    kaiboost = 'kaiboost',
    kaitrance = 'trance',
    kola = 'kola',
    lament = false,
    lay = 'lay',
    levitating = 'levitation',
    lifegiver = false,
    lifesteal = false,
    lifevision = 'lifevision',
    lipreading = 'lipread',
    magicresist = 'magicresist',
    megalithtattoo = false,
    mercury = 'mercury',
    metawake = 'metawake',
    mindcloak = 'mindcloak',
    mindnet = 'mindnet',
    mindseye = 'mindseye',
    mindtelesense = 'mindtelesense',
    moontattoo = false,
    morph = false,
    mosstattoo = false,
    nightsight = 'nightsight',
    numbness = 'numb',
    oxtattoo = false,
    pacing = 'pacing',
    panacea = 'panacea',
    phased = 'phase',
    pinchblock = 'pinchblock',
    poisonresist = 'venom',
    preachblessing = false,
    precision = 'trusad',
    prismatic = 'lyre',
    projectiles = 'projectiles',
    promosurcoat = false,
    putrefaction = 'putrefaction',
    rebounding = 'rebounding',
    reflections = 'reflection',
    reflexes = false,
    regeneration = 'regeneration',
    resistance = 'resistance',
    retaliation = 'retaliationstrike',
    satiation = 'satiation',
    scales = 'scales',
    scholasticism = 'myrrh',
    scouting = 'scout',
    secondsight = 'secondsight',
    selfishness = 'selfishness',
    setweapon = 'impaling',
    shadowveil = 'shadowveil',
    shield = 'shield',
    shikudoform = false,
    shinbinding = 'bind',
    shinclarity = 'clarity',
    shinrejoinder = false,
    shintrance = 'shintrance',
    shipwarning = 'shipwarning',
    skywatch = 'skywatch',
    slippery = 'slipperiness',
    softfocusing = 'softfocus',
    songbird = 'songbird',
    soulcage = 'soulcage',
    speed = 'speed',
    spinning = 'spinning',
    spinningstaff = false,
    spiritbonded = 'bonding',
    spiritwalk = false,
    splitmind = 'splitmind',
    standingfirm = 'sturdiness',
    starburst = 'starburst',
    stealth = 'stealth',
    stonefist = 'stonefist',
    stoneskin = 'stoneskin',
    sulphur = 'sulphur',
    swiftcurse = 'swiftcurse',
    tekurastance = false,
    telesense = 'telesense',
    temperance = 'frost',
    tentacles = 'tentacles',
    thermalshield = 'thermalblessing',
    thirdeye = 'thirdeye',
    tin = 'tin',
    toughness = 'toughness',
    treewatch = 'treewatch',
    truestare = 'truestare',
    tune = 'tune',
    twoartsstance = false,
    vengeance = 'vengeance',
    vigilance = 'vigilance',
    vigour = 'vigour',
    viridian = 'viridian',
    vitality = 'vitality',
    ward = false,
    waterwalking = 'waterwalk',
    weakvigour = false,
    weathering = 'weathering',
    weaving = 'weaving',
    wildgrowth = 'wildgrowth',
    willpowerblessing = 'willpowerblessing',
    xporb = false,
  },
  svotossa = {},
  svotossd = {}
} -- end of dict

if svo.haveskillset('subterfuge') then
  svo.dict.sstosvod.shroud = 'cloaking'
else
  svo.dict.sstosvod.shroud = 'shroud'
end

if svo.haveskillset('weaponmastery') then
  svo.dict.prone.misc.actions = {'stand', &quot;recover footing&quot;}
else
  svo.dict.prone.misc.action = 'stand'
end

-- undeffable since serverside can't morph to get a specific defence up
if svo.haveskillset('metamorphosis') then
  svo.dict.nightsight.physical.undeffable = true
end

if svo.haveskillset('shindo') then
  svo.dict.deaf.misc = {
    aspriority = 0,
    spriority = 0,
    def = true,

    isadvisable = function ()
      return (not defc.deaf and conf.shindodeaf and not defc.dragonform and ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf)) and not svo.doingaction('waitingondeaf')) or false
    end,

    oncompleted = function ()
      svo.doaction(svo.dict.waitingondeaf.waitingfor)
    end,

    action = 'deaf',
    onstart = function ()
      send('deaf', conf.commandecho)
    end
  }
end
if svo.haveskillset('kaido') then
  svo.dict.deaf.misc = {
    aspriority = 0,
    spriority = 0,
    def = true,

    isadvisable = function ()
      return (not defc.deaf and conf.kaidodeaf and not defc.dragonform and ((sys.deffing and defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf)) and not svo.doingaction('waitingondeaf')) or false
    end,

    oncompleted = function ()
      svo.doaction(svo.dict.waitingondeaf.waitingfor)
    end,

    action = 'deaf',
    onstart = function ()
      send('deaf', conf.commandecho)
    end
  }
end
if svo.haveskillset('shindo') then
  svo.dict.blind.misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.shindoblind and not defc.dragonform and ((sys.deffing and defdefup[defs.mode].blind and not defc.blind) or (conf.keepup and defkeepup[defs.mode].blind and not defc.blind)) and not svo.doingaction'waitingonblind') or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingonblind.waitingfor)
      end,

      action = 'blind',
      onstart = function ()
        send('blind', conf.commandecho)
      end
    }
end
if svo.haveskillset('kaido') then
  svo.dict.blind.misc = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (conf.kaidoblind and not defc.dragonform and ((sys.deffing and defdefup[defs.mode].blind and not defc.blind) or (conf.keepup and defkeepup[defs.mode].blind and not defc.blind)) and not svo.doingaction'waitingonblind') or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingonblind.waitingfor)
      end,

      action = 'blind',
      onstart = function ()
        send('blind', conf.commandecho)
      end
    }
end


-- skillset-specific defences
if svo.haveskillset('necromancy') then
  svo.dict.lifevision = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.lifevision and ((sys.deffing and defdefup[defs.mode].lifevision) or (conf.keepup and defkeepup[defs.mode].lifevision)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone and stats.currentmana &gt;= 600) or false
      end,

      oncompleted = function ()
        defences.got('lifevision')
      end,

      action = 'lifevision',
      onstart = function ()
        send('lifevision', conf.commandecho)
      end
    }
  }
end


if svo.haveskillset('devotion') then
  svo.dict.frostblessing = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.frostblessing and ((sys.deffing and defdefup[defs.mode].frostblessing) or (conf.keepup and defkeepup[defs.mode].frostblessing)) and not codepaste.balanceful_defs_codepaste() and not affs.prone and defc.air and defc.water and stats.currentmana &gt;= 750) or false
      end,

      oncompleted = function ()
        defences.got('frostblessing')
      end,

      action = &quot;bless me spiritshield frost&quot;,
      onstart = function ()
        send(&quot;bless me spiritshield frost&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.willpowerblessing = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.willpowerblessing and ((sys.deffing and defdefup[defs.mode].willpowerblessing) or (conf.keepup and defkeepup[defs.mode].willpowerblessing)) and not codepaste.balanceful_defs_codepaste() and not affs.prone and defc.air and defc.water and defc.fire and stats.currentmana &gt;= 750) or false
      end,

      oncompleted = function ()
        defences.got('willpowerblessing')
      end,

      action = &quot;bless me willpower&quot;,
      onstart = function ()
        send(&quot;bless me willpower&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.thermalblessing = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.thermalblessing and ((sys.deffing and defdefup[defs.mode].thermalblessing) or (conf.keepup and defkeepup[defs.mode].thermalblessing)) and not codepaste.balanceful_defs_codepaste() and not affs.prone and defc.spirit and defc.fire and stats.currentmana &gt;= 750) or false
      end,

      oncompleted = function ()
        defences.got('thermalblessing')
      end,

      action = &quot;bless me spiritshield thermal&quot;,
      onstart = function ()
        send(&quot;bless me spiritshield thermal&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.earthblessing = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.earthblessing and ((sys.deffing and defdefup[defs.mode].earthblessing) or (conf.keepup and defkeepup[defs.mode].earthblessing)) and not codepaste.balanceful_defs_codepaste() and not affs.prone and defc.earth and defc.water and defc.fire and stats.currentmana &gt;= 750) or false
      end,

      oncompleted = function ()
        defences.got('earthblessing')
      end,

      action = &quot;bless me spiritshield earth&quot;,
      onstart = function ()
        send(&quot;bless me spiritshield earth&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.enduranceblessing = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.enduranceblessing and ((sys.deffing and defdefup[defs.mode].enduranceblessing) or (conf.keepup and defkeepup[defs.mode].enduranceblessing)) and not codepaste.balanceful_defs_codepaste() and not affs.prone and defc.air and defc.earth and defc.water and defc.fire and stats.currentmana &gt;= 750) or false
      end,

      oncompleted = function ()
        defences.got('enduranceblessing')
      end,

      action = &quot;bless me endurance&quot;,
      onstart = function ()
        send(&quot;bless me endurance&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('spirituality') then
  svo.dict.mace = {
    physical = {
      aspriority = 0,
      spriority = 0,
      unpauselater = false,
      balanceful_act = true, -- it is balanceless, but this causes it to be bundled with a balanceful action - not desired
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].mace and not defc.mace) or (conf.keepup and defkeepup[defs.mode].mace and not defc.mace)) and not svo.doingaction('waitingformace') and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingformace.waitingfor)
      end,

      alreadyhave = function ()
        svo.dict.waitingformace.waitingfor.oncompleted()
        send(&quot;wield mace&quot;, conf.commandecho)
      end,

      action = &quot;summon mace&quot;,
      onstart = function ()
      -- user commands catching needs this check
        if not (bals.balance and bals.equilibrium) then return end

        send(&quot;summon mace&quot;, conf.commandecho)

        if not conf.paused then
          svo.dict.mace.physical.unpauselater = true
          conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Temporarily pausing to summon the mace.&quot;)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('mace')
      end,
    }
  }
  svo.dict.waitingformace = {
    spriority = 0,
    waitingfor = {
      customwait = 3,

      oncompleted = function ()
        defences.got('mace')

        if conf.paused and svo.dict.mace.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')

          svo.echof(&quot;Obtained mace, unpausing.&quot;)
        end
        svo.dict.mace.physical.unpauselater = false
      end,

      cancelled = function ()
        if conf.paused and svo.dict.mace.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.echof(&quot;Oops, summoning interrupted. Unpausing.&quot;)
        end
        svo.dict.mace.physical.unpauselater = false
      end,

      ontimeout = function()
        if conf.paused and svo.dict.mace.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.echof(&quot;Hm... doesn't seem the mace summon is happening. Going to try again.&quot;)
        end
        svo.dict.mace.physical.unpauselater = false
      end,

      onstart = function() end
    }
  }
  svo.dict.sacrifice = {
    description = &quot;tracks whenever you've sent the angel sacrifice command - so an illusion on angel sacrifice won't trick the system into clearing all affs&quot;,
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return false
      end,

      oncompleted = function ()
      end,

      action = &quot;angel sacrifice&quot;,
      onstart = function ()
        send(&quot;angel sacrifice&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.summon = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.summon and ((sys.deffing and defdefup[defs.mode].summon) or (conf.keepup and defkeepup[defs.mode].summon)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('summon')
      end,

      action = &quot;angel summon&quot;,
      onstart = function ()
        send(&quot;angel summon&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.empathy = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.empathy and ((sys.deffing and defdefup[defs.mode].empathy) or (conf.keepup and defkeepup[defs.mode].empathy)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and defc.summon) or false
      end,

      oncompleted = function ()
        defences.got('empathy')
      end,

      action = &quot;angel empathy on&quot;,
      onstart = function ()
        send(&quot;angel empathy on&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.watch = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.watch and ((sys.deffing and defdefup[defs.mode].watch) or (conf.keepup and defkeepup[defs.mode].watch)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and defc.summon) or false
      end,

      oncompleted = function ()
        defences.got('watch')
      end,

      action = &quot;angel watch on&quot;,
      onstart = function ()
        send(&quot;angel watch on&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.care = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.care and ((sys.deffing and defdefup[defs.mode].care) or (conf.keepup and defkeepup[defs.mode].care)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and defc.summon) or false
      end,

      oncompleted = function ()
        defences.got('care')
      end,

      action = &quot;angel care on&quot;,
      onstart = function ()
        send(&quot;angel care on&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('shindo') then
  svo.dict.phoenix = {
    description = &quot;tracks whenever you've sent the shindo phoenix command - so an illusion on shindo phoenix won't trick the system into clearing all affs&quot;,
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return false
      end,

      oncompleted = function ()
      end,

      action = &quot;shin phoenix&quot;,
      onstart = function ()
        send(&quot;shin phoenix&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('twoarts') then
  svo.dict.doya = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].doya and not defc.doya) or (conf.keepup and defkeepup[defs.mode].doya and not defc.doya)) and not defc.thyr and not defc.mir and not defc.arash and not defc.sanya and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        for _, stance in ipairs{'doya', 'thyr', 'mir', 'arash', 'sanya'} do
          defences.lost(stance)
        end

        defences.got('doya')
      end,

      action = 'doya',
      onstart = function ()
        send('doya', conf.commandecho)
      end
    },
  }
  svo.dict.thyr = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].thyr and not defc.thyr) or (conf.keepup and defkeepup[defs.mode].thyr)) and not defc.doya and not defc.thyr and not defc.mir and not defc.arash and not defc.sanya and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        for _, stance in ipairs{'doya', 'thyr', 'mir', 'arash', 'sanya'} do
          defences.lost(stance)
        end

        defences.got('thyr')
      end,

      action = 'thyr',
      onstart = function ()
        send('thyr', conf.commandecho)
      end
    },
  }
  svo.dict.mir = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].mir and not defc.mir) or (conf.keepup and defkeepup[defs.mode].mir)) and not defc.doya and not defc.thyr and not defc.mir and not defc.arash and not defc.sanya and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        for _, stance in ipairs{'doya', 'thyr', 'mir', 'arash', 'sanya'} do
          defences.lost(stance)
        end

        defences.got('mir')
      end,

      action = 'mir',
      onstart = function ()
        send('mir', conf.commandecho)
      end
    },
  }
  svo.dict.arash = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].arash and not defc.arash) or (conf.keepup and defkeepup[defs.mode].arash)) and not defc.doya and not defc.thyr and not defc.mir and not defc.arash and not defc.sanya and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        for _, stance in ipairs{'doya', 'thyr', 'mir', 'arash', 'sanya'} do
          defences.lost(stance)
        end

        defences.got('arash')
      end,

      action = 'arash',
      onstart = function ()
        send('arash', conf.commandecho)
      end
    },
  }
  svo.dict.sanya = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].sanya and not defc.sanya) or (conf.keepup and defkeepup[defs.mode].sanya)) and not defc.doya and not defc.thyr and not defc.mir and not defc.arash and not defc.sanya and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        for _, stance in ipairs{'doya', 'thyr', 'mir', 'arash', 'sanya'} do
          defences.lost(stance)
        end

        defences.got('sanya')
      end,

      action = 'sanya',
      onstart = function ()
        send('sanya', conf.commandecho)
      end
    },
  }
end

if svo.haveskillset('metamorphosis') then
  svo.dict.affinity = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.affinity and ((sys.deffing and defdefup[defs.mode].affinity) or (conf.keepup and defkeepup[defs.mode].affinity)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('affinity')
      end,

      action = &quot;embrace spirit&quot;,
      onstart = function ()
        if sk.inamorph() then
          send(&quot;embrace spirit&quot;, conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end

          if sk.skillmorphs.wyvern then
            send(&quot;morph wyvern&quot;, conf.commandecho)
          else
            send(&quot;morph &quot;..sk.morphsforskill.nightsight[1], conf.commandecho)
          end
        end
      end
    }
  }
  svo.dict.fitness = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        if not (not affs.weakness and not defc.dragonform and bals.fitness and not codepaste.balanceful_defs_codepaste() and (defc.wyvern or defc.wolf or defc.hyena or defc.jaguar or defc.cheetah or defc.elephant or defc.hydra) and not affs.cantmorph and sk.morphsforskill.fitness) then
          return false
        end

        for name, func in pairs(svo.fitness) do
          if not me.disabledfitnessfunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function ()
        svo.rmaff('asthma')
        svo.lostbal_fitness()
      end,

      curedasthma = function ()
        svo.rmaff('asthma')
      end,

      weakness = function ()
        svo.addaffdict(svo.dict.weakness)
      end,

      allgood = function()
        svo.rmaff('asthma')
      end,

      actions = {'fitness'},
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'fitness' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'fitness' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.fitness[1], conf.commandecho)
        elseif sk.inamorphfor'fitness' then
          send('fitness', conf.commandecho)
        end
      end
    },
  }
  svo.dict.elusiveness = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.elusiveness and ((sys.deffing and defdefup[defs.mode].elusiveness) or (conf.keepup and defkeepup[defs.mode].elusiveness)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.elusiveness) or false
      end,

      oncompleted = function ()
        defences.got('elusiveness')
      end,

      action = &quot;elusiveness on&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'elusiveness' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'elusiveness' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.elusiveness[1], conf.commandecho)
        elseif sk.inamorphfor'elusiveness' then
          send(&quot;elusiveness on&quot;, conf.commandecho)
        end
      end
    },
  }
  svo.dict.temperance = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.temperance and ((sys.deffing and defdefup[defs.mode].temperance) or (conf.keepup and defkeepup[defs.mode].temperance)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.temperance) or false
      end,

      oncompleted = function ()
        defences.got('temperance')
        defences.got('frost')
      end,

      action = 'temperance',
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'temperance' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'temperance' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.temperance[1], conf.commandecho)
        elseif sk.inamorphfor'temperance' then
          send('temperance', conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('frost')
      end
    }
  }
  svo.dict.stealth = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.stealth and ((sys.deffing and defdefup[defs.mode].stealth) or (conf.keepup and defkeepup[defs.mode].stealth)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.stealth) or false
      end,

      oncompleted = function ()
        defences.got('stealth')
      end,

      action = &quot;stealth on&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'stealth' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'stealth' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.stealth[1], conf.commandecho)
        elseif sk.inamorphfor'stealth' then
          send(&quot;stealth on&quot;, conf.commandecho)
        end
      end
    },
  }
  svo.dict.resistance = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.resistance and ((sys.deffing and defdefup[defs.mode].resistance) or (conf.keepup and defkeepup[defs.mode].resistance)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.resistance) or false
      end,

      oncompleted = function ()
        defences.got('resistance')
      end,

      action = 'resistance',
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'resistance' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'resistance' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.resistance[1], conf.commandecho)
        elseif sk.inamorphfor'resistance' then
          send('resistance', conf.commandecho)
        end
      end
    },
  }
  svo.dict.rest = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.rest and ((sys.deffing and defdefup[defs.mode].rest) or (conf.keepup and defkeepup[defs.mode].rest)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.rest) or false
      end,

      oncompleted = function ()
        defences.got('rest')
      end,

      action = 'rest',
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'rest' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'rest' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.rest[1], conf.commandecho)
        elseif sk.inamorphfor'rest' then
          send('rest', conf.commandecho)
        end
      end
    },
  }
  svo.dict.vitality = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        if (not defc.vitality and ((sys.deffing and defdefup[defs.mode].vitality) or (conf.keepup and defkeepup[defs.mode].vitality)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.vitality and not svo.doingaction'cantvitality') then

         if (stats.currenthealth &gt;= stats.maxhealth and stats.currentmana &gt;= stats.maxmana)
          then
            return true
          elseif not sk.gettingfullstats then
            svo.fullstats(true)
            svo.echof(&quot;Getting fullstats for vitality now...&quot;)
          end
        end
      end,

      oncompleted = function ()
        defences.got('vitality')
      end,

      action = 'vitality',
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'vitality' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'vitality' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.vitality[1], conf.commandecho)
        elseif sk.inamorphfor'vitality' then
          send('vitality', conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('vitality')
        if not svo.actions.cantvitality_waitingfor then svo.doaction(svo.dict.cantvitality.waitingfor) end
      end
    }
  }
  -- nightsight = {
  --   physical = {
  --     aspriority = 0,
  --     spriority = 0,
  --     balanceful_act = true,
  --     def = true,

  --     isadvisable = function ()
  --       return (not defc.nightsight and ((sys.deffing and defdefup[defs.mode].nightsight) or (conf.keepup and defkeepup[defs.mode].nightsight)) and not codepaste.balanceful_defs_codepaste() and ((not affs.cantmorph and sk.morphsforskill.nightsight) or defc.dragonform)) or false
  --     end,

  --     oncompleted = function ()
  --       defences.got('nightsight')
  --     end,

  --     action = &quot;nightsight on&quot;,
  --     onstart = function ()
  --       if not defc.dragonform and (not conf.transmorph and sk.inamorph() and not sk.inamorphfor'nightsight') then
  --         if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
  --         send('human', conf.commandecho)
  --       elseif not defc.dragonform and not sk.inamorphfor'nightsight' then
  --         if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
  --         send(&quot;morph &quot;..sk.morphsforskill.nightsight[1], conf.commandecho)
  --       elseif defc.dragonform or sk.inamorphfor'nightsight' then
  --         send(&quot;nightsight on&quot;, conf.commandecho)
  --       end
  --     end
  --   },
  -- },
  svo.dict.flame = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true, -- mark as undeffable since serverside can't morph

      isadvisable = function ()
        return (not defc.flame and ((sys.deffing and defdefup[defs.mode].flame) or (conf.keepup and defkeepup[defs.mode].flame)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and sk.morphsforskill.flame) or false
      end,

      oncompleted = function ()
        defences.got('flame')
      end,

      actions = {&quot;summon flame&quot;, &quot;summon fire&quot;},
      onstart = function ()
        if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'flame' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        elseif not sk.inamorphfor'flame' then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph &quot;..sk.morphsforskill.flame[1], conf.commandecho)
        elseif sk.inamorphfor'flame' then
          send(&quot;summon flame&quot;, conf.commandecho)
        end
      end
    },
  }
  svo.dict.squirrel = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.squirrel and ((sys.deffing and defdefup[defs.mode].squirrel) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].squirrel)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('squirrel')
      end,

      action = &quot;morph squirrel&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph squirrel&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('squirrel')
      end,
    }
  }
  svo.dict.wildcat = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.wildcat and ((sys.deffing and defdefup[defs.mode].wildcat) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].wildcat)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('wildcat')
      end,

      action = &quot;morph wildcat&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph wildcat&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('wildcat')
      end,
    }
  }
  svo.dict.wolf = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.wolf and ((sys.deffing and defdefup[defs.mode].wolf) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].wolf)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('wolf')
      end,

      action = &quot;morph wolf&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph wolf&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('wolf')
      end,
    }
  }
  svo.dict.turtle = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.turtle and ((sys.deffing and defdefup[defs.mode].turtle) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].turtle)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('turtle')
      end,

      action = &quot;morph turtle&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph turtle&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('turtle')
      end,
    }
  }
  svo.dict.jackdaw = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.jackdaw and ((sys.deffing and defdefup[defs.mode].jackdaw) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].jackdaw)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('jackdaw')
      end,

      action = &quot;morph jackdaw&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph jackdaw&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('jackdaw')
      end,
    }
  }
  svo.dict.cheetah = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.cheetah and ((sys.deffing and defdefup[defs.mode].cheetah) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].cheetah)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('cheetah')
      end,

      action = &quot;morph cheetah&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph cheetah&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('cheetah')
      end,
    }
  }
  svo.dict.owl = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.owl and ((sys.deffing and defdefup[defs.mode].owl) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].owl)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('owl')
      end,

      action = &quot;morph owl&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph owl&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('owl')
      end,
    }
  }
  svo.dict.hyena = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.hyena and ((sys.deffing and defdefup[defs.mode].hyena) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].hyena)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('hyena')
      end,

      action = &quot;morph hyena&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph hyena&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('hyena')
      end,
    }
  }
  svo.dict.condor = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.condor and ((sys.deffing and defdefup[defs.mode].condor) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].condor)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('condor')
      end,

      action = &quot;morph condor&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph condor&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('condor')
      end,
    }
  }
  svo.dict.gopher = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.gopher and ((sys.deffing and defdefup[defs.mode].gopher) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].gopher)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('gopher')
      end,

      action = &quot;morph gopher&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph gopher&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('gopher')
      end,
    }
  }
  svo.dict.sloth = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.sloth and ((sys.deffing and defdefup[defs.mode].sloth) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].sloth)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('sloth')
      end,

      action = &quot;morph sloth&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph sloth&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('sloth')
      end,
    }
  }
  svo.dict.bear = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.bear and ((sys.deffing and defdefup[defs.mode].bear) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].bear)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('bear')
      end,

      action = &quot;morph bear&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph bear&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('bear')
      end,
    }
  }
  svo.dict.nightingale = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.nightingale and ((sys.deffing and defdefup[defs.mode].nightingale) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].nightingale)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('nightingale')
      end,

      action = &quot;morph nightingale&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph nightingale&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('nightingale')
      end,
    }
  }
  svo.dict.elephant = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.elephant and ((sys.deffing and defdefup[defs.mode].elephant) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].elephant)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('elephant')
      end,

      action = &quot;morph elephant&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph elephant&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('elephant')
      end,
    }
  }
  svo.dict.wolverine = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.wolverine and ((sys.deffing and defdefup[defs.mode].wolverine) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].wolverine)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('wolverine')
      end,

      action = &quot;morph wolverine&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph wolverine&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('wolverine')
      end,
    }
  }
  svo.dict.eagle = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.eagle and ((sys.deffing and defdefup[defs.mode].eagle) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].eagle)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('eagle')
      end,

      action = &quot;morph eagle&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph eagle&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('eagle')
      end,
    }
  }
  svo.dict.gorilla = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.gorilla and ((sys.deffing and defdefup[defs.mode].gorilla) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].gorilla)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('gorilla')
      end,

      action = &quot;morph gorilla&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph gorilla&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('gorilla')
      end,
    }
  }
  svo.dict.icewyrm = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.icewyrm and ((sys.deffing and defdefup[defs.mode].icewyrm) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].icewyrm)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('icewyrm')
      end,

      action = &quot;morph icewyrm&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph icewyrm&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('icewyrm')
      end,
    }
  }
end

if svo.haveskillset('swashbuckling') then
  svo.dict.drunkensailor = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].drunkensailor and not defc.drunkensailor) or (conf.keepup and defkeepup[defs.mode].drunkensailor and not defc.drunkensailor) and not defc.heartsfury and not svo.doingaction'drunkensailor' and not affs.paralysis) or false
      end,

      oncompleted = function ()
        defences.got('drunkensailor')
      end,

      action = 'drunkensailor',
      onstart = function ()
        send('drunkensailor', conf.commandecho)
      end
    },
  }
  svo.dict.heartsfury = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return ((sys.deffing and defdefup[defs.mode].heartsfury and not defc.heartsfury) or (conf.keepup and defkeepup[defs.mode].heartsfury and not defc.heartsfury) and not defc.drunkensailor and not svo.doingaction'heartsfury' and not affs.paralysis) or false
      end,

      oncompleted = function ()
        defences.got('heartsfury')
      end,

      action = 'heartsfury',
      onstart = function ()
        send('heartsfury', conf.commandecho)
      end
    },
  }
end

if svo.haveskillset('voicecraft') then
  svo.dict.lay = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].lay and not defc.lay) or (conf.keepup and defkeepup[defs.mode].lay and not defc.lay)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'lay' and bals.voice) or false
      end,

      oncompleted = function ()
        defences.got('lay')
        svo.lostbal_voice()
      end,

      action = &quot;sing lay&quot;,
      onstart = function ()
        send(&quot;sing lay&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.tune = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].tune and not defc.tune) or (conf.keepup and defkeepup[defs.mode].tune and not defc.tune)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'tune' and bals.voice) or false
      end,

      oncompleted = function ()
        defences.got('tune')
        svo.lostbal_voice()
      end,

      action = &quot;sing tune&quot;,
      onstart = function ()
        send(&quot;sing tune&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.aria = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].aria and not defc.aria) or (conf.keepup and defkeepup[defs.mode].aria and not defc.aria)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'aria' and bals.voice and not affs.deafaff and not defc.deaf) or false
      end,

      oncompleted = function ()
        defences.got('aria')
        svo.lostbal_voice()
      end,

      action = &quot;sing aria at me&quot;,
      onstart = function ()
        send(&quot;sing aria at me&quot;, conf.commandecho)
      end
    },
  }
end

if svo.haveskillset('occultism') then
  svo.dict.astralform = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.astralform and ((sys.deffing and defdefup[defs.mode].astralform) or (conf.keepup and defkeepup[defs.mode].astralform)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('astralform')
        defences.lost('riding')
      end,

      action = 'astralform',
      onstart = function ()
        send('astralform', conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('healing') then
  svo.dict.bedevil = {
    gamename = 'bedevilaura',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.bedevil and ((sys.deffing and defdefup[defs.mode].bedevil) or (conf.keepup and defkeepup[defs.mode].bedevil)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.air and defc.water and defc.fire and defc.earth and defc.spirit) or false
      end,

      oncompleted = function ()
        defences.got('bedevil')
      end,

      action = 'bedevil',
      onstart = function ()
        send('bedevil', conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('healing') or svo.haveskillset('elementalism') or svo.haveskillset('weatherweaving') then
  svo.dict.simultaneity = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.simultaneity and ((sys.deffing and defdefup[defs.mode].simultaneity) or (conf.keepup and defkeepup[defs.mode].simultaneity)) and not codepaste.balanceful_defs_codepaste() and stats.currentmana &gt;= 1000) or false
      end,

      oncompleted = function ()
        defences.got('simultaneity')
      end,

      action = 'simultaneity',
      onstart = function ()
        send('simultaneity', conf.commandecho)
      end
    }
  }
  svo.dict.air = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.air and ((sys.deffing and defdefup[defs.mode].air) or (conf.keepup and defkeepup[defs.mode].air)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('air')
        if defc.air and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit)
        and (svo.haveskillset('weatherweaving') or defc.fire) then
          defences.got('simultaneity')
        end
      end,

      action = &quot;channel air&quot;,
      onstart = function ()
        send(&quot;channel air&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('air')
        defences.lost('simultaneity')
      end
    }
  }
  svo.dict.water = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.water and ((sys.deffing and defdefup[defs.mode].water) or (conf.keepup and defkeepup[defs.mode].water)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('water')
        if defc.air and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit)
        and (svo.haveskillset('weatherweaving') or defc.fire) then
          defences.got('simultaneity')
        end
      end,

      action = &quot;channel water&quot;,
      onstart = function ()
        send(&quot;channel water&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('water')
        defences.lost('simultaneity')
      end
    }
  }
  svo.dict.earth = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.earth and ((sys.deffing and defdefup[defs.mode].earth) or (conf.keepup and defkeepup[defs.mode].earth)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('earth')
        if defc.air and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit)
        and (svo.haveskillset('weatherweaving') or defc.fire) then
          defences.got('simultaneity')
        end
      end,

      action = &quot;channel earth&quot;,
      onstart = function ()
        send(&quot;channel earth&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('earth')
        defences.lost('simultaneity')
      end
    }
  }
if not svo.haveskillset('weatherweaving') then
  svo.dict.fire = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.fire and ((sys.deffing and defdefup[defs.mode].fire) or (conf.keepup and defkeepup[defs.mode].fire)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('fire')
        if defc.air and defc.fire and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit) then
          defences.got('simultaneity')
        end
      end,

      action = &quot;channel fire&quot;,
      onstart = function ()
        send(&quot;channel fire&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('fire')
        defences.lost('simultaneity')
      end
    }
  }
end
if svo.haveskillset('healing') then
  svo.dict.spirit = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].spirit and not defc.spirit) or (conf.keepup and defkeepup[defs.mode].spirit and not defc.spirit))) or (conf.keepup and defkeepup[defs.mode].spirit and not defc.spirit)) and not codepaste.balanceful_defs_codepaste() and defc.air and defc.fire and defc.water and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('spirit')
        if defc.air and defc.fire and defc.earth and defc.water and defc.spirit then
          defences.got('simultaneity')
        end
      end,

      action = &quot;channel spirit&quot;,
      onstart = function ()
        send(&quot;channel spirit&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('spirit')
        defences.lost('simultaneity')
      end
    }
  }
end
  svo.dict.bindall = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].bindall and not defc.bindall) or (conf.keepup and defkeepup[defs.mode].bindall and not defc.bindall))) or (conf.keepup and defkeepup[defs.mode].bindall and not defc.bindall)) and not codepaste.balanceful_defs_codepaste() and stats.currentmana &gt;= 750 and defc.air and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit)
        and (svo.haveskillset('weatherweaving') or defc.fire)) or false
      end,

      oncompleted = function ()
        defences.got('bindall')
      end,

      action = &quot;bind all&quot;,
      onstart = function ()
        send(&quot;bind all&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.boundair = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].boundair and not defc.boundair) or (conf.keepup and defkeepup[defs.mode].boundair and not defc.boundair))) or (conf.keepup and defkeepup[defs.mode].boundair and not defc.boundair)) and not codepaste.balanceful_defs_codepaste() and defc.air) or false
      end,

      oncompleted = function ()
        defences.got('boundair')
        if defc.boundair and defc.boundearth and defc.boundwater and (not svo.haveskillset('healing') or defc.boundspirit) and (svo.haveskillset('weatherweaving') or defc.boundfire) then
          defences.got('bindall')
        end
      end,

      action = &quot;bind air&quot;,
      onstart = function ()
        send(&quot;bind air&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('boundair')
        defences.lost('bindall')
      end
    }
  }
  svo.dict.boundwater = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].boundwater and not defc.boundwater) or (conf.keepup and defkeepup[defs.mode].boundwater and not defc.boundwater))) or (conf.keepup and defkeepup[defs.mode].boundwater and not defc.boundwater)) and not codepaste.balanceful_defs_codepaste() and defc.water) or false
      end,

      oncompleted = function ()
        defences.got('boundwater')
        if defc.boundair and defc.boundearth and defc.boundwater and (not svo.haveskillset('healing') or defc.boundspirit) and (svo.haveskillset('weatherweaving') or defc.boundfire) then
          defences.got('bindall')
        end
      end,

      action = &quot;bind water&quot;,
      onstart = function ()
        send(&quot;bind water&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('boundwater')
        defences.lost('bindall')
      end
    }
  }
  if not svo.haveskillset('weatherweaving') then
    svo.dict.boundfire = {
      physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true,

        isadvisable = function ()
          return (((((sys.deffing and defdefup[defs.mode].boundfire and not defc.boundfire) or (conf.keepup and defkeepup[defs.mode].boundfire and not defc.boundfire))) or (conf.keepup and defkeepup[defs.mode].boundfire and not defc.boundfire)) and not codepaste.balanceful_defs_codepaste() and defc.fire) or false
        end,

        oncompleted = function ()
          defences.got('boundfire')
          if defc.boundair and defc.boundfire and defc.boundearth and defc.boundwater and (not svo.haveskillset('healing') or defc.boundspirit) then
            defences.got('bindall')
          end
        end,

        action = &quot;bind fire&quot;,
        onstart = function ()
          send(&quot;bind fire&quot;, conf.commandecho)
        end
      },
      gone = {
        oncompleted = function ()
          defences.lost('boundfire')
          defences.lost('bindall')
        end
      }
    }
  end
  svo.dict.boundearth = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].boundearth and not defc.boundearth) or (conf.keepup and defkeepup[defs.mode].boundearth and not defc.boundearth))) or (conf.keepup and defkeepup[defs.mode].boundearth and not defc.boundearth)) and not codepaste.balanceful_defs_codepaste() and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('boundearth')
        if defc.boundair and defc.boundearth and defc.boundwaterand (not svo.haveskillset('healing') or defc.boundspirit) and (svo.haveskillset('weatherweaving') or defc.boundfire) then
          defences.got('bindall')
        end
      end,

      action = &quot;bind earth&quot;,
      onstart = function ()
        send(&quot;bind earth&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('boundearth')
        defences.lost('bindall')
      end
    }
  }
  if svo.haveskillset('healing') then
    svo.dict.boundspirit = {
      physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true,

        isadvisable = function ()
          return (((((sys.deffing and defdefup[defs.mode].boundspirit and not defc.boundspirit) or (conf.keepup and defkeepup[defs.mode].boundspirit and not defc.boundspirit))) or (conf.keepup and defkeepup[defs.mode].boundspirit and not defc.boundspirit)) and not codepaste.balanceful_defs_codepaste() and defc.spirit) or false
        end,

        oncompleted = function ()
          defences.got('boundspirit')
          if defc.boundair and defc.boundfire and defc.boundearth and defc.boundwater and defc.boundspirit then
            defences.got('bindall')
          end
        end,

        action = &quot;bind spirit&quot;,
        onstart = function ()
          send(&quot;bind spirit&quot;, conf.commandecho)
        end
      },
      gone = {
        oncompleted = function ()
          defences.lost('boundspirit')
          defences.lost('bindall')
        end
      }
    }
  end
  svo.dict.fortifyall = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].fortifyall and not defc.fortifyall) or (conf.keepup and defkeepup[defs.mode].fortifyall and not defc.fortifyall))) or (conf.keepup and defkeepup[defs.mode].fortifyall and not defc.fortifyall)) and not codepaste.balanceful_defs_codepaste() and stats.currentmana &gt;= 600 and defc.air and defc.earth and defc.water and (not svo.haveskillset('healing') or defc.spirit) and (svo.haveskillset('weatherweaving') or defc.fire)) or false
      end,

      oncompleted = function ()
        defences.got('fortifyall')
      end,

      action = &quot;fortify all&quot;,
      onstart = function ()
        send(&quot;fortify all&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.fortifiedair = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].fortifiedair and not defc.fortifiedair) or (conf.keepup and defkeepup[defs.mode].fortifiedair and not defc.fortifiedair))) or (conf.keepup and defkeepup[defs.mode].fortifiedair and not defc.fortifiedair)) and not codepaste.balanceful_defs_codepaste() and defc.air) or false
      end,

      oncompleted = function ()
        defences.got('fortifiedair')
        if defc.fortifiedair and defc.fortifiedearth and defc.fortifiedwaterand and (not svo.haveskillset('healing') or defc.fortifiedspirit) and (svo.haveskillset('weatherweaving') or defc.fortifiedfire) then
          defences.got('fortifyall')
        end
      end,

      action = &quot;fortify air&quot;,
      onstart = function ()
        send(&quot;fortify air&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('fortifiedair')
        defences.lost('fortifyall')
      end
    }
  }
  svo.dict.fortifiedwater = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].fortifiedwater and not defc.fortifiedwater) or (conf.keepup and defkeepup[defs.mode].fortifiedwater and not defc.fortifiedwater))) or (conf.keepup and defkeepup[defs.mode].fortifiedwater and not defc.fortifiedwater)) and not codepaste.balanceful_defs_codepaste() and defc.water) or false
      end,

      oncompleted = function ()
        defences.got('fortifiedwater')
        if defc.fortifiedair and defc.fortifiedearth and defc.fortifiedwater and (not svo.haveskillset('healing') or defc.fortifiedspirit) and (svo.haveskillset('weatherweaving') or defc.fortifiedfire) then
          defences.got('fortifyall')
        end
      end,

      action = &quot;fortify water&quot;,
      onstart = function ()
        send(&quot;fortify water&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('fortifiedwater')
        defences.lost('fortifyall')
      end
    }
  }
  if not svo.haveskillset('weatherweaving') then
    svo.dict.fortifiedfire = {
      physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true,

        isadvisable = function ()
          return (((((sys.deffing and defdefup[defs.mode].fortifiedfire and not defc.fortifiedfire) or (conf.keepup and defkeepup[defs.mode].fortifiedfire and not defc.fortifiedfire))) or (conf.keepup and defkeepup[defs.mode].fortifiedfire and not defc.fortifiedfire)) and not codepaste.balanceful_defs_codepaste() and defc.fire) or false
        end,

        oncompleted = function ()
          defences.got('fortifiedfire')
          if defc.fortifiedair and defc.fortifiedfire and defc.fortifiedearth and defc.fortifiedwater and (not svo.haveskillset('healing') or defc.fortifiedspirit) then
            defences.got('fortifyall')
          end
        end,

        action = &quot;fortify fire&quot;,
        onstart = function ()
          send(&quot;fortify fire&quot;, conf.commandecho)
        end
      },
      gone = {
        oncompleted = function ()
          defences.lost('fortifiedfire')
          defences.lost('fortifyall')
        end
      }
    }
  end
  svo.dict.fortifiedearth = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((((sys.deffing and defdefup[defs.mode].fortifiedearth and not defc.fortifiedearth) or (conf.keepup and defkeepup[defs.mode].fortifiedearth and not defc.fortifiedearth))) or (conf.keepup and defkeepup[defs.mode].fortifiedearth and not defc.fortifiedearth)) and not codepaste.balanceful_defs_codepaste() and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('fortifiedearth')
        if defc.fortifiedair and defc.fortifiedearth and defc.fortifiedwater and (not svo.haveskillset('healing') or defc.fortifiedspirit) and (svo.haveskillset('weatherweaving') or defc.fortifiedfire) then
          defences.got('fortifyall')
        end
      end,

      action = &quot;fortify earth&quot;,
      onstart = function ()
        send(&quot;fortify earth&quot;, conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('fortifiedearth')
        defences.lost('fortifyall')
      end
    }
  }
  if svo.haveskillset('healing') then
    svo.dict.fortifiedspirit = {
      physical = {
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,
        undeffable = true,

        isadvisable = function ()
          return (((((sys.deffing and defdefup[defs.mode].fortifiedspirit and not defc.fortifiedspirit) or (conf.keepup and defkeepup[defs.mode].fortifiedspirit and not defc.fortifiedspirit))) or (conf.keepup and defkeepup[defs.mode].fortifiedspirit and not defc.fortifiedspirit)) and not codepaste.balanceful_defs_codepaste() and defc.spirit) or false
        end,

        oncompleted = function ()
          defences.got('fortifiedspirit')
          if defc.fortifiedair and defc.fortifiedfire and defc.fortifiedearth and defc.fortifiedwater and defc.fortifiedspirit then
            defences.got('fortifyall')
          end
        end,

        action = &quot;fortify spirit&quot;,
        onstart = function ()
          send(&quot;fortify spirit&quot;, conf.commandecho)
        end
      },
      gone = {
        oncompleted = function ()
          defences.lost('fortifiedspirit')
          defences.lost('fortifyall')
        end
      }
    }
  end
end

if svo.haveskillset('elementalism') then
  svo.dict.waterweird = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
       return (not defc.waterweird and ((sys.deffing and defdefup[defs.mode].waterweird) or (conf.keepup and defkeepup[defs.mode].waterweird)) and not codepaste.balanceful_defs_codepaste() and defc.water) or false
      end,

      oncompleted = function ()
        defences.got('waterweird')
      end,

      action = &quot;cast waterweird at me&quot;,
      onstart = function ()
        send(&quot;cast waterweird at me&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.chargeshield = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.chargeshield and ((sys.deffing and defdefup[defs.mode].chargeshield) or (conf.keepup and defkeepup[defs.mode].chargeshield)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.air) or false
      end,

      oncompleted = function ()
        defences.got('chargeshield')
      end,

      action = &quot;cast chargeshield at me&quot;,
      onstart = function ()
        send(&quot;cast chargeshield at me&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.stonefist = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.stonefist and ((sys.deffing and defdefup[defs.mode].stonefist) or (conf.keepup and defkeepup[defs.mode].stonefist)) and not codepaste.balanceful_defs_codepaste() and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('stonefist')
      end,

      action = &quot;cast stonefist&quot;,
      onstart = function ()
        send(&quot;cast stonefist&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.stoneskin = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.stoneskin and ((sys.deffing and defdefup[defs.mode].stoneskin) or (conf.keepup and defkeepup[defs.mode].stoneskin)) and not codepaste.balanceful_defs_codepaste() and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('stoneskin')
      end,

      action = &quot;cast stoneskin&quot;,
      onstart = function ()
        send(&quot;cast stoneskin&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.diamondskin = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.diamondskin and ((sys.deffing and defdefup[defs.mode].diamondskin) or (conf.keepup and defkeepup[defs.mode].diamondskin)) and not codepaste.balanceful_defs_codepaste() and defc.earth and defc.water and defc.fire) or false
      end,

      oncompleted = function ()
        defences.got('diamondskin')
      end,

      action = &quot;cast diamondskin&quot;,
      onstart = function ()
        send(&quot;cast diamondskin&quot;, conf.commandecho)
      end
    }
  }
end
if svo.haveskillset('elementalism') or svo.haveskillset('weatherweaving') then
  svo.dict.reflection = {
    gamename = 'reflections',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.reflection and ((sys.deffing and defdefup[defs.mode].reflection) or (conf.keepup and defkeepup[defs.mode].reflection)) and not codepaste.balanceful_defs_codepaste() and defc.air and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('reflection')
      end,

      action = &quot;cast reflection at me&quot;,
      onstart = function ()
        send(&quot;cast reflection at me&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('apostasy') then
  svo.dict.baalzadeen = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        if (not defc.baalzadeen and ((sys.deffing and defdefup[defs.mode].baalzadeen) or (conf.keepup and defkeepup[defs.mode].baalzadeen)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) then

          if (stats.mp &gt;= 100) then
             return true
           elseif not sk.gettingfullstats then
             svo.fullstats(true)
             svo.echof(&quot;Getting fullstats for Baalzadeen summoning...&quot;)
           end
        end
      end,

      oncompleted = function ()
        defences.got('baalzadeen')
      end,

      action = &quot;summon baalzadeen&quot;,
      onstart = function ()
        send(&quot;summon baalzadeen&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.armour = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.armour and ((sys.deffing and defdefup[defs.mode].armour) or (conf.keepup and defkeepup[defs.mode].armour)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got('armour')
      end,

      action = &quot;demon armour&quot;,
      onstart = function ()
        send(&quot;demon armour&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.syphon = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.syphon and ((sys.deffing and defdefup[defs.mode].syphon) or (conf.keepup and defkeepup[defs.mode].syphon)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got('syphon')
      end,

      action = &quot;demon syphon&quot;,
      onstart = function ()
        send(&quot;demon syphon&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.mask = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.mask and ((sys.deffing and defdefup[defs.mode].mask) or (conf.keepup and defkeepup[defs.mode].mask)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and defc.baalzadeen) or false
      end,

      oncompleted = function ()
        defences.got('mask')
      end,

      action = 'mask',
      onstart = function ()
        send('mask', conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('weatherweaving') then
  svo.dict.circulate = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.circulate and ((sys.deffing and defdefup[defs.mode].circulate) or (conf.keepup and defkeepup[defs.mode].circulate)) and not codepaste.balanceful_defs_codepaste() and defc.air and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('circulate')
      end,

      action = &quot;cast circulate&quot;,
      onstart = function ()
        send(&quot;cast circulate&quot;, conf.commandecho)
      end
    }
  }
end






if svo.haveskillset('kaido') then
  svo.dict.boosting = {
    gamename = 'boostedregeneration',
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].boosting and not defc.boosting) or (conf.keepup and defkeepup[defs.mode].boosting and not defc.boosting)) and not codepaste.balanceful_defs_codepaste() and defc.regeneration) or false
      end,

      oncompleted = function ()
        defences.got('boosting')
      end,

      action = &quot;boost regeneration&quot;,
      onstart = function ()
        send(&quot;boost regeneration&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.kaiboost = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].kaiboost and not defc.kaiboost) or (conf.keepup and defkeepup[defs.mode].kaiboost and not defc.kaiboost)) and not codepaste.balanceful_defs_codepaste() and stats.kai &gt;= 11 and not svo.doingaction'kaiboost') or false
      end,

      oncompleted = function ()
        defences.got('kaiboost')
      end,

      action = &quot;kai boost&quot;,
      onstart = function ()
        send(&quot;kai boost&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.vitality = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,

      isadvisable = function ()
        if (not defc.vitality and not defc.numb and ((sys.deffing and defdefup[defs.mode].vitality) or (conf.keepup and defkeepup[defs.mode].vitality)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'cantvitality') then

          if (stats.currenthealth &gt;= stats.maxhealth and stats.currentmana &gt;= stats.maxmana) then
            return true
          elseif not sk.gettingfullstats then
            svo.fullstats(true)
            svo.echof(&quot;Getting fullstats for vitality now...&quot;)
          end
        end
      end,

      oncompleted = function ()
        defences.got('vitality')
      end,

      action = 'vitality',
      onstart = function ()
        send('vitality', conf.commandecho)
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('vitality')
        if not svo.actions.cantvitality_waitingfor then svo.doaction(svo.dict.cantvitality.waitingfor) end
      end
    }
  }
end



if svo.haveskillset('tarot') then
  svo.dict.devil = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.devil and ((sys.deffing and defdefup[defs.mode].devil) or (conf.keepup and defkeepup[defs.mode].devil)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('devil')
      end,

      action = &quot;fling devil at ground&quot;,
      onstart = function ()
        sendAll(&quot;outd 1 devil&quot;,&quot;fling devil at ground&quot;,&quot;ind 1 devil&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('shikudo') then
  svo.dict.grip = {
    gamename = 'gripping',
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      action = 'grip',

      isadvisable = function()
        return (
          not defc.grip
          and (
            (sys.deffing and defdefup[defs.mode].grip)
            or (conf.keepup and defkeepup[defs.mode].grip)
          )
          and me.path == 'shikudo'
          and not codepaste.balanceful_defs_codepaste()
          and sys.canoutr
          and not affs.paralysis
          and not affs.prone
        ) or false
      end,

      oncompleted = function()
        defences.got('grip')
      end,

      onstart = function()
        send('grip', conf.commandecho)
      end
    }
  }
  svo.dict.tykonos = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt tykonos form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('tykonos') end,
      oncompleted = function() return shikudo_form_oncompleted('tykonos') end,

      onstart = function ()
        send(&quot;adopt tykonos form&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.willow = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt willow form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('willow') end,
      oncompleted = function() return shikudo_form_oncompleted('willow') end,

      onstart = function ()
        send(&quot;adopt willow form&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.rain = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt rain form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('rain') end,
      oncompleted = function() return shikudo_form_oncompleted('rain') end,

      onstart = function ()
        send(&quot;adopt rain form&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.oak = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt oak form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('oak') end,
      oncompleted = function() return shikudo_form_oncompleted('oak') end,

      onstart = function ()
        send(&quot;adopt oak form&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.gaital = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt gaital form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('gaital') end,
      oncompleted = function() return shikudo_form_oncompleted('gaital') end,

      onstart = function ()
        send(&quot;adopt gaital form&quot;, conf.commandecho)
      end
    },
  }
  svo.dict.maelstrom = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = &quot;adopt maelstrom form&quot;,
      isadvisable = function() return shikudo_ability_isadvisable('maelstrom') end,
      oncompleted = function() return shikudo_form_oncompleted('maelstrom') end,

      onstart = function ()
        send(&quot;adopt maelstrom form&quot;, conf.commandecho)
      end
    },
  }
end

if svo.haveskillset('tekura') then
  svo.dict.bodyblock = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      isadvisable = function() return tekura_ability_isadvisable('bodyblock') end,
      action = 'bdb',

      oncompleted = function ()
        defences.got('bodyblock')
      end,

      onstart = function ()
        send('bdb', conf.commandecho)
      end
    },
  }
  svo.dict.evadeblock = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      action = 'evb',
      isadvisable = function() return tekura_ability_isadvisable('evadeblock') end,

      oncompleted = function ()
        defences.got('evadeblock')
      end,

      onstart = function ()
        send('evb', conf.commandecho)
      end
    },
  }
  svo.dict.pinchblock = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      action = 'pnb',
      isadvisable = function() return tekura_ability_isadvisable('pinchblock') end,

      oncompleted = function ()
        defences.got('pinchblock')
      end,

      onstart = function ()
        send('pnb', conf.commandecho)
      end
    },
  }
  svo.dict.horse = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'hrs',
      isadvisable = function() return tekura_ability_isadvisable('horse') end,
      oncompleted = function() return tekura_stance_oncompleted('horse') end,

      onstart = function ()
        send('hrs', conf.commandecho)
      end
    },
  }
  svo.dict.eagle = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'egs',
      isadvisable = function() return tekura_ability_isadvisable('eagle') end,
      oncompleted = function() return tekura_stance_oncompleted('eagle') end,

      onstart = function ()
        send('egs', conf.commandecho)
      end
    },
  }
  svo.dict.cat = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'cts',
      isadvisable = function() return tekura_ability_isadvisable('cat') end,
      oncompleted = function() return tekura_stance_oncompleted('cat') end,

      onstart = function ()
        send('cts', conf.commandecho)
      end
    },
  }
  svo.dict.bear = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'brs',
      isadvisable = function() return tekura_ability_isadvisable('bear') end,
      oncompleted = function() return tekura_stance_oncompleted('bear') end,

      onstart = function ()
        send('brs', conf.commandecho)
      end
    },
  }
  svo.dict.rat = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'rts',
      isadvisable = function() return tekura_ability_isadvisable('rat') end,
      oncompleted = function() return tekura_stance_oncompleted('rat') end,

      onstart = function ()
        send('rts', conf.commandecho)
      end
    },
  }
  svo.dict.scorpion = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'scs',
      isadvisable = function() return tekura_ability_isadvisable('scorpion') end,
      oncompleted = function() return tekura_stance_oncompleted('scorpion') end,

      onstart = function ()
        send('scs', conf.commandecho)
      end
    },
  }
  svo.dict.dragon = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,
      action = 'drs',
      isadvisable = function() return tekura_ability_isadvisable('dragon') end,
      oncompleted = function() return tekura_stance_oncompleted('dragon') end,

      onstart = function ()
        send('drs', conf.commandecho)
      end
    },
  }
end



if svo.haveskillset('venom') then
  svo.dict.shrugging = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceless_act = true,

      isadvisable = function ()
        if not next(affs) or not bals.shrugging or affs.sleep or not conf.shrugging or affs.stun or affs.unconsciousness or affs.weakness or codepaste.nonstdcure() or defc.dragonform then return false end

        for name, func in pairs(svo.shrugging) do
          if not me.disabledshruggingfunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function (number)
        if number then
          -- empty
          if number+1 == getLineNumber() then
            empty.shrugging()
          end
        end
        signals.after_lifevision_processing:unblock(cnrl.checkwarning)

        svo.lostbal_shrugging()
      end,

      action = 'shrugging',
      onstart = function ()
        send('shrugging', conf.commandecho)
      end,

      offbal = function ()
        svo.lostbal_shrugging()
      end
    }
  }
end

if svo.haveskillset('alchemy') then
  svo.dict.extispicy = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.extispicy and ((sys.deffing and defdefup[defs.mode].extispicy) or (conf.keepup and defkeepup[defs.mode].extispicy)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('extispicy')
      end,

      norat = function()
        if svo.ignore.extispicy then return end

        svo.ignore.extispicy = true

        if sys.deffing then
          echo'\n' svo.echof(&quot;Looks like we have no rat - going to skip extispicy in this defup.&quot;)

          signals.donedefup:connect(function()
            svo.ignore.extispicy = nil
          end, &quot;donedefup ignore extispicy&quot;)
        else
          echo'\n' svo.echof(&quot;Looks like we have no rat for keepup - placing extispicy on ignore.&quot;)
        end
      end,

      action = &quot;dissect rat&quot;,
      onstart = function ()
        send(&quot;dissect rat&quot;, conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('woodlore') then
  svo.dict.impaling = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].impaling and not defc.impaling) or (conf.keepup and defkeepup[defs.mode].impaling and not defc.impaling)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('impaling')
      end,

      onstart = function ()
        send(&quot;set &quot;..(conf.weapon and conf.weapon or 'unknown'), conf.commandecho)
      end
    }
  }
  svo.dict.spinning = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].spinning and not defc.spinning) or (conf.keepup and defkeepup[defs.mode].spinning and not defc.spinning)) and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function ()
        defences.got('spinning')
      end,

      onstart = function ()
        send(&quot;spin &quot;..conf.weapon and conf.weapon or 'unknown', conf.commandecho)
      end
    }
  }
end

if svo.haveskillset('propagation') then
  svo.dict.barkskin = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
       return (not defc.barkskin and ((sys.deffing and defdefup[defs.mode].barkskin) or (conf.keepup and defkeepup[defs.mode].barkskin)) and not codepaste.balanceful_defs_codepaste() and defc.earth) or false
      end,

      oncompleted = function ()
        defences.got('barkskin')
      end,

      action = 'barkskin',
      onstart = function ()
        send('barkskin', conf.commandecho)
      end
    }
  }
  svo.dict.viridian = {
    physical = {
      aspriority = 0,
      spriority = 0,
      unpauselater = false,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].viridian and not defc.viridian) or (conf.keepup and defkeepup[defs.mode].viridian and not defc.viridian)) and not svo.doingaction('waitingforviridian') and not codepaste.balanceful_defs_codepaste()) or false
      end,

      oncompleted = function (def)
        if def and not defc.viridian then defences.got('viridian')
        else svo.doaction(svo.dict.waitingforviridian.waitingfor) end
      end,

      alreadyhave = function ()
        svo.dict.waitingforviridian.waitingfor.oncompleted()
      end,

      indoors = function ()
        if conf.paused and svo.dict.viridian.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Unpaused - you must be outside to cast Viridian.&quot;)
        end
        svo.dict.viridian.physical.unpauselater = false
        defences.got('viridian')
      end,

      notonland = function ()
        if conf.paused and svo.dict.viridian.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;You must be in contact with the earth in order to call upon the might of the Viridian.&quot;)
        end
        svo.dict.viridian.physical.unpauselater = false
        defences.got('viridian')
      end,

      actions = {&quot;assume viridian&quot;, &quot;assume viridian staff&quot;},
      onstart = function ()
        if defc.flail then
          send(&quot;assume viridian staff&quot;, conf.commandecho)
        else
          send(&quot;assume viridian&quot;, conf.commandecho)
        end

        if not conf.paused then
          svo.dict.viridian.physical.unpauselater = true
          conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Temporarily pausing for viridian.&quot;)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('viridian')
      end,
    }
  }
  svo.dict.waitingforviridian = {
    spriority = 0,
    waitingfor = {
      customwait = 20,

      oncompleted = function ()
        defences.got('viridian')
        svo.dict.riding.gone.oncompleted()

        if conf.paused and svo.dict.viridian.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')

          echo&quot;\n&quot;
          svo.echof(&quot;Obtained viridian, unpausing.&quot;)
        end
        svo.dict.viridian.physical.unpauselater = false
      end,

      cancelled = function ()
        if conf.paused and svo.dict.viridian.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Unpausing.&quot;)
        end
        svo.dict.viridian.physical.unpauselater = false
      end,

      ontimeout = function()
        svo.dict.waitingforviridian.waitingfor.cancelled()
      end,

      onstart = function()
      end,
    }
  }
end

if svo.haveskillset('groves') then
  svo.dict.flail = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,
      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].flail and not defc.flail) or (conf.keepup and defkeepup[defs.mode].flail and not defc.flail)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('flail')
      end,

      onstart = function ()
        send('wield quarterstaff', conf.commandecho)
        send('flail quarterstaff', conf.commandecho)
      end
    }
  }
  svo.dict.lyre = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.lyre and not svo.doingaction('lyre') and ((sys.deffing and defdefup[defs.mode].lyre) or (conf.keepup and defkeepup[defs.mode].lyre)) and not svo.will_take_balance() and not conf.lyre_step and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('lyre')

        if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,

      ontimeout = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum didn't happen - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.make_gnomes_work()
        end
      end,

      onkill = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum cancelled - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      end,

      action = &quot;evoke barrier&quot;,
      onstart = function ()
        sys.sendonceonly = true

        -- small fix to make 'lyc' work and be in-order (as well as use batching)
        local send = send
        -- record in systemscommands, so it doesn't get killed later on in the controller and loop
        if conf.batch then send = function(what, ...) svo.sendc(what, ...) sk.systemscommands[what] = true end end

        if not defc.dragonform and (not conf.lyrecmd or conf.lyrecmd == &quot;evoke barrier&quot;) then
          send(&quot;evoke barrier&quot;, conf.commandecho)
        else
          send(tostring(conf.lyrecmd), conf.commandecho)
        end
        sys.sendonceonly = false

        if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('lyre')

        -- as a special case for handling the following scenario:
        --[[(focus)
          Your prismatic barrier dissolves into nothing.
          You focus your mind intently on curing your mental maladies.
          Food is no longer repulsive to you. (7.548s)
          H: 3294 (50%), M: 4911 (89%) 28725e, 10294w 89.3% ex|cdk- 19:24:04.719(sip health|eat bayberry|outr bayberry|eat
          irid|outr irid)(+324h, 5.0%, -291m, 5.3%)
          You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.
          (p) H: 3294 (50%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:04.897
          Your prismatic barrier dissolves into nothing.
          You take a drink from a purple heartwood vial.
          The elixir heals and soothes you.
          H: 4767 (73%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:05.247(+1473h, 22.7%)
          You eat some bayberry bark.
          Your eyes dim as you lose your sight.
        ]]
        -- we want to kill lyre going up when it goes down and you're off balance, because you won't get it up off-bal

        -- but don't kill it if it is in lifevision - meaning we're going to get it:
        --[[
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
          (x) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}
          You have recovered equilibrium. (3.887s)
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
        ]]

        if not (bals.balance and bals.equilibrium) and svo.actions.lyre_physical and not svo.lifevision.l.lyre_physical then svo.killaction(svo.dict.lyre.physical) end

        -- unpause should we lose the lyre def for some reason - but not while we're doing lyc
        -- since we'll lose the lyre def and it'll come up right away
        if conf.lyre and conf.paused and not svo.actions.lyre_physical then conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,
    }
  }
  svo.dict.rejuvenate = {
    description = &quot;auto pauses/unpauses the system when you're rejuvenating the forests&quot;,
    physical = {
      aspriority = 0,
      spriority = 0,
      unpauselater = false,
      balanceful_act = true,

      isadvisable = function ()
        return false
      end,

      oncompleted = function ()
        svo.doaction(svo.dict.waitingforrejuvenate.waitingfor)
      end,

      action = 'rejuvenate',
      onstart = function ()
      -- user commands catching needs this check
        if not (bals.balance and bals.equilibrium) then return end

        send('rejuvenate', conf.commandecho)

        if not conf.paused then
          svo.dict.rejuvenate.physical.unpauselater = true
          conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused')
          echo&quot;\n&quot; svo.echof(&quot;Temporarily pausing to summon the rejuvenate.&quot;)
        end
      end
    }
  }
  svo.dict.waitingforrejuvenate = {
    spriority = 0,
    waitingfor = {
      customwait = 30,

      oncompleted = function ()
        if conf.paused and svo.dict.rejuvenate.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')

          svo.echof(&quot;Finished rejuvenating, unpausing.&quot;)
        end
        svo.dict.rejuvenate.physical.unpauselater = false
      end,

      cancelled = function ()
        if conf.paused and svo.dict.rejuvenate.physical.unpauselater then
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.echof(&quot;Oops, interrupted rejuvenation. Unpausing.&quot;)
        end
        svo.dict.rejuvenate.physical.unpauselater = false
      end,

      ontimeout = function()
        svo.dict.waitingforrejuvenate.waitingfor.cancelled()
      end,

      onstart = function() end
    }
  }
end

-- override groves lyre, as druids can get 2 types of lyre (groves and nightingale)
if svo.haveskillset('metamorphosis') then
  svo.dict.lyre = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.lyre and ((sys.deffing and defdefup[defs.mode].lyre) or (conf.keepup and defkeepup[defs.mode].lyre)) and not svo.will_take_balance() and (not defc.dragonform or (not affs.cantmorph and sk.morphsforskill.lyre)) and not conf.lyre_step and not affs.prone) or false
      end,

      oncompleted = function ()
        defences.got('lyre')

        if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,

      ontimeout = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum didn't happen - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.make_gnomes_work()
        end
      end,

      onkill = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum cancelled - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      end,

      action = &quot;sing melody&quot;,
      onstart = function ()
        if not defc.dragonform and (not conf.lyrecmd or conf.lyrecmd == &quot;sing melody&quot;) then
          if not conf.transmorph and sk.inamorph() and not sk.inamorphfor'lyre' then
            if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
            send('human', conf.commandecho)
          elseif not sk.inamorphfor'lyre' then
            if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
            send(&quot;morph &quot;..sk.morphsforskill.lyre[1], conf.commandecho)

            if conf.transmorph then
              sys.sendonceonly = true
              send(&quot;sing melody&quot;, conf.commandecho)
              sys.sendonceonly = false
              if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
            end
          elseif sk.inamorphfor'lyre' then
            sys.sendonceonly = true
            send(&quot;sing melody&quot;, conf.commandecho)
            sys.sendonceonly = false

            if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
          end
        else
          -- small fix to make 'lyc' work and be in-order (as well as use batching)
          local send = send
        -- record in systemscommands, so it doesn't get killed later on in the controller and loop
        if conf.batch then send = function(what, ...) svo.sendc(what, ...) sk.systemscommands[what] = true end end

          sys.sendonceonly = true
          send(tostring(conf.lyrecmd), conf.commandecho)
          sys.sendonceonly = false

          if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('lyre')

        -- as a special case for handling the following scenario:
        --[[(focus)
          Your prismatic barrier dissolves into nothing.
          You focus your mind intently on curing your mental maladies.
          Food is no longer repulsive to you. (7.548s)
          H: 3294 (50%), M: 4911 (89%) 28725e, 10294w 89.3% ex|cdk- 19:24:04.719(sip health|eat bayberry|outr bayberry|eat
          irid|outr irid)(+324h, 5.0%, -291m, 5.3%)
          You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.
          (p) H: 3294 (50%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:04.897
          Your prismatic barrier dissolves into nothing.
          You take a drink from a purple heartwood vial.
          The elixir heals and soothes you.
          H: 4767 (73%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:05.247(+1473h, 22.7%)
          You eat some bayberry bark.
          Your eyes dim as you lose your sight.
        ]]
        -- we want to kill lyre going up when it goes down and you're off balance, because you won't get it up off-bal

        -- but don't kill it if it is in lifevision - meaning we're going to get it:
        --[[
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
          (x) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}
          You have recovered equilibrium. (3.887s)
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
        ]]

        if not (bals.balance and bals.equilibrium) and svo.actions.lyre_physical and not svo.lifevision.l.lyre_physical then svo.killaction(svo.dict.lyre.physical) end

        -- unpause should we lose the lyre def for some reason - but not while we're doing lyc
        -- since we'll lose the lyre def and it'll come up right away
        if conf.lyre and conf.paused and not svo.actions.lyre_physical then conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,
    }
  }
end

if svo.haveskillset('domination') then
  svo.dict.arctar = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.arctar and ((sys.deffing and defdefup[defs.mode].arctar) or (conf.keepup and defkeepup[defs.mode].arctar)) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and bals.entities) or false
      end,

      oncompleted = function ()
        defences.got('arctar')
      end,

      action = &quot;command orb&quot;,
      onstart = function ()
        send(&quot;command orb&quot;, conf.commandecho)
      end
    }
  }
end
if svo.haveskillset('shadowmancy') then
  svo.dict.shadowcloak = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        local shadowcloak = me.getitem(&quot;a grim cloak&quot;)
        if not defc.dragonform and not defc.shadowcloak and ((sys.deffing and defdefup[defs.mode].shadowcloak) or (conf.keepup and defkeepup[defs.mode].shadowcloak) or (sys.deffing and defdefup[defs.mode].disperse) or (conf.keepup and defkeepup[defs.mode].disperse) or (sys.deffing and defdefup[defs.mode].shadowveil) or (conf.keepup and defkeepup[defs.mode].shadowveil) or (sys.deffing and defdefup[defs.mode].hiding) or (conf.keepup and defkeepup[defs.mode].hiding)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and stats.mp then
          if not shadowcloak then
            if stats.mp &gt;= 100 then
              return true
            elseif not sk.gettingfullstats then
              svo.fullstats(true)
              svo.echof(&quot;Getting fullstats for Shadowcloak summoning...&quot;)
            end
          else
            return true
          end
        end
        return false
      end,

      oncompleted = function ()
        defences.got('shadowcloak')
      end,

      action = &quot;shadow cloak&quot;,
      onstart = function ()
        local shadowcloak = me.getitem(&quot;a grim cloak&quot;)
        if not shadowcloak then
          send(&quot;shadow cloak&quot;, conf.commandecho)
        elseif not shadowcloak.attrib or not shadowcloak.attrib:find('w') then
          send(&quot;wear &quot; .. shadowcloak.id, conf.commandecho)
        else
      defences.got('shadowcloak')
        end
      end
    }
  }
  svo.dict.disperse = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return not defc.dragonform and not defc.disperse and defc.shadowcloak and ((sys.deffing and defdefup[defs.mode].disperse) or (conf.keepup and defkeepup[defs.mode].disperse)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone
      end,

      oncompleted = function ()
        defences.got('disperse')
      end,

      action = &quot;shadow disperse&quot;,
      onstart = function ()
        send(&quot;shadow disperse&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.shadowveil = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return not defc.dragonform and not defc.shadowveil and defc.shadowcloak and ((sys.deffing and defdefup[defs.mode].shadowveil) or (conf.keepup and defkeepup[defs.mode].shadowveil)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone
      end,

      oncompleted = function ()
        defences.got('shadowveil')
      end,

      action = &quot;shadow veil&quot;,
      onstart = function ()
        send(&quot;shadow veil&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.hiding = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return not defc.dragonform and not defc.hiding and defc.shadowcloak and ((sys.deffing and defdefup[defs.mode].hiding) or (conf.keepup and defkeepup[defs.mode].hiding)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone
      end,

      oncompleted = function ()
        defences.got('hiding')
      end,

      action = &quot;shadow veil&quot;,
      onstart = function ()
        send(&quot;shadow veil&quot;, conf.commandecho)
      end
    }
  }
end
if svo.haveskillset('aeonics') then
  svo.dict.dilation = {
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (((sys.deffing and defdefup[defs.mode].dilation and not defc.dilation) or (conf.keepup and defkeepup[defs.mode].dilation and not defc.dilation)) and not codepaste.balanceful_defs_codepaste() and not svo.doingaction'dilation' and (stats.age and stats.age &gt; 0)) or false
      end,

      oncompleted = function ()
        defences.got('dilation')
      end,

      actions = {&quot;chrono dilation&quot;, &quot;chrono dilation boost&quot;},
      onstart = function ()
        send(&quot;chrono dilation&quot;, conf.commandecho)
      end
    }
  }
end
if svo.haveskillset('terminus') then
  svo.dict.trusad = {
    gamename = 'precision',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.trusad and ((sys.deffing and defdefup[defs.mode].trusad) or (conf.keepup and defkeepup[defs.mode].trusad)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('trusad')
      end,

      action = &quot;intone trusad&quot;,
      onstart = function ()
        send(&quot;intone trusad&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.tsuura = {
    gamename = 'durability',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.tsuura and ((sys.deffing and defdefup[defs.mode].tsuura) or (conf.keepup and defkeepup[defs.mode].tsuura)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('tsuura')
      end,

      action = &quot;intone tsuura&quot;,
      onstart = function ()
        send(&quot;intone tsuura&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.ukhia = {
    gamename = 'bloodquell',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.ukhia and ((sys.deffing and defdefup[defs.mode].ukhia) or (conf.keepup and defkeepup[defs.mode].ukhia)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('ukhia')
      end,

      action = &quot;intone ukhia&quot;,
      onstart = function ()
        send(&quot;intone ukhia&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.qamad = {
    gamename = 'ironwill',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.qamad and ((sys.deffing and defdefup[defs.mode].qamad) or (conf.keepup and defkeepup[defs.mode].qamad)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('qamad')
      end,

      action = &quot;intone qamad&quot;,
      onstart = function ()
        send(&quot;intone qamad&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.mainaas = {
    gamename = 'bodyaugment',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.mainaas and ((sys.deffing and defdefup[defs.mode].mainaas) or (conf.keepup and defkeepup[defs.mode].mainaas)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('mainaas')
      end,

      action = &quot;intone mainaas&quot;,
      onstart = function ()
        send(&quot;intone mainaas&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.gaiartha = {
    gamename = 'antiforce',
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc.dragonform and not defc.gaiartha and ((sys.deffing and defdefup[defs.mode].gaiartha) or (conf.keepup and defkeepup[defs.mode].gaiartha)) and not codepaste.balanceful_defs_codepaste() and not affs.paralysis and not affs.prone and bals.word) or false
      end,

      oncompleted = function ()
        defences.got('gaiartha')
      end,

      action = &quot;intone gaiartha&quot;,
      onstart = function ()
        send(&quot;intone gaiartha&quot;, conf.commandecho)
      end
    }
  }
  svo.dict.lyre = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.lyre and not svo.doingaction('lyre') and ((sys.deffing and defdefup[defs.mode].lyre) or (conf.keepup and defkeepup[defs.mode].lyre)) and not svo.will_take_balance() and not conf.lyre_step and not affs.prone and (defc.dragonform or (conf.lyrecmd and conf.lyrecmd ~= &quot;intone kail&quot;) or bals.word)) or false
      end,

      oncompleted = function ()
        defences.got('lyre')

        if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,

      ontimeout = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum didn't happen - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
          svo.make_gnomes_work()
        end
      end,

      onkill = function()
        if conf.paused and not defc.lyre then
          svo.echof(&quot;Lyre strum cancelled - unpausing.&quot;)
          conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      end,

      action = &quot;intone kail&quot;,
      onstart = function ()
        sys.sendonceonly = true

        -- small fix to make 'lyc' work and be in-order (as well as use batching)
        local send = send
        -- record in systemscommands, so it doesn't get killed later on in the controller and loop
        if conf.batch then send = function(what, ...) svo.sendc(what, ...) sk.systemscommands[what] = true end end

        if not defc.dragonform and not conf.lyrecmd then
          send(&quot;intone kail&quot;, conf.commandecho)
        elseif conf.lyrecmd then
          send(tostring(conf.lyrecmd), conf.commandecho)
        else
          send(&quot;strum lyre&quot;, conf.commandecho)
        end
        sys.sendonceonly = false

        if conf.lyre then conf.paused = true; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('lyre')

        -- as a special case for handling the following scenario:
        --[[(focus)
          Your prismatic barrier dissolves into nothing.
          You focus your mind intently on curing your mental maladies.
          Food is no longer repulsive to you. (7.548s)
          H: 3294 (50%), M: 4911 (89%) 28725e, 10294w 89.3% ex|cdk- 19:24:04.719(sip health|eat bayberry|outr bayberry|eat
          irid|outr irid)(+324h, 5.0%, -291m, 5.3%)
          You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.
          (p) H: 3294 (50%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:04.897
          Your prismatic barrier dissolves into nothing.
          You take a drink from a purple heartwood vial.
          The elixir heals and soothes you.
          H: 4767 (73%), M: 4911 (89%) 28725e, 10194w 89.3% x|cdk- 19:24:05.247(+1473h, 22.7%)
          You eat some bayberry bark.
          Your eyes dim as you lose your sight.
        ]]
        -- we want to kill lyre going up when it goes down and you're off balance, because you won't get it up off-bal

        -- but don't kill it if it is in lifevision - meaning we're going to get it:
        --[[
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
          (x) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}
          You have recovered equilibrium. (3.887s)
          (ex) 4600h|100%, 4000m|84%, 100w%, 100e%, (cdbkr)-  {9 Mayan 637}(strum lyre)
          Your prismatic barrier dissolves into nothing.
          You strum a Lasallian lyre, and a prismatic barrier forms around you.
          (svo): Lyre strum cancelled - unpausing.
        ]]

        if not (bals.balance and bals.equilibrium) and svo.actions.lyre_physical and not svo.lifevision.l.lyre_physical then svo.killaction(svo.dict.lyre.physical) end

        -- unpause should we lose the lyre def for some reason - but not while we're doing lyc
        -- since we'll lose the lyre def and it'll come up right away
        if conf.lyre and conf.paused and not svo.actions.lyre_physical then conf.paused = false; raiseEvent(&quot;svo config changed&quot;, 'paused') end
      end,
    }
  }
end

if svo.me.class == 'Sentinel' then
  svo.dict.basilisk = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.basilisk and ((sys.deffing and defdefup[defs.mode].basilisk) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].basilisk)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('basilisk')
      end,

      action = &quot;morph basilisk&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph basilisk&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('basilisk')
      end,
    }
  }
end
if svo.me.class == 'Sentinel' then
  svo.dict.jaguar = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.jaguar and ((sys.deffing and defdefup[defs.mode].jaguar) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].jaguar)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('jaguar')
      end,

      action = &quot;morph jaguar&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph jaguar&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('jaguar')
      end,
    }
  }
end
if svo.me.class == 'Druid' then
  svo.dict.wyvern = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.wyvern and ((sys.deffing and defdefup[defs.mode].wyvern) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].wyvern)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('wyvern')
      end,

      action = &quot;morph wyvern&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph wyvern&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('wyvern')
      end,
    }
  }
  svo.dict.hydra = {
    physical = {
      balanceful_act = true,
      aspriority = 0,
      spriority = 0,
      def = true,
      undeffable = true,

      isadvisable = function ()
        return (not defc.hydra and ((sys.deffing and defdefup[defs.mode].hydra) or (not sys.deffing and conf.keepup and defkeepup[defs.mode].hydra)) and not codepaste.balanceful_defs_codepaste() and not affs.cantmorph and codepaste.nonmorphdefs()) or false
      end,

      oncompleted = function ()
        sk.clearmorphs()

        defences.got('hydra')
      end,

      action = &quot;morph hydra&quot;,
      onstart = function ()
        if not conf.transmorph and sk.inamorph() then
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send('human', conf.commandecho)
        else
          if defc.flame then send(&quot;relax flame&quot;, conf.commandecho) end
          send(&quot;morph hydra&quot;, conf.commandecho)
        end
      end
    },
    gone = {
      oncompleted = function ()
        defences.lost('hydra')
      end,
    }
  }
end
if svo.haveskillset('healing') then
  svo.dict.usehealing = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        if not next(affs) or not bals.balance or not bals.equilibrium or not bals.healing or conf.usehealing == 'none' or not svo.can_usemana() or svo.doingaction'usehealing' or affs.transfixed or stats.currentwillpower &lt;= 50 or defc.bedevil or ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) then return false end

        -- we calculate here if we can use Healing on any of the affs we got; cache the result as well

        -- small func for getting the spriority of a thing
        local function getprio(what)
          local type = type
          for _,v in pairs(what) do
            if type(v) == 'table' and v.spriority then
              return v.spriority
            end
          end
        end

        local t = {}
        for affname, _ in pairs(affs) do
          if sk.healingmap[affname] and not svo.ignore[affname] and not svo.doingaction(affname) and not svo.doingaction('curing'..affname) and sk.healingmap[affname]() then
            t[affname] = getprio(svo.dict[affname])
          end
        end

        if not next(t) then return false end
        svo.dict.usehealing.afftocure = svo.getHighestKey(t)
        return true
      end,

      oncompleted = function()
        if not svo.dict.usehealing.curingaff or (svo.dict.usehealing.curingaff ~= 'deaf' and svo.dict.usehealing.curingaff ~= 'blind') then
          svo.lostbal_healing()
        end

        svo.dict.usehealing.curingaff = nil
      end,

      empty = function ()
        if not svo.dict.usehealing.curingaff or (svo.dict.usehealing.curingaff ~= 'deaf' and svo.dict.usehealing.curingaff ~= 'blind') then
          svo.lostbal_healing()
        end

        if not svo.dict.usehealing.curingaff then return end
        svo.rmaff(svo.dict.usehealing.curingaff)
        svo.dict.usehealing.curingaff = nil
      end,

      -- haven't regained healing balance yet
      nobalance = function()
        if not svo.dict.usehealing.curingaff or (svo.dict.usehealing.curingaff ~= 'deaf' and svo.dict.usehealing.curingaff ~= 'blind') then
          svo.lostbal_healing()
        end

        svo.dict.usehealing.curingaff = nil
      end,

      -- have bedevil def up; can't use healing
      bedevilheal = function()
        svo.dict.usehealing.curingaff = nil
        defences.got('bedevil')
      end,

      onstart = function ()
        local aff = svo.dict.usehealing.afftocure
        local svonames = {
          blind = 'blindness',
          deaf = 'deafness',
          blindaff = 'blindness',
          deafaff = 'deafness',
          illness = 'vomiting',
          weakness = 'weariness',
          crippledleftarm = 'arms',
          crippledrightarm = 'arms',
          crippledleftleg = 'legs',
          crippledrightleg = 'legs',
          unknowncrippledleg = 'legs',
          unknowncrippledarm = 'arms',
          ablaze = 'burning',
        }

        local use_no_name = {
          unknowncrippledlimb = true,
          blackout = true,
        }

        if use_no_name[aff] then
          send('heal', conf.commandecho)
        else
          send(&quot;heal me &quot;..(svonames[aff] or aff), conf.commandecho)
        end
        svo.dict.usehealing.curingaff = svo.dict.usehealing.afftocure
        svo.dict.usehealing.afftocure = nil
      end
    }
  }
end
if svo.haveskillset('kaido') then
  svo.dict.transmute = {
    -- transmutespam is used to throttle bleed spamming so it doesn't get out of control
    transmutespam = false,
    transmutereps = 0,
    physical = {
      balanceless_act = true,
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (conf.transmute ~= 'none' and not defc.dragonform and (stats.currenthealth &lt; sys.transmuteamount or (sk.gettingfullstats and stats.currenthealth &lt; stats.maxhealth)) and not svo.doingaction'healhealth' and not svo.doingaction'transmute' and not codepaste.balanceful_codepaste() and svo.can_usemana() and (not affs.prone or svo.doingaction'prone') and not svo.dict.transmute.transmutespam) or false
      end,

      oncompleted = function()
        -- count down transmute reps, and if we can, cancel the transmute-blocking timer
        svo.dict.transmute.transmutereps = svo.dict.transmute.transmutereps - 1
        if svo.dict.transmute.transmutereps &lt;= 0 then
          -- in case transmute expired and we finish after
          if svo.dict.transmute.transmutespam then killTimer(svo.dict.transmute.transmutespam); svo.dict.transmute.transmutespam = nil end
          svo.dict.transmute.transmutereps = 0
        end
      end,

      onstart = function ()
        local necessary_amount = (not sk.gettingfullstats and math.ceil(sys.transmuteamount - stats.currenthealth) or (stats.maxhealth - stats.currenthealth))
        local available_mana = math.floor(stats.currentmana - sys.manause)

        -- compute just how much of the necessary amount can we transmute given our available mana, and a 1:1 health gain/mana loss mapping
        necessary_amount = (available_mana &gt; necessary_amount) and necessary_amount or available_mana

        svo.dict.transmute.transmutereps = 0
        local reps = math.floor(necessary_amount/1000)

        for _ = 1, reps do
          send(&quot;transmute 1000&quot;, conf.commandecho)
          svo.dict.transmute.transmutereps = svo.dict.transmute.transmutereps + 1
        end
        if necessary_amount % 1000 ~= 0 then
          send(&quot;transmute &quot;..necessary_amount % 1000, conf.commandecho)
          svo.dict.transmute.transmutereps = svo.dict.transmute.transmutereps + 1
        end

        -- after sending a bunch of transmutes, wait a bit before doing it again
        if svo.dict.transmute.transmutespam then killTimer(svo.dict.transmute.transmutespam); svo.dict.transmute.transmutespam = nil end
        svo.dict.transmute.transmutespam = tempTimer(svo.getping()*1.5, function () svo.dict.transmute.transmutespam = nil; svo.dict.transmute.transmutereps = 0 svo.make_gnomes_work() end)
        -- if it's just one transmute, then we can get it done in ping time (but allow for flexibility) - otherwise do it in 2x ping time, as there's a big skip between the first and latter commands
      end
    }
  }
end
if svo.haveskillset('voicecraft') then
  svo.dict.dwinnu = {
    misc = {
      aspriority = 0,
      spriority = 0,

      isadvisable = function ()
        return (conf.dwinnu and bals.voice and (affs.webbed or affs.roped) and codepaste.writhe() and not affs.paralysis and not defc.dragonform) or false
      end,

      oncompleted = function ()
        svo.rmaff{'webbed', 'roped'}
        svo.lostbal_voice()
      end,

      action = &quot;chant dwinnu&quot;,
      onstart = function ()
        send(&quot;chant dwinnu&quot;, conf.commandecho)
      end
    },
  }
end

if svo.haveskillset('chivalry') then
  svo.dict.rage = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        if not (conf.rage and bals.rage and (affs.inlove or affs.justice or affs.generosity or affs.pacifism or affs.peace) and not defc.dragonform and svo.can_usemana()) then return false end

        for name, func in pairs(svo.rage) do
          if not me.disabledragefunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function ()
        svo.lostbal_rage()
      end,

      empty = function ()
        svo.rmaff{'inlove', 'justice', 'generosity', 'pacifism', 'peace'}
        svo.lostbal_rage()
      end,

      action = 'rage',
      onstart = function ()
        send('rage', conf.commandecho)
      end
    },
  }
end
if svo.haveskillset('metamorphosis') then
  svo.dict.cantmorph = {
    waitingfor = {
      customwait = 30,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,
      ontimeout = function ()
        svo.rmaff('cantmorph')
        echo&quot;\n&quot;svo.echof(&quot;We can probably morph again now.&quot;)
      end,

      oncompleted = function ()
        svo.rmaff('cantmorph')
      end
    },
    aff = {
      oncompleted = function ()
        svo.addaffdict(svo.dict.cantmorph)
      end
    },
    gone = {
      oncompleted = function ()
        svo.rmaff('cantmorph')
      end,
    }
  }
end
if svo.haveskillset('metamorphosis') or svo.haveskillset('kaido') then
  svo.dict.cantvitality = {
    waitingfor = {
      customwait = 122,

      isadvisable = function ()
        return false
      end,

      onstart = function () end,
      ontimeout = function ()
        if not defc.vitality then
          echo&quot;\n&quot;svo.echof(&quot;We can vitality again now.&quot;)
          svo.make_gnomes_work()
        end
      end,

      oncompleted = function ()
        svo.dict.cantvitality.waitingfor.ontimeout()
      end
    },
    gone = {
      oncompleted = function ()
        svo.killaction(svo.dict.cantvitality.waitingfor)
      end
    }
  }
end
if svo.haveskillset('weaponmastery') then
  svo.dict.footingattack = {
    description = &quot;Tracks attacks suitable for use with balanceless recover footing&quot;,
    happened = {
      oncompleted = function ()
        sk.didfootingattack = true
      end
    }
  }
end
if svo.haveskillset('aeonics') then
  svo.dict.age = {
    happened = {
      onstart = function () end,

      oncompleted = function(amount)
        if amount &gt; 1400 then
          svo.ignore_illusion(&quot;Age went over the possible max&quot;)
          stats.age = 0
        elseif amount == 0 then
          if svo.dict.age.happened.timer then killTimer(svo.dict.age.happened.timer) end
          stats.age = 0
          svo.dict.age.happened.timer = nil
        else
          if svo.dict.age.happened.timer then killTimer(svo.dict.age.happened.timer) end
          svo.dict.age.happened.timer = tempTimer(6 + svo.getping(), function()
            svo.ignore_illusion(&quot;Age tick timed out&quot;)
            stats.age = 0
          end)
          stats.age = amount
        end
      end
    }
  }
end
if svo.haveskillset('chivalry') or svo.haveskillset('striking') or svo.haveskillset('kaido') then
  svo.dict.fitness = {
    physical = {
      aspriority = 0,
      spriority = 0,
      balanceful_act = true,
      uncurable = true,

      isadvisable = function ()
        if not (not affs.weakness and not defc.dragonform and bals.fitness and not codepaste.balanceful_defs_codepaste()) then
          return false
        end

        for name, func in pairs(svo.fitness) do
          if not me.disabledfitnessfunc[name] then
            local s,m = pcall(func[1])
            if s and m then return true end
          end
        end
      end,

      oncompleted = function ()
        svo.rmaff('asthma')
        svo.lostbal_fitness()
      end,

      curedasthma = function ()
        svo.rmaff('asthma')
        svo.lostbal_fitness()
      end,

      weakness = function ()
        svo.addaffdict(svo.dict.weakness)

      end,

      allgood = function()
        svo.rmaff('asthma')
      end,

      actions = {'fitness'},
      onstart = function ()
        send('fitness', conf.commandecho)
      end
    },
  }
end
if svo.haveskillset('devotion') then
  svo.dict.bloodsworntoggle = {
    misc = {
      aspriority = 0,
      spriority = 0,
      uncurable = true,

      isadvisable = function ()
        return (defc.bloodsworn and conf.bloodswornoff and stats.currenthealth &lt;= sys.bloodswornoff and not svo.doingaction'bloodsworntoggle' and not defc.dragonform) or false
      end,

      oncompleted = function ()
        defences.lost('bloodsworn')
      end,

      action = &quot;bloodsworn off&quot;,
      onstart = function ()
        send(&quot;bloodsworn off&quot;, conf.commandecho)
      end
    }
  }
end

function svo.basicdef(which, command, balanceless, gamename, undeffable)
  svo.dict[which] = {
    physical = {
      aspriority = 0,
      spriority = 0,
      def = true,

      isadvisable = function ()
        return (not defc[which] and ((sys.deffing and defdefup[defs.mode][which]) or (conf.keepup and defkeepup[defs.mode][which])) and not codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.paralysis and not affs.prone and (balanceless or not svo.doingaction(which))) or false
      end,

      oncompleted = function ()
        defences.got(which)
      end,

      action = command,
      onstart = function ()
        send(command, conf.commandecho)
      end
    }
  }
  if gamename then
    svo.dict[which].gamename = gamename
  end
  if balanceless then
    svo.dict[which].balanceless_act = true
  else
    svo.dict[which].balanceful_act = true
  end
  if undeffable then
    svo.dict[which].undeffable = true
  end
end
local basicdef = svo.basicdef

basicdef('satiation', 'satiation')
basicdef('treewatch', &quot;treewatch on&quot;, true)
basicdef('skywatch', &quot;skywatch on&quot;, true)
basicdef('groundwatch', &quot;groundwatch on&quot;, true)
basicdef('telesense', &quot;telesense on&quot;, true)
basicdef('softfocus', &quot;softfocus on&quot;, true, 'softfocusing')
basicdef('vigilance', &quot;vigilance on&quot;, true)
basicdef('magicresist', &quot;activate magic resistance&quot;, true)
basicdef('fireresist', &quot;activate fire resistance&quot;, true)
basicdef('coldresist', &quot;activate cold resistance&quot;, true)
basicdef('electricresist', &quot;activate electric resistance&quot;, true)
basicdef('alertness', &quot;alertness on&quot;)
basicdef('bell', &quot;touch bell&quot;, true, 'belltattoo')
basicdef('hypersight', &quot;hypersight on&quot;)
basicdef('curseward', 'curseward')
basicdef('clinging', 'cling')
if svo.haveskillset('necromancy') then
  basicdef('putrefaction', 'putrefaction')
  basicdef('shroud', 'shroud')
  basicdef('vengeance', &quot;vengeance on&quot;)
  basicdef('deathaura', &quot;deathaura on&quot;)
  basicdef('soulcage', &quot;soulcage activate&quot;)
end
if svo.haveskillset('chivalry') then
  basicdef('mastery', &quot;mastery on&quot;, true, 'blademastery')
  basicdef('sturdiness', &quot;stand firm&quot;, false, 'standingfirm')
  basicdef('weathering', 'weathering', true)
  basicdef('resistance', 'resistance', true)
  basicdef('grip', 'grip', true, 'gripping')
  basicdef('fury', &quot;fury on&quot;)
end
if svo.haveskillset('devotion') then
  basicdef('inspiration', &quot;perform inspiration&quot;)
  basicdef('bliss', &quot;perform bliss&quot;, nil, nil, true)
end
if svo.haveskillset('spirituality') then
  basicdef('heresy', &quot;hunt heresy&quot;)
end
if svo.haveskillset('shindo') then
  basicdef('clarity', 'clarity', nil, nil, true)
  basicdef('sturdiness', &quot;stand firm&quot;, false, 'standingfirm')
  basicdef('weathering', 'weathering', true)
  basicdef('grip', 'grip', true, 'gripping')
  basicdef('toughness', 'toughness', true)
  basicdef('mindnet', &quot;mindnet on&quot;)
  basicdef('constitution', 'constitution')
  basicdef('waterwalk', 'waterwalk', false, 'waterwalking')
  basicdef('retaliationstrike', 'retaliationstrike', nil, 'retaliation')
  basicdef('shintrance', &quot;shin trance&quot;)
  basicdef('consciousness', &quot;consciousness on&quot;)
  basicdef('bind', &quot;binding on&quot;, nil, nil, true)
  basicdef('projectiles', &quot;projectiles on&quot;)
  basicdef('dodging', &quot;dodging on&quot;)
  basicdef('immunity', 'immunity')
end
if svo.haveskillset('metamorphosis') then
  basicdef('bonding', &quot;bond spirit&quot;, nil, nil, true)
end
if svo.haveskillset('swashbuckling') then
  basicdef('arrowcatch', &quot;arrowcatch on&quot;, nil, 'arrowcatching')
  basicdef('balancing', &quot;balancing on&quot;)
  basicdef('acrobatics', &quot;acrobatics on&quot;)
  basicdef('dodging', &quot;dodging on&quot;)
  basicdef('grip', 'grip', true, 'gripping')
end
if svo.haveskillset('voicecraft') then
  basicdef('songbird', &quot;whistle for songbird&quot;)
end
if svo.haveskillset('harmonics') then
  basicdef('lament', &quot;play lament&quot;, nil, nil, true)
  basicdef('anthem', &quot;play anthem&quot;, nil, nil, true)
  basicdef('harmonius', &quot;play harmonius&quot;, nil, nil, true)
  basicdef('contradanse', &quot;play contradanse&quot;, nil, nil, true)
  basicdef('paxmusicalis', &quot;play paxmusicalis&quot;, nil, nil, true)
  basicdef('gigue', &quot;play gigue&quot;, nil, nil, true)
  basicdef('bagatelle', &quot;play bagatelle&quot;, nil, nil, true)
  basicdef('partita', &quot;play partita&quot;, nil, nil, true)
  basicdef('berceuse', &quot;play berceuse&quot;, nil, nil, true)
  basicdef('continuo', &quot;play continuo&quot;, nil, nil, true)
  basicdef('wassail', &quot;play wassail&quot;, nil, nil, true)
  basicdef('canticle', &quot;play canticle&quot;, nil, nil, true)
  basicdef('reel', &quot;play reel&quot;, nil, nil, true)
  basicdef('hallelujah', &quot;play hallelujah&quot;, nil, nil, true)
end
if svo.haveskillset('occultism') then
  basicdef('shroud', 'shroud')
  basicdef('astralvision', 'astralvision', nil, nil, true)
  basicdef('distortedaura', 'distortaura')
  basicdef('tentacles', 'tentacles')
  basicdef('devilmark', 'devilmark')
  basicdef('heartstone', 'heartstone', nil, nil, true)
  basicdef('simulacrum', 'simulacrum', nil, nil, true)
  basicdef('transmogrify', &quot;transmogrify activate&quot;, nil, nil, true)
end
if svo.haveskillset('elementalism') then
  basicdef('efreeti', &quot;cast efreeti&quot;, nil, nil, true)
end
if svo.haveskillset('apostasy') then
  basicdef('daegger', &quot;summon daegger&quot;, nil, nil, true)
  basicdef('pentagram', &quot;carve pentagram&quot;, nil, nil, true)
end
if svo.haveskillset('evileye') then
  basicdef('truestare', 'truestare')
end
if svo.haveskillset('pranks') then
  basicdef('arrowcatch', &quot;arrowcatch on&quot;, nil, 'arrowcatching')
  basicdef('balancing', &quot;balancing on&quot;)
  basicdef('acrobatics', &quot;acrobatics on&quot;)
  basicdef('slipperiness', 'slipperiness', nil, 'slippery')
end
if svo.haveskillset('puppetry') or svo.haveskillset('vodun') then
  basicdef('grip', 'grip', true, 'gripping')
end
if svo.haveskillset('curses') then
  basicdef('swiftcurse', 'swiftcurse')
end
if svo.haveskillset('kaido') then
  basicdef('numb', 'numb', nil, nil, true)
  basicdef('weathering', 'weathering', true)
  basicdef('nightsight', &quot;nightsight on&quot;, true)
  basicdef('immunity', 'immunity')
  basicdef('regeneration', &quot;regeneration on&quot;, true)
  basicdef('resistance', 'resistance', true)
  basicdef('toughness', 'toughness', true)
  basicdef('trance', &quot;kai trance&quot;, true, 'kaitrance')
  basicdef('consciousness', &quot;consciousness on&quot;, true)
  basicdef('projectiles', &quot;projectiles on&quot;, true)
  basicdef('dodging', &quot;dodging on&quot;, true)
  basicdef('constitution', 'constitution')
  basicdef('splitmind', &quot;split mind&quot;)
  basicdef('sturdiness', &quot;stand firm&quot;, false, 'standingfirm')
end
if svo.haveskillset('telepathy') then
  basicdef('mindtelesense', &quot;mind telesense on&quot;, true)
  basicdef('hypersense', &quot;mind hypersense on&quot;)
  basicdef('mindnet', &quot;mindnet on&quot;, true)
  basicdef('mindcloak', &quot;mind cloak on&quot;, true)
end
if svo.haveskillset('skirmishing') then
  basicdef('scout', 'scout', nil, 'scouting')
end
if svo.haveskillset('weaponmastery') then
  basicdef('deflect', 'deflect', true)
end
if svo.haveskillset('subterfuge') then
  basicdef('scales', 'scales')
  basicdef('hiding', 'hide', false, 'hiding', true)
  basicdef('pacing', &quot;pacing on&quot;)
  basicdef('bask', 'bask', false, 'basking')
  basicdef('listen', 'listen', false, false, true)
  basicdef('eavesdrop', 'eavesdrop', false, 'eavesdropping', true) -- serverside bugs out and doesn't accept it
  basicdef('lipread', 'lipread', false, 'lipreading', true) -- serverside bugs and does it while blind
  basicdef('weaving', &quot;weaving on&quot;)
  basicdef('cloaking', &quot;conjure cloak&quot;, false, 'shroud')
  basicdef('ghost', &quot;conjure ghost&quot;)
  basicdef('phase', 'phase', false, 'phased', true)
  basicdef('secondsight', 'secondsight')
end
if svo.haveskillset('alchemy') then
  basicdef('lead', &quot;educe lead&quot;, nil, nil, true)
  basicdef('tin', &quot;educe tin&quot;)
  basicdef('sulphur', &quot;educe sulphur&quot;)
  basicdef('mercury', &quot;educe mercury&quot;)
  basicdef('empower', &quot;astronomy empower me&quot;, nil, nil, true)
end
if svo.haveskillset('woodlore') then
  basicdef('barkskin', 'barkskin')
  basicdef('fleetness', 'fleetness')
  basicdef('hiding', 'hide', false, 'hiding', true)
  basicdef('firstaid', &quot;firstaid on&quot;)
end
if svo.haveskillset('groves') then
  basicdef('panacea', &quot;evoke panacea&quot;, false, false, true)
  basicdef('vigour', &quot;evoke vigour&quot;, false, false, true)
  basicdef('roots', &quot;grove roots&quot;, false, false, true)
  basicdef('wildgrowth', &quot;evoke wildgrowth&quot;, false, false, true)
  basicdef('dampening', &quot;evoke dampening&quot;, false, false, true)
  basicdef('snowstorm', &quot;evoke snowstorm&quot;, false, false, true)
  basicdef('roots', &quot;grove roots&quot;, false, false, true)
  basicdef('concealment', &quot;grove concealment&quot;, false, false, true)
  basicdef('screen', &quot;grove screen&quot;, false, false, true)
  basicdef('swarm', &quot;call new swarm&quot;, false, false, true)
  basicdef('harmony', &quot;evoke harmony me&quot;, false, false, true)
end
if svo.haveskillset('domination') then
  basicdef('golgotha', &quot;summon golgotha&quot;, nil, 'golgothagrace')
end

for ssa, svoa in pairs(svo.dict.sstosvoa) do
  if type(svoa) == 'string' then svo.dict.svotossa[svoa] = ssa end
end

for ssd, svod in pairs(svo.dict.sstosvod) do
  if type(svod) == 'string' then svo.dict.svotossd[svod] = ssd end
end

-- finds the lowest missing priority num for given balance
function svo.find_lowest_async(balance)
  local data = svo.make_prio_table(balance)
  local t = {}

  for k,_ in pairs(data) do
    t[#t+1] = k
  end

  table.sort(t)

  local function contains(value)
    for _, v in ipairs(t) do
      if v == value then return true end
    end
    return false
  end

  for i = 1, table.maxn(t) do
    if not contains(i) then return i end
  end

  return table.maxn(t)+1
end

function svo.find_lowest_sync()
  local data = svo.make_sync_prio_table(&quot;%s%s&quot;)
  local t = {}

  for k,_ in pairs(data) do
    t[#t+1] = k
  end

  table.sort(t)
  local function contains(value)
    for _, v in ipairs(t) do
      if v == value then return true end
    end
    return false
  end

  for i = 1, table.maxn(t) do
    if not contains(i) then return i end
  end

  return table.maxn(t)+1
end

function svo.dict_setup()
  svo.dict_balanceful  = {}
  svo.dict_balanceless = {}
  -- defence shortlists
  svo.dict_herb      = {}
  svo.dict_misc      = {}
  svo.dict_misc_def  = {}
  svo.dict_purgative = {}
  svo.dict_salve_def = {}
  svo.dict_smoke_def = {}

  local unassigned_actions      = {}
  local unassigned_sync_actions = {}

  for action, balance in pairs(svo.dict) do
    for balancename, balancedata in pairs(balance) do
      if type(balancedata) == 'table' then
        if not balancedata.name then balancedata.name = action .. '_' .. balancename end
        if not balancedata.balance then balancedata.balance = balancename end
        if not balancedata.action_name then balancedata.action_name = action end
        if balancedata.aspriority == 0 then
          unassigned_actions[balancename] = unassigned_actions[balancename] or {}
          unassigned_actions[balancename][#unassigned_actions[balancename]+1] = action
        end
        if balancedata.spriority == 0 then
          unassigned_sync_actions[balancename] = unassigned_sync_actions[balancename] or {}
          unassigned_sync_actions[balancename][#unassigned_sync_actions[balancename]+1] = action
        end

        -- if it's a def, create the gone handler as well so lifevision will watch it
        if not balance.gone and balancedata.def then
          balance.gone = {
            name = action .. '_gone',
            balance = 'gone',
            action_name = action,

            oncompleted = function ()
              defences.lost(action)
            end
          }
        end
      end
    end

    if not balance.name then balance.name = action end
    if balance.physical and balance.physical.balanceless_act and not balance.physical.def then svo.dict_balanceless[action] = {p = svo.dict[action]} end
    if balance.physical and balance.physical.balanceful_act and not balance.physical.def then svo.dict_balanceful[action] = {p = svo.dict[action]} end

    if balance.purgative and balance.purgative.def then
      svo.dict_purgative[action] = {p = svo.dict[action]} end

    -- balanceful and balanceless moved to a signal for dragonform!

    if balance.misc and balance.misc.def then
      svo.dict_misc_def[action] = {p = svo.dict[action]} end

    if balance.smoke and balance.smoke.def then
      svo.dict_smoke_def[action] = {p = svo.dict[action]} end

    if balance.salve and balance.salve.def then
      svo.dict_salve_def[action] = {p = svo.dict[action]} end

    if balance.misc and not balance.misc.def then
      svo.dict_misc[action] = {p = svo.dict[action]} end

    if balance.herb and balance.herb.def then
      svo.dict_herb[action] = {p = svo.dict[action]} end

    if balance.herb and not balance.herb.noeffect then
      balance.herb.noeffect = function()
        svo.lostbal_herb(true)
      end
    end

    -- mickey steals balance and gives illness
    if balance.herb and not balance.herb.mickey then
      balance.herb.mickey = function()
        svo.lostbal_herb(false, true)
        svo.addaffdict(svo.dict.illness)
      end
    end

    if balance.focus and not balance.focus.offbalance then
      balance.focus.offbalance = function()
        svo.lostbal_focus()
      end
    end
    if balance.salve and not balance.salve.offbalance then
      balance.salve.offbalance = function()
        svo.lostbal_salve()
      end
    end
    if balance.herb and not balance.herb.offbalance then
      balance.herb.offbalance = function()
        svo.lostbal_herb()
      end
    end
    if balance.smoke and not balance.smoke.offbalance then
      balance.smoke.offbalance = function()
        svo.lostbal_smoke()
      end
    end

    if balance.focus and not balance.focus.nomana then
      balance.focus.nomana = function ()
        if not svo.actions.nomana_waitingfor and stats.currentmana ~= 0 then
          svo.echof(&quot;Seems we're out of mana.&quot;)
          svo.doaction(svo.dict.nomana.waitingfor)
        end
      end
    end

    if not balance.sw then balance.sw = createStopWatch() end
  end -- went through the dict list once at this point

  for balancename, list in pairs(unassigned_actions) do
    if #list &gt; 0 then
      -- shift up by # all actions for that balance to make room @ bottom
      for _,j in pairs(svo.dict) do
        for balance,l in pairs(j) do
          if balance == balancename and type(l) == 'table' and l.aspriority and l.aspriority ~= 0 then
            l.aspriority = l.aspriority + #list
          end
        end
      end

      -- now setup the low id's
      for i, actionname in ipairs(list) do
        svo.dict[actionname][balancename].aspriority = i
      end
    end
  end

  local totalcount = 0
  for _, list in pairs(unassigned_sync_actions) do
    totalcount = totalcount + #list
  end

  for balancename, list in pairs(unassigned_sync_actions) do
    if totalcount &gt; 0 then
      -- shift up by # all actions for that balance to make room @ bottom
      for _,j in pairs(svo.dict) do
        for _,l in pairs(j) do
          if type(l) == 'table' and l.spriority and l.spriority ~= 0 then
            l.spriority = l.spriority + totalcount
          end
        end
      end

      -- now setup the low id's
      for i, actionname in ipairs(list) do
        svo.dict[actionname][balancename].spriority = i
      end
    end
  end

  -- we don't want stuff in svo.dict.lovers.map!
  svo.dict.lovers.map = {}
end
svo.dict_setup() -- call once now to auto-setup missing dict() functions, and later on prio import to sort out the 0's.

function svo.dict_validate()
  -- basic theory is to create table keys for each table within svo.dict.#,
  -- store the dupe aspriority values inside in key-pair as well, and report
  -- what we got.
  local data = {}
  local dupes = {}
  local key = false

  -- check async ones first
  for i,j in pairs(svo.dict) do
    for k,l in pairs(j) do
      if type(l) == 'table' and l.aspriority then
        local balance = k:split('_')[1]
        if not data[balance] then data[balance] = {} dupes[balance] = {} end
        key = svo.containsbyname(data[balance], l.aspriority)
          if key then
          -- store the new dupe that we found
          dupes[balance][(k:split('_')[2] and k:split('_')[2] .. &quot; for &quot; or &quot;&quot;) .. i] = l.aspriority
          -- and store the previous one that we had already!
          dupes[balance][(key.balance:split('_')[2] and key.balance:split('_')[2] .. &quot; for &quot; or &quot;&quot;) .. key.action_name] = l.aspriority
        end
        data[balance][l] = l.aspriority

      end
    end
  end

  -- if we got something, complain
  for i,j in pairs(dupes) do
    if next(j) then
        svo.echof(&quot;Meh, problem. The following actions in %s balance have the same priorities: %s&quot;, i, svo.oneconcatwithval(j))
    end
  end

  -- clear table for next use, don't re-make to not force rehashes
  for k in pairs(data) do
    data[k] = nil
  end
  for k in pairs(dupes) do
    dupes[k] = nil
  end

  -- check sync ones
  for _,j in pairs(svo.dict) do
    for _,l in pairs(j) do
      if type(l) == 'table' and l.spriority then
        local balance = l.name
        local synckey = svo.containsbyname(data, l.spriority)
        if key then
          dupes[balance] = l.spriority
          dupes[synckey] = l.spriority
        end
        data[balance] = l.spriority

      end
    end
  end

  -- if we got something, complain
  if not next(dupes) then return end

  -- sort them first before complaining
  local sorted_dupes = {}
    -- stuff into table
  for i,j in pairs(dupes) do
    sorted_dupes[#sorted_dupes+1] = {name = i, prio = j}
  end

    -- sort table
  table.sort(sorted_dupes, function(a,b) return a.prio &lt; b.prio end)

  local function a(tbl)
    svo.assert(type(tbl) == 'table')
    local result = {}
    for _,j in pairs(tbl) do
      result[#result+1] = j.name .. &quot;(&quot; .. j.prio .. &quot;)&quot;
    end

    return table.concat(result, &quot;, &quot;)
  end

    -- complaining time
  svo.echof(&quot;Meh, problem. The following actions in sync mode have the same priorities: %s&quot;, a(sorted_dupes))
end

signals.dragonform:connect(function ()
  svo.dict_balanceful_def = {}
  svo.dict_balanceless_def = {}

  if not defc.dragonform then
    for i,j in pairs(svo.dict) do
      if j.physical and j.physical.balanceful_act and j.physical.def then
        svo.dict_balanceful_def[i] = {p = svo.dict[i]} end

      if j.physical and j.physical.balanceless_act and j.physical.def then
        svo.dict_balanceless_def[i] = {p = svo.dict[i]} end
    end
  else
    for i,j in pairs(svo.dict) do
      if j.physical and j.physical.balanceful_act and j.physical.def and svo.defs_data[i] and (svo.defs_data[i].type == 'general' or svo.defs_data[i].type == 'dragoncraft' or svo.defs_data[i].availableindragon) then
        svo.dict_balanceful_def[i] = {p = svo.dict[i]} end

      if j.physical and j.physical.balanceless_act and j.physical.def and svo.defs_data[i] and (svo.defs_data[i].type == 'general' or svo.defs_data[i].type == 'dragoncraft' or svo.defs_data[i].availableindragon) then
        svo.dict_balanceless_def[i] = {p = svo.dict[i]} end
    end

    -- special case for nightsight and monks: they have it
  end

end, &quot;update allowed actions in dragonform&quot;)
signals.systemstart:connect(function () signals.dragonform:emit() end, &quot;run dragonform check on system start&quot;)
signals.gmcpcharstatus:connect(function ()
  if gmcp.Char.Status.race then
    if gmcp.Char.Status.race:find('Dragon') then
      defences.got('dragonform')
    else
      defences.lost('dragonform')
    end
  end

  signals.dragonform:emit()
end, &quot;update dragonform status off gmcp&quot;)

svo.make_prio_table = function (filterbalance)
  local data = {}

  for action,balances in pairs(svo.dict) do
    for k,l in pairs(balances) do
      if k:sub(1, #filterbalance) == filterbalance and type(l) == 'table' and l.aspriority then
        if #k ~= #filterbalance then
          data[l.aspriority] = k:sub(#filterbalance+2) .. &quot; for &quot; .. action
        else
          data[l.aspriority] = action
        end
      end
    end
  end

  return data
end

svo.make_sync_prio_table = function(format)
  local data, type, sformat = {}, type, string.format
  for i,j in pairs(svo.dict) do
    for k,l in pairs(j) do
      if type(l) == 'table' and l.spriority then
        data[l.spriority] = sformat(format, i, k)
      end
    end
  end

  return data
end

-- func gets passed the action name to operate on, needs to return true for it to be added
svo.make_prio_tablef = function (filterbalance, func)
  local data = {}

  for action, balances in pairs(svo.dict) do
    for balance, l in pairs(balances) do
      if balance == filterbalance and type(l) == 'table' and l.aspriority and (not func or func(action)) then
        data[l.aspriority] = action
      end
    end
  end

  return data
end

-- func gets passed the action name to operate on
-- skipbals is a key-value table, where a key is a balance to ignore
svo.make_sync_prio_tablef = function(format, func, skipbals)
  local data, type, sformat = {}, type, string.format
  for action, balances in pairs(svo.dict) do
    for balance, balancedata in pairs(balances) do
      if type(balancedata) == 'table' and not skipbals[balance] and balancedata.spriority and (not func or func(action)) then
        data[balancedata.spriority] = sformat(format, action, balance)
      end
    end
  end

  return data
end

svo.clear_balance_prios = function(balance)
  for _,j in pairs(svo.dict) do
    for k,l in pairs(j) do
      if k == balance and type(l) == 'table' and l.aspriority then
        l.aspriority = 0
      end
    end
  end
end

svo.clear_sync_prios = function()
  for _,j in pairs(svo.dict) do
    for _,l in pairs(j) do
      if type(l) == 'table' and l.spriority then
        l.spriority = 0
      end
    end
  end
end

-- register various handlers
signals.curedwith_focus:connect(function (what)
  svo.dict.unknownmental.focus[what] ()
end, 'update unknown mental affs when cured with focus')

svo.sk.check_retardation = function()
  if affs.retardation then
    svo.rmaff('retardation')
  end
end

if svo.haveskillset('subterfuge') then
signals.newroom:connect(function()
  if defc.listen then defences.lost('listen') end
end, 'remove listen defence on move')
end

signals.newroom:connect(function()
  if defc.block then svo.dict.block.gone.oncompleted() end
  if defc.eavesdrop then defences.lost('eavesdrop') end
  if defc.lyre then defences.lost('lyre') end
end, 'remove common defs on room move')

signals.newroom:connect(sk.check_retardation, 'check retardation on room move')
signals.newroom:block(sk.check_retardation)

-- reset impale
signals.newroom:connect(function()
  if not next(affs) then return end

  local removables = {'impale'}
  local escaped = {}
  for i = 1, #removables do
    if affs[removables[i]] then
      escaped[#escaped+1] = removables[i]
      svo.rmaff(removables[i])
    end
  end

  if #escaped &gt; 0 then
    tempTimer(0, function()
      if stats.currenthealth &gt; 0 then
        tempTimer(0, function()
          if not svo.find_until_last_paragraph(&quot;You scrabble futilely at the ground as&quot;, 'substring') then
            svo.echof(&quot;Woo! We escaped from %s.&quot;, svo.concatand(escaped))
          end
        end)
      end
    end)
  end
end, 'remove impale on room move')

signals.systemstart:connect(function()
  sys.input_to_actions = {}

  for action, actiont in pairs(svo.dict) do
    for _, balancet in pairs(actiont) do
      -- ignore &quot;check*&quot; actions, as they are only useful when used by the system,
      -- and they can override actions that could be done by the user
      if type(balancet) == 'table' and not action:find(&quot;^check&quot;) then
        if type(balancet.sipcure) == 'string' then
          sys.input_to_actions[&quot;drink &quot;..balancet.sipcure] = balancet
          sys.input_to_actions[&quot;sip &quot;..balancet.sipcure] = balancet
        elseif type(balancet.sipcure) == 'table' then
          for _, potion in ipairs(balancet.sipcure) do
            sys.input_to_actions[&quot;drink &quot;..potion] = balancet
            sys.input_to_actions[&quot;sip &quot;..potion] = balancet
          end

        elseif type(balancet.eatcure) == 'string' then
          sys.input_to_actions[&quot;eat &quot;..balancet.eatcure] = balancet
        elseif type(balancet.eatcure) == 'table' then
          for _, thing in ipairs(balancet.eatcure) do
            sys.input_to_actions[&quot;eat &quot;..thing] = balancet
          end

        elseif type(balancet.smokecure) == 'string' then
          sys.input_to_actions[&quot;smoke &quot;..balancet.smokecure] = balancet
          sys.input_to_actions[&quot;puff &quot;..balancet.smokecure] = balancet
        elseif type(balancet.smokecure) == 'table' then
          for _, thing in ipairs(balancet.smokecure) do
            sys.input_to_actions[&quot;smoke &quot;..thing] = balancet
            sys.input_to_actions[&quot;puff &quot;..thing] = balancet
          end
        end

        -- add action separately, as sileris has both eatcure and action
        if balancet.action then
          sys.input_to_actions[balancet.action] = balancet
        elseif balancet.actions then
          for _, balanceaction in pairs(balancet.actions) do
            sys.input_to_actions[balanceaction] = balancet
          end
        end
      end
    end
  end

end, 'setup command to action mapping')


-- validate stuffs on our own
-- for i,j in pairs(svo.dict) do
--  for k,l in pairs(j) do
--   if type(l) == 'table' and k == 'focus' then
--     svo.echof(&quot;%s %s is focusable&quot;, i, k)
--   end
--   end
-- end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Curing skeleton</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local deepcopy, conf, sk, me, defs, defc = svo.deepcopy, svo.conf, svo.sk, svo.me, svo.defs, svo.defc
local defences, stats, cnrl, rift = svo.defences, svo.stats, svo.cnrl, svo.rift
local bals, pipes, watch = svo.bals, svo.pipes, svo.watch

-- misc functions
function svo.errorf(...)
  error(string.format(...))
end

function svo.echon(...)
  local function wrapper(...) decho(string.format(...)) end
  local status, result = pcall(wrapper, ...)
  if not status then error(result, 2) end
  echo(&quot;\n&quot;)
end

function svo.contains(t, value)
  svo.assert(type(t) == 'table', &quot;svo.contains wants a table!&quot;)

  for k, v in pairs(t) do
    if v == value then
      return k
    end
  end

  return false
end

if svo.haveskillset('healing') then
  -- used by 'normal' cure functions to see if we should ignore curing this aff
  -- returns true - Healing will *not* cure, use normal
  -- returns false - Healing *will* cure, don't use normal
  function sk.wont_heal_this(aff)
    if type(conf.usehealing) ~= 'string' or conf.usehealing ~= 'full' or not svo.can_usemana() then return true end

    if sk.healingmap[aff] and sk.healingmap[aff]() then
      return false
    end

    return true
  end
end

svo.sk.checking_herb_ai = function()
  return (svo.doingaction'checkparalysis' or svo.doingaction'checkasthma' or svo.doingaction'checkimpatience') and true or false
end

svo.force_send = _G.send

-- new incoming balances that are tracked between the lines and the prompt
svo.newbals = {}

-- checks

-- sip check
local healthchecks = {
  healhealth = {p = svo.dict.healhealth},
  healmana = {p = svo.dict.healmana}
}

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.
svo.check_sip = function(sync_mode)
  -- can we even sip?
  if not bals.sip or svo.usingbal('sip') or affs.stun or affs.unconsciousness or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.sip and j.p.sip.isadvisable() and not svo.ignore[i] then
        prios[i] = (not sync_mode) and j.p.sip.aspriority or j.p.sip.spriority
      end
    end
  end

  check(affs)
  check(healthchecks)

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].sip) else
    return svo.dict[svo.getHighestKey(prios)].sip end
end

-- purgative check: needs to be asynced as well
svo.check_purgative = function(sync_mode)
  -- can we even sip?
  if not bals.purgative or svo.usingbal('purgative') or affs.stun or affs.unconsciousness or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    local gotsomething = false
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.purgative and j.p.purgative.isadvisable() and not svo.ignore[i] then
        if svo.haveskillset('healing') and not sk.wont_heal_this(i) then
          return
        end

      prios[i] = (not sync_mode) and j.p.purgative.aspriority or j.p.purgative.spriority
      gotsomething = true
      end
    end

    return gotsomething
  end

  check(affs)

  if sys.deffing or conf.keepup then
    check(svo.dict_purgative)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].purgative) else
    return svo.dict[svo.getHighestKey(prios)].purgative end
end


-- salve check
svo.check_salve = function(sync_mode)
  -- can we even use salves?
  if not bals.salve or svo.usingbal('salve') or
    affs.sleep or affs.stun or affs.unconsciousness or affs.slickness then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.salve and j.p.salve.isadvisable() and not svo.ignore[i] then
        if svo.haveskillset('healing') and not sk.wont_heal_this(i) then
          return
        end
        prios[i] = (not sync_mode) and j.p.salve.aspriority or j.p.salve.spriority
      end
    end
  end

  check(affs)
  if sys.deffing or conf.keepup then check(svo.dict_salve_def) end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].salve) else
    return svo.dict[svo.getHighestKey(prios)].salve end
end

-- herb check

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.
svo.check_herb = function(sync_mode)
  -- can we even eat?
  if not bals.herb or svo.usingbal('herb') or affs.sleep
    or affs.stun or affs.unconsciousness or svo.sacid or affs.anorexia
    or (conf.aillusion and conf.waitherbai and sk.checking_herb_ai()) then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check (what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.herb and j.p.herb.isadvisable() and not svo.ignore[i]
        -- make sure that we can outrift things, or if we can't, we have the herb in our inventory
        and (sys.canoutr or sk.can_eat_for(j.p.herb)) then
          if svo.haveskillset('healing') and not sk.wont_heal_this(i) then
            return
          end
          prios[i] = (not sync_mode) and j.p.herb.aspriority or j.p.herb.spriority
      end
    end
  end

  check(affs)
  if sys.deffing or conf.keepup then check(svo.dict_herb) end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].herb) else
    return svo.dict[svo.getHighestKey(prios)].herb end
end

-- misc check

-- build a table of all the things we need to do with their priority numbers,
-- sort it, and do the topmost thing.

-- this is just in case we're checking amnesia only
local amnesias = {
  amnesia = {p = svo.dict.amnesia},
  fear    = {p = svo.dict.fear},
}
svo.check_misc = function(sync_mode, onlyamnesia)
  -- we -don't- check for sleep here, but a bit lower down - so waking can be on a misc
  if affs.stun or affs.unconsciousness then
    return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.misc and j.p.misc.isadvisable() and not svo.ignore[i] and not svo.doingaction (i) and (not affs.sleep or j.p.misc.action_name == 'sleep') then
        if svo.haveskillset('healing') and not sk.wont_heal_this(i) then
          return
        end
        prios[i] = (not sync_mode) and j.p.misc.aspriority or j.p.misc.spriority
      end
    end
  end

  if not onlyamnesia then
    check(affs)
    check(svo.dict_misc)
    if sys.deffing or conf.keepup then check(svo.dict_misc_def) end
  else
    check(amnesias)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest! Also go down the list in priorities in case you need to dontbatch
  if not sync_mode then
    local set = svo.index_map(prios)

    local highest, lowest = svo.getBoundary(prios)

    local dontbatch
    for i = highest, lowest, -1 do
      if set[i] then
        if not svo.dict[set[i]].misc.dontbatch or not dontbatch then
          svo.doaction(svo.dict[set[i]].misc)

          if svo.dict[set[i]].misc.dontbatch then dontbatch = true end
        end
      end
    end
  else
    -- otherwise, do the highest!
    return svo.dict[svo.getHighestKey(prios)].misc
  end
end

local check_for_asthma = {
  checkasthma = {p = svo.dict.checkasthma}
}
svo.check_smoke = function(sync_mode)
  if not bals.smoke or affs.stun or affs.unconsciousness or affs.sleep or affs.asthma or affs.mucous then
    return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.smoke and j.p.smoke.isadvisable() and not svo.ignore[i] and not svo.doingaction(i) then
        if svo.haveskillset('healing') and not sk.wont_heal_this(i) then
          return
        end
        prios[i] = (not sync_mode) and j.p.smoke.aspriority or j.p.smoke.spriority
      end
    end
  end

  check(affs)
  if svo.affsp.asthma then check(check_for_asthma) end
  if sys.deffing or conf.keepup then check(svo.dict_smoke_def) end

  -- have nada?
  if not next(prios) then return end

  if not sync_mode then
    local set = svo.index_map(prios)

    local highest, lowest = svo.getBoundary(prios)
    for i = highest, lowest, -1 do
      if set[i] then
        svo.doaction(svo.dict[set[i]].smoke)
      end
    end
  else
    -- otherwise, do the highest!
    return svo.dict[svo.getHighestKey(prios)].smoke
  end
end

svo.check_moss = function(sync_mode)
  -- can we even sip?
  if not conf.moss or svo.usingbal('moss') or affs.stun or affs.unconsciousness or not bals.moss
    or affs.sleep or affs.anorexia then
      return
  end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.moss and j.p.moss.isadvisable() and not svo.ignore[i] then
        prios[i] = (not sync_mode) and j.p.moss.aspriority or j.p.moss.spriority
      end
    end
  end

  if not conf.secondarymoss then check(healthchecks) end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].moss) else
    return svo.dict[svo.getHighestKey(prios)].moss end
end

svo.check_focus = function(sync_mode)
  -- can we even focus?
  if not next(affs) or svo.usingbal('focus') or affs.stun or affs.unconsciousness or not bals.focus
    or affs.sleep or not svo.can_usemana() or not conf.focus or stats.currentwillpower &lt;= 75
    or affs.impatience or affs.inquisition or (affs.cadmus and not conf.focuswithcadmus) then
      return
  end

  local wont_heal_this = sk.wont_heal_this

  -- get all prios in the list
  local prios = {}
  for i, j in pairs(affs) do
    if not (conf.serverside and svo.serverignore[i]) and j.p.focus and (not affs.cadmus or (conf.focuswithcadmus and me.cadmusaffs[i])) and j.p.focus.isadvisable() and not svo.ignore[i] then
          if svo.haveskillset('healing') and not wont_heal_this(i) then
            return
          end
        prios[i] = (not sync_mode) and j.p.focus.aspriority or j.p.focus.spriority
    end
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].focus) else
    return svo.dict[svo.getHighestKey(prios)].focus end
end


-- lifevision system

-- if something was added here, that means it was validated via other
-- means already - all we need to do now is to check if we had lifevision
-- catch the line or no.

-- other_action means do something else than default when done
-- arg is the argument to pass either to the default action
-- lineguard is how many lines this should be across - ineffective with vconfig batch
function svo.lifevision.add(what, other_action, arg, lineguard)
  svo.lifevision.l:set(what.name, {
    p = what,
    other_action = other_action,
    arg = arg
  })

  if lineguard and (not sys.lineguard or sys.lineguard &gt; lineguard) then -- remember the smallest one, because if we have two conflicts, the smallest one is most valid
    sys.lineguard = lineguard
  end

  svo.debugf(&quot;svo.lifevision: %s added with '%s' call (%s)%s&quot;, tostring(what.name), other_action and other_action or 'default', tostring(arg), (lineguard and &quot; lg: &quot;..lineguard or &quot;&quot;))

  if not sys.sync then return end
  if svo.actions[what.name] and what.balance ~= 'aff' and what.balance ~= 'gone' and color_table[conf.slowcurecolour] then
    selectCurrentLine()
    fg(conf.slowcurecolour)
    resetFormat()
    deselect()
  end
end

-- special: adds something where required, ie, first position in the queue
-- was necessary to have blackout be above everything else so stun AI doesn't slow it down 'till next prompt
function svo.lifevision.addcust(what, where, other_action, arg)
  svo.assert(what, &quot;svo.lifevision.addcust wants an argument&quot;)
  svo.lifevision.l:insert(where, what.name, {
    p = what,
    other_action = other_action,
    arg = arg
  })
  svo.debugf(&quot;svo.lifevision: %s added (pos %d) with '%s' call (%s)&quot;, tostring(what.name), where, other_action and other_action or 'default', tostring(arg))
end

-- returns the current lineguard that's set or nil
function svo.lifevision.getlineguard()
  return sys.lineguard
end

function svo.lifevision.clearlineguard()
  sys.lineguard = nil
end

local function run_through_actions()
  for _,j in svo.lifevision.l:iter() do
    if not sk.stopprocessing then
      svo.actionfinished(j.p, j.other_action, j.arg)
    else
      svo.actionclear(j.p)
    end
  end
end

function svo.lifevision.validate()
  -- take a line off the paragraph_length if the game's curing went off, as it is a 'meta' message and shouldn't be counted
  local paragraph_length = svo.paragraph_length
  if sk.sawcuring() then paragraph_length = paragraph_length - 1 end

  -- batch needs to disable lineguard, as commands come at once then. Plus, illusions aren't as prevalent anymore since serverside curing is completely immune to them
  if sys.flawedillusion or (not conf.batch and sys.lineguard and paragraph_length &gt; sys.lineguard) then
    if sys.not_illusion then
      svo.debugf(&quot;cancelled illusion&quot;)
      run_through_actions()

      moveCursor(0, getLineNumber()-1)
      moveCursor(#getCurrentLine(), getLineNumber())
      insertLink(&quot; (!i)&quot;, '', (type(sys.not_illusion) == 'string' and sys.not_illusion or &quot;Cancelled detected 'illusion' due to script override.&quot;))
      sys.not_illusion = false
    else
      svo.debugf(&quot;got an illusion&quot;)

      for _,j in svo.lifevision.l:iter() do
        svo.actionclear(j.p)
      end

      if sys.lineguard and not sys.flawedillusion then
        svo.debugf(&quot;svo.lifevision.validate: paragraph_length %d, sys.lineguard %d&quot;, paragraph_length, sys.lineguard)
        moveCursor(0, getLineNumber()-1)
        moveCursor(#getCurrentLine(), getLineNumber())
        insertLink(&quot; (i)&quot;, '', &quot;Ignored this whole illusion because the line(s) present need to be in their own.&quot;)
        moveCursorEnd()
      end
    end
    sys.flawedillusion, me.haveillusion = false, false
  else
    run_through_actions()
  end
  svo.lifevision.l = svo.pl.OrderedMap()
  sk.stopprocessing = nil
  sys.lineguard = false
end

svo.checkanyaffs = function (...)
  local t = {...}
  for i=1,#t do
    local j = t[i]

    if affs[j.name] then
    return j end
  end
end

-- balanceful check
svo.check_balanceful_acts = function(sync_mode)
  if affs.sleep or affs.stun or affs.unconsciousness or not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or (svo.me.class == 'Druid' and not bals.hydra)
  then return end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.physical.balanceful_act and j.p.physical.isadvisable() and not svo.ignore[i] then
        prios[i] = (not sync_mode) and j.p.physical.aspriority or j.p.physical.spriority
      end
    end
  end

  check(svo.dict_balanceful)

  if sys.deffing or conf.keepup then
    check(svo.dict_balanceful_def)
  end

  -- have nada?
  if not next(prios) then return false end

  -- otherwise, do the highest!
  if not sync_mode then
    svo.doaction(svo.dict[svo.getHighestKey(prios)].physical) else
    return svo.dict[svo.getHighestKey(prios)].physical end

  return true
end

-- balanceless check
svo.check_balanceless_acts = function(sync_mode)
  if affs.sleep or affs.stun or affs.unconsciousness or not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or (svo.me.class == 'Druid' and not bals.hydra)
   then return end

  -- get all prios in the list
  local prios = {}
  local function check(what)
    local gotsomething = false

    for i, j in pairs(what) do
      if not (conf.serverside and svo.serverignore[i]) and j.p.physical.balanceless_act and j.p.physical.isadvisable() and not svo.ignore[i] then
        prios[i] = (not sync_mode) and j.p.physical.aspriority or j.p.physical.spriority
        gotsomething = true
      end
    end

    return gotsomething
  end

  check(svo.dict_balanceless)

  if sys.deffing or conf.keepup then
    check(svo.dict_balanceless_def)
  end

  -- have nada?
  if not next(prios) then return end

  -- otherwise, do the highest!
  if not sync_mode then
    local set = svo.index_map(prios)

    local highest, lowest = svo.getBoundary(prios)
    for i = highest, lowest, -1 do
      if set[i] then
        svo.doaction(svo.dict[set[i]].physical)
      end
    end
  else
    return svo.dict[svo.getHighestKey(prios)].physical
  end

  return true
end

local balanceless = svo.balanceless or {}
local balanceful = svo.balanceful or {}

function svo.sk.balance_controller()
  if sys.balanceid == sys.balancetick then return end

  if not (bals.balance and bals.equilibrium) or (affs.webbed or affs.bound or affs.transfixed or affs.roped or affs.impale or affs.paralysis or affs.sleep) then return end

  -- loop through all balanceless functions
  for _, f in pairs(balanceless) do
    f()
  end

-- loop through balanceful actions until we get one that takes bal or eq
  local r
  for _,f in pairs(balanceful) do
    r = f()
    if r then
      if sys.actiontimeoutid then killTimer(sys.actiontimeoutid) end
      if type(r) == 'number' then
        sys.actiontimeoutid = tempTimer(r, function () sys.balancetick = sys.balancetick + 1; svo.make_gnomes_work() end)
      elseif conf.lag and conf.lag == 4 then
        -- 24 does it right away!
        sys.actiontimeoutid = tempTimer(60*60*23, function () sys.balancetick = sys.balancetick + 1; svo.make_gnomes_work() end)
      else
        sys.actiontimeoutid = tempTimer(sys.actiontimeout, function () sys.balancetick = sys.balancetick + 1; svo.make_gnomes_work() end)
      end

      sys.balanceid = sys.balancetick
      break
    end
  end
end

function svo.addbalanceless(name, func)
  svo.assert(name and func, &quot;svo.addbalanceless: both name and function are required&quot;)
  svo.assert(type(func) == 'function', &quot;svo.addbalanceless: function needs to be an actual function, while you gave it a &quot;..type(func))

  balanceless[name] = func
end

function svo.removebalanceless(name)
  balanceless[name] = nil
end

function svo.addbalanceful(name, func)
  svo.assert(name and func, &quot;svo.addbalanceful: both name and function are required&quot;)
  svo.assert(type(func) == 'function', &quot;svo.addbalanceful: second argument has to be a function (you gave it a &quot;..type(func)..&quot;)&quot;)

  balanceful[name] = func
end

function svo.removebalanceful(name)
  balanceful[name] = nil
end

function svo.clearbalanceful()
  balanceful = {}
  svo.addbalanceful(&quot;svo check do&quot;, sk.check_do)
  raiseEvent(&quot;svo balanceful ready&quot;)
end

function svo.clearbalanceless()
  balanceless = {}
  svo.addbalanceless(&quot;svo check dofree&quot;, svo.check_dofree)
  raiseEvent(&quot;svo balanceless ready&quot;)
end

tempTimer(0, function ()
  raiseEvent(&quot;svo balanceless ready&quot;)
  raiseEvent(&quot;svo balanceful ready&quot;)
end)

-- svo Got prompt
-- DO WORK!

-- utils
local function find_highest_action(tbl)
  local result
  local highest = 0
  for _,j in pairs(tbl) do
    if j.spriority &gt; highest then
      highest = j.spriority
      result = j
    end
  end

  return result
end

local workload = {svo.check_salve, svo.check_focus, svo.check_sip, svo.check_purgative,
            svo.check_smoke, svo.check_herb, svo.check_moss, svo.check_misc,
            svo.check_balanceless_acts, svo.check_balanceful_acts}

-- real functions
local function work_slaves_work()
  -- in async, ask each bal to do its action

  svo.check_misc(false, true) -- amnesia &amp; fear only

  svo.check_focus()
  svo.check_salve()

  svo.check_sip()
  svo.check_purgative()
  svo.check_smoke()
  svo.check_herb()

  svo.check_misc() -- fails for amnesia, but works for Priest Healing...

  svo.check_moss()

  svo.check_balanceless_acts()

  -- if the system didn't use bal, let it be used for other things.
  if not svo.check_balanceful_acts() and not svo.will_take_balance() then sk.balance_controller() end

  -- serverside prios: eat, apply, smoke, focus
end

svo.make_gnomes_work_async = function()
  if conf.paused then return end

  signals.sysdatasendrequest:block(cnrl.processusercommand)

  if conf.commandecho and (conf.commandechotype == 'fancy' or conf.commandechotype == 'fancynewline') then
    send = svo.fancysend

    -- insert expandAlias (used in dofree, dor and similar) into the current batch, breaking the batch up in the process
    local oldexpandAlias = expandAlias
    if conf.batch then
      expandAlias = function(command, show)
        svo.sendc({ func = oldexpandAlias, args = {command, show} })
      end
    end

    work_slaves_work()
    -- commands are echoed by fancysendall() in onpromptr() in case of a prompt from the game, otherwise echo them right away if from a forced svo.make_gnomes_work()
    if not sk.processing_prompt then svo.fancysendall() end
    send = svo.oldsend

    if conf.batch then
      expandAlias = oldexpandAlias
    end
  else
    work_slaves_work()
  end

  signals.sysdatasendrequest:unblock(cnrl.processusercommand)
end

svo.make_gnomes_work_sync = function()
  sk.syncdebug = false
  if conf.paused or svo.sacid then return end

  signals.sysdatasendrequest:block(cnrl.processusercommand)

  -- if we're already doing an action that is not of an 'waitingfor' type, don't do anything!
  -- logic: if next returns nil,
  local result
  for balance,actions in pairs(svo.bals_in_use) do
    if balance ~= 'waitingfor' and balance ~= 'gone' and balance ~= 'aff' and next(actions) then result = select(2, next(actions)) break end
  end
  if result then
    svo.debugf(&quot;doing %s, quitting for now&quot;, result.name)
    sk.syncdebug = string.format(&quot;[%s]: Currently doing: %s&quot;, getTimestamp(getLineCount()):trim(), result.name)

    signals.sysdatasendrequest:unblock(cnrl.processusercommand)
    return
  end

  sk.gnomes_are_working = true

  local action_list = {}

  --... check for all bals.
  -- in sync, only return values
  for _,j in pairs(workload) do
    result = j(true)
    if result then action_list[result.name] = result end
  end

  local actions = svo.pl.tablex.keys(action_list)
  table.sort(actions, function(a,b)
    return action_list[a].spriority &gt; action_list[b].spriority
  end)

  sk.syncdebug = string.format('[%s]: Feasible actions we\'re currently considering doing (in order): %s', getTimestamp(getLineCount()):trim(), (not next(action_list) and '(none)' or svo.concatand(actions)))

  -- nothing to do =)
  if not next(action_list) then
    sk.gnomes_are_working = false

    signals.sysdatasendrequest:unblock(cnrl.processusercommand)
    return
  end

  if conf.commandecho and conf.commandechotype == 'fancy' then
    send = svo.fancysend
    local oldbatch = conf.batch
    conf.batch = false
    svo.doaction(find_highest_action(action_list))
    -- commands are echoed by fancysendall() in onpromptr() in case of a prompt from the game, otherwise echo them right away if from a forced svo.make_gnomes_work()
    if not sk.processing_prompt then svo.fancysendall() end
    send = svo.oldsend
    conf.batch = oldbatch
  else
    svo.doaction(find_highest_action(action_list))
  end
  sk.gnomes_are_working = false

  signals.sysdatasendrequest:unblock(cnrl.processusercommand)
end

-- default is async
signals.aeony:connect(function()
  if sys.sync then
    svo.make_gnomes_work = svo.make_gnomes_work_sync
  else
    svo.make_gnomes_work = svo.make_gnomes_work_async
  end
end, &quot;change curing types&quot;)
sk.checkaeony()
signals.aeony:emit()

function svo.send_in_the_gnomes()
  -- at first, deal with lifevision.
  svo.lifevision.validate()
  signals.after_lifevision_processing:emit()

  svo.make_gnomes_work()
end

function svo.update_rift_view()
  local status, msg = pcall(function () svo.mm_create_riftlabel() end)

  if not status then error(msg) end
end

-- retrieve all lines until the last prompt, not including it
function svo.sk.getuntilprompt()
  -- lastpromptnumber would include the prompt, -1 doesn't
  return getLines(svo.lastpromptnumber+1, getLastLineNumber('main'))
end

function svo.sk.makewarnings()
  svo.sk.warnings = {
    lowwillpower = {
      time = 30,
      msg = &quot;Warning: your &lt;253,63,73&gt;willpower is too low&quot;..svo.getDefaultColor()..&quot;! Need to regen some - otherwise you can't fight well (no clot, focus, and so on).&quot;
    },
    somewhatreavable = {
      time = 10,
      msg = &quot;Warning: you have two humours - an Alchemists &lt;253,63,73&gt;Reave&quot;..svo.getDefaultColor()..&quot; will take 10s&quot;,
    },
    nearlyreavable = {
      time = 5,
      msg = &quot;Warning: you have three humours - an Alchemists &lt;253,63,73&gt;Reave&quot;..svo.getDefaultColor()..&quot; will take 8s&quot;,
    },
    reavable = {
      time = 5,
      msg = &quot;Warning: you have all four humours - an Alchemists &lt;253,63,73&gt;Reave&quot;..svo.getDefaultColor()..&quot; will only take 4s&quot;,
    },
    dismemberable = {
      time = 5,
      msg = &quot;Warning: you're bound and impaled - you can be instakilled! (dismember)&quot;
    },
    cantclotmana = {
      time = 10,
      msg = &quot;Going temporarily pause clotting your mana bleeding, your health is below corruptedhealthmin&quot;
    },
    golemdestroyable = {
      time = 5,
      msg = &quot;Warning: your flesh is melting - you can be instakilled! (golem destroy)&quot;
    },
    pulpable = {
      time = 5,
      msg = &quot;Warning: prone and serious concussion - you can be installed! (pulp)&quot;
    },
    badaeon = {
      time = 5,
      msg = function()
        svo.echof(&quot;Warning: your aeon situation is looking bad, you might want to %swalk out%s&quot;,
          (not conf.blockcommands and '' or &quot;tsc off and &quot;),
          (conf.org == 'Ashtan' and &quot; and ask for an empress&quot;) or
          (conf.org == 'Targossas' and &quot; and ask for a deliver&quot;) or
          (conf.org == 'Cyrene' and &quot; and ask for a deliver&quot;) or
          &quot;&quot;
        )
      end
    }
  }

  if conf.curemethod == 'transonly' then
    sk.warnings.noelmid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;cinnabar&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;malachite&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe and it's empty! Don't chase balance for a bit&quot;,
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe, it's empty, but can't due to blocking afflictions :(&quot;,
    }
  elseif conf.curemethod == 'preferconc' then
    sk.warnings.noelmid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;elm&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;cinnabar&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;skullcap&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;malachite&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe and it's empty! Don't chase balance for a bit&quot;,
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot; pipe, it's empty, but can't due to blocking afflictions :(&quot;,
    }
  elseif conf.curemethod == 'prefertrans' then
    sk.warnings.noelmid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;cinnabar&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;elm&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.novalerianid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;malachite&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;skullcap&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe and it's empty! Don't chase balance for a bit&quot;,
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;realgar&quot;..svo.getDefaultColor()..&quot;/&lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe, it's empty, but can't due to blocking afflictions :(&quot;,
    }
  else
    sk.warnings.noelmid = {
        time = 20,
        msg = &quot;Warning: need to use your &lt;31,31,153&gt;elm&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
      }
    sk.warnings.novalerianid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.noskullcapid = {
      time = 20,
      msg = &quot;Warning: need to use your &lt;31,31,153&gt;skullcap&quot;..svo.getDefaultColor()..&quot; pipe and you don't have one!&quot;,
    }
    sk.warnings.emptyvalerianpipe = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe and it's empty! Don't chase balance for a bit&quot;,
    }
    sk.warnings.emptyvalerianpipenorefill = {
      time = 10,
      msg = &quot;Warning: need to refill your &lt;31,31,153&gt;valerian&quot;..svo.getDefaultColor()..&quot; pipe, it's empty, but can't due to blocking afflictions :(&quot;,
    }
  end
end

signals.systemstart:add_post_emit(sk.makewarnings)
signals.orgchanged:add_post_emit(sk.makewarnings)
signals.curemethodchanged:connect(sk.makewarnings, &quot;update warnings for curemethod&quot;)

svo.sk.warn = function (what)
  if sk.warnings[what].warned then return end

  tempTimer(sk.warnings[what].time, function() sk.warnings[what].warned = false end)
  sk.warnings[what].warned = true

  moveCursorEnd('main')
  echo(&quot;\n&quot;)

  if type(sk.warnings[what].msg) == 'function' then
    sk.warnings[what].msg()
  else svo.echof(sk.warnings[what].msg) end

  echo(&quot;\n&quot;)
end

sk.retardation_count = 0
function svo.sk.retardation_symptom()
  if (affs.retardation or affs.aeon or svo.affsp.retardation or svo.affsp.aeon or svo.affsp.truename) then return end

  sk.retardation_count = sk.retardation_count + 1
  if sk.retardation_count &gt;= 4 then
    if not affs.blackout then
      if not conf.aillusion then
        svo.valid.simpleretardation()
        echo&quot;\n&quot; svo.echof(&quot;auto-detected retardation.&quot;)
      else
        svo.checkaction(svo.dict.checkslows.aff, true)
        svo.lifevision.add(svo.actions.checkslows_aff.p, nil, 'retardation')
        echo&quot;\n&quot; svo.echof(&quot;Maybe we're in retardation - checking it.&quot;)
      end
    else
      svo.valid.simpleunknownany(conf.unknownany)
      echo&quot;\n&quot; svo.echof(&quot;auto-detection aeon or retardation (going to diagnose to check which)&quot;)
    end
    sk.retardation_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 3, function ()
    sk.retardation_count = sk.retardation_count - 1
    if sk.retardation_count &lt; 0 then sk.retardation_count = 0 end
  end)
end

sk.stupidity_count = 0
function svo.sk.stupidity_symptom()

  if conf.serverside then return end

  if affs.stupidity then return end

  sk.stupidity_count = sk.stupidity_count + 1

  if sk.stupidity_count &gt;= 3 then
    svo.valid.simplestupidity()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected stupidity.&quot;)
    sk.stupidity_count = 0
    return
  end

  tempTimer(svo.syncdelay() + 2, function ()
    sk.stupidity_count = sk.stupidity_count - 1
    if sk.stupidity_count &lt; 0 then sk.stupidity_count = 0 end
  end)
end

sk.illness_constitution_count = 0
function svo.sk.illness_constitution_symptom()
  if not defc.constitution then return end
  if conf.serverside then return end

  if affs.illness_constitution then return end

  sk.illness_constitution_count = sk.illness_constitution_count + 1

  if sk.illness_constitution_count &gt;= 2 then
    svo.valid.simplehypochondria()

    echo&quot;\n&quot; svo.echof(&quot;auto-detected hypochondria.&quot;)

    sk.illness_constitution_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 3, function ()
    sk.illness_constitution_count = sk.illness_constitution_count - 1
    if sk.illness_constitution_count &lt; 0 then sk.illness_constitution_count = 0 end
  end)
end

sk.transfixed_count = 0
function svo.sk.transfixed_symptom()
  if affs.transfixed then return end
  if conf.serverside then return end

  if affs.transfixed then return end

  sk.transfixed_count = sk.transfixed_count + 1

  if sk.transfixed_count &gt;= 2 then
    svo.valid.simpletransfixed()

    -- supress echo when got hit with it before ai went off
    if not svo.affsp.transfixed then
      echo&quot;\n&quot; svo.echof(&quot;auto-detected transfix.&quot;)
    end
    sk.transfixed_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 3, function ()
    sk.transfixed_count = sk.transfixed_count - 1
    if sk.transfixed_count &lt; 0 then sk.transfixed_count = 0 end
  end)
end

sk.stun_count = 0
function svo.sk.stun_symptom()
  if affs.stun then return end

  sk.stun_count = sk.stun_count + 1

  if sk.stun_count &gt;= 3 then
    svo.valid.simplestun()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected stun.&quot;)
    sk.stun_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.stun_count = sk.stun_count - 1
    if sk.stun_count &lt; 0 then sk.stun_count = 0 end
  end)
end

sk.impale_count = 0
function svo.sk.impale_symptom()
  if conf.serverside then return end

  if affs.impale then return end

  sk.impale_count = sk.impale_count + 1

  if sk.impale_count &gt;= 2 then
    svo.valid.simpleimpale()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected impale.&quot;)
    sk.impale_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.impale_count = sk.impale_count - 1
    if sk.impale_count &lt; 0 then sk.impale_count = 0 end
  end)
end

sk.aeon_count = 0
function svo.sk.aeon_symptom()
  if affs.aeon then return end

  sk.aeon_count = sk.aeon_count + 1

  if sk.aeon_count &gt;= 2 then
    svo.valid.simpleaeon()
    defs.lost_speed()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected aeon.&quot;)
    sk.aeon_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.aeon_count = sk.aeon_count - 1
    if sk.aeon_count &lt; 0 then sk.aeon_count = 0 end
  end)
end

sk.paralysis_count = 0
function svo.sk.paralysis_symptom()
  if conf.serverside then return end

  if affs.paralysis then return end

  sk.paralysis_count = sk.paralysis_count + 1

  if sk.paralysis_count &gt;= 2 then
    svo.valid.simpleparalysis()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected paralysis.&quot;)
    sk.paralysis_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.paralysis_count = sk.paralysis_count - 1
    if sk.paralysis_count &lt; 0 then sk.paralysis_count = 0 end
  end)
end

sk.haemophilia_count = 0
function svo.sk.haemophilia_symptom()
 if affs.haemophilia then return end

  sk.haemophilia_count = sk.haemophilia_count + 1

  if sk.haemophilia_count &gt;= 2 then
    svo.valid.simplehaemophilia()
    echo&quot;\n&quot; svo.echof(&quot;haemophilia seems to be real.&quot;)
    sk.haemophilia_count = 0
    return
  end

  -- special # 1 - so haemophilia illusions 'can't' happen within 1s
  tempTimer(svo.syncdelay() + 1, function ()
    sk.haemophilia_count = sk.haemophilia_count - 1
    if sk.haemophilia_count &lt; 0 then sk.haemophilia_count = 0 end
  end)
end

sk.webbed_count = 0
function svo.sk.webbed_symptom()
  if conf.serverside then return end

  if affs.webbed then return end

  sk.webbed_count = sk.webbed_count + 1
  if sk.webbed_count &gt;= 2 then
    svo.valid.simplewebbed()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected web.&quot;)
    sk.webbed_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.webbed_count = sk.webbed_count - 1
    if sk.webbed_count &lt; 0 then sk.webbed_count = 0 end
  end)
end

sk.roped_count = 0
function svo.sk.roped_symptom()
  if conf.serverside then return end

  if affs.roped then return end

  sk.roped_count = sk.roped_count + 1

  if sk.roped_count &gt;= 2 then
    svo.valid.simpleroped()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected roped.&quot;)
    sk.roped_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.roped_count = sk.roped_count - 1
    if sk.roped_count &lt; 0 then sk.roped_count = 0 end
  end)
end

sk.impaled_count = 0
function svo.sk.impaled_symptom()
  if conf.serverside then return end

  if affs.impale then return end

  sk.impaled_count = sk.impaled_count + 1

  if sk.impaled_count &gt;= 2 then
    svo.valid.simpleimpale()
    echo&quot;\n&quot; svo.echof(&quot;auto-detected impale.&quot;)
    sk.impaled_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.impaled_count = sk.impaled_count - 1
    if sk.impaled_count &lt; 0 then sk.impaled_count = 0 end
  end)
end


sk.hypochondria_count = 0
function svo.sk.hypochondria_symptom()
  if svo.find_until_last_paragraph(line, 'exact') or affs.hypochondria then return end

  sk.hypochondria_count = sk.hypochondria_count + 1

  if sk.hypochondria_count &gt;= 3 then
    svo.valid.simplehypochondria()
    sk.hypochondria_count = 0
  end

  tempTimer(12, function ()
    sk.hypochondria_count = sk.hypochondria_count - 1
    if sk.hypochondria_count &lt; 0 then sk.hypochondria_count = 0 end
  end)
end

sk.unparryable_count = 0
function svo.sk.unparryable_symptom()
  if conf.aillusion and svo.paragraph_length ~= 1 and not svo.find_until_last_paragraph(&quot;Your scabbard does not contain your blade, Warrior.&quot;, 'exact') and not svo.find_until_last_paragraph(&quot;You have not positioned a scabbard on your hip, Warrior.&quot;, 'exact') then
    svo.ignore_illusion(&quot;not first&quot;) return
  elseif affs.unparryable then return end

  sk.unparryable_count = sk.unparryable_count + 1

  if sk.unparryable_count &gt;= 2 then
    sk.cant_parry()
    sk.unparryable_count = 0
    return
  end

  tempTimer(svo.syncdelay() + sys.wait * 2, function ()
    sk.unparryable_count = sk.unparryable_count - 1
    if sk.unparryable_count &lt; 0 then sk.unparryable_count = 0 end
  end)
end

svo.updateaffcount = function (which)
  svo.affl[which.name].count = which.count

  raiseEvent(&quot;svo updated aff&quot;, which.name, 'count', which.count)
end


-- adds an affliction for the system to be tracking (ie - you are afflicted with it)
-- does not mess with aff.&lt;affliction&gt;s table if the aff is already registered.
-- this is the old internal 'addaff' function that Svof used when it was out of Mudlet
local old_internal_addaff = function (new_aff)
  if not new_aff then svo.debugf(&quot;no new, log: %s&quot;, debug.traceback()) end
  if affs[new_aff.name] then return end

  local name = new_aff.name

  svo.affs[name] = {
    p = new_aff,
    sw = new_aff.sw or createStopWatch()
  }
  startStopWatch(affs[name].sw)

  -- call the onadded handler if any
  if svo.dict[name].onadded then svo.dict[name].onadded() end

  if not svo.affl[name] then
    svo.affl[name] = { sw = affs[name].sw }
    signals.svogotaff:emit(name)
    raiseEvent(&quot;svo got aff&quot;, name)
  end
end
-- this is the old public 'addaff' function that Svof enabled when it was out of Mudlet
local old_public_addaff = function (new_aff)
  svo.assert(type(new_aff) == 'string', &quot;svo.addaff: what aff would you like to add? name must be a string&quot;)
  svo.assert(svo.dict[new_aff] and svo.dict[new_aff].aff, &quot;svo.addaff: &quot;..new_aff..&quot; isn't a known aff name&quot;)

  if affs[new_aff] then
    return false
  else
    if svo.dict[new_aff].aff and svo.dict[new_aff].aff.forced then
      svo.dict[new_aff].aff.forced()
    elseif svo.dict[new_aff].aff then
      svo.dict[new_aff].aff.oncompleted()
    else
      old_internal_addaff(svo.dict[new_aff])
    end

    signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    sk.checkaeony()
    signals.aeony:emit()
    svo.codepaste.badaeon()

    return true
  end
end
svo.addaff = function(aff_string_or_table)
  if type(aff_string_or_table) == 'table' then
    old_internal_addaff(aff_string_or_table)
  else
    old_public_addaff(aff_string_or_table)
  end
end
svo.addaffdict = old_public_addaff

-- old internal version of removeaff
svo.rmaff = function (old)
  if type(old) == 'table' then
    for _,aff in pairs(old) do
      svo.rmaff(aff)
    end
    return
  end

  if not affs[old] then return end

  if svo.affl[old] then
    svo.affl[old] = nil
    signals.svolostaff:emit(old)
    raiseEvent(&quot;svo lost aff&quot;, old)
  end

  -- rmaff can be called on affs that don't exist, that's valid
  local sw = (affs[old] and affs[old].sw or nil)
  affs[old] = nil

  -- call the onremoved handler if any. Should be called after affs is cleaned, because scripts here reply on the 'current' state
  if svo.dict[old].onremoved then
    svo.debugf(&quot;calling onremoved for %s&quot;, old)
    svo.dict[old].onremoved()
  end

  if conf.showafftimes and sw then
    svo.echoafftime(stopStopWatch(sw), old)
  end
end

-- public version of removeaff. The two should be merged.
svo.removeaff = function (which)
  svo.assert(type(which) == 'string', &quot;svo.removeaff: what aff would you like to remove? name must be a string&quot;)
  svo.assert(svo.dict[which] and svo.dict[which].aff, &quot;svo.removeaff: &quot;..which..&quot; isn't a known aff name&quot;)

  local removed = false
  if svo.lifevision.l[which..'_aff'] then
    svo.lifevision.l:set(which..'_aff', nil)
    removed = true
  end

  if affs[which] then
    if svo.dict[which].gone then
      svo.dict[which].gone.oncompleted()
    else
      svo.removeaff(which)
    end

    removed = true
  end

  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
  sk.checkaeony()
  signals.aeony:emit()

  return removed
end

svo.removeafflevel = function (which, amount, keep)
  svo.assert(type(which) == 'string', &quot;svo.removeafflevel: what aff would you like to remove? name must be a string&quot;)
  svo.assert(svo.dict[which] and svo.dict[which].aff, &quot;svo.removeafflevel: &quot;..which..&quot; isn't a known aff name&quot;)

  local removed = false
  if svo.lifevision.l[which..'_aff'] then
    svo.lifevision.l:set(which..'_aff', nil)
    removed = true
  end

  if affs[which] then
    if svo.dict[which].gone then
      svo.dict[which].gone.general_cure(amount or 1, not keep)
    else
      svo.removeaff(which)
    end

    removed = true
  end

  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
  sk.checkaeony()
  signals.aeony:emit()

  return removed
end

-- externally available as svo.prompttrigger
sk.onpromptfuncs = {}
function sk.onprompt_beforeaction_add(name, what)
  sk.onpromptfuncs[name] = what
end

sk.onprompt_beforeaction_do = function()
  for name, func in pairs(sk.onpromptfuncs) do
    local s,m = pcall(func)
    if not s then
    svo.debugf(&quot;sk.onprompt_beforeaction_do error from %s: %q&quot;, name, m)
      echoLink(&quot;(e!)&quot;, &quot;echo([[The problem was: &quot;..tostring(name)..&quot; prompttrigger failed to work: &quot;..string.format(&quot;%q&quot;, m)..&quot;]])&quot;, 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw if this isn\'t your own function.')
    end
  end
  sk.onpromptfuncs = {}
end
signals.after_lifevision_processing:connect(sk.onprompt_beforeaction_do, &quot;add onprompt_beforeaction_do&quot;)

-- externally available as svo.aiprompt
sk.onpromptaifuncs = {}
function sk.onprompt_beforelifevision_add(name, what)
  sk.onpromptaifuncs[name] = what
end

sk.onprompt_beforelifevision_do = function()
  for name, func in pairs(sk.onpromptaifuncs) do
    local s,m = pcall(func)
    if not s then
      echoLink(&quot;(e!)&quot;, &quot;echo([[The problem was: &quot;..tostring(name)..&quot; aiprompt failed to work: &quot;..string.format(&quot;%q&quot;, m)..&quot;]])&quot;, 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw if this isn\'t your own function.')
    end
  end
  sk.onpromptaifuncs = {}
end
signals.before_prompt_processing:connect(sk.onprompt_beforelifevision_do, &quot;add onprompt_beforelifevision_do&quot;)

svo.lostbal_tree = function()
  if bals.tree then tempTimer(0, [[raiseEvent(&quot;svo lost balance&quot;, 'tree')]]) end
  bals.tree = false
  svo.startbalancewatch('tree')
  if sys.treetimer then killTimer(sys.treetimer) end
  -- if conf.treebalance is set, use that - otherwise use the defaults as setup by conf.efficiency + hardcoded numbers
  local timeout
  if not conf.treebalance or conf.treebalance == 0 then
    timeout = conf.efficiency and (16+svo.getping()) or (40+svo.getping())
  else
    timeout = conf.treebalance
  end
  if affs.ninkharsag then timeout = timeout + 10 end

  sys.treetimer = tempTimer(timeout, [[svo.bals.tree = true;
    svo.echof(&quot;Can touch tree again.&quot;)
    svo.showprompt()
    raiseEvent(&quot;svo got balance&quot;, 'tree')]])
end

svo.lostbal_focus = function()
  if not bals.focus then return end

  bals.focus = false
  svo.startbalancewatch('focus')
  sk.focustick = sk.focustick + 1
  local oldfocustick = sk.focustick

  -- respect conf.ai_resetfocusbal while setting a minimum of 8s
  local timeout = conf.ai_resetfocusbal
  if affs.rixil then
    if conf.ai_resetfocusbal &lt; 5 then
      timeout = conf.ai_resetfocusbal + 5
    else
      timeout = 8
    end
  end

  tempTimer(timeout, function ()
    if not bals.focus and sk.focustick == oldfocustick then
      bals.focus = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'focus')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'focus')
end

svo.lostbal_shrugging = function()
  if not bals.shrugging then return end

  bals.shrugging = false
  svo.startbalancewatch('shrugging')
  sk.shruggingtick = sk.shruggingtick + 1
  local oldshruggingtick = sk.shruggingtick

  tempTimer(10+svo.getping(), function ()
    if not bals.shrugging and sk.shruggingtick == oldshruggingtick then
      bals.shrugging = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'shrugging')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'shrugging')
end

svo.lostbal_fitness = function()
  if not bals.fitness then return end

  bals.fitness = false
  svo.startbalancewatch('fitness')
  sk.fitnesstick = sk.fitnesstick + 1
  local oldfitnesstick = sk.fitnesstick

  -- takes 9s to recover
  tempTimer(15+svo.getping(), function ()
    if not bals.fitness and sk.fitnesstick == oldfitnesstick then
      bals.fitness = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'fitness')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'fitness')
end

svo.lostbal_rage = function()
  if not bals.rage then return end

  bals.rage = false
  svo.startbalancewatch('rage')
  sk.ragetick = sk.ragetick + 1
  local oldragetick = sk.ragetick

  -- takes 9s to recover
  tempTimer(15+svo.getping(), function ()
    if not bals.rage and sk.ragetick == oldragetick then
      bals.rage = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'rage')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'rage')
end

svo.lostbal_voice = function()
  if not bals.voice then return end

  bals.voice = false
  svo.startbalancewatch('voice')
  sk.voicetick = sk.voicetick + 1
  local oldvoicetick = sk.voicetick

  tempTimer(10+svo.getping(), function ()
    if not bals.voice and sk.voicetick == oldvoicetick then
      bals.voice = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'voice')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'voice')
end

svo.lostbal_sip = function()
  bals.sip = false
  svo.startbalancewatch('sip')
  sk.siptick = sk.siptick + 1
  local oldsiptick = sk.siptick

  -- multiply by 2 if we have addiction
  local lostbalance = conf.ai_resetsipbal
  if affs.addiction then lostbalance = lostbalance * 2 end
  -- add .5s for earth disrupt delaying it
  if affs.earthdisrupt then lostbalance = lostbalance + 0.5 end

  tempTimer(lostbalance, function ()
    if not bals.sip and sk.siptick == oldsiptick then
      bals.sip = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'sip')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'sip')
end

svo.lostbal_herb = function(noeffect, mickey)
  bals.herb = false
  svo.startbalancewatch('herb')
  sk.herbtick = sk.herbtick + 1
  local oldherbtick = sk.herbtick

  tempTimer(conf.ai_resetherbbal, function ()
    if not bals.herb and sk.herbtick == oldherbtick then
      bals.herb = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'herb')
    end
  end)

  watch['bal_herb'] = watch['bal_herb'] or createStopWatch()
  startStopWatch(watch['bal_herb'])

  -- voided gives us the balance quick enough
  if (affs.voided and noeffect) then raiseEvent(&quot;svo lost balance&quot;, 'herb') return end

  watch.herb_block = watch.herb_block or createStopWatch()
  startStopWatch(watch.herb_block)

  if sk.blockherbbal then killTimer(sk.blockherbbal) end
  -- mickey steals bal for .8s
  sk.blockherbbal = tempTimer((mickey and .5 or conf.ai_minherbbal), function ()
    sk.blockherbbal = nil
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'herb')
end

svo.lostbal_salve = function()
  bals.salve = false
  svo.startbalancewatch('salve')
  sk.salvetick = sk.salvetick + 1
  local oldsalvetick = sk.salvetick

  tempTimer(conf.ai_resetsalvebal, function ()
    if not bals.salve and sk.salvetick == oldsalvetick then
      bals.salve = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'salve')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'salve')
end

svo.lostbal_moss = function()
  bals.moss = false
  svo.startbalancewatch('moss')
  sk.mosstick = sk.mosstick + 1
  local oldmosstick = sk.mosstick

  tempTimer(conf.ai_resetmossbal, function ()
    if not bals.moss and sk.mosstick == oldmosstick then
      bals.moss = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'moss')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'moss')
end

svo.lostbal_purgative = function()
  bals.purgative = false
  svo.startbalancewatch('purgative')
  sk.purgativetick = sk.purgativetick + 1
  local oldpurgativetick = sk.purgativetick

  tempTimer(conf.ai_resetpurgativebal, function ()
    if not bals.purgative and sk.purgativetick == oldpurgativetick then
      bals.purgative = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'purgative')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'purgative')
end

svo.lostbal_smoke = function()
  bals.smoke = false
  svo.startbalancewatch('smoke')
  sk.smoketick = sk.smoketick + 1
  local oldsmoketick = sk.smoketick

  tempTimer(conf.ai_resetsmokebal, function ()
    if not bals.smoke and sk.smoketick == oldsmoketick then
      bals.smoke = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'smoke')
    end
  end)

  watch['bal_smoke'] = watch['bal_smoke'] or createStopWatch()
  startStopWatch(watch['bal_smoke'])

  raiseEvent(&quot;svo lost balance&quot;, 'smoke')
end

svo.lostbal_dragonheal = function()
  bals.dragonheal = false
  svo.startbalancewatch('dragonheal')
  sk.dragonhealtick = sk.dragonhealtick + 1
  local olddragonhealtick = sk.dragonhealtick

  -- dragonheal bal is quite long, add a bit of variation on it
  tempTimer(conf.ai_resetdragonhealbal+svo.getping(), function ()
    if not bals.dragonheal and sk.dragonhealtick == olddragonhealtick then
      bals.dragonheal = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'dragonheal')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'dragonheal')
end

if svo.haveskillset('healing') then
svo.lostbal_healing = function()
  if not bals.healing then return end

  bals.healing = false
  svo.startbalancewatch('healing')
  sk.healingtick = sk.healingtick + 1
  local oldhealingtick = sk.healingtick

  tempTimer(conf.ai_resethealingbal, function ()
    if not bals.healing and sk.healingtick == oldhealingtick then
      svo.endbalancewatch('healing')
      bals.healing = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'healing')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'healing')
end
end

if svo.haveskillset('terminus') then
svo.lostbal_word = function()
  if not bals.word then return end

  bals.word = false
  svo.startbalancewatch('word')
  sk.wordtick = sk.wordtick + 1
  local oldwordtick = sk.wordtick

  tempTimer(17+svo.getping(), function ()
    if not bals.word and sk.wordtick == oldwordtick then
      bals.word = true
      svo.make_gnomes_work()
      raiseEvent(&quot;svo got balance&quot;, 'word')
    end
  end)

  raiseEvent(&quot;svo lost balance&quot;, 'word')
end
end

function sk.doingstuff_inslowmode()
  local result
  for balance,actions in pairs(svo.bals_in_use) do
    if balance ~= 'waitingfor' and balance ~= 'gone' and balance ~= 'aff' and next(actions) then result = select(2, next(actions)) break end
  end
  if result then return true end
end

function sk.checkwillpower()
  if stats.currentwillpower &lt;= 1000 and not sk.lowwillpower then
    sk.lowwillpower = true
    sk.warn('lowwillpower')

    svo.can_usemana = function()
      return (stats.currentmana &gt; sys.manause and stats.currentwillpower &gt;= 100 and not svo.doingaction ('nomana'))
    end

  -- amounts differ so we don't toggle often
  elseif stats.currentwillpower &gt; 1500 and sk.lowwillpower then
    sk.lowwillpower = false

    svo.can_usemana = function()
      return (stats.currentmana &gt; sys.manause and not svo.doingaction ('nomana'))
    end
  end
end

sk.limbnames = {
  rightarm = true,
  leftarm = true,
  leftleg = true,
  rightleg = true,
  torso = true,
  head = true
}

if svo.haveskillset('healing') then
  sk.updatehealingmap = function ()
    sk.healingmap = {}
    if not conf.healingskill then return end

    local healdata = svo.pl.OrderedMap{}
    -- afflictions sorted in order of learning the Healing skillset - so not sort this list!
    -- healdata:set('blind', function() return defc.earth end)
    healdata:set('blindaff', function() return defc.earth end)
    healdata:set('paralysis', function() return defc.fire end)
    -- healdata:set('deaf', function() return defc.air end)
    healdata:set('deafaff', function() return defc.air end)
    -- healdata:set('fear', function() return defc.water end)
    healdata:set('confusion', function() return defc.fire end)
    -- healdata:set('insomnia', function() return defc.air end)
    healdata:set('slickness', function() return defc.earth end)
    healdata:set('stuttering', function() return defc.fire end)
    healdata:set('paranoia', function() return defc.earth and defc.water end)
    healdata:set('shyness', function() return defc.earth end)
    healdata:set('hallucinations', function() return defc.earth end)
    healdata:set('generosity', function() return defc.earth end)
    healdata:set('loneliness', function() return defc.air and defc.water end)
    healdata:set('impatience', function() return defc.fire end)
    healdata:set('unconsciousness', function() return defc.earth and defc.fire end)
    healdata:set('claustrophobia', function() return defc.fire and defc.water end)
    healdata:set('vertigo', function() return defc.earth and defc.fire end)
    healdata:set('sensitivity', function() return defc.earth and defc.fire and defc.water end)
    healdata:set('dizziness', function() return defc.water end)
    healdata:set('crippledrightarm', function() return defc.earth and not affs.mangledrightarm and not affs.mutilatedrightarm and not affs.mangledleftarm and not affs.mutilatedleftarm end)
    healdata:set('crippledleftarm', function() return defc.earth and not affs.mangledleftarm and not affs.mutilatedleftarm and not affs.mangledrightarm and not affs.mutilatedrightarm end)
    healdata:set('dementia', function() return defc.fire end)
    healdata:set('clumsiness', function() return defc.air and defc.water end)
    healdata:set('ablaze', function() return defc.earth and defc.water end)
    healdata:set('recklessness', function() return defc.water end)
    healdata:set('anorexia', function() return defc.earth and defc.air end)
    healdata:set('agoraphobia', function() return defc.air and defc.fire end)
    healdata:set('disloyalty', function() return defc.fire and defc.water end)
    healdata:set('hypersomnia', function() return defc.air and defc.water end)
    healdata:set('darkshade', function() return defc.earth and defc.fire end)
    healdata:set('masochism', function() return defc.air and defc.fire end)
    healdata:set('epilepsy', function() return defc.air and defc.fire end)
    healdata:set('asthma', function() return defc.air end)
    healdata:set('stupidity', function() return defc.water end)
    healdata:set('illness', function() return defc.earth and defc.water end)
    healdata:set('weakness', function() return defc.fire end)
    healdata:set('haemophilia', function() return defc.water end)
    healdata:set('crippledrightleg', function() return defc.air and defc.earth and not affs.mangledrightleg and not affs.mutilatedrightleg and not affs.mangledleftleg and not affs.mutilatedleftleg end)
    healdata:set('crippledleftleg', function() return defc.air and defc.earth and not affs.mangledleftleg and not affs.mutilatedleftleg and not affs.mangledrightleg and not affs.mutilatedrightleg end)
    healdata:set('hypochondria', function() return defc.earth and defc.air and defc.fire and defc.water end)

    local svonames = {
      ablaze          = 'burning',
      blindness       = 'blind',
      crippledleftarm = 'arms',
      crippledleftleg = 'legs',
      deafness        = 'deaf',
      illness         = 'vomiting',
      weakness        = 'weariness',
    }

    -- setup a map of afflictions that we can cure - key is aff, value is the proper aura cure as a string / table if it's a regen
    for aff, afft in healdata:iter() do
      sk.healingmap[aff] = afft

      if aff == conf.healingskill or (svonames[aff] and svonames[aff] == conf.healingskill) then break end
    end

  end
  signals.healingskillchanged:connect(sk.updatehealingmap, &quot;update available healing skills&quot;)
  signals.systemstart:connect(sk.updatehealingmap, &quot;update available healing skills&quot;)
end

function svo.sk.increase_lagconf()
  -- don't go above 3, 4 is reserved for do really
  if conf.lag &gt;= 3 then return end

  if sk.lag_tickedonce and not sk.increasedlag then
    conf.lag = conf.lag+1
    echo&quot;\n&quot; svo.echof(&quot;auto-increased the lag tolerance level to %d.&quot;, conf.lag)
    raiseEvent(&quot;svo config changed&quot;, 'lag')
    sk.increasedlag = true
    cnrl.update_wait()

    if sys.reset_laglevel then killTimer(sys.reset_laglevel) end
    sys.reset_laglevel = tempTimer(30, function ()
      if not svo.wait_tbl[conf.lag-1] then return end

      local variance = getNetworkLatency()*2+getNetworkLatency()
      for i = 0, #svo.wait_tbl do
        if variance &lt;= svo.wait_tbl[i].n then
          conf.lag = i
          cnrl.update_wait()
          echo&quot;\n&quot; svo.echof(&quot;automatically reset lag tolerance down to %d.&quot;, conf.lag)
          raiseEvent(&quot;svo config changed&quot;, 'lag')
          break
        end
      end
    end)
  else
    sk.lag_tickedonce = tempTimer(10, function () sk.lag_tickedonce = nil; sk.increasedlag = true end)
  end
end

if svo.haveskillset('metamorphosis') then
function svo.sk.clearmorphs()
  local morphs
  if svo.me.class == 'Druid' then
    morphs = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra'}
  else
    morphs = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm'}
  end
  for _, morph in ipairs(morphs) do
    if defc[morph] then
      defences.lost(morph)
    end
  end
end

function svo.sk.inamorph()
  local t
if svo.me.class == 'Druid' then
  t = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra'}
else
  t = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm'}
end
  for i = 1, #t do
    if defc[t[i]] then return true end
  end

  return false
end

function svo.sk.validmorphskill(name)
  local morphs
if svo.me.class == 'Druid' then
  morphs = {'squirrel', 'powers', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'bear', 'bonding', 'nightingale', 'elephant', 'transmorph', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'affinity', 'wyvern', 'hydra', 'truemorph'}
else
  morphs = {'squirrel', 'powers', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'bonding', 'nightingale', 'elephant', 'transmorph', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'affinity', 'truemorph'}
end

  for _, morph in ipairs(morphs) do
    if name:lower() == morph then return true end
  end

  return false
end

function svo.sk.inamorphfor(defence)
  if not sk.morphsforskill[defence] then return false end

  for i = 1, #sk.morphsforskill[defence] do
    if defc[sk.morphsforskill[defence][i]] then return true end
  end

  return false
end

function svo.sk.updatemorphskill()
  sk.morphsforskill = {}
if svo.me.class == 'Druid' then
  sk.morphsforskill.elusiveness = { 'hyena', 'wolverine' }
else
  sk.morphsforskill.elusiveness = { 'basilisk', 'hyena', 'wolverine', 'jaguar' }
end
if svo.me.class == 'Druid' then
  sk.morphsforskill.fitness = { 'wolf', 'cheetah', 'hyena', 'elephant', 'wyvern', 'hydra' }
else
  sk.morphsforskill.fitness = { 'wolf', 'cheetah', 'hyena', 'elephant', 'jaguar'}
end
if svo.me.class == 'Druid' then
  sk.morphsforskill.flame = { 'wyvern' }
else
  sk.morphsforskill.flame = { 'wyvern', 'basilisk' }
end
  sk.morphsforskill.lyre = { 'nightingale' }
if svo.me.class == 'Druid' then
  sk.morphsforskill.nightsight = { 'wildcat', 'wolf', 'cheetah', 'owl', 'hyena', 'condor', 'wolverine', 'eagle', 'icewyrm', 'wyvern', 'hydra' }
else
  sk.morphsforskill.nightsight = { 'wildcat', 'wolf', 'cheetah', 'owl', 'hyena', 'condor', 'wolverine', 'jaguar', 'eagle', 'icewyrm' }
end
  sk.morphsforskill.rest = { 'sloth' }
if svo.me.class == 'Druid' then
  sk.morphsforskill.resistance = { 'hydra' }
else
  sk.morphsforskill.resistance = { 'basilisk', 'jaguar' }
end
if svo.me.class == 'Druid' then
  sk.morphsforskill.stealth = { 'hyena' }
else
  sk.morphsforskill.stealth = { 'basilisk', 'hyena', 'jaguar' }
end
if svo.me.class == 'Druid' then
  sk.morphsforskill.temperance = { 'icewyrm', 'wyvern', 'hydra' }
else
  sk.morphsforskill.temperance = { 'icewyrm' }
end
if svo.me.class == 'Druid' then
  sk.morphsforskill.vitality = { 'bear', 'elephant', 'icewyrm', 'wyvern', 'hydra' }
else
  sk.morphsforskill.vitality = { 'bear', 'elephant', 'jaguar', 'icewyrm' }
end

  sk.skillmorphs = {}
  for skill, t in pairs(sk.morphsforskill) do
    for _, morph in ipairs(t) do
      sk.skillmorphs[morph] = sk.skillmorphs[morph] or {}
      sk.skillmorphs[morph][skill] = true
    end
  end

  local newskillmorphs = {}
  local morphlist
if svo.me.class == 'Druid' then
  morphlist = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'bear', 'nightingale', 'elephant', 'wolverine', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra'}
else
  morphlist = {'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm'}

end
  for _, morph in pairs(morphlist) do
    newskillmorphs[morph] = sk.skillmorphs[morph]
    if svo.conf.morphskill == morph then break end
  end
  sk.skillmorphs = newskillmorphs

  sk.morphsforskill = {}
  for morph, t in pairs(sk.skillmorphs) do
    for def, _ in pairs(t) do
      sk.morphsforskill[def] = sk.morphsforskill[def] or {}
      sk.morphsforskill[def][#sk.morphsforskill[def]+1] = morph
    end
  end

  do -- sort morph names in sk.morphsforskill such that the first one has the most morphs
    local morphdefs = {}
    for morph, t in pairs(sk.skillmorphs) do
      morphdefs[morph] = table.size(t)
    end

    for _, t in pairs(sk.morphsforskill) do
      table.sort(t, function(a,b) if morphdefs[a] and morphdefs[b] then return morphdefs[a] &gt; morphdefs[b] end end)
    end
  end
end
  signals.morphskillchanged:connect(sk.updatemorphskill, &quot;update available morph skills&quot;)
  signals.systemstart:connect(sk.updatemorphskill, &quot;update available morph skills&quot;)
end

signals.gmcpcharitemslist:connect(function ()
  if not gmcp.Char.Items.List.location then svo.debugf(&quot;(GMCP problem) location field is missing from Achaea's response.&quot;) return end
  if not sk.inring or gmcp.Char.Items.List.location ~= 'inv' then return end

  local hadsomething = {}
  for _, t in pairs(gmcp.Char.Items.List.items) do
    if t.attrib and t.attrib:find('r', 1, true) then

      -- see if we can optimize groupables with 'inr all &lt;type&gt;', making it easier count as well: handle groups first
      if t.name and t.name:find(&quot;a group of&quot;, 1, true) then
        -- function to scan plurals table
        local check = function(value,input) return input:find(&quot;a group of &quot;..value) end

        -- check herbs table
        local found_plural = next(svo.pl.tablex.map(check, rift.herbs_plural, t.name or &quot;&quot;))
        -- check other riftable items table
        found_plural = found_plural or next(svo.pl.tablex.map(check, rift.items_plural, t.name or &quot;&quot;))

        if found_plural and not hadsomething[found_plural] then
          svo.sendc(&quot;inr all &quot;..found_plural, false)
          hadsomething[found_plural] = true
        elseif not found_plural and not hadsomething[t.id] then
          svo.sendc(&quot;inr &quot;..t.id, false)
          hadsomething[t.id] = true
        end

      -- singular herb items that we know of
      elseif t.name and rift.herbs_singular[t.name] and not hadsomething[rift.herbs_singular[t.name]] then
        hadsomething[rift.herbs_singular[t.name]] = true
        svo.sendc(&quot;inr all &quot;..rift.herbs_singular[t.name], false)

      -- singular non-herb items
      elseif t.name and rift.items_singular[t.name] and not hadsomething[rift.items_singular[t.name]] then
        hadsomething[rift.items_singular[t.name]] = true
        svo.sendc(&quot;inr all &quot;..rift.items_singular[t.name], false)

      -- all the rest
      elseif not rift.items_singular[t.name] and not rift.herbs_singular[t.name] and not hadsomething[t.id] and t.attrib and t.attrib:find('r', 1, true) then
        svo.sendc(&quot;inr &quot;..t.id, true)
        hadsomething[t.id] = true
      end
    end
  end

  sk.inring = nil
  if next(hadsomething) then
    svo.echof(&quot;Stuffing everything away...&quot;)
  else
    svo.echof(&quot;There's nothing to stuff away.&quot;)
  end
end, &quot;handle inr&quot;)

signals.gmcpcharitemslist:connect(function()
  if not sk.retrieving_herbs or gmcp.Char.Items.List.location ~= 'room' then return end

  for _, t in pairs(gmcp.Char.Items.List.items) do
    if rift.herbs_singular[t.name] then
      svo.doaddfree(&quot;get &quot;..t.id)
    end

    -- tally up rift.herbs_plural items
    for _,l in pairs(rift.herbs_plural) do
      local result = t.name:match(l)
      if result then
        for _ = 1, tonumber(result) do -- getting group # only gets 1 item, have to repeatedly cycle it
          svo.doaddfree(&quot;get &quot;..t.id)
        end
      end
    end
  end

  sk.retrieving_herbs = nil
end, &quot;pick up plants&quot;)

for _, herb in ipairs{'elm', 'valerian', 'skullcap'} do
  sk[herb..'_smokepuff'] = function ()
    if not conf.arena then
      pipes[herb].puffs = pipes[herb].puffs - 1
      if pipes[herb].puffs &lt; 0 then pipes[herb].puffs = 0 end
    end

    if herb == 'valerian' then
      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    end

    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    setFgColor(unpack(svo.getDefaultColorNums))
    insertText(string.format(&quot; (%s %s left)&quot;, pipes[herb].puffs, pipes[herb].filledwith))
    resetFormat()
    moveCursorEnd()
  end
end

if svo.haveskillset('occultism') then
signals.gmcpcharitemslist:connect(function ()
  if not gmcp.Char.Items.List.location or not gmcp.Char.Items.List.items then svo.debugf(&quot;(GMCP problem) location or items field is missing from Achaea's response.&quot;) return end

  if gmcp.Char.Items.List.location ~= 'inv' then return end

  for _, t in pairs(gmcp.Char.Items.List.items) do
    if t.name then
      if t.name == &quot;a heartstone&quot; then
        defences.got('heartstone')
      elseif t.name == &quot;a simulacrum shaped like &quot;..me.name then
        defences.got('simulacrum')
      end
    end
  end
end, &quot;check heartstoneand simulacrum defs&quot;)
end

function svo.sk.enable_single_prompt()
  if svo.bottomprompt then svo.bottomprompt:show() end
  svo.bottomprompt = Geyser.MiniConsole:new({
    name=&quot;svo.bottomprompt&quot;,
    x=0, y=&quot;100%&quot;,
    width=&quot;98%&quot;, height='1c',
    fontSize = conf.singlepromptsize or 11
  })
  svo.bottomprompt:setFontSize(conf.singlepromptsize or 11)

  function svo.bottomprompt:reposition()
     local _,height = calcFontSize(conf.singlepromptsize or 11)

     if not svo.bottom_border or svo.bottom_border ~= height then
       svo.bottom_border = height
       tempTimer(0, function() setBorderBottom(height) end)
     end

     moveWindow(self.name, self:get_x(), self:get_y()-(height+(height/3)))
     resizeWindow(self.name, self:get_width(), self:get_height())
  end
  setBackgroundColor(&quot;svo.bottomprompt&quot;,0,0,0,255)
  svo.bottomprompt:reposition()

  if svo.moveprompt then killTrigger(svo.moveprompt) end
  -- moveprompt = tempRegexTrigger('^', [[
  --   if not isPrompt() then return end
  --   selectCurrentLine()
  --   copy()
  --   clearWindow(&quot;svo.bottomprompt&quot;)
  --   paste(&quot;svo.bottomprompt&quot;)
  --   if svo.conf.singlepromptblank then
  --     replace(&quot;&quot;)
  --   elseif not svo.conf.singlepromptkeep then deleteLine() end
  --   deselect()
  -- ]])
end

function svo.sk.showstatchanges()
  local t = sk.statchanges
  if #t &gt; 0 then
    if conf.singleprompt then
      moveCursor(0, getLineNumber()-1)
      moveCursor(#getCurrentLine(), getLineNumber())
      dinsertText(' &lt;192,192,192&gt;('..table.concat(t, &quot;, &quot;)..'&lt;192,192,192&gt;) ')
    else
      decho('&lt;192,192,192&gt;('..table.concat(t, &quot;, &quot;)..'&lt;192,192,192&gt;) ')
    end

    resetFormat()
    if conf.singleprompt then moveCursorEnd() end
  end
end

-- logic: if something we are wielding does not show up unparryables, then we can wield
function svo.sk.have_parryable()
  me.unparryables = me.unparryables or {}

  for _, item in pairs(me.wielded) do
    if not me.unparryables[item.name] then return true end
  end
end

function svo.sk.cant_parry()
  local t = {}
  me.unparryables = me.unparryables or {}
  for _, item in pairs(me.wielded) do
    if not me.unparryables[item.name] then
      t[#t+1] = item.name
      me.unparryables[item.name] = true
    end
  end

  if #t &gt; 0 then
    echo'\n'

    local lines = {
      &quot;Oh, looks like we can't parry with %s.&quot;,
      &quot;Doesn't look like we can parry with %s.&quot;,
      &quot;Oops. Can't parry with %s.&quot;,
      &quot;And %s won't fly, either.&quot;,
      &quot;And %s won't work, either.&quot;
    }

    svo.echof(lines[math.random(#lines)], table.concat(t, ' or '))
  end
end

signals.newroom:connect(function ()
  -- don't get tricked by dementia, which does send false gmcp
  -- nor by hidden dementia
  if affs.dementia or affs.unknownany or affs.unknownmental or not conf.autoarena then return end

  local t = sk.arena_areas

  local area = atcp.RoomArea or gmcp.Room.Info.area

  if t[area] and not conf.arena then
    conf.arena = true
    raiseEvent(&quot;svo config changed&quot;, 'arena')
    svo.prompttrigger(&quot;arena echo&quot;, function()
      local echos = {&quot;Arena mode enabled. Good luck!&quot;, &quot;Beat 'em up! Arena mode enabled.&quot;, &quot;Arena mode on.&quot;, &quot;Arena mode enabled. Kill them all!&quot;}
      svo.itf(echos[math.random(#echos)]..'\n')
    end)
  elseif conf.arena and not t[area] then
    conf.arena = false
    raiseEvent(&quot;svo config changed&quot;, &quot;arena`&quot;)
    tempTimer(0, function()
      local echos = {&quot;Arena mode disabled.&quot;}
      svo.echof(echos[math.random(#echos)]..'\n')

      -- the game resets armbals quietly
      if not bals.rightarm then bals.rightarm = true end
      if not bals.leftarm then bals.leftarm = true end
    end)
  end
end, 'update arena status')

-- this will get connected on load
sk.check_burrow_pause = function()
  local roomname = _G.gmcp.Room.Info.name

  if not conf.paused and roomname == &quot;Surrounded by dirt&quot; then sk.paused_for_burrow = true; svo.app('on')
  elseif sk.paused_for_burrow and conf.paused and roomname ~= &quot;Surrounded by dirt&quot; and stats.currenthealth &gt; 0 then svo.app('off')
  end
end

function svo.sk.check_shipmode()
  -- failsafe for disabling captain control - since there are a few ways in which you can lose it without an explicit line.
  if conf.shipmode and gmcp.Room.Info.environment ~= 'Vessel' then
    svo.config.set('shipmode', 'off', true)
  end
end

function svo.balanceful_used()
  return (sys.balanceid == sys.balancetick) and true or false
end

-- getNetworkLatency, with a cap
function svo.getping(caparg)
  local cap = caparg or .500
  local lat = getNetworkLatency()

  return (lat &lt; cap) and lat or cap
end

-- returns true if a curing command was seen in this paragraph
function svo.sk.sawcuring()
  -- don't search the buffer, but set a flag, because people could be gagging the line and buffer search will thus fail
  return sk.sawcuringcommand and true or false
end

function svo.sk.sawqueueing()
  return sk.sawqueueingcommand and true or false
end

function svo.amiwielding(what)
  for _, item in pairs(svo.me.wielded) do
    if item.name:find(&quot;%f[%a]&quot;..what..&quot;%f[%A]&quot;) then return true end
  end

  return false
end

function sk.sendqueuecmd(...)
  local args = {...}
  for i = 1, #args do
    local what = args[i]
    if type(what) == 'string' then
      -- flush the buffer if it'll overflow how many chars we can send
      if sk.sendqueuel + #what + 1 &gt;= sk.achaea_command_max_length then
        sk.dosendqueue()
      end

      sk.sendqueue[#sk.sendqueue+1] = what
      sk.sendqueuel = sk.sendqueuel + #what + 1 -- +1 for the separator
      if not sk.sendcuringtimer then
        sk.sendcuringtimer = tempTimer(0, sk.dosendqueue)
      end
    elseif type(what) == 'table' and what.func then
      sk.dosendqueue() --flush send queue first
      if what.args then
        what.func(unpack(what.args))
      else
        what.func()
      end
    end
  end
end

function svo.sendcuring(what)
  what = &quot;curing &quot;..what

  sk.sendqueuecmd(what)
end

-- public function
svo.sendc = sk.sendqueuecmd

function svo.sk.dosendqueue()
  if sk.sendcuringtimer then killTimer(sk.sendcuringtimer) end

  if #sk.sendqueue &lt;= 1 then
    send(sk.sendqueue[1] or '', false)
  elseif conf.commandseparator and conf.commandseparator ~= '' and #sk.sendqueue &lt;= 10 then
    send(table.concat(sk.sendqueue, conf.commandseparator), false)
  elseif #sk.sendqueue &lt;= 9 then
    send(&quot;9multicmd {&quot;..table.concat(sk.sendqueue, &quot;}{&quot;)..&quot;}&quot;, false)
  else
    local text = table.concat(sk.sendqueue, &quot;/&quot;)
    sendAll(&quot;setalias multicmd &quot;..text, 'multicmd', false)
  end

  sk.sendqueue = {}
  sk.sendqueuel = 18 -- 'setalias multicmd ' is 24 characters
  sk.sendcuringtimer = nil
end

function svo.sk.setup9multicmd()
  send(&quot;setalias 9multicmd %1/%2/%3/%4/%5/%6/%7/%8/%9&quot;, false)
end
signals.charname:connect(sk.setup9multicmd, 'setup 9multicmd')
signals.gmcpcharname:connect(sk.setup9multicmd, 'setup 9multicmd')

svo['9multicmd_cleared'] = function()
  send(&quot;setalias 9multicmd %1/%2/%3/%4/%5/%6/%7/%8/%9&quot;)

  echo(&quot;\n&quot;)
  svo.echof(&quot;Oy! I need that! This is for vconfig batch to work.&quot;)

  svo.reenabled9multi = tempTimer(5, function() svo.reenabled9multi = nil end)
end

-- things line blind/deaf can be either afflictions or defences.
-- This function is called whenever their status as a defence might change, and you have them - hence they need to be
-- changed to a defence now or back
function svo.sk.fix_affs_and_defs()
  if affs.blindaff and ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
    or (svo.me.class ~= 'Apostate' and defc.mindseye)) then
    svo.rmaff('blindaff')
    defences.got('blind')
    svo.echof(&quot;blindness is now considered a defence.&quot;)
  elseif defc.blind and not ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)
   or (svo.me.class ~= 'Apostate' and defc.mindseye)) then
    defences.lost('blind')
    svo.addaffdict(svo.dict.blindaff)
    svo.echof(&quot;blindness is now considered an affliction, will cure it.&quot;)
  end

  if affs.deafaff and ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
    svo.rmaff('deafaff')
    defences.got('deaf')
    svo.echof(&quot;deafness is now considered a defence.&quot;)
  elseif defc.deaf and not ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
    defences.lost('deaf')
    svo.addaffdict(svo.dict.deafaff)
    svo.echof(&quot;deafness is now considered an affliction, will cure it.&quot;)
  end
end


function svo.sk.checkrewield()
  local s,m = pcall(function()
    if svo.paragraph_length &gt; 1 and not svo.find_until_last_paragraph(&quot;You cease to prop up a tall totem pole.&quot;, 'exact') and
      not svo.find_until_last_paragraph(&quot;You lob&quot;, 'substring') and not svo.lifevision.l.breath_gone and
      not svo.find_until_last_paragraph(&quot;You begin to wield&quot;, 'substring') then
      -- we wish to rewield wieldables!
      svo.dict.rewield.rewieldables = deepcopy(sk.rewielddables)
      svo.debugf(&quot;dict.rewield.rewieldables - %s&quot;, svo.pl.pretty.write(svo.dict.rewield.rewieldables))
      svo.echof(&quot;Need to rewield %s%s!&quot;, tostring(svo.dict.rewield.rewieldables[1].name),
        tostring(((svo.dict.rewield.rewieldables[2] and svo.dict.rewield.rewieldables[2].name) and
          (&quot; and &quot;..svo.dict.rewield.rewieldables[2].name) or &quot;&quot;)))
    end
  end)
  if not s then
    echoLink(&quot;(e!)&quot;, [[echo(&quot;The problem was: ']]..tostring(m)..[['&quot;)]], 'Oy - there was a problem. Click on this link '
      ..'and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  sk.rewielddables = nil
  signals.before_prompt_processing:disconnect(sk.checkrewield)
end

signals.gmcpcharitemsremove:connect(function ()
  sk.removed_something = true
  sk.onprompt_beforeaction_add('gmcpcharitemsremove', function ()
    sk.removed_something = nil
  end)
end, 'update sk.removed_something')
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Controllers</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local conf, sk, me, defs, defc = svo.conf, svo.sk, svo.me, svo.defs, svo.defc
local defences, stats, cnrl, rift = svo.defences, svo.stats, svo.cnrl, svo.rift
local bals, pipes, valid, actions = svo.bals, svo.pipes, svo.valid, svo.actions
local lifevision = svo.lifevision

local oldhealth, oldmana = 0, 0
me.healthchange, me.manachange = 0, 0
local function calculatestatchanges()
  local t = {}

  me.healthchange = 0
  me.manachange = 0
  if oldhealth &gt; stats.currenthealth then
    me.healthchange = stats.currenthealth - oldhealth

    if conf.showchanges then
      if conf.changestype == 'full' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt; Health&quot;, me.healthchange)
      elseif conf.changestype == 'short' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt;h&quot;, me.healthchange)
      elseif conf.changestype == 'fullpercent' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt; Health, %.1f%%&quot;, me.healthchange, 100/stats.maxhealth*me.healthchange*-1)
      elseif conf.changestype == 'shortpercent' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt;h, %.1f%%&quot;, me.healthchange, 100/stats.maxhealth*me.healthchange*-1)
      end
    end

  elseif oldhealth &lt; stats.currenthealth then
    me.healthchange = stats.currenthealth - oldhealth

    if conf.showchanges then
      if conf.changestype == 'full' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt; Health&quot;, me.healthchange)
      elseif conf.changestype == 'short' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt;h&quot;, me.healthchange)
      elseif conf.changestype == 'fullpercent' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt; Health, %.1f%%&quot;, me.healthchange, 100/stats.maxhealth*me.healthchange)
      elseif conf.changestype == 'shortpercent' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt;h, %.1f%%&quot;, me.healthchange, 100/stats.maxhealth*me.healthchange)
      end
    end
  end

  if oldmana &gt; stats.currentmana then
    me.manachange = stats.currentmana - oldmana

    if conf.showchanges then
      if conf.changestype == 'full' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt; Mana&quot;, me.manachange)
      elseif conf.changestype == 'short' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt;m&quot;, me.manachange)
      elseif conf.changestype == 'fullpercent' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt; Mana, %.1f%%&quot;, me.manachange, 100/stats.maxmana*me.manachange*-1)
      elseif conf.changestype == 'shortpercent' then
        t[#t+1] = string.format(&quot;&lt;255,0,0&gt;%d&lt;128,128,128&gt;m, %.1f%%&quot;, me.manachange, 100/stats.maxmana*me.manachange*-1)
      end
    end

  elseif oldmana &lt; stats.currentmana then
    me.manachange = stats.currentmana - oldmana

    if conf.showchanges then
      if conf.changestype == 'full' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt; Mana&quot;, me.manachange)
      elseif conf.changestype == 'short' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt;m&quot;, me.manachange)
      elseif conf.changestype == 'fullpercent' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt; Mana, %.1f%%&quot;, me.manachange, 100/stats.maxmana*me.manachange)
      elseif conf.changestype == 'shortpercent' then
        t[#t+1] = string.format(&quot;&lt;0,255,0&gt;+%d&lt;128,128,128&gt;m, %.1f%%&quot;, me.manachange, 100/stats.maxmana*me.manachange)
      end
    end
  end

  -- update the public old values
  me.oldhealth, me.oldmana = oldhealth, oldmana

  -- update oldhealth, oldmana to current values
  oldhealth, oldmana = stats.currenthealth, stats.currentmana

  -- store away changed for showing later, as the custom prompt that follows overrides
  sk.statchanges = t
end

local blackout_flag
function svo.blackout()
  blackout_flag = true
end

local function checkblackout()
  if blackout_flag and not affs.blackout then
    valid.simpleblackout()
  elseif not blackout_flag and affs.blackout and getCurrentLine() ~= &quot;&quot; then
    if actions.touchtree_misc then
      lifevision.add(actions.touchtree_misc.p, nil, 'blackout')
    else
      svo.checkaction(svo.dict.blackout.waitingfor, true)
      lifevision.add(actions.blackout_waitingfor.p)
    end
  end

  blackout_flag = false
end

function svo.valid.setup_prompt()
  if line == &quot;-&quot; or line:find(&quot;^%-%d+%-$&quot;) or line == &quot; Vote-&quot; then
    -- bals.balance = true
    -- bals.equilibrium = true
    bals.rightarm = 'unset'
    bals.leftarm = 'unset'
  else
    bals.balance = false
    bals.equilibrium = false
if svo.haveskillset('healing') then
    bals.healing = false
end
    svo.pflags = {}
  end
end

local function check_promptflags()
  local pflags = svo.pflags

  if pflags.b and not defc.blind and not affs.blindaff then
    if ((defdefup[defs.mode].blind) or (conf.keepup and defkeepup[defs.mode].blind)) then
      if svo.me.class == 'Apostate' and not defc.mindseye then
        return
      end
      defences.got('blind')
    else
      svo.addaffdict(svo.dict.blindaff)
    end
  elseif not pflags.b and (defc.blind or affs.blindaff) then
    svo.rmaff('blindaff')
    defences.lost('blind')
  end

  if pflags.d and not defc.deaf and not affs.deafaff then
    if ((defdefup[defs.mode].deaf) or (conf.keepup and defkeepup[defs.mode].deaf) or defc.mindseye) then
      defences.got('deaf')
    else
      svo.addaffdict(svo.dict.deafaff)
    end
  elseif not pflags.d and (defc.deaf or affs.deafaff) then
    svo.rmaff('deafaff')
    defences.lost('deaf')
  end

  if pflags.k and not defc.kola then
    defences.got('kola')
  elseif not pflags.k and defc.kola then
    defences.lost('kola')
  end

  if pflags.c and not defc.cloak then
    defences.got('cloak')
  elseif not pflags.c and defc.cloak then
    defences.lost('cloak')
  end

if svo.haveskillset('shindo') then
  stats.shin = line:match(&quot;%-(%d+)%-&quot;) or line:match(&quot;%-(%d+) Vote%-&quot;) or 0
end

if svo.haveskillset('kaido') then
  stats.kai = line:match(&quot;%-(%d+)%-&quot;) or line:match(&quot;%-(%d+) Vote%-&quot;) or 0
end

if svo.haveskillset('necromancy') then
  if pflags.at then defences.got('blackwind') else defences.lost('blackwind') end
end

if svo.haveskillset('occultism') then
  if pflags.at then defences.got('astralform') else defences.lost('astralform') end
end

if svo.haveskillset('subterfuge') then
  if pflags.at then defences.got('phase') else defences.lost('phase') end
end

  local oldgametarget, oldgametargethp = me.gametarget, me.gametargethp
  me.gametarget, me.gametargethp = line:match(&quot;%[(.-)%](%d+)%%&quot;)
  if me.gametargethp then me.gametargethp = tonumber(me.gametargethp) end
  if oldgametarget ~= me.gametarget then
    raiseEvent(&quot;svo gametarget changed&quot;, me.gametarget)
  end
  if oldgametargethp ~= me.gametargethp then
    raiseEvent(&quot;svo gametargethp changed&quot;, me.gametarget, me.gametargethp)
  end

if svo.haveskillset('weaponmastery') then
  stats.weaponmastery = line:match(&quot;k(%d+)&quot;)
end

  me.servertime = line:match(&quot;-s(%d+:%d+:%d+%.%d+)&quot;)
end

function svo.onprompt()
  raiseEvent(&quot;svo before the prompt&quot;)
  sk.processing_prompt = true
  sk.systemscommands = {}

  svo.promptcount = svo.promptcount + 1

  checkblackout()
  check_promptflags()

  sys.lagcount = 0
  svo.prompt_stats()
  calculatestatchanges()

  local s,m = pcall(signals.before_prompt_processing.emit, signals.before_prompt_processing)
  if not s then
    echoLink(&quot;(e!)&quot;, [[svo.echof(&quot;The problem was: stuff before the actual work failed (]]..tostring(m)..[[)&quot;)]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  svo.send_in_the_gnomes()

  if conf.showchanges and not conf.commandecho or (conf.commandecho and conf.commandechotype == 'fancynewline') then
    sk.showstatchanges()
  end

  local processing_status, processing_message = pcall(signals.after_prompt_processing.emit, signals.after_prompt_processing)
  if not processing_status then
    svo.debugf(processing_message)
    echoLink(&quot;(e!)&quot;, string.format(&quot;svo.echof([[The problem was: stuff after the actual work failed (%q)]])&quot;, m), 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end

  if conf.showchanges and conf.commandecho and conf.commandechotype ~= 'fancynewline' then sk.showstatchanges() end
  if sys.deffing then svo.defupfinish() end

  -- show system commands
  svo.fancysendall()

  -- send off all batched commands
  sk.dosendqueue()

  local currentlinenumber = getLastLineNumber('main')
  svo.lastpromptnumber = currentlinenumber
  -- record the time of the latest prompt we've seen - doing so is okay because we aren't using the current time, but retrieving the already calculated time from Mudlet
  -- using this, we can then find which was the most recent prompt line. Sometimes another line will share the time with the prompt, but the prompt will always be latest
  svo.lastprompttime = getTimestamp(currentlinenumber)
  svo.paragraph_length = 0
  sk.processing_prompt = false
  raiseEvent(&quot;svo done with prompt&quot;)
end

signals.after_prompt_processing:connect(function ()
  -- svo prompt pipeline - deals with the custom and singleprompts. This is done before onprompt()

  -- move the real prompt over for later use.
  moveCursorEnd()
  if selectString( getCurrentLine(), 1 ) ~= -1 then
    copy()
    moveCursorEnd('svo_prompt')
    paste('svo_prompt')
  end

  -- stats are updated in a pre-emit of before_prompt_processing; available to the customprompt here
  if affs.blackout or svo.innews then return end

  -- replace w/ customprompt if necessary
  if conf.customprompt then
    selectString(line, 1)
    replace(&quot;&quot;)
  end

  -- prefix an orange '?:' if we don't know the exact stats
  if affs.recklessness or affs.blackout then
    local currentline = getLineCount()
    moveCursor('main', 0, currentline)
    deselect()
    setFgColor(255, 102, 0)
    insertText(&quot;?:&quot;)
    deselect(); resetFormat()
    moveCursorEnd()
  end

  if sys.sync then
    local currentline = getLineCount()
    deselect()
    moveCursor('main', 0, currentline)
    setFgColor(255, 0, 0)
    insertText(&quot;(&quot;)
    moveCursor('main', 1, currentline)

    -- you're overriding the system, green
    if svo.sacid then
      setFgColor(0,255,0)
    -- system is doing something, red
    elseif sk.doingstuff_inslowmode() then
      setFgColor(255,0,0)
    -- system isn't doing anything and you aren't overriding, blue
    else
      setFgColor(0,0,255)
    end

    if svo.sacid then
      insertLink('a', 'svo.echof[[You\'re currently overriding the system]]', 'You were overriding the system at this point', true)
    elseif sk.syncdebug then
      insertLink('a', 'svo.echof[['..sk.syncdebug..']]', 'Click to see actions we were considering doing at this point', true)
    else
      insertText('a')
    end

    moveCursor('main', 2, currentline)
    setFgColor(255, 0, 0)
    insertText(&quot;)&quot;)
    moveCursor('main', 3, currentline)
    setFgColor(0,0,0)
    insertText(&quot; &quot;)
    moveCursorEnd()
    resetFormat()
  end

  if conf.paused then
    moveCursor('main', 0, getLineCount())
    cinsertText(&quot;&lt;a_red&gt;(&lt;a_darkgrey&gt;p&lt;a_red&gt;)&lt;black&gt; &quot;)
  end

  if conf.customprompt then
    cecho(svo.cp.display() or &quot;&quot;)
  end

  -- then do singleprompt business
  if conf.singleprompt then
    selectString(getCurrentLine(), 1)
    copy()
    clearWindow('bottomprompt')
    svo.bottomprompt:paste()

    if conf.singlepromptblank then
      replace(&quot;&quot;)
    elseif not conf.singlepromptkeep then
      deleteLine()
    end

    deselect()
  end
end, &quot;main prompt processing&quot;)

signals.gmcpcharname:connect(function()
  svo.innews = nil
  sk.logged_in = true
end, &quot;set login status&quot;)

signals.gmcpcharstatus:connect(function()
  sys.charname = gmcp.Char.Status.name
  me.name = gmcp.Char.Status.name
end, &quot;grab gmcp name&quot;)

local old500num = 0
local old500p = false


function svo.prio_makefirst(action, balance)
  svo.assert(action and svo.dict[action], &quot;svo.prio_makefirst: &quot; .. (action and action or 'nil') .. &quot; isn't a valid action.&quot;)

  local act = svo.dict[action]

  -- find if it's only one available
  if not balance then
    local count = table.size(act)
    if act.aff then count = count - 1 end
    if act.waitingfor then count = count - 1 end

    svo.assert(count == 1, &quot;svo.prio_makefirst: &quot; .. action .. &quot; uses more than one balance, which one do you want to move?&quot;)
    local balance = false
    for k,_ in pairs(act) do
      if k ~= 'aff' and k ~= 'waitingfor' then balance = k end
    end
  end

  svo.assert(act[balance] and act[balance] ~= 'aff' and act[balance] ~= 'waitingfor', &quot;svo.prio_makefirst: &quot; .. action .. &quot; doesn't use the &quot; .. (balance and balance or 'nil') .. &quot; balance.&quot;)

  local beforestate = sk.getbeforestateprios()

  -- at this point, we both have the act and balance we want to move up.
  -- logic: move to 500, remember the original val. when we have to move back,
  -- we'll swap it to the original val.
  svo.prio_undofirst()

  old500num = act[balance].spriority
  old500p = act[balance]
  act[balance].spriority = 500

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function svo.prio_undofirst()
  if not old500p then return end

  local beforestate = sk.getbeforestateprios()

  old500p.spriority = old500num
  old500p, old500num = false, nil

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function svo.prio_slowswap(what, arg3, echoback, callback, ...)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end
  local what, balance = what:match(&quot;(%w+)_(%w+)&quot;)
  local balance2
  if not tonumber(arg3) then
    svo.assert(balance and balance2, &quot;What balances do you want to use for swapping?&quot;, sendf)
    arg3, balance2 = arg3:match(&quot;(%w+)_(%w+)&quot;)
  end

  local beforestate = sk.getbeforestateprios()

  if tonumber(arg3) then -- swap to a #
    local name, balance2 = svo.prio.getslowaction(tonumber(arg3))
    if not name then -- see if we have anyone in that # already
      svo.dict[what][balance].spriority = arg3
      if echoback then
        svo.echof(&quot;%s is now at %d.&quot;, what, arg3)
      end
    else -- if we do have someone at that #, swap them
      svo.dict[what][balance].spriority, svo.dict[name][balance2].spriority =
      svo.dict[name][balance2].spriority, svo.dict[what][balance].spriority
      if echoback then svo.echof(&quot;%s is now &gt; %s.&quot;, what, name) end
      if echoback then svo.echof(&quot;&lt;0,255,0&gt;%s (%s) &lt;255,255,255&gt;&gt; &lt;0,255,0&gt;%s (%s)&quot;, what, balance, name, balance2) end
    end
  else -- swap one action_balance with another action_balance
    if svo.dict[what][balance].spriority &lt; svo.dict[arg3][balance2].spriority then
      svo.dict[what][balance].spriority, svo.dict[arg3][balance2].spriority =
      svo.dict[arg3][balance2].spriority, svo.dict[what][balance].spriority
      if echoback then svo.echof(&quot;%s is now &gt; %s.&quot;, what, arg3) end
      if echoback then svo.echof(&quot;&lt;0,255,0&gt;%s (%s) &lt;255,255,255&gt;&gt; &lt;0,255,0&gt;%s (%s)&quot;, arg3, balance2, what, balance) end
    elseif echoback then
      svo.echof(&quot;%s is already &gt; %s.&quot;, what, arg3)
    end
  end

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)

  if callback and type(callback) == 'function' then callback(...) end
end

function svo.prio_swap(what, balance, arg2, arg3, echoback, callback, ...)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end
  svo.assert(what and svo.dict[what] and balance and svo.dict[what][balance] and balance ~= 'aff' and balance ~= 'waitingfor', &quot;what item and balance do you want to swap?&quot;, sendf)

  local function swaptwo(what, name, balance, ...)
    if svo.dict[what][balance].aspriority &lt; svo.dict[name][balance].aspriority then
      svo.dict[what][balance].aspriority, svo.dict[name][balance].aspriority =
      svo.dict[name][balance].aspriority, svo.dict[what][balance].aspriority
      if echoback then svo.echof(&quot;&lt;0,255,0&gt;%s &lt;255,255,255&gt;&gt; &lt;0,255,0&gt;%s%s in %s balance&quot;, what, name, svo.getDefaultColor(), balance) end
    elseif svo.dict[what][balance].aspriority &gt; svo.dict[name][balance].aspriority then
      svo.dict[what][balance].aspriority, svo.dict[name][balance].aspriority =
      svo.dict[name][balance].aspriority, svo.dict[what][balance].aspriority
      if echoback then svo.echof(&quot;&lt;0,255,0&gt;%s &lt;255,255,255&gt;&gt; &lt;0,255,0&gt;%s%s in %s balance&quot;, name, what, svo.getDefaultColor(), balance) end
    end

    if callback and type(callback) == 'function' then callback(...) end
  end

  local beforestate = sk.getbeforestateprios()

  -- we want our 'what' to be at this arg2 number, swap what was there with its previous position
  if not arg3 then

    svo.assert(tonumber(arg2), &quot;what number do you want to swap &quot; .. what .. &quot; with?&quot;, sendf)
    local to_num = tonumber(arg2)
    local name = svo.prio.getaction(to_num, balance)

    -- swapping two affs
    if name then
      swaptwo(what, name, balance, ...)

    -- or just setting one aff
    else
      svo.dict[what][balance].aspriority = to_num
      if echoback then
        svo.echof(&quot;%s is now at %d.&quot;, what, to_num)
      end
    end

    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    return
  end

  -- we want to swap two affs
  svo.assert(svo.dict[arg2] and svo.dict[arg2][arg3], &quot;what balance of &quot;..arg2..&quot; do you want to swap with?&quot;, sendf)
  swaptwo(what, arg2, arg3, ...)

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

svo.prompt_stats = function ()
  local s,m = pcall(function()
    if not (gmcp and gmcp.Char and gmcp.Char.Vitals) then
        if not conf.paused then
          conf.paused = true
          echo&quot;\n&quot; svo.echof(&quot;Paused the system - please enable GMCP for it in Mudlet settings!&quot;) svo.showprompt()
          raiseEvent(&quot;svo config changed&quot;, 'paused')
        end
      return
    end

    local temp = {
      maxhealth = stats.maxhealth or 0,
      maxmana = stats.maxmana or 0,
    }

    local vitals = gmcp.Char.Vitals
    local sformat = string.format


    stats.currenthealth, stats.maxhealth,
    stats.currentmana, stats.maxmana,
    stats.currentendurance, stats.maxendurance,
    stats.currentwillpower, stats.maxwillpower
     =
        vitals.hp, vitals.maxhp,
        vitals.mp, vitals.maxmp,
        vitals.ep, vitals.maxep,
        vitals.wp, vitals.maxwp

    stats.nextlevel = gmcp.Char.Vitals.nl or 0
    stats.xprank = gmcp.Char.Status.xprank or 0

    stats.hp = sformat(&quot;%.1f&quot;, (100/stats.maxhealth)*stats.currenthealth)
    stats.mp = sformat(&quot;%.1f&quot;, (100/stats.maxmana)*stats.currentmana)
    stats.wp = sformat(&quot;%.1f&quot;, (100/stats.maxwillpower)*stats.currentwillpower)
    stats.ed = sformat(&quot;%.1f&quot;, (100/stats.maxendurance)*stats.currentendurance)

    for i,j in pairs(stats) do
      stats[i] = tonumber(j) or 0
    end

    if (stats.currentwillpower &lt;= 1000 and not (stats.currenthealth == 0 and stats.currentmana == 0)) or sk.lowwillpower then
      sk.checkwillpower()
    end

    if (affs.blackout and not ((lifevision.l.touchtree_misc and lifevision.l.touchtree_misc.arg == 'blackout') or lifevision.l.blackout_waitingfor)) or (affs.recklessness and not actions.recklessness_focus and not actions.recklessness_herb) then
      local assumestats = conf.assumestats/100
      stats.currenthealth, stats.currentmana =
        math.floor(stats.maxhealth * assumestats), math.floor(stats.maxmana * assumestats)
    end

    -- see what max values changed, update other info accordingly
    if temp.maxhealth ~= stats.maxhealth then
      signals.changed_maxhealth:emit(temp.maxhealth, stats.maxhealth)
    end
    if temp.maxmana ~= stats.maxmana then
      signals.changed_maxmana:emit(temp.maxmana, stats.maxmana)
    end
  end)

  if not s then
    echoLink(&quot;(e!)&quot;, [[echo(&quot;The problem was: prompt vitals function failed - (]]..tostring(m)..[[). Maybe the system isn't installed yet?&quot;)]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
  end
end


function svo.QQ()
  signals.quit:emit()
end

svo.savesettings = svo.QQ

-- add in blackout only, otherwise go off the prompt - this allows for time tracking
function svo.goteq()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end

  if sys.misseddisrupt then killTimer(sys.misseddisrupt); sys.misseddisrupt = nil end
  sys.extended_eq = nil

  if affs.blackout and not bals.equilibrium then bals.equilibrium = true; raiseEvent(&quot;svo got balance&quot;, 'equilibrium') end
end

function svo.gotbalance()
  if affs.blackout then bals.balance = true end
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end

  -- FIXME
  if affs.blackout and not bals.balance then bals.balance = true; raiseEvent(&quot;svo got balance&quot;, 'balance') end
end

function svo.gotarmbalance()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end
end

signals[&quot;svo lost balance&quot;]:connect(function(balance)
  if balance ~= 'equilibrium' or not conf.noeqtimeout or conf.noeqtimeout == 0 or conf.serverside then return end

  if sys.misseddisrupt then killTimer(sys.misseddisrupt) end
  sys.misseddisrupt = tempTimer(conf.noeqtimeout, function()
    if not bals.equilibrium and not sys.extended_eq and not svo.innews and not affs.disrupt then
      svo.addaffdict(svo.dict.disrupt)
      if not me.passive_eqloss then
        svo.echof(&quot;didn't get eq back in %ss - assuming disrupt&quot;, tostring(conf.noeqtimeout))
      else
        svo.echof(&quot;didn't get eq back in %ss - assuming disrupt and confusion&quot;, tostring(conf.noeqtimeout))
        svo.addaffdict(svo.dict.confusion)
      end

      svo.make_gnomes_work()
    end
  end)
end, &quot;disrupt/confusion detection&quot;)

signals[&quot;svo got balance&quot;]:connect(function(balance)
  if balance ~= 'equilibrium' then return end

  if affs.disrupt then svo.rmaff('disrupt') end
end, &quot;disrupt gone detection&quot;)

if svo.haveskillset('weaponmastery') then
signals[&quot;svo got balance&quot;]:connect(function(balance)
  if balance ~= 'balance' then return end

  sk.didfootingattack = false
end, &quot;footingattack&quot;)
end

-- set a flag that we shouldn't assume disrupt on long-eq actions
function svo.extended_eq()
  sys.extended_eq = true
end

function svo.cnrl.update_siphealth()
  if conf.siphealth then sys.siphealth                   = math.floor(stats.maxhealth * (conf.siphealth/100)) end
  if conf.mosshealth then sys.mosshealth                 = math.floor(stats.maxhealth * (conf.mosshealth/100)) end
  if conf.transmuteamount then sys.transmuteamount       = math.floor(stats.maxhealth * (conf.transmuteamount/100)) end
  if conf.corruptedhealthmin then sys.corruptedhealthmin = math.floor(stats.maxhealth * (conf.corruptedhealthmin/100)) end
if svo.haveskillset('devotion') then
  if conf.bloodswornoff then sys.bloodswornoff           = math.floor(stats.maxhealth * (conf.bloodswornoff/100)) end
end
end
signals.changed_maxhealth:connect(cnrl.update_siphealth, &quot;cnrl.update_siphealth&quot;)

function svo.cnrl.update_sipmana()
  if conf.sipmana then sys.sipmana = math.floor(stats.maxmana * (conf.sipmana/100)) end
  if conf.mossmana then sys.mossmana = math.floor(stats.maxmana * (conf.mossmana/100)) end

  sys.manause = math.floor(stats.maxmana * (conf.manause/100))
end
signals.changed_maxmana:connect(cnrl.update_sipmana, &quot;cnrl.update_sipmana&quot;)


function svo.cnrl.update_wait()
  sys.wait = svo.wait_tbl[conf.lag].n
end

svo.can_usemana = function()
  return stats.currentmana &gt; sys.manause and
    not svo.doingaction('nomana') -- pseudo-tracking for blackout and recklessness
    and (stats.wp or 0) &gt; 1
end

if svo.haveskillset('healing') then
-- string -&gt; boolean
-- given an affliction, returns true if we've got the available channels open for it
svo.havechannelsfor = function(aff)
  if sk.healingmap[aff] and sk.healingmap[aff]() then
    return true
  end
end
end

svo.cnrl.warnids = {}

-- tbl: {initialmsg = &quot;&quot;, prefixwarning = &quot;&quot;, startin = 0, duration = 0}
function svo.givewarning(tbl)
  svo.checkaction(svo.dict.givewarning.happened, true)

  if conf.aillusion then
    lifevision.add(actions.givewarning_happened.p, nil, tbl, 1)
  else
    lifevision.add(actions.givewarning_happened.p, nil, tbl)
  end
end
function svo.givewarning_multi(tbl)
  svo.checkaction(svo.dict.givewarning.happened, true)
  lifevision.add(actions.givewarning_happened.p, nil, tbl)
end

svo.prefixwarning = function ()
  local deselect, echo, setFgColor = deselect, echo, setFgColor

  if conf.warningtype == 'right' then
    local currentline = getCurrentLine()
    deselect()
    echo(string.rep(&quot; &quot;, conf.screenwidth - #currentline - #cnrl.warning-3))
    setFgColor(0, 050, 200)
    echo(&quot;(&quot;)
    setFgColor(128, 128, 128)
    echo(cnrl.warning)
    setFgColor(0, 050, 200)
    echo(&quot;)&quot;)
    moveCursorEnd()
    resetFormat()
  else
    local currentline = getLineCount()
    deselect()
    moveCursor('main', 0, currentline)
    setFgColor(0, 050, 200)
    insertText(&quot;(&quot;)
    moveCursor('main', 1, currentline)
    setFgColor(128, 128, 128)
    insertText(cnrl.warning)
    moveCursor('main', 1+#cnrl.warning, currentline)
    setFgColor(0, 050, 200)
    insertText(&quot;)&quot;)
    moveCursor('main', 2+#cnrl.warning, currentline)
    setFgColor(0,0,0)
    insertText(&quot; &quot;)
    moveCursorEnd()
    resetFormat()
  end
end

svo.cnrl.lockdata = {
  ['soft'] = function () return (affs.slickness and affs.anorexia and affs.asthma) end,
  ['venom'] = function () return (affs.slickness and affs.anorexia and affs.asthma and affs.paralysis) end,
  ['hard'] = function () return (affs.slickness and affs.anorexia and affs.asthma and (affs.impatience or (not svo.can_usemana() or not svo.conf.focus))) end,
  ['dragon'] = function () return (defc.dragonform and affs.slickness and affs.anorexia and affs.asthma and (affs.impatience or (not svo.can_usemana() or not svo.conf.focus)) and affs.recklessness and affs.weakness) end,
  ['stain'] = function() return (affs.stain and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) and pipes.valerian.puffs == 0) end,
  ['rift'] = function() return ((affs.asthma and (rift.invcontents.kelp == 0 and rift.invcontents.aurum == 0)) and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) end,
  [&quot;rift 2&quot;] = function() return (affs.asthma and affs.slickness and affs.anorexia and (affs.paralysis or (affs.disrupt and not bals.equilibrium)) and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))) end,
  ['slow'] = function () return (affs.asthma and affs.slickness and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm)) and (affs.mildconcussion or affs.seriousconcussion) and affs.aeon) end,
  ['true'] = function () return (affs.slickness and affs.anorexia and affs.asthma and affs.paralysis and affs.impatience and affs.disrupt and affs.confusion) end
}

--[[ cnrl.checkwarning gets unblocked whenever we receive an aff that is
      included in any of the locks. If you have a lock, it enables the
      cnrl.checkgreen flag, and unblocks dowarning, which allows powercure
      to run and do it's thing. Post processing, cnrl.dolockwarning is run,
      notifying the user on the prompt of any locks (and if any of them
      are in the process of being cured, highlight the lock name in green).

      When we don't have a lock, checkwarning disables itself, the flag,
      and dowarning]]

cnrl.warnings = {}
cnrl.checkwarning = function ()
  cnrl.warnings = {}
  me.locks = {}
  local t = cnrl.warnings
  for lock, func in pairs(cnrl.lockdata) do
    if func() then t[#t+1] = lock; me.locks[lock] = true end
  end

  if not cnrl.checkgreen and #t &gt; 0 then
    signals.after_prompt_processing:unblock(cnrl.dolockwarning)
    cnrl.checkgreen = true
  elseif cnrl.checkgreen and #t == 0 then
    cnrl.checkgreen = false
    signals.after_lifevision_processing:block(cnrl.checkwarning)
    signals.after_prompt_processing:block(cnrl.dolockwarning)
  end
end
signals.after_lifevision_processing:connect(cnrl.checkwarning, &quot;cnrl.checkwarning&quot;)
signals.after_lifevision_processing:block(cnrl.checkwarning)

cnrl.dolockwarning = function ()
  local t = cnrl.warnings
  if #t == 1 then
    cecho(&quot;&lt;red&gt;(&lt;grey&gt;lock: &lt;orange&gt;&quot; .. t[1]..&quot;&lt;red&gt;)&quot;)
  elseif #t &gt; 1 then
    cecho(&quot;&lt;red&gt;(&lt;grey&gt;locks: &lt;orange&gt;&quot; .. svo.concatand(t)..&quot;&lt;red&gt;)&quot;)
  else
    -- no more warnings? stop checking for them. Failsafe, we should never get here normally.
    cnrl.checkgreen = false
    signals.after_lifevision_processing:block(cnrl.checkwarning)
    signals.after_prompt_processing:block(cnrl.dolockwarning)
  end
end
signals.after_prompt_processing:connect(cnrl.dolockwarning, &quot;cnrl.dolockwarning&quot;)
signals.after_prompt_processing:block(cnrl.dolockwarning)

function svo.cnrl.processcommand(what)
  if not sys.sync or conf.send_bypass then return end

  if conf.blockcommands
  -- and the system is doing something right now...
  and sk.doingstuff_inslowmode()
  -- and this command right here is from you, not the system. Ignore commands starting with 'curing'
  -- though, as those are for serverside and aren't affected
  and not sk.gnomes_are_working and not what:lower():find(&quot;^curing&quot;) then
    denyCurrentSend()
    if math.random(1,5) == 1 then
      svo.echof(&quot;denying &lt;79,92,88&gt;%s%s. Lemme finish!&quot;, what, svo.getDefaultColor())
    elseif math.random(1,10) == 1 then
      svo.echof(&quot;denying &lt;79,92,88&gt;%s%s. Use tsc to toggle deny mode.&quot;, what, svo.getDefaultColor())
    else
      svo.echof(&quot;denying &lt;79,92,88&gt;%s%s.&quot;, what, svo.getDefaultColor()) end
    return
  elseif not conf.blockcommands and not sk.gnomes_are_working then -- override mode, command from you, not the system

    -- kill old timer first
    if not svo.sacid then svo.echof(&quot;pausing curing for your commands.&quot;) end

    if svo.sacid then killTimer(svo.sacid) end
    svo.sacid = tempTimer(svo.syncdelay() + getNetworkLatency() + conf.sacdelay, function ()
      svo.sacid = false
      if sys.sync then svo.echof(&quot;resuming curing.&quot;) end
      svo.make_gnomes_work()
    end)
  end

  -- retardation detection: works by setting a timer off a command, if the timer isn't already set
  -- then when the sluggish msg is seen, the timer is cleared.
  -- amnesia screws with it by hiding the sluggish msg itself!
  if not sk.sluggishtimer and not affs.amnesia and what ~= &quot;&quot; and not what:lower():find(&quot;^curing&quot;) then
    sk.sawsluggish = getLastLineNumber('main')
    local time = sys.wait + svo.syncdelay() + getNetworkLatency()
    sk.sluggishtimer = tempTimer(time, function ()
      if type(sk.sawsluggish) == 'number' and sk.sawsluggish ~= getLastLineNumber('main') and (affs.retardation or svo.affsp.retardation) then
        if affs.retardation then echo&quot;\n&quot; svo.echof(&quot;Retardation seems to have went away.&quot;) end
        svo.rmaff('retardation')
      end

      sk.sluggishtimer = nil
    end)
  end
end

signals.sysdatasendrequest:connect(cnrl.processcommand, &quot;cnrl.processcommand&quot;)
signals.sysdatasendrequest:block(cnrl.processcommand)

-- parse things for acceptance. ideas to prevent looping: either debug.traceback() (very slow it turned out), or block/unblock handler when doing sys actions (solution used)
function svo.cnrl.processusercommand(what, now)
  -- remove spaces, as some people may use spaces, ie &quot;bedevil &quot; instead of just 'bedevil' which then confuses tracking
  what = what:trim()

  -- if this is a system command done outside of a cnrl.processusercommand block because of batching, catch it
  if sk.systemscommands[what] then svo.debugf(&quot;ignoring %s, it's actually a system command&quot;, what) return end

  -- debugf(&quot;sys.input_to_actions: %s&quot;, pl.pretty.write(pl.tablex.keys(sys.input_to_actions)))
  -- debugf(&quot;sk.systemscommands: %s&quot;, pl.pretty.write(sk.systemscommands))

  if not svo.innews and (what == 'qq' or what == 'quit') then
    svo.QQ()
    svo.echof(&quot;Going into empty defs mode so pre-cache doesn't take anything out, and stuffing away all riftables...&quot;)
    defs.switch('empty')
    svo.inra()
  elseif not svo.innews and (what == 'ir' or what == &quot;info rift&quot;) then
    me.parsingrift = 'all'
  elseif not svo.innews and (what == &quot;ir herb&quot; or what == &quot;ir plant&quot;) then -- missing info rift variants
    me.parsingrift = 'herbs'
  elseif not svo.innews and (what == &quot;ir mineral&quot;) then
    me.parsingrift = 'minerals'

  elseif sys.input_to_actions[what] then
    local function dostuff()
      svo.killaction(sys.input_to_actions[what])
      local oldsend, oldsendc, oldsendAll = _G.send, svo.sendc, _G.sendAll
      _G.send = function() end
      svo.sendc = function() end
      _G.sendAll = function() end
      local s,m = pcall(svo.doaction, sys.input_to_actions[what])
      if not s then
        echoLink(&quot;(e!)&quot;, [[svo.echof(&quot;The problem was: re-mapping commands to system actions failed: (]]..tostring(m)..[[)&quot;)]], 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a copy/paste of what you saw.')
      end
      _G.send = oldsend
      svo.sendc = oldsendc
      _G.sendAll = oldsendAll
    end

    -- when 'now' is given, put it into queue right away - this is useful for capturing the game curing command
    if now then dostuff() else tempTimer(0, dostuff) end
  end
end
signals.sysdatasendrequest:connect(cnrl.processusercommand, &quot;cnrl.processusercommand&quot;)

-- limited_around: don't show the full list, but only 13 elements around the center one
function svo.printorder(balance, limited_around)
  -- translate the obvious 'balance' to 'physical'
  if balance == 'balance' then balance = 'physical' end
  local sendf = svo.errorf
  svo.assert(type(balance) == 'string', &quot;svo.printorder: what balance do you want to print for?&quot;, sendf)

  -- get into table...
  local data = svo.make_prio_table(balance)
  local orderly = {}

  -- get a sorted list of just the prios
  for i,_ in pairs(data) do
    orderly[#orderly+1] = i
  end

  table.sort(orderly, function(a,b) return a&gt;b end)

  -- locate where the center of the list is, if we need it
  local center
  if limited_around then
    local counter = 1
    for _, j in pairs(orderly) do
      if j == limited_around then center = counter break end
      counter = counter +1
    end
  end

  svo.echof(&quot;%s balance priority list (&lt;112,112,112&gt;clear gaps%s):&quot;, balance:title(), svo.getDefaultColor())
  if selectString(&quot;clear gaps&quot;, 1) ~= -1 then
    setLink(&quot;svo.prio.cleargaps('&quot;..balance..&quot;', true)&quot;, &quot;Clear all gaps in the &quot;..balance..&quot; balance&quot;)
  end

  if not limited_around then
    svo.echof(&quot;Stuff at the top will be cured first, if it's possible to cure it.&quot;)
  end

  local list = svo.prio.getsortedlist(balance)
  local temp_affs, temp_defs = sk.splitdefs(balance, list)
  local raffs, rdefs = {}, {}
  for index, aff in pairs(temp_affs) do raffs[aff] = index end
  for index, def in pairs(temp_defs) do rdefs[def] = index end

  if limited_around then
    svo.echofn(&quot;(&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;...&quot;, &quot;svo.printorder('&quot;..balance..&quot;')&quot;, &quot;Click to view the full &quot;..balance..&quot; priority list&quot;, true)
    setUnderline(false)
    echo(&quot;)\n&quot;)
  end

  local function echoserver(j, raffs, rdefs, balance, ssprioamount)
    if raffs[data[j]] then
      return string.format(&quot;ss aff %&quot;..ssprioamount..'s', (raffs[data[j]] &lt;= 25 and raffs[data[j]] or '25'))
    elseif rdefs[data[j]] then
      return string.format(&quot;ss def %&quot;..ssprioamount..'s', (rdefs[data[j]] &lt;= 25 and rdefs[data[j]] or '25'))
    elseif svo.dict[data[j]][balance].def then
      return &quot;ss def&quot;..(' '):rep(ssprioamount)..&quot;-&quot;
    elseif svo.dict[data[j]][balance].aff then
      return &quot;ss aff&quot;..(' '):rep(ssprioamount)..&quot;-&quot;
    else
      return &quot;ss    &quot;..(' '):rep(ssprioamount)..&quot;-&quot;
    end
  end

  local counter = 1
  local intlen = svo.intlen
  local prioamount = intlen(table.size(orderly))
  local ssprioamount = intlen(table.size(raffs) and table.size(raffs) or table.size(rdefs))
  for _,j in pairs(orderly) do
    if not limited_around or not (counter &gt; (center+6) or counter &lt; (center-6)) then
      setFgColor(255,147,107) echo&quot;  &quot;
      echoLink(&quot;^^&quot;, 'svo.prio_swap(&quot;'..data[j]..'&quot;, &quot;'..balance..'&quot;, '..(j+1)..', nil, false, svo.printorder, &quot;'..balance..'&quot;, '..(j+1)..')', 'shuffle '..data[j]..' up', true)
      echo(&quot; &quot;)
      setFgColor(148,148,255)
      echoLink('vv', 'svo.prio_swap(&quot;'..data[j]..'&quot;, &quot;'..balance..'&quot;, '..(j-1)..', nil, false, svo.printorder, &quot;'..balance..'&quot;, '..(j-1)..')', 'shuffle '..data[j]..' down', true)
      setFgColor(112,112,112)
      -- focus balance can't have 'priority'
      if not conf.serverside or balance == 'focus' then
        echo(string.format(&quot; (%s) &quot;..(' '):rep(prioamount - intlen(j))..&quot;%s&quot;, j, data[j]))
      else
        -- defs not on defup/keepup won't have a priority
        echo(string.format(&quot; (svo %&quot;..prioamount..&quot;s|%s) %s&quot;, j, echoserver(j, raffs, rdefs, balance, ssprioamount), data[j]))
      end
      echo(&quot;\n&quot;)
      resetFormat()
    end

    counter = counter + 1
  end

  svo.showprompt()
end

function svo.printordersync(limited_around)
  -- step 1: get into table...
  local data = svo.make_sync_prio_table(&quot;%s (%s)&quot;)
  local orderly = {}

  for i,_ in pairs(data) do
    orderly[#orderly+1] = i
  end

  table.sort(orderly, function(a,b) return a&gt;b end)

  svo.echof(&quot;aeon/retardation priority list (clear gaps):&quot;)
  if selectString(&quot;clear gaps&quot;, 1) ~= -1 then
    setFgColor(112,112,112)
    setLink(&quot;svo.prio.cleargaps('slowcuring', true)&quot;, &quot;Clear all gaps in the aeon/retardation priority&quot;)
    resetFormat()
  end

  -- locate where the center of the list is, if we need it
  local center
  if limited_around then
    local counter = 1
    for _, j in pairs(orderly) do
      if j == limited_around then center = counter break end
      counter = counter +1
    end
  end

  if not limited_around then
    svo.echof(&quot;Stuff at the top will be cured first, if it's possible to cure it.&quot;)
  end

  if limited_around then
    svo.echofn(&quot;(&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;...&quot;, &quot;svo.printordersync()&quot;, &quot;Click to view the full aeon/retardation priority list&quot;, true)
    setUnderline(false)
    echo(&quot;)\n&quot;)
  end

  local counter = 1
  for _,j in pairs(orderly) do
    if not limited_around or not (counter &gt; (center+6) or counter &lt; (center-6)) then
      setFgColor(255,147,107) echo&quot;  &quot;
      echoLink(&quot;^^&quot;, 'svo.prio_slowswap(&quot;'..string.format(&quot;%s_%s&quot;, string.match(data[j], &quot;(%w+) %((%w+)%)&quot;))..'&quot;, '..(j+1)..', false, svo.printordersync, '..(j+1)..')', 'shuffle '..data[j]..' up', true)
      echo(&quot; &quot;)
      setFgColor(148,148,255)
      echoLink('vv', 'svo.prio_slowswap(&quot;'..string.format(&quot;%s_%s&quot;, string.match(data[j], &quot;(%w+) %((%w+)%)&quot;))..'&quot;, '..(j-1)..', false, svo.printordersync, '..(j-1)..')', 'shuffle '..data[j]..' up', true)
      setFgColor(112,112,112)
      echo(&quot; (&quot; .. j..&quot;) &quot;..data[j])
      echo(&quot;\n&quot;)
      resetFormat()
    end

    counter = counter + 1
  end

  svo.showprompt()
end

function svo.sk.check_fullstats()
  if stats.currenthealth &gt;= stats.maxhealth and stats.currentmana &gt;= stats.maxmana and not affs.recklessness then
    sk.gettingfullstats = false
    signals.after_prompt_processing:disconnect(sk.check_fullstats)
    tempTimer(0, function() svo.echof(&quot;We're fully healed up now.&quot;) svo.showprompt() end)
    raiseEvent(&quot;svo got fullstats&quot;)

    if sk.fullstatsunignorehp then
      sk.fullstatsunignorehp = nil
      svo.serverignore.healhealth = true
    end

    if sk.fullstatsunignoremp then
      sk.fullstatsunignoremp = nil
      svo.serverignore.healmana = true
    end

    if type(sk.fullstatscallback) == 'function' then
      local s,m = pcall(sk.fullstatscallback)
      if not s then svo.echof(&quot;Your fullstats function had a problem:\n  %s&quot;, m) end
    elseif type(sk.fullstatscallback) == 'string' then
      local s,m = pcall(loadstring(sk.fullstatscallback))
      if not s then svo.echof(&quot;Your fullstats code had a problem:\n  %s&quot;, m) end
    end
    sk.fullstatscallback = nil
  end
end


function svo.fullstats(newstatus, callback, echoback)
  if newstatus then
    if stats.currenthealth &gt;= stats.maxhealth and stats.currentmana &gt;= stats.maxmana then
      if echoback then svo.echof(&quot;We're already completely healthy.&quot;) end
      raiseEvent(&quot;svo got fullstats&quot;)

      if newstatus and type(callback) == 'function' then
        local s,m = pcall(callback)
        if not s then svo.echof(&quot;Your fullstats function had a problem:\n  %s&quot;, m) end
      elseif newstatus and type(callback) == 'string' then
        local s,m = pcall(loadstring(callback))
        if not s then svo.echof(&quot;Your fullstats code had a problem:\n  %s&quot;, m) end
      end
      return
    else

      sk.gettingfullstats = true

      -- if serverside is on, take healhealth off ignore (if it's there) and let it sip up
      if conf.serverside then
        if svo.serverignore.healhealth then
          sk.fullstatsunignorehp = true
          svo.serverignore.healhealth = nil
        end

        if svo.serverignore.healmana then
          sk.fullstatsunignoremp = true
          svo.serverignore.healmana = nil
        end
      end

      signals.after_prompt_processing:connect(sk.check_fullstats, &quot;sk.check_fullstats&quot;)
      sk.fullstatscallback = callback
      if echoback then svo.echof(&quot;Healing up to full stats.&quot;) end
      raiseEvent(&quot;svo started fullstats&quot;)
      svo.make_gnomes_work()
    end
  elseif not newstatus then
    sk.gettingfullstats = false
    signals.after_prompt_processing:disconnect(sk.check_fullstats)
    if echoback then svo.echof(&quot;Resumed normal health/mana healing.&quot;) end
    raiseEvent(&quot;svo stopped fullstats&quot;)
  end
end

svo.prompttrigger = function (name, func)
  svo.assert(name, &quot;svo.prompttrigger: the name needs to be provided&quot;)
  svo.assert(type(func) == 'function' or type(func) == 'nil', &quot;svo.prompttrigger: the second argument needs to be a Lua function or nil&quot;)

  sk.onprompt_beforeaction_add(name, func)
end

svo.aiprompt = function (name, func)
  sk.onprompt_beforelifevision_add(name, func)
end

function svo.lyre_step()
  if not (bals.balance and bals.equilibrium) then svo.echof(&quot;Don't have balance+eq.&quot;) return end

  if not conf.lyre then svo.config.set('lyre', 'on', true) end

  if sys.sync then sk.gnomes_are_working = true end
  svo.conf.paused = false
  raiseEvent(&quot;svo config changed&quot;, 'paused')

  svo.conf.lyre_step = true
  svo.make_gnomes_work()

  if not actions.lyre_physical then
    svo.doaction(svo.dict.lyre.physical)
  end
  svo.conf.lyre_step = false

  if sys.sync then sk.gnomes_are_working = false end
end

-- capture the incoming values for gmcp balance and eq
signals.gmcpcharvitals:connect(function()
  svo.newbals.balance     = gmcp.Char.Vitals.bal == '1' and true or false
  svo.newbals.equilibrium = gmcp.Char.Vitals.eq == '1' and true or false
end, &quot;new balance detection&quot;)

-- feed the curing systems curing command through the system, so it can track actions
-- don't raise a systadasendrequest because that would trigger command deny/override
function svo.curingcommand(command)
  sk.sawcuringcommand = true
  cnrl.processusercommand(command:lower(), true)
  svo.prompttrigger(&quot;clear curing command&quot;, function() sk.sawcuringcommand = false end)

  if conf.gagservercuring then deleteLine() end
end

-- same as curingcommand, but for actions via queue
function svo.queuecommand(command)
  sk.sawqueueingcommand = true
  cnrl.processusercommand(command:lower(), true)

  svo.prompttrigger(&quot;clear queueing command&quot;, function() sk.sawqueueingcommand = false end)
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Action system</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

-- action system
local pl = svo.pl
 -- a map of balances, with a map of actions in each
svo.actions_performed = svo.actions_performed or {}
svo.bals_in_use       = svo.bals_in_use or {}

local actions, dict, affs, sys, syncdelay = svo.actions, svo.dict, svo.affs, svo.sys, svo.syncdelay
local debugf, actions_performed, bals_in_use = svo.debugf, svo.actions_performed, svo.bals_in_use
local sk, echof, make_gnomes_work, conf, signals = svo.sk, svo.echof, svo.make_gnomes_work, svo.conf, svo.signals
local lifevision = svo.lifevision

-- does an action - call this when you'd like to execute an action. The system will setup
-- the timeout failsafes (which flow through into stupidity and lag detection), as well as
-- record actions in per-action, per-balance tables for checking against later
-- ie: doaction(dict.healhealth.sip)
svo.doaction = function(arg1, arg2)
  local act, which, balance
  -- do action used to be available in 2 modes - internal and external. Internal API took a dict[action][balance] and
  -- the external API took 2 strings as the action and balance. This is a compatibility layer for the merged result
  if type(arg1) == 'table' then
    act = arg1
  else
    which = arg1
    balance = arg2
    svo.assert(dict[which], &quot;svo.doaction: &quot;..which..&quot; action doesn't exist. See 'vshow ignorelist' for a list of them.&quot;)
    svo.assert(dict[which][balance], &quot;svo.doaction: &quot;..which..&quot; doesn't have a &quot;..balance.. &quot; balance.&quot;)
  end
  --it'll be in format of dict.what.#somebalance
  -- add to a table, create timers and store id's in there
  -- if ai is on, enable the relevant triggers &lt;- maybe we should do
  -- it in dict action.

  local expirein =
    affs.seriousconcussion and sys.sync
    and (syncdelay()+.3) -- w/ aeon, waits 1.3s and etc, w/o aeon - 0.3s and etc..
    or ((act.customwait or (act.customwaitf and act.customwaitf()) or 0) + sys.wait) + syncdelay()

  debugf(&quot;expirein for %s set to %s&quot;, act.name, expirein)

  local timerid = tempTimer(expirein,
    function ()
      debugf(&quot;actions: %s timed out&quot;, tostring(act.name))
      actions:set(act.name, nil)  -- remove from actions list

      -- it should always be there, even after reset - but a failsafe is in place anyway
      if bals_in_use[act.balance] then
        bals_in_use[act.balance][act.name] = nil
      end
      actions_performed[act.action_name] = nil

      -- there might be a case where actions_performed was being taken up by another action, like a cure,
      -- that was overwritten by an aff now. This needs to be rectified back.
      for bal, _ in pairs(bals_in_use) do
        if actions[act.action_name..'_'..bal] then
          actions_performed[act.action_name] = bals_in_use[bal][act.action_name..'_'..bal]

          debugf(&quot;actions: added %s_%s back&quot;, act.action_name, bal)
        end
      end

      -- don't need to pause the system itself as all actions timing out will come to this, ie build up,
      -- get disabled until next prompt
      sys.lagcount = sys.lagcount + 1
      if sys.lagcount &lt; (sys.lagcountmax+1) then
        if act.ontimeout then act.ontimeout() end

        -- if we have a stupidity counted and we timed out, then stupidity might be real
        if sk.stupidity_count and sk.stupidity_count &gt; 0 and not affs.stupidity then
          svo.addaffdict(dict.stupidity)
          echof(&quot;I suspect we've got stupidity.&quot;)
        end

        make_gnomes_work()
      elseif sys.lagcount == (sys.lagcountmax+1) and not conf.paused then
        echof(&quot;Warning, lag detected (while doing/curing %s)&quot;, act.action_name)
        sk.increase_lagconf()
      end
    end
  )

  -- act.name is a single string of action + balance - ie, bleeding_misc (cure) or bleeding_aff (affliction)
  actions:set(act.name, {
    timerid = timerid,
    completed = function (other_action, arg)
      killTimer(timerid)
      if (other_action) then debugf(&quot;doaction other action: %s&quot;, tostring(other_action)) end
      if not (act[other_action or 'oncompleted']) then
        debugf(&quot;[error] %s does not exist for %s!&quot;, tostring(other_action or 'oncompleted'), tostring(act.name))
      end
      act[other_action or 'oncompleted'](arg)
      debugf(&quot;actions: %s%s completed (killed %s)&quot;, act.name, arg and (' ('..tostring(arg)..')') or &quot;&quot;,
        tostring(timerid))

      if act.balance == 'focus' then signals.curedwith_focus:emit(other_action or 'oncompleted') end
    end,
    p = act
  })

  if not (act.balance or act.action_name) then
    debugf(&quot;balance: %s, name: %s, what: %s&quot;, tostring(act.balance), tostring(act.action_name), tostring(act))
  end

  bals_in_use[act.balance] = bals_in_use[act.balance] or {}
  bals_in_use[act.balance][act.name] = act
  -- ie, bleeding
  actions_performed[act.action_name] = act

  -- lastly, do it! :)

  debugf(&quot;actions: doing %s&quot;, act.name)
  local s,m = pcall(act.onstart)
  if not s then
    debugf(&quot;error from onstart(): &quot;..m)
    echoLink(&quot;(e!)&quot;, [[echo(&quot;The problem was: ]]..tostring(act.action_name)..[[ failed to start (]]..
      tostring(m)..[[). If this is curing-related, please include that your curemethod is set to ]]..
      tostring(conf.curemethod)..[[&quot;)]],
      'Oy - there was a problem. Click this link to show the error')
  else
    -- action started successfully - start the stopwatch for it.
    -- It's accessible via actions.action_balance.p.actionwatch
    act.actionwatch = act.actionwatch or createStopWatch()
    startStopWatch(act.actionwatch)
  end

end

-- used for pre-checking if we're doing an action in trigger functions.
-- if anti-illusion is off, or the true argument is passed, the action
-- will get recorded as currently being done (this helps in cases where a 3rd
-- party did an action on you and you want to record it)
svo.checkaction = function (act, input)
  if not act then debugf(&quot;[svo error]: checkaction called with -nothing-&quot;) return end
  -- if doesnt exist in table, and we got ai off, make one up
  if not actions[act.name] and ((not conf.aillusion and input ~= false) or input) then

  debugf(&quot;actions: force-adding %s&quot;, act.name)

    actions:set(act.name, {
      completed = function (other_action, arg)
        if (other_action) then debugf(&quot;checkaction other action: %s&quot;, other_action) end
        if not (act[other_action or 'oncompleted']) then
          debugf(&quot;[error] %s does not exist for %s!&quot;, tostring(other_action or 'oncompleted'), tostring(act.name))
        end
        act[other_action or 'oncompleted'](arg)
      debugf(&quot;actions: %s%s completed&quot;, act.name, arg and tostring(arg) or &quot;&quot;)
        if act.balance == 'focus' then signals.curedwith_focus:emit(other_action or 'oncompleted') end
      end,
      p = act,
    })

    bals_in_use[act.balance] = bals_in_use[act.balance] or {}
    bals_in_use[act.balance][act.name] = act
    actions_performed[act.action_name] = act
  end
end

-- checks if any of the actions are being done (multi-param version of checkaction), returns one if true
-- doesn't have ability to force-insert like checkaction
svo.checkany = function (...)
  local t = {...}

  for i=1,#t do
    local j = t[i]
    if not j then debugf(&quot;missing %s, traceback: %s&quot;, j, debug.traceback()) end
    if actions[j.name] then
      return j
    end
  end
end

-- returns one of the actions currently being done in the given balance
svo.findbybal = function (balance)
  return bals_in_use[balance] and select(2, next(bals_in_use[balance]))
end

-- checks if any of the physical actions being done right now are expected to consume balance
svo.will_take_balance = function()
  bals_in_use.physical = bals_in_use.physical or {}
  for _, data in pairs(bals_in_use.physical) do
    if data.balanceful_act then return true end
  end
end

svo.codepaste.balanceful_codepaste = svo.will_take_balance

-- multi-balance version of findbybal
svo.findbybals = function(balances)
  local t = {}

  for _, bal in ipairs(balances) do
    if bals_in_use[bal] then
      for _, act in pairs(bals_in_use[bal]) do
        t[act.name] = act
      end
    end
  end

  if next(t) then return t end
end

-- only used by lifevision system if an illusion was detected - used by lifevision system to clear actions it has seen
svo.actionclear = function(act)
  debugf(&quot;actions: cleared action %s&quot;, tostring(act.name))

  actions:set(act.name, nil)
   -- it should always be there, even after reset - but a failsafe is in place anyway
  if bals_in_use[act.balance] then
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil

  -- there might be a case where actions_performed was being taken up by another action,
  -- like a cure, that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name..'_'..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name..'_'..bal]

      debugf(&quot;actions: added %s_%s back&quot;, act.action_name, bal)
    end
  end

  if act.oncancel then
    local s,m = pcall(act.oncancel)
    if not s then
      debugf(&quot;error from oncancel(): &quot;..m)
      echoLink(&quot;(e!)&quot;, [[echo(&quot;The problem was: ]]..tostring(act.action_name)..[[ failed to cancel (]]..tostring(m)..
        [[). If this is curing-related, please include that your curemethod is set to ]]..tostring(conf.curemethod)..
        [[&quot;)]],
        'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a '..
        'copy/paste of what you saw.')
    end
  end
end

-- used by lifevision system to complete an action that was seen in the paragraph (when no illusion was seen)
svo.actionfinished = function(act, other_action, arg)
  svo.assert(act, &quot;svo.actionfinished wants an argument&quot;)
  if not act.name or not actions[act.name] or not actions[act.name].completed then
    echo(&quot;(e!)&quot;)
    debugf(&quot;actionfinished: %s&quot;, debug.traceback())
    return
  end

  if not act.name then debugf(&quot;svo error: no name field, total: %s&quot;, pl.pretty.write(act or {})) return end
  if not actions[act.name] then debugf(&quot;svo error: no such action %s being done atm&quot;, act.name) return end
  if not actions[act.name].completed then debugf(&quot;svo error: no completed method on %s&quot;, act.name) return end

  local result, msg = pcall(actions[act.name].completed, other_action, arg)

  if not result then
    debugf(&quot;error from completed() &quot;..msg)
    if other_action then debugf(&quot;other_action was: %s&quot;, other_action) end
    echoLink(&quot;(e!)&quot;, [[svo.echof(&quot;The problem was: ]]..tostring(act.action_name)..[[ failed to complete: ]]..msg..[[&quot;)]]
      , 'Oy - there was a problem. Click on this link and submit a bug report with what it says along with a '..
        'copy/paste of what you saw.')
     end

  actions:set(act.name, nil)
  if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil

  if not other_action then debugf(&quot;actions: finished action %s&quot;, tostring(act.name)) else
  debugf(&quot;actions: finished action %s, with non-default action: (%s)&quot;, tostring(act.name), other_action) end

  -- there might be a case where actions_performed was being taken up by another action, like a cure,
  -- that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name..'_'..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name..'_'..bal]

      debugf(&quot;actions: added %s_%s back&quot;, act.action_name, bal)
    end
  end

  -- slow curing? kick the next action into going then
  if sys.sync then tempTimer(0, function() make_gnomes_work() end) end
end

-- cancels an action entirely
-- needs the dict+balance, ie: killaction (dict.icing.waitingfor)
svo.killaction = function (act)
  if not (act and act.name) then
    debugf(&quot;%s is invalid action to kill.&quot;, tostring(act))
    return
  end

  svo.assert(act, &quot;svo.killaction wants an argument&quot;)

  if not actions[act.name] then return end

  if act.onkill then act.onkill() end

  if actions[act.name].timerid then
    killTimer(actions[act.name].timerid)
  end
  actions:set(act.name, nil)

  if bals_in_use[act.balance] then -- it should always be there, even after reset - but a failsafe is in place anyway
    bals_in_use[act.balance][act.name] = nil
  end
  actions_performed[act.action_name] = nil

  debugf(&quot;actions: killed early %s&quot;, tostring(act.name))

  -- there might be a case where actions_performed was being taken up by another action, like a cure,
  -- that was overwritten by an aff now. This needs to be rectified back.
  for bal, _ in pairs(bals_in_use) do
    if actions[act.action_name..'_'..bal] then
      actions_performed[act.action_name] = bals_in_use[bal][act.action_name..'_'..bal]

      debugf(&quot;actions: added %s_%s back&quot;, act.action_name, bal)
    end
  end

  if lifevision.l[act.name] then
    lifevision.l:set(act.name, nil)
    debugf(&quot;actions: also removed it from lifevision&quot;)
  end

  -- slow curing? kick the next action into going then
  if sys.sync then tempTimer(0, function() make_gnomes_work() end) end
end

-- returns true if the balance will be used up by an action that was sent
svo.usingbal = function (which)
  return (bals_in_use[which] and next(bals_in_use[which])) and true or false
end

-- usingbal was previously private - this is for historical API compatibility
svo.usingbalance = svo.usingbal

-- slight problem with this - it uses the short name, without the balance/action - so some misc things such as sleep,
--  which can happen at once, are a problem. workaround is to combine doingaction with usingbal in there.
svo.doingaction = function (which)
  svo.assert(which, &quot;svo.doingaction wants an argument&quot;)

  return actions_performed[which] and true or false
end

-- doingaction was previously private - this is for historical API compatibility
svo.doing = svo.doingaction

-- String -&gt; Action/Aff/Nil
-- returns true if we currently have or will register (after this prompt and no illusions) an affliction
svo.haveorwill = function (aff)
  return actions[aff..'_aff'] or affs[aff]
end

-- string -&gt; boolean
-- returns true if the given string in the format of actionname_balance exists
svo.valid_sync_action = function(name)
  local actionname, balance = name:match(&quot;^(%w+)_(%w+)$&quot;)
  if not (actionname and balance) then
    return false, &quot;actionname is in invalid format; it should be as 'actionname_balance'&quot;
  end

  if not dict[actionname] then return false, &quot;action &quot;..actionname..&quot; doesn't exist&quot; end
  if not dict[actionname][balance] then return false, actionname..&quot; doesn't operate on the &quot;..balance..&quot; balance&quot; end

  return true, actionname, balance
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Pipes</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/pipes&quot;)

svo.me.pipes = svo.me.pipes or {}

local pipes, me = svo.pipes, svo.me

pipes.valerian = pipes.valerian or
  {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'valerian', filledwith2 = 'valerian', maxpuffs = 10, maxpuffs2 = 10}
me.pipes.valerian = pipes.valerian

pipes.elm = pipes.elm or
{lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'elm', filledwith2 = 'elm', maxpuffs = 10, maxpuffs2 = 10}
me.pipes.elm = pipes.elm

pipes.skullcap = pipes.skullcap or
{lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'skullcap', filledwith2 = 'skullcap', maxpuffs = 10, maxpuffs2 = 10}
me.pipes.skullcap = pipes.skullcap

pipes.pnames = {'valerian', 'skullcap', 'elm'}

pipes.expectations = {'valerian', 'skullcap', 'elm'}

pipes.empties = {}

function svo.lastlit(which)
  for i = 1, #pipes.expectations do
    local v = pipes.expectations[i]
    if v == which then
      table.remove(pipes.expectations, i)
      pipes.expectations[#pipes.expectations+1] = which
      return
    end
  end
end

function svo.pipeout()
  local what = pipes.expectations[1]
  pipes[what].lit = false
  table.remove(pipes.expectations, 1)
  pipes.expectations[#pipes.expectations+1] = what
end

function svo.pipestart()
  local oldvalerianmaxpuffs, oldelmmaxpuffs, oldskullcapmaxpuffs = pipes.valerian.maxpuffs, pipes.elm.maxpuffs, pipes.skullcap.maxpuffs
  local oldvalerianmaxpuffs2, oldelmmaxpuffs2, oldskullcapmaxpuffs2 = pipes.valerian.maxpuffs2, pipes.elm.maxpuffs2, pipes.skullcap.maxpuffs2

  pipes.valerian = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'valerian', filledwith2 = 'valerian', maxpuffs = oldvalerianmaxpuffs, maxpuffs2 = oldvalerianmaxpuffs2}
  me.pipes.valerian = pipes.valerian

  pipes.elm = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'elm', filledwith2 = 'elm', maxpuffs = oldelmmaxpuffs, maxpuffs2 = oldelmmaxpuffs2}
  me.pipes.elm = pipes.elm

  pipes.skullcap = {lit = false, lit2 = false, id = 0, id2 = 0, arty = false, arty2 = false, puffs = 0, puffs2 = 0, filledwith = 'skullcap', filledwith2 = 'skullcap', maxpuffs = oldskullcapmaxpuffs, maxpuffs2 = oldskullcapmaxpuffs2}
  me.pipes.skullcap = pipes.skullcap
end

function svo.parseplist()
  local pipenames = {
    [&quot;slippery elm&quot;]                = 'elm',
    [&quot;a valerian leaf&quot;]             = 'valerian',
    [&quot;a skullcap flower&quot;]           = 'skullcap',
    [&quot;a pinch of ground cinnabar&quot;]  = 'elm',
    [&quot;a pinch of realgar crystals&quot;] = 'valerian',
    [&quot;a pinch of ground malachite&quot;] = 'skullcap'
  }

  local short_names = {
    [&quot;slippery elm&quot;]                = 'elm',
    [&quot;a valerian leaf&quot;]             = 'valerian',
    [&quot;a skullcap flower&quot;]           = 'skullcap',
    [&quot;a pinch of ground cinnabar&quot;]  = 'cinnabar',
    [&quot;a pinch of realgar crystals&quot;] = 'realgar',
    [&quot;a pinch of ground malachite&quot;] = 'malachite'
  }

  local id     = tonumber(matches[3])
  local herb   = pipenames[matches[4]]
  local puffs  = tonumber(matches[5])
  local status = matches[2]

  if not (id and herb and puffs and status) then return end

  local filled,lit,arty,puffskey, maxpuffs
  if pipes[herb].id == 0 then
    pipes[herb].id = id
    svo.firstpipe = true
    filled = 'filledwith'
    lit = 'lit'
    arty = 'arty'
    puffskey = 'puffs'
    maxpuffs = 'maxpuffs'
  else
    pipes[herb].id2 = id
    svo.firstpipe = false
    filled = 'filledwith2'
    lit = 'lit2'
    arty = 'arty2'
    puffskey = 'puffs2'
    maxpuffs = 'maxpuffs2'
  end

  pipes[herb][arty] = false

  pipes[herb][filled] = short_names[matches[4]]

  if status == 'out' then
    pipes[herb][lit] = false
  elseif status == 'lit' then
    pipes[herb][lit] = true
   elseif status == 'artf' then
    pipes[herb][arty] = true
  end

  pipes[herb][puffskey] = puffs

  -- assume it's a 20 puff pipe if the puffs we have atm is over 10 (bigger than normal)
  if puffs &gt; 10 then
    pipes[herb][maxpuffs] = 20
    echo(&quot; &quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    echo(&quot;(a 20-puff pipe)&quot;)
  end

  -- warn if relighting any pipes is on ignore, to make it more obvious - people tended to miss the original line
  if svo.ignore['light'..herb] then
    decho(&quot; &quot;..svo.getDefaultColor()..&quot;(&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;re-enable lighting&quot;, 'svo.ignore.light'..herb..' = nil; svo.echof(&quot;Re-enabled lighting of the '..pipes[herb].filledwith..' pipe.&quot;); if not svo.conf.relight then svo.config.set([[relight]], [[on]], true) end', 'Re-lighting the '..pipes[herb].filledwith..' pipe was put on ignore because '..svo.ignore['light'..herb].because..' - click the link to re-enable it', true)
    setUnderline(false)
    decho(svo.getDefaultColor()..&quot;)&quot;)
  end
end

function svo.parseplistempty()
  local id = tonumber(matches[3])
  local status = matches[2]
  if not (id and status) then return end

  -- save the data, to later assign the pipes to herbs
  pipes.empties[#pipes.empties+1] = {id = id, arty = (status == 'artf' and true or false), status = status}
end

function svo.parseplistend()
  -- fill up at least one of each first
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i] and pipes[i].id == 0 and next(pipes.empties) then
      pipes[i].id = pipes.empties[#pipes.empties].id
      if pipes.empties[#pipes.empties].status == 'Lit' then
        pipes[i].lit = true
      else
        pipes[i].lit = false
      end

      if pipes.empties[#pipes.empties].arty then
        pipes[i].arty = true
      end

      pipes.empties[#pipes.empties] = nil
    end
  end

  -- fill up secondary ones
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i] and pipes[i].id2 == 0 and next(pipes.empties) then
      pipes[i].id2 = pipes.empties[#pipes.empties].id
      if pipes.empties[#pipes.empties].status2 == 'Lit' then
        pipes[i].lit2 = true
      else
        pipes[i].lit2 = false
      end

      if pipes.empties[#pipes.empties].arty then
        pipes[i].arty2 = true
      end

      pipes.empties[#pipes.empties] = nil
    end
  end

  pipes.empties = {}
  svo.signals.after_lifevision_processing:unblock(svo.cnrl.checkwarning) -- check for stain lock
  svo.make_gnomes_work()
end

-- assumes that we set some pipe to 0 already. This is used during install only
function svo.pipe_assignid(newid)
  newid = tonumber(newid)
  for id = 1, #pipes.pnames do
    local i = pipes.pnames[id]
    if pipes[i].id == 0 then
      pipes[i].id = newid
      svo.conf[i..'id'] = newid
      pipes[i].lit = false
      send(&quot;empty &quot;..newid, false)
      raiseEvent(&quot;svo config changed&quot;, i..'id')
      return i
    elseif pipes[i].id2 == 0 then
      pipes[i].id2 = newid
      svo.conf[i..'id2'] = newid
      pipes[i].lit2 = false
      send(&quot;empty &quot;..newid, false)
      raiseEvent(&quot;svo config changed&quot;, i..'id2')
      return i
    end
  end
end

if lfs.attributes(getMudletHomeDir() .. &quot;/svo/pipes/conf&quot;) then
  local ok = pcall(table.load, getMudletHomeDir() .. &quot;/svo/pipes/conf&quot;, pipes)
  if ok then
    -- maxpuffs were added later on in the game, so make sure this field exists for upgrading systems
    pipes.elm.maxpuffs         = pipes.elm.maxpuffs or 10
    pipes.skullcap.maxpuffs    = pipes.skullcap.maxpuffs or 10
    pipes.valerian.maxpuffs    = pipes.valerian.maxpuffs or 10

    -- secondary pipes were added later on, so drop it in
    pipes.elm.maxpuffs2        = pipes.elm.maxpuffs2 or 10
    pipes.skullcap.maxpuffs2   = pipes.skullcap.maxpuffs2 or 10
    pipes.valerian.maxpuffs2   = pipes.valerian.maxpuffs2 or 10

    pipes.elm.lit2             = pipes.elm.lit2 or false
    pipes.skullcap.lit2        = pipes.skullcap.lit2 or false
    pipes.valerian.lit2        = pipes.valerian.lit2 or false

    pipes.elm.id2              = pipes.elm.id2 or 0
    pipes.skullcap.id2         = pipes.skullcap.id2 or 0
    pipes.valerian.id2         = pipes.valerian.id2 or 0

    pipes.elm.arty2            = pipes.elm.arty2 or false
    pipes.skullcap.arty2       = pipes.skullcap.arty2 or false
    pipes.valerian.arty2       = pipes.valerian.arty2 or false

    pipes.elm.puffs2           = pipes.elm.puffs2 or 0
    pipes.skullcap.puffs2      = pipes.skullcap.puffs2 or 0
    pipes.valerian.puffs2      = pipes.valerian.puffs2 or 0

    pipes.elm.filledwith2      = pipes.elm.filledwith2 or 'elm'
    pipes.skullcap.filledwith2 = pipes.skullcap.filledwith2 or 'skullcap'
    pipes.valerian.filledwith2 = pipes.valerian.filledwith2 or 'valerian'

    me.pipes.elm               = pipes.elm
    me.pipes.skullcap          = pipes.skullcap
    me.pipes.valerian          = pipes.valerian
  end
end

svo.signals.connected:connect(function ()
  if not pipes.valerian.arty then pipes.valerian.lit   = false end
  if not pipes.elm.arty then pipes.elm.lit             = false end
  if not pipes.skullcap.arty then pipes.skullcap.lit   = false end

  if not pipes.valerian.arty2 then pipes.valerian.lit2 = false end
  if not pipes.elm.arty2 then pipes.elm.lit2           = false end
  if not pipes.skullcap.arty2 then pipes.skullcap.lit2 = false end

  if not pipes.valerian.filledwith then pipes.valerian.filledwith   = 'valerian' end
  if not pipes.elm.filledwith then pipes.elm.filledwith             = 'elm' end
  if not pipes.skullcap.filledwith then pipes.skullcap.filledwith   = 'skullcap' end

  if not pipes.valerian.filledwith2 then pipes.valerian.filledwith2 = 'valerian' end
  if not pipes.elm.filledwith2 then pipes.elm.filledwith2           = 'elm' end
  if not pipes.skullcap.filledwith2 then pipes.skullcap.filledwith2 = 'skullcap' end
end, 'setup pipes on login')

svo.signals.saveconfig:connect(function ()
  local s,m = svo.tablesave(getMudletHomeDir() .. &quot;/svo/pipes/conf&quot;, pipes)
  if not s then
    svo.echof(&quot;Couldn't save settings; %s&quot;, m)
  end
end, 'save pipes config')
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Rift</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

--[[  basic idea: if asked to eat something, and we a) don't have it (or not enough),
      or b) are in aeon and have it we outr it, and eat it

      otherwise just eat
  ]]
svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/rift+inv&quot;)

local rift, me, sys, sk, conf = svo.rift, svo.me, svo.sys, svo.sk, svo.conf
local pipes = svo.pipes

rift.riftcontents = {}
rift.invcontents = {}
me.riftcontents = rift.riftcontents
me.invcontents = rift.invcontents

rift.precache = {}
rift.precachedata = {}

rift.doprecache = false

rift.allherbs = {'ash', 'bayberry', 'bellwort', 'bloodroot', 'cohosh', 'echinacea', 'elm', 'ginger', 'ginseng', 'goldenseal', 'hawthorn', 'kelp', 'kola', 'kuzu', 'lobelia', 'myrrh', 'pear', 'sileris', 'skullcap', 'valerian', 'weed', 'slipper', 'irid', 'ferrum', 'stannum', 'dolomite', 'antimony', 'bisemutum', 'bellwort', 'magnesium', 'calamine', 'malachite', 'azurite', 'plumbum', 'realgar', 'arsenic', 'cohosh', 'argentum', 'calcite', 'potash', 'quicksilver', 'kelp', 'kola', 'cinnabar', 'cuprum', 'aurum', 'quartz', 'gypsum'}
rift.herbsminerals = {'antimony', 'argentum', 'arsenic', 'ash', 'aurum', 'azurite', 'bayberry', 'bellwort', 'bisemutum', 'bloodroot', 'calamine', 'calcite', 'cinnabar', 'cohosh', 'cuprum', 'dolomite', 'echinacea', 'elm', 'ferrum', 'ginger', 'ginseng', 'goldenseal', 'gypsum', 'hawthorn', 'irid', 'kelp', 'kola', 'lobelia', 'magnesium', 'malachite', 'myrrh', 'plumbum', 'potash', 'quartz', 'quicksilver', 'realgar', 'sileris', 'skullcap', 'stannum', 'valerian', 'weed'}
rift.functionalherbs = {'slipper', 'kuzu', 'pear'}

rift.herblist = {'elm', 'valerian', 'ash', 'bayberry', 'bellwort', 'bloodroot', 'cohosh', 'echinacea', 'ginger', 'ginseng', 'goldenseal', 'hawthorn', 'kelp', 'kola', 'kuzu', 'lobelia', 'irid', 'myrrh', 'pear', 'sileris', 'skullcap', 'slipper', 'weed'}
rift.curativeherbs = {'ash', 'bayberry', 'bellwort', 'bloodroot', 'cohosh', 'echinacea', 'elm', 'ginger', 'ginseng', 'goldenseal', 'hawthorn', 'irid', 'kelp', 'kola', 'lobelia', 'myrrh', 'pear', 'sileris', 'skullcap', 'valerian'}

rift.minerallist = {'ferrum', 'stannum', 'dolomite', 'antimony', 'bisemutum', 'cuprum', 'magnesium', 'calamine', 'malachite', 'azurite', 'plumbum', 'realgar', 'arsenic', 'gypsum', 'argentum', 'calcite', 'potash', 'quicksilver', 'aurum', 'quartz', 'cinnabar'}

me.herblist = rift.herblist
me.minerallist = rift.minerallist

rift.forestalvials = {'caloric', 'epidermal', 'frost', 'health', 'immunity', 'levitation', 'mana', 'mass', 'mending', 'restoration', 'speed', 'venom'}

rift.resetriftcontents = function()
  for _, herb in ipairs(rift.allherbs) do
    rift.riftcontents[herb] = 0
  end

  svo.myrift = rift.riftcontents
end

rift.resetinvcontents = function()
  for _, herb in ipairs(rift.allherbs) do
    rift.invcontents[herb] = 0
  end

  svo.myinv = rift.invcontents
end

rift.resetriftcontents()
rift.resetinvcontents()

rift.herbs_plural = {
  elm        = &quot;(%d+) slippery elms&quot;,
  valerian   = &quot;(%d+) valerian leaves&quot;,
  ash        = &quot;(%d+) pieces of prickly ash bark&quot;,
  bayberry   = &quot;(%d+) pieces of bayberry bark&quot;,
  bellwort   = &quot;(%d+) bellwort flowers&quot;,
  bloodroot  = &quot;(%d+) bloodroot leaves&quot;,
  cohosh     = &quot;(%d+) cohosh roots&quot;,
  echinacea  = &quot;(%d+) echinacea roots&quot;,
  ginger     = &quot;(%d+) ginger roots&quot;,
  ginseng    = &quot;(%d+) ginseng roots&quot;,
  goldenseal = &quot;(%d+) goldenseal roots&quot;,
  hawthorn   = &quot;(%d+) hawthorn berries&quot;,
  kelp       = &quot;(%d+) pieces of kelp&quot;,
  kola       = &quot;(%d+) kola nuts&quot;,
  kuzu       = &quot;(%d+) kuzu roots&quot;,
  lobelia    = &quot;(%d+) lobelia seeds&quot;,
  irid       = &quot;(%d+) pieces of irid moss&quot;,
  myrrh      = &quot;(%d+) myrrh balls&quot;,
  pear       = &quot;(%d+) prickly pears&quot;,
  sileris    = &quot;(%d+) sileris berries&quot;,
  skullcap   = &quot;(%d+) skullcap flowers&quot;,
  slipper    = &quot;(%d+) lady's slipper roots&quot;,
  weed       = &quot;(%d+) sprigs of cactus weed&quot;,

  ferrum      = &quot;(%d+) ferrum flakes&quot;,
  stannum     = &quot;(%d+) stannum flakes&quot;,
  dolomite    = &quot;(%d+) dolomite grains&quot;,
  antimony    = &quot;(%d+) antimony flakes&quot;,
  bisemutum   = &quot;(%d+) bisemutum chips&quot;,
  cuprum      = &quot;(%d+) cuprum flakes&quot;,
  magnesium   = &quot;(%d+) magnesium chips&quot;,
  calamine    = &quot;(%d+) calamine crystals&quot;,
  malachite   = &quot;(%d+) pinches of ground malachite&quot;,
  azurite     = &quot;(%d+) azurite motes&quot;,
  plumbum     = &quot;(%d+) plumbum flakes&quot;,
  realgar     = &quot;(%d+) pinches of ground realgar&quot;,
  arsenic     = &quot;(%d+) arsenic pellets&quot;,
  gypsum      = &quot;(%d+) gypsum crystals&quot;,
  argentum    = &quot;(%d+) argentum flakes&quot;,
  calcite     = &quot;(%d+) calcite motes&quot;,
  potash      = &quot;(%d+) potash crystals&quot;,
  quicksilver = &quot;(%d+) quicksilver droplets&quot;,
  aurum       = &quot;(%d+) aurum flakes&quot;,
  quartz      = &quot;(%d+) quartz grains&quot;,
  cinnabar    = &quot;(%d+) pinches of ground cinnabar&quot;,
}

rift.herbs_singular = {
  [&quot;some prickly ash bark&quot;]  = 'ash',
  [&quot;some bayberry bark&quot;]     = 'bayberry',
  [&quot;a bellwort flower&quot;]      = 'bellwort',
  [&quot;a bloodroot leaf&quot;]       = 'bloodroot',
  [&quot;a black cohosh root&quot;]    = 'cohosh',
  [&quot;an echinacea root&quot;]      = 'echinacea',
  [&quot;slippery elm&quot;]           = 'elm',
  [&quot;a ginger root&quot;]          = 'ginger',
  [&quot;a ginseng root&quot;]         = 'ginseng',
  [&quot;a goldenseal root&quot;]      = 'goldenseal',
  [&quot;a hawthorn berry&quot;]       = 'hawthorn',
  [&quot;a piece of kelp&quot;]        = 'kelp',
  [&quot;a kola nut&quot;]             = 'kola',
  [&quot;a kuzu root&quot;]            = 'kuzu',
  [&quot;a lobelia seed&quot;]         = 'lobelia',
  [&quot;some irid moss&quot;]         = 'irid',
  [&quot;a ball of myrrh gum&quot;]    = 'myrrh',
  [&quot;a prickly pear&quot;]         = 'pear',
  [&quot;a sileris berry&quot;]        = 'sileris',
  [&quot;a skullcap flower&quot;]      = 'skullcap',
  [&quot;a lady's slipper root&quot;]  = 'slipper',
  [&quot;a valerian leaf&quot;]        = 'valerian',
  [&quot;a sprig of cactus weed&quot;] = 'weed',

  [&quot;a ferrum flake&quot;]              = 'ferrum',
  [&quot;a stannum flake&quot;]             = 'stannum',
  [&quot;a dolomite grain&quot;]            = 'dolomite',
  [&quot;an antimony flake&quot;]           = 'antimony',
  [&quot;a bisemutum chip&quot;]            = 'bisemutum',
  [&quot;a cuprum flake&quot;]              = 'cuprum',
  [&quot;a magnesium chip&quot;]            = 'magnesium',
  [&quot;a calamine crystal&quot;]          = 'calamine',
  [&quot;a pinch of ground malachite&quot;] = 'malachite',
  [&quot;an azurite mote&quot;]             = 'azurite',
  [&quot;a plumbum flake&quot;]             = 'plumbum',
  [&quot;a pinch of realgar crystals&quot;] = 'realgar',
  [&quot;an arsenic pellet&quot;]           = 'arsenic',
  [&quot;a gypsum crystal&quot;]            = 'gypsum',
  [&quot;an argentum flake&quot;]           = 'argentum',
  [&quot;a calcite mote&quot;]              = 'calcite',
  [&quot;a potash crystal&quot;]            = 'potash',
  [&quot;a quicksilver droplet&quot;]       = 'quicksilver',
  [&quot;an aurum flake&quot;]              = 'aurum',
  [&quot;a quartz grain&quot;]              = 'quartz',
  [&quot;a pinch of ground cinnabar&quot;]  = 'cinnabar',
}

-- outr line in Achaea uses some special naming - this is formatted for it
rift.herbs_singular_sansprefix = {
  [&quot;prickly ash bark&quot;]    = 'ash',
  [&quot;bayberry bark&quot;]       = 'bayberry',
  [&quot;bellwort flower&quot;]     = 'bellwort',
  [&quot;bloodroot leaf&quot;]      = 'bloodroot',
  [&quot;black cohosh&quot;]        = 'cohosh',
  ['echinacea']           = 'echinacea',
  [&quot;slippery elm&quot;]        = 'elm',
  [&quot;ginger root&quot;]         = 'ginger',
  [&quot;ginseng root&quot;]        = 'ginseng',
  [&quot;goldenseal root&quot;]     = 'goldenseal',
  [&quot;hawthorn berry&quot;]      = 'hawthorn',
  ['kelp']                = 'kelp',
  [&quot;kola nut&quot;]            = 'kola',
  [&quot;kuzu root&quot;]           = 'kuzu',
  [&quot;lobelia seed&quot;]        = 'lobelia',
  [&quot;irid moss&quot;]           = 'irid',
  [&quot;myrrh gum&quot;]           = 'myrrh',
  [&quot;prickly pear&quot;]        = 'pear',
  ['sileris']             = 'sileris',
  ['skullcap']            = 'skullcap',
  [&quot;lady's slipper root&quot;] = 'slipper',
  ['valerian']            = 'valerian',
  ['weed']                = 'weed',

  ['ferrum']      = 'ferrum',
  ['stannum']     = 'stannum',
  ['dolomite']    = 'dolomite',
  ['antimony']    = 'antimony',
  ['bisemutum']   = 'bisemutum',
  ['cuprum']      = 'cuprum',
  ['magnesium']   = 'magnesium',
  ['calamine']    = 'calamine',
  ['malachite']   = 'malachite',
  ['azurite']     = 'azurite',
  ['plumbum']     = 'plumbum',
  ['realgar']     = 'realgar',
  ['arsenic']     = 'arsenic',
  ['gypsum']      = 'gypsum',
  ['argentum']    = 'argentum',
  ['calcite']     = 'calcite',
  ['potash']      = 'potash',
  ['quicksilver'] = 'quicksilver',
  ['aurum']       = 'aurum',
  ['quartz']      = 'quartz',
  ['cinnabar']    = 'cinnabar',
}

-- non-herb items - used in inra sorting. A space is used to accomodate the different materials without introducing complications in the code
rift.items_plural = {
  [&quot;iron &quot;]   = &quot;(%d+) pinches of iron filings&quot;,
  [&quot;silver &quot;] = &quot;(%d+) bars of silver&quot;,
  coal        = &quot;(%d+) coal pieces&quot;,
  gold        = &quot;(%d+) nuggets of gold&quot;,
  iron        = &quot;(%d+) iron bars&quot;,
  lead        = &quot;(%d+) lead beads&quot;,
  nodule      = &quot;(%d+) nodules of copper&quot;,
  silver      = &quot;(%d+) silver bars&quot;,
  tin         = &quot;(%d+) chunks of tin&quot;,
  scales      = &quot;(%d+) piles of fish scales&quot;,
  lacquer     = &quot;(%d+) pots of lacquer&quot;,
  stone       = &quot;(%d+) stones&quot;,
}

rift.items_singular = {
  [&quot;a bar of silver&quot;]        = 'silver',
  [&quot;a bead of lead&quot;]         = 'lead',
  [&quot;a chunk of tin&quot;]         = 'tin',
  [&quot;a nodule of copper&quot;]     = 'nodule',
  [&quot;a piece of coal&quot;]        = 'coal',
  [&quot;a small nugget of gold&quot;] = 'gold',
  [&quot;an iron bar&quot;]            = 'iron',
  [&quot;a pile of fish scales&quot;]  = 'scales',
  [&quot;a small pot of lacquer&quot;] = 'lacquer',
  [&quot;a block of stone&quot;]       = 'stone',
}

rift.herb_conversions = {
  ash        = 'stannum',
  bayberry   = 'arsenic',
  bellwort   = 'cuprum',
  bloodroot  = 'magnesium',
  cohosh     = 'gypsum',
  echinacea  = 'dolomite',
  elm        = 'cinnabar',
  ginger     = 'antimony',
  ginseng    = 'ferrum',
  goldenseal = 'plumbum',
  hawthorn   = 'calamine',
  irid       = 'potash',
  kelp       = 'aurum',
  kola       = 'quartz',
  lobelia    = 'argentum',
  myrrh      = 'bisemutum',
  pear       = 'calcite',
  sileris    = 'quicksilver',
  skullcap   = 'azurite',
  valerian   = 'realgar',
}

rift.vial_conversions = {
  caloric     = 'exothermic',
  epidermal   = 'sensory',
  frost       = 'endothermia',
  health      = 'vitality',
  immunity    = 'antigen',
  levitation  = 'hovering',
  mana        = 'mentality',
  mass        = 'density',
  mending     = 'renewal',
  restoration = 'reconstructive',
  speed       = 'haste',
  venom       = 'toxin',
}

function svo.intlen(number)
  return number == 0 and 1 or math.floor(math.log10(number)+1)
end

rift.update_riftlabel = function()
  if not svo.riftlabel or svo.riftlabel.hidden then return end

  local count = 0
  local tbl = {}
  local columncount = svo.conf.riftlabelcolumns or 3
  local charwidth = 20

  for _, j in pairs(rift.herbsminerals) do
    count = count + 1

    tbl[#tbl+1] = string.format([[&lt;font style=&quot;color:grey;&quot;&gt;%s&lt;/font&gt;%s%d&lt;font style=&quot;color:grey;&quot;&gt;/&lt;/font&gt;%d ]], j, string.rep(&quot;&amp;nbsp;&quot;, charwidth - #j- svo.intlen(rift.invcontents[j]) - svo.intlen(rift.riftcontents[j])), rift.invcontents[j], rift.riftcontents[j])
    if count % columncount == 0 then tbl[#tbl+1] = &quot;&lt;br /&gt;&quot; end
  end

  -- fill up the rest with spaces for alignment
  if count % columncount ~= 0 then
    -- insert spaces for each column (20 chars default) + 1 between each column
    local spacesneeded = (columncount - (count % columncount)) * (charwidth+1)
    tbl[#tbl+1] = string.rep(&quot;&amp;nbsp;&quot;, spacesneeded)
  end

  echo(&quot;svo.riftlabel&quot;, string.format([[&lt;center&gt;&lt;p style=&quot;font-size: ]]..(svo.conf.herbstatsize and svo.conf.herbstatsize or 9)..[[px; color:white; font-weight:;&quot;&gt;%s&lt;/p&gt;&lt;/center&gt;]], table.concat(tbl)))
end

rift.outr = function (what)
  if not sys.canoutr then return end

  if (rift.precache[what] and rift.precache[what] == 0) or not rift.invcontents[what] or not rift.precache[what] or (rift.invcontents[what] and rift.precache[what] and (rift.invcontents[what] - 1 &gt;= rift.precache[what])) then
    send(&quot;outr &quot; .. what, svo.conf.commandecho)
  else
    send(&quot;outr &quot; .. (rift.precache[what] - rift.invcontents[what] + 1) .. &quot; &quot; .. what, svo.conf.commandecho)
  end

  -- allow other outrs to catch up, then re-check again
  if sys.blockoutr then killTimer(sys.blockoutr); sys.blockoutr = nil end
  sys.blockoutr = tempTimer(sys.wait + svo.syncdelay(), function () sys.blockoutr = nil; svo.debugf(&quot;sys.blockoutr expired&quot;) svo.make_gnomes_work() end)
  svo.debugf(&quot;sys.blockoutr setup: &quot;, debug.traceback())
end

rift.checkprecache = function()
  rift.doprecache = false

  for herb, _ in pairs(rift.precache) do
    -- if we have addiction, then only precache 1, otherwise, however much is needed
    if rift.precache[herb] ~= 0 and rift.riftcontents[herb] ~= 0 and (not svo.affs.addiction and (rift.invcontents[herb] &lt; rift.precache[herb]) or (rift.invcontents[herb] == 0)) then
      rift.doprecache = true; return
    end
  end
end

-- used by skeleton's check_herb to see that you can eat something. It checks the appropriate herb in inv if we can't outr
-- takes in dict.&lt;aff&gt;.herb as an argument
svo.signals.curemethodchanged:connect(function ()
  if svo.conf.curemethod == 'conconly' then
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[1]] &gt; 0)
    end
  elseif svo.conf.curemethod == 'transonly' then
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[2]] &gt; 0)
    end
  else -- handles nil and prefer*s for curemethod
    sk.can_eat_for = function (aff)
      return (rift.invcontents[aff.eatcure[1]] &gt; 0) or (rift.invcontents[aff.eatcure[2]] &gt; 0)
    end
  end
end, 'update svo.sk.can_eat_for on curemethod change')

local function siprandom(what)
  if not svo.es_vialids or not svo.es_vialids[what] or not svo.es_vialids[what][1] then return what end

  return svo.es_vialids[what][math.random(#svo.es_vialids[what])]
end

-- determine the sip method. gets a table as arg with two things - the conc and trans cure
svo.signals.curemethodchanged:connect(function ()
  svo.sip = function (what)
    local use = what.sipcure[1]
    if conf.siprandom then use = siprandom(use) end
    send(&quot;sip &quot;..use, conf.commandecho)
    sys.last_used[what.name] = use
  end
end, 'update svo.sip on curemethod change')

-- determine the apply method
svo.signals.curemethodchanged:connect(function ()
  svo.apply = function (what, whereto)
    whereto = whereto or &quot;&quot;
    local use = what.applycure[1]
    send(&quot;apply &quot;..use..whereto, conf.commandecho)
    sys.last_used[what.name] = use
  end
end, 'update svo.apply on curemethod change')

-- used to determine what to eat, and set what we've eaten
svo.signals.curemethodchanged:connect(function ()
  if conf.curemethod == 'conconly' then
    sk.synceat = function(what)
      local use = what.eatcure[1]
      if rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use = what.eatcure[1]
      if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send(&quot;eat &quot; .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == 'transonly' then
    sk.synceat = function(what)
      local use = what.eatcure[2]
      if rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use = what.eatcure[2]
      if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send(&quot;eat &quot; .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == nil or conf.curemethod == 'preferconc' then
    sk.synceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
      if (not (rift.invcontents[use] &gt; 0) and (rift.invcontents[use2] &gt; 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[use] &gt; 0) then
          use = use2
      end

      if rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
      if (not (rift.invcontents[use] &gt; 0) and (rift.invcontents[use2] &gt; 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[use] &gt; 0) then
          use = use2
      end

      if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send(&quot;eat &quot; .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == 'prefertrans' then
    -- should eat trans if it's in inv
    -- should eat trans if it's in the rift and no conc in inv
    sk.synceat = function(what)
      -- check if we should use trans
      local use, use2 = what.eatcure[1], what.eatcure[2]
      if (rift.invcontents[use2] &gt; 0)
        or (not (rift.invcontents[use] &gt; 0) and (rift.riftcontents[use2] &gt; 0)) then
          use = use2
      end

      if rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        sys.last_used[what.name] = use
      else
        rift.outr(use)
      end
    end
    sk.asynceat = function(what)
      local use, use2 = what.eatcure[1], what.eatcure[2]
      if (rift.invcontents[use2] &gt; 0)
        or (not (rift.invcontents[use] &gt; 0) and (rift.riftcontents[use2] &gt; 0)) then
          use = use2
      end

      if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
        send(&quot;eat &quot; .. use, conf.commandecho)
        rift.outr(use)
      else
        rift.outr(use)
        send(&quot;eat &quot; .. use, conf.commandecho)
      end
      sys.last_used[what.name] = use
    end

  elseif conf.curemethod == 'prefercustom' then
    -- should eat trans if it's in inv
    -- should eat trans if it's in the rift and no conc in inv
    sk.synceat = function(what)
      if me.curelist[what.eatcure[1]] == what.eatcure[1] then
        local use, use2 = what.eatcure[1], what.eatcure[2]
        -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
        if (not (rift.invcontents[use] &gt; 0) and (rift.invcontents[use2] &gt; 0))
          -- or if we don't have the conc cure in rift either, use alchemy
          or not (rift.riftcontents[use] &gt; 0) then
            use = use2
        end

        if rift.invcontents[use] &gt; 0 then
          send(&quot;eat &quot; .. use, conf.commandecho)
          sys.last_used[what.name] = use
        else
          rift.outr(use)
        end
      else
        local use, use2 = what.eatcure[1], what.eatcure[2]
        if (rift.invcontents[use2] &gt; 0)
          or (not (rift.invcontents[use] &gt; 0) and (rift.riftcontents[use2] &gt; 0)) then
            use = use2
        end

        if rift.invcontents[use] &gt; 0 then
          send(&quot;eat &quot; .. use, conf.commandecho)
          sys.last_used[what.name] = use
        else
          rift.outr(use)
        end
      end
    end
    sk.asynceat = function(what)
      if me.curelist[what.eatcure[1]] == what.eatcure[1] then
        local use, use2 = what.eatcure[1], what.eatcure[2]
        -- if we don't have the conc cure in inv, but have the alchemy one, use alchemy
        if (not (rift.invcontents[use] &gt; 0) and (rift.invcontents[use2] &gt; 0))
          -- or if we don't have the conc cure in rift either, use alchemy
          or not (rift.riftcontents[use] &gt; 0) then
            use = use2
        end

        if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
          send(&quot;eat &quot; .. use, conf.commandecho)
          rift.outr(use)
        else
          rift.outr(use)
          send(&quot;eat &quot; .. use, conf.commandecho)
        end
        sys.last_used[what.name] = use
      else
        local use, use2 = what.eatcure[1], what.eatcure[2]
        if (rift.invcontents[use2] &gt; 0)
          or (not (rift.invcontents[use] &gt; 0) and (rift.riftcontents[use2] &gt; 0)) then
            use = use2
        end

        if rift.invcontents[use] and rift.invcontents[use] &gt; 0 then
          send(&quot;eat &quot; .. use, conf.commandecho)
          rift.outr(use)
        else
          rift.outr(use)
          send(&quot;eat &quot; .. use, conf.commandecho)
        end
        sys.last_used[what.name] = use
      end
    end

    -- disabled for now, because tracking which herb we used for an action is problematic
  -- elseif conf.curemethod == 'auto' then
  --   sk.synceat = function(what)
  --     -- if we have the alchemy cure, use it, otherwise stick to usual
  --     local haveusual, havealchemy = rift.invcontents[what], rift.invcontents[herb_conversions[what]]
  --     if haveusual and havealchemy then
  --       what = (math.random(1,2) == 1) and what or herb_conversions[what]
  --     elseif not haveusual then
  --       what = herb_conversions[what]
  --     end

  --     if rift.invcontents[what] &gt; 0 then
  --       send(&quot;eat &quot; .. what, conf.commandecho)
  --     else
  --       rift.outr(what)
  --     end
  --   end
  --   sk.asynceat = function(what)
  --     local haveusual, havealchemy = rift.invcontents[what], rift.invcontents[herb_conversions[what]]
  --     if haveusual and havealchemy then
  --       what = (math.random(1,2) == 1) and what or herb_conversions[what]
  --     elseif not haveusual then
  --       what = herb_conversions[what]
  --     end

  --     if rift.invcontents[what] and rift.invcontents[what] &gt; 0 then
  --       send(&quot;eat &quot; .. what, conf.commandecho)
  --       rift.outr(what)
  --     else
  --       rift.outr(what)
  --       send(&quot;eat &quot; .. what, conf.commandecho)
  --     end
    -- end
  end

  -- update the actual 'eat' function
  sk.checkaeony()
  svo.signals.aeony:emit()
end, 'update svo.eat on curemethod change')

svo.signals.systemstart:connect(function()
  svo.signals.curemethodchanged:emit()
end, 'create eat, apply, etc functions on system start')

svo.signals.aeony:connect(function ()
  if sys.sync then
    svo.eat = sk.synceat
  else
    svo.eat = sk.asynceat
  end
end, 'update svo.eat on aeon/retardation')

local smoke_herb_conversions = {
  elm      = 'cinnabar',
  skullcap = 'malachite',
  valerian = 'realgar',
}

-- pipes don't need to be refilled that often, so we'll do the herb selection realtime instead of recompiling this huge monster all the time
function sk.asyncfill(what, where)
  local orig = what

  -- work out if we need to change what to its alternative
  if conf.curemethod ~= 'conconly' and (

    conf.curemethod == 'transonly' or

    ((conf.curemethod == 'preferconc' or conf.curemethod == nil) and
      -- we don't have in forestal inventory, but do have alchemy in inventory, use alchemy
       (not (rift.invcontents[what] &gt; 0) and (rift.invcontents[smoke_herb_conversions[what]] &gt; 0)) or
        -- or if we don't have the conc cure in rift either, use alchemy
       (not (rift.riftcontents[what] &gt; 0))) or

    (conf.curemethod == 'prefertrans' and -- we *do* have the trans available
      (rift.invcontents[smoke_herb_conversions[what]] &gt; 0
        or (not (rift.invcontents[what] &gt; 0) and (rift.riftcontents[smoke_herb_conversions[what]] &gt; 0)))) or

    -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
    (conf.curemethod == 'prefercustom' and
      ((me.curelist[what] == smoke_herb_conversions[what] and rift.riftcontents[smoke_herb_conversions[what]] &gt; 0)
        or
       (me.curelist[what] == what and rift.riftcontents[what] &lt;= 0)
      )
    )) then
      what = smoke_herb_conversions[what]
  end

  sys.last_used['fill'..orig..'_physical'] = what
  pipes[orig].filledwith = what

  if rift.invcontents[what] &gt; 0 then
    if pipes[orig].puffs &gt; 0 then
      if not svo.defc.selfishness then
        send(&quot;empty &quot;..where, conf.commandecho)
      else
        for _ = 1, (pipes[orig].puffs + 1) do
          send(&quot;smoke &quot;..where, conf.commandecho)
        end
      end
    end

    send(&quot;put &quot; .. what .. &quot; in &quot; .. where, conf.commandecho)
    rift.outr(what)
  else
    rift.outr(what)
    if pipes[orig].puffs &gt; 0 then
      if not svo.defc.selfishness then
        send(&quot;empty &quot;..where, conf.commandecho)
      else
        for _ = 1, (pipes[orig].puffs + 1) do
          send(&quot;smoke &quot;..where, conf.commandecho)
        end
      end
    end
    send(&quot;put &quot; .. what .. &quot; in &quot; .. where, conf.commandecho)
  end
end

function sk.syncfill(what, where)
  local orig = what
  -- work out if we need to change what to its alternative
  if conf.curemethod ~= 'conconly' and (

    conf.curemethod == 'transonly' or

    ((conf.curemethod == 'preferconc' or conf.curemethod == nil) and
       (not (rift.invcontents[what] &gt; 0) and (rift.invcontents[smoke_herb_conversions[what]] &gt; 0))
        -- or if we don't have the conc cure in rift either, use alchemy
        or not (rift.riftcontents[what] &gt; 0)) or

    (conf.curemethod == 'prefertrans' and
      (rift.invcontents[smoke_herb_conversions[what]] &gt; 0)
        or (not (rift.invcontents[what] &gt; 0) and (rift.riftcontents[smoke_herb_conversions[what]] &gt; 0))) or

    -- prefercustom, and we either prefer alchy and have it, or prefer conc and don't have it
    (conf.curemethod == 'prefercustom' and (
      (me.curelist[what] == what and rift.riftcontents[what] &lt;= 0)
        or
      (me.curelist[what] == smoke_herb_conversions[what] and rift.riftcontents[smoke_herb_conversions[what]] &gt; 0)
    ))) then
      what = smoke_herb_conversions[what]
  end

  sys.last_used['fill'..orig..'_physical'] = what
  pipes[orig].filledwith = what

  if pipes[orig].puffs &gt; 0 then
    if svo.defc.selfishness then svo.echof(&quot;Problem - can't refill while selfish :/&quot;) return end
    send(&quot;empty &quot;..where, conf.commandecho)
  elseif rift.invcontents[what] &gt; 0 then
    send(&quot;put &quot; .. what .. &quot; in &quot; .. where, conf.commandecho)
  else
    rift.outr(what)
  end
end

svo.signals.aeony:connect(function ()
  if sys.sync then
    svo.fillpipe = sk.syncfill
  else
    svo.fillpipe = sk.asyncfill
  end
end, 'update svo.fillpipe')


function svo.riftline()
  for i = 1, #matches, 3 do
    local amount = tonumber(matches[i+1])
    local rawherbstring, herb = matches[i+2], false

    -- Achaea's rift doesn't use standard singular naming or even the short names,
    -- so substring find which herb is it
    for _, herbi in ipairs(rift.allherbs) do
      if rawherbstring:find(&quot;%f[%a]&quot;..herbi..&quot;%f[%A]&quot;) then
        herb = herbi
        break
      end
    end

    if herb and amount then
      rift.riftcontents[herb] = amount
    end
  end

  rift.update_riftlabel()
end

function svo.showrift()
  display(rift.riftcontents)
end

function svo.showinv()
  display(rift.invcontents)
end

function svo.showprecache()
  local count = 1

  local function makelink(herb, sign)
    if sign == &quot;-&quot; and rift.precache[herb] == 0 then
      echo &quot; &quot;
    elseif sign == &quot;+&quot; then
      echoLink(sign, [[svo.setprecache(&quot;]]..herb..[[&quot;, 1, 'add', nil, true)]], sign .. &quot; the &quot; .. herb .. &quot; amount&quot;)
    elseif sign == &quot;-&quot; then
      echoLink(sign, [[svo.setprecache(&quot;]]..herb..[[&quot;, 1, 'subtract', nil, true)]], sign .. &quot; the &quot; .. herb .. &quot; amount&quot;)
    else
      echo &quot; &quot;
    end

    return &quot;&quot;
  end

--[[  moveCursor('main', 0, getLastLineNumber('main'))
  debugf(&quot;line: &quot; .. getCurrentLine() .. &quot;, latest: &quot; .. getLastLineNumber('main'))
  if getCurrentLine() == &quot;-&quot; or getCurrentLine() == &quot; &quot; then
    insertText(&quot; &quot;)
    for i = 1, 1000 do deleteLine()
    debugf('deleting') end
  end]]
  svo.echof(&quot;Herb pre-cache list (%s defences):&quot;, svo.defs.mode)

  local t = {}; for herb in pairs(rift.precache) do t[#t+1] = herb end; table.sort(t)
  for i = 1, #t do
    local herb, amount = t[i], rift.precache[t[i]]
  -- for herb, amount in pairs(rift.precache) do
    if count % 3 ~= 0 then
      decho(string.format(&quot;&lt;153,204,204&gt;[&lt;91,134,214&gt;%d&lt;153,204,204&gt;%s%s] %-&quot;..(svo.intlen(amount) == 1 and '23' or '22')..'s', amount, makelink(herb, &quot;+&quot;), makelink(herb, &quot;-&quot;), herb))
    else
      decho(string.format(&quot;&lt;153,204,204&gt;[&lt;91,134,214&gt;%d&lt;153,204,204&gt;%s%s] %s&quot;, amount, makelink(herb, &quot;+&quot;), makelink(herb, &quot;-&quot;), herb)) end

    if count % 3 == 0 then echo(&quot;\n&quot;) end
    count = count + 1
  end

--[[  moveCursor('main', 0, getLastLineNumber('main'))
  moveCursor('main', #getCurrentLine(), getLastLineNumber('main'))
  insertText(&quot;\n-\n&quot;)]]
  echo&quot;\n&quot;
  svo.showprompt()
end

function svo.setprecache(herb, amount, flag, echoback, show_list)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end

  svo.assert(rift.precache[herb], &quot;what herb do you want to set a precache amount for?&quot;, sendf)

  if flag == 'add' then
    rift.precache[herb] = rift.precache[herb] + amount
  elseif flag == 'subtract' then
    rift.precache[herb] = rift.precache[herb] - amount
    if rift.precache[herb] &lt; 0 then rift.precache[herb] = 0 end
  elseif not flag or flag == 'set' then
    rift.precache[herb] = amount
  end

  if echoback then
    svo.echof(&quot;Will keep at least %d of %s out in the inventory now.&quot;, rift.precache[herb], herb)
  elseif show_list then
    svo.showprecache()
  end
  rift.checkprecache()
end

function svo.invline()
  rift.resetinvcontents()

  -- lowercase as the first letter is capitalised
  local line = line:lower()
  local tabledline = line:split(&quot;, &quot;)

  -- strip out the last 'and'
  if tabledline[#tabledline]:starts(&quot;and &quot;) then
    tabledline[#tabledline] = tabledline[#tabledline]:gsub(&quot;^and &quot;, '')
  end

  -- for everything we got in our inv
  for i = 1, #tabledline do
    local riftable = tabledline[i]
    if riftable:sub(-1) == &quot;.&quot; then riftable = riftable:sub(1,#riftable - 1) end -- kill trailing dot

    -- tally up rift.herbs_singular items
    if rift.herbs_singular[riftable] then
      rift.invcontents[rift.herbs_singular[riftable]] = rift.invcontents[rift.herbs_singular[riftable]] + 1
    end

    -- tally up rift.herbs_plural items
    for k,l in pairs(rift.herbs_plural) do
      local result = riftable:match(l)
      if result then
        rift.invcontents[k] = rift.invcontents[k] + tonumber(result)
      end
    end
  end

  rift.update_riftlabel()
  rift.checkprecache()
end

function svo.riftremoved()
  local removed = tonumber(matches[2])
  local what = rift.herbs_singular_sansprefix[matches[3]]
  local inrift = tonumber(matches[4])

  if not (what and removed and inrift) then return end

  if rift.riftcontents[what] then rift.riftcontents[what] = inrift end
  if rift.invcontents[what] then rift.invcontents[what] = rift.invcontents[what] + removed end

  rift.update_riftlabel()

  svo.signals.removed_from_rift:emit(removed, what, inrift)

  -- don't add if not doing it
  svo.checkaction(svo.dict.doprecache.misc, false)
  if svo.actions.doprecache_misc then
    svo.lifevision.add(svo.actions.doprecache_misc.p)
  end
end

function svo.pocketbelt_added()
  local removedamount = tonumber(matches[2])
  local what = matches[3]
  if not rift.invcontents[what] then return end

  rift.invcontents[what] = rift.invcontents[what] - removedamount
end

function svo.pocketbelt_removed()
  local removedamount = tonumber(matches[2])
  local what = matches[3]
  if not rift.invcontents[what] then return end

  rift.invcontents[what] = rift.invcontents[what] + removedamount
end

function svo.riftadded()
  local removed = tonumber(matches[2])
  local what = rift.herbs_singular_sansprefix[matches[3]]
  if not what then return end
  local inrift = tonumber(matches[4])

  if rift.riftcontents[what] then rift.riftcontents[what] = inrift end
  if rift.invcontents[what] then rift.invcontents[what] = rift.invcontents[what] - removed end
  if rift.invcontents[what] and rift.invcontents[what] &lt; 0 then rift.invcontents[what] = 0 end

  rift.update_riftlabel()
  rift.checkprecache()
end

function svo.riftnada()
  local what = matches[2]
  if rift.invcontents[what] then rift.invcontents[what] = 0 end

  rift.update_riftlabel()
  rift.checkprecache()
end

function svo.riftate()
  -- if conf.aillusion and not (usingbal'herb' or usingbal'moss') then
  --   resetFormat()
  --   echoLink(&quot; (i)&quot;, '', &quot;Precache considered this to be an illusion (because the system isn't eating anything right now) and didn't count the herb used&quot;, true)
  --   return
  -- end

  local what = matches[2]

  if not rift.herbs_singular[what] then return end

  if not svo.conf.arena then
    rift.invcontents[rift.herbs_singular[what]] = rift.invcontents[rift.herbs_singular[what]] - 1
    if rift.invcontents[rift.herbs_singular[what]] &lt; 0 then rift.invcontents[rift.herbs_singular[what]] = 0 end
  end

  rift.update_riftlabel()
  rift.checkprecache()
end

do
  local oldCL = createLabel
  function createLabel(name, posX, posY, width, height, fillBackground)
    oldCL(name, 0, 0, 0, 0, fillBackground)
    moveWindow(name, posX, posY)
    resizeWindow(name, width, height)
  end
end

function svo.toggle_riftlabel(toggle)
  if (type(toggle) == 'nil' and svo.riftlabel.hidden) or (type(toggle) ~= 'nil' and toggle) then
    svo.riftlabel:show()
    rift.update_riftlabel()
    svo.echof(&quot;Spawned the herbstat window.&quot;)
    svo.conf.riftlabel = true
    raiseEvent(&quot;svo config changed&quot;, 'riftlabel')
  elseif (type(toggle) == 'nil' and not svo.riftlabel.hidden) or (type(toggle) ~= 'nil' and not toggle) then
    svo.riftlabel:hide()
    svo.echof(&quot;Hid the herbstat window.&quot;)
    svo.conf.riftlabel = false
    raiseEvent(&quot;svo config changed&quot;, 'riftlabel')
  end
end

svo.signals.systemstart:add_post_emit(function ()
  if lfs.attributes(getMudletHomeDir() .. &quot;/svo/rift+inv/rift&quot;) then
    table.load(getMudletHomeDir() .. &quot;/svo/rift+inv/rift&quot;, rift.riftcontents)
  end
  if lfs.attributes(getMudletHomeDir() .. &quot;/svo/rift+inv/inv&quot;) then
    table.load(getMudletHomeDir() .. &quot;/svo/rift+inv/inv&quot;, rift.invcontents)
  end

  -- reset, because we can't have herbs in inv at login
  rift.resetinvcontents()

  for mode, _ in pairs(svo.defdefup) do
    rift.precachedata[mode] = {}

    for _,herb in pairs(rift.herbsminerals) do
      rift.precachedata[mode][herb] = 0
    end

    if mode == 'combat' then
      rift.precachedata[mode].irid = 1
      rift.precachedata[mode].kelp = 1
      rift.precachedata[mode].bloodroot = 1
    end
  end



  local tmp = {}
  if lfs.attributes(getMudletHomeDir() .. &quot;/svo/rift+inv/precachedata&quot;) then
    table.load(getMudletHomeDir() .. &quot;/svo/rift+inv/precachedata&quot;, tmp)
    svo.update(rift.precachedata, tmp)
    rift.precache = rift.precachedata[svo.defs.mode]

    -- moss was removed, get rid of it
    for _, m in pairs(rift.precachedata) do
      if m.moss then m.moss = nil end
    end
  end
  rift.update_riftlabel()
end)

svo.signals.enablegmcp:connect(function()
  sendGMCP([[Core.Supports.Add [&quot;IRE.Rift 1&quot;] ]])
end, 'enable gmcp rift tracking')

svo.signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/rift+inv/rift&quot;, rift.riftcontents)
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/rift+inv/inv&quot;, rift.invcontents)
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/rift+inv/precachedata&quot;, rift.precachedata)
end, 'save rift config')


sk.checkaeony()
svo.signals.aeony:emit()

</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Diag trigger functions</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

function svo.valid.diagnose_start()
  svo.checkaction(svo.dict.diag.physical)
  if svo.actions.diag_physical then
    svo.lifevision.add(svo.actions.diag_physical.p)
  elseif svo.conf.aillusion then
    setTriggerStayOpen(&quot;svo diag&quot;, 0)
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
    insertLink(&quot; (i)&quot;, '', 'Ignored this diagnose because we aren\'t actually diagnosing right now (if this is godfeelings, don\'t mind me, then)')
    moveCursorEnd()

    -- necessary since the trigger itself lasts on the next line
    svo.prompttrigger(&quot;reset diag&quot;, function() svo.sk.diag_list = {} end)
   end
end

function svo.valid.empty_diagnose()
  svo.checkaction(svo.dict.diag.physical)
  if svo.actions.diag_physical then
    svo.lifevision.add(svo.actions.diag_physical.p, nil, nil, 1)
    svo.valid.diagnose_end()
  else
    svo.ignore_illusion(&quot;Ignoring this illusion because we weren't diagnosing right now.&quot;)
  end
end

local whitelist = {}
whitelist.lovers, whitelist.retardation, whitelist.hoisted, whitelist.paradox = true, true, true, true
if svo.haveskillset('metamorphosis') then
  whitelist.cantvitality = true
end
if svo.haveskillset('metamorphosis') or svo.haveskillset('shindo') or svo.haveskillset('kaido') then
  whitelist.cantmorph = true
end

function svo.valid.diagnose_end()
  if svo.sk.diag_list.godfeelings then svo.sk.diag_list = {} setTriggerStayOpen(&quot;svo diag&quot;, 0) return end

  -- clear ones we don't have
  for affn, _ in pairs(svo.affs) do
    if not svo.sk.diag_list[affn] and not whitelist[affn] then
      svo.debugf(&quot;removed %s, don't actually have it.&quot;, affn)
      if svo.dict[affn].count then svo.dict[affn].count = 0 end
      svo.rmaff(affn)
    elseif not whitelist[affn] then -- if we do have the aff, remove from diag list, so we don't add it again
      -- but update the current count!
      if type(svo.sk.diag_list[affn]) == 'number' and svo.dict[affn].count then
        svo.dict[affn].count = svo.sk.diag_list[affn]
        svo.updateaffcount(svo.dict[affn])
        svo.debugf(&quot;%s count updated to %d&quot;, affn, svo.dict[affn].count)
      end

      svo.sk.diag_list[affn] = nil
    end
  end

  -- add left over ones
  for j,k in pairs(svo.sk.diag_list) do
    if not svo.dict[j].aff then svo.debugf(&quot;svo: invalid %s in diag end&quot;, j) end
    -- skip defs
    if svo.defc[j] == nil then
      svo.checkaction(svo.dict[j].aff, true)
      if type(k) == 'number' and not svo.dict[j].count then
        for _ = 1, k do svo.lifevision.add(svo.actions[j .. '_aff'].p) end
      elseif type(k) == 'number' and svo.dict[j].count then
        svo.lifevision.add(svo.actions[j .. '_aff'].p, nil, k)
      else
        svo.lifevision.add(svo.actions[j .. '_aff'].p)
      end
    end
  end

  svo.affsp = {} -- potential affs
  svo.sk.checkaeony()
  svo.signals.aeony:emit()
  setTriggerStayOpen(&quot;svo diag&quot;, 0)
  svo.sk.diag_list = {}
end

for _,affname in ipairs({'ablaze', 'severeburn', 'extremeburn', 'charredburn', 'meltingburn', 'addiction', 'aeon', 'agoraphobia', 'anorexia', 'asthma', 'blackout', 'bleeding', 'bound', 'burning', 'claustrophobia', 'clumsiness', 'mildconcussion', 'confusion', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'darkshade', 'deadening', 'dementia', 'disloyalty', 'disrupt', 'dissonance', 'dizziness', 'epilepsy', 'fear', 'galed', 'generosity', 'haemophilia', 'hallucinations', 'healthleech', 'heartseed', 'hellsight', 'hypersomnia', 'hypochondria', 'icing', 'illness', 'impale', 'impatience', 'inlove', 'inquisition', 'itching', 'justice', 'laceratedthroat', 'lethargy', 'loneliness', 'lovers', 'madness', 'mangledleftarm', 'mangledleftleg', 'mangledrightarm', 'mangledrightleg', 'masochism', 'mildtrauma', 'mutilatedleftarm', 'mutilatedleftleg', 'mutilatedrightarm', 'mutilatedrightleg', 'pacifism', 'paralysis', 'paranoia', 'peace', 'prone', 'recklessness', 'relapsing', 'roped', 'selarnia', 'sensitivity', 'seriousconcussion', 'serioustrauma', 'shyness', 'slashedthroat', 'slickness', 'stun', 'stupidity', 'stuttering', 'transfixed', 'unknownany', 'unknowncrippledarm', 'unknowncrippledleg', 'unknownmental', 'vertigo', 'voided', 'voyria', 'weakness', 'webbed', 'hamstring', 'shivering', 'frozen', 'manaleech', 'voyria', 'slightfluid', 'elevatedfluid', 'highfluid', 'seriousfluid', 'criticalfluid', 'godfeelings', 'phlogistication', 'vitrification', 'corrupted', 'stain', 'rixil', 'palpatar', 'cadmus', 'hecate', 'ninkharsag', 'spiritdisrupt', 'airdisrupt', 'firedisrupt', 'earthdisrupt', 'waterdisrupt', 'hoisted', 'swellskin', 'pinshot', 'hypothermia', 'scalded', 'dehydrated', 'timeflux', 'numbedleftarm', 'numbedrightarm', 'unconsciousness', 'depression', 'parasite', 'retribution', 'shadowmadness', 'timeloop', 'degenerate', 'deteriorate', 'hatred'}) do
  svo.valid['diag_'..affname] = function()
    svo.sk.diag_list[affname] = true

    if not svo.affs[affname] then
      decho(svo.getDefaultColor()..&quot;(new)&quot;)
    else
      decho(svo.getDefaultColor()..&quot; (&quot;..getStopWatchTime(svo.affs[affname].sw)..&quot;s)&quot;)
    end

    if svo.ignore[affname] then
      decho(svo.getDefaultColor()..&quot; (currently ignored)&quot;)
    end
  end
end

-- afflictions with a count
for _, aff in ipairs({'cholerichumour', 'melancholichumour', 'phlegmatichumour', 'sanguinehumour', 'bleeding', 'skullfractures', 'crackedribs', 'wristfractures', 'torntendons'}) do
  svo.valid['diag_'..aff] = function(howmuch)
    svo.sk.diag_list[aff] = tonumber(howmuch)

    if svo.ignore[aff] then
      echo(&quot; (currently ignored)&quot;)
    end
  end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Simple trigger functions</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local conf, me = svo.conf, svo.me
local stats = svo.stats
local valid, actions = svo.valid, svo.actions
local lifevision = svo.lifevision

do
  local afflist = {'ablaze', 'severeburn', 'extremeburn', 'charredburn', 'meltingburn', 'addiction', 'aeon', 'agoraphobia', 'anorexia', 'asthma', 'blackout', 'bleeding', 'bound', 'burning', 'claustrophobia', 'clumsiness', 'mildconcussion', 'confusion', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'darkshade', 'deadening', 'dementia', 'disloyalty', 'disrupt', 'dissonance', 'dizziness', 'epilepsy', 'fear', 'galed', 'generosity', 'haemophilia', 'hallucinations', 'healthleech', 'heartseed', 'hellsight', 'hypersomnia', 'hypochondria', 'icing', 'illness', 'impale', 'impatience', 'inlove', 'inquisition', 'itching', 'justice', 'laceratedthroat', 'lethargy', 'loneliness', 'lovers', 'madness', 'mangledleftarm', 'mangledleftleg', 'mangledrightarm', 'mangledrightleg', 'masochism', 'mildtrauma', 'mutilatedleftarm', 'mutilatedleftleg', 'mutilatedrightarm', 'mutilatedrightleg', 'pacifism', 'paralysis', 'paranoia', 'peace', 'prone', 'recklessness', 'relapsing', 'roped', 'selarnia', 'sensitivity', 'seriousconcussion', 'serioustrauma', 'shyness', 'slashedthroat', 'slickness', 'stun', 'stupidity', 'stuttering', 'transfixed', 'unknownany', 'unknowncrippledarm', 'unknowncrippledleg', 'unknownmental', 'vertigo', 'voided', 'voyria', 'weakness', 'webbed', 'hamstring', 'shivering', 'frozen', 'blindaff', 'deafaff', 'retardation', 'manaleech', 'sleep', 'amnesia', 'unknowncrippledlimb', 'cholerichumour', 'melancholichumour', 'phlegmatichumour', 'sanguinehumour', 'phlogistication', 'vitrification', 'corrupted', 'stain', 'rixil', 'palpatar', 'cadmus', 'hecate', 'ninkharsag', 'spiritdisrupt', 'airdisrupt', 'firedisrupt', 'earthdisrupt', 'waterdisrupt', 'swellskin', 'pinshot', 'hypothermia', 'scalded', 'dehydrated', 'timeflux', 'lullaby', 'numbedleftarm', 'numbedrightarm', 'unconsciousness', 'depression', 'parasite', 'retribution', 'shadowmadness', 'timeloop', 'degenerate', 'deteriorate', 'hatred'}
  if svo.haveskillset('metamorphosis') then
    afflist[#afflist+1] = 'cantmorph'
  end

  for _,j in ipairs(afflist) do
    valid['simple' .. j] = function ()
      svo.checkaction(svo.dict[j].aff, true)
      lifevision.add(actions[j .. '_aff'].p)
    end
  end
end

svo.valid.simplehoisted = function(name)
  svo.assert(name)

  if (conf.autowrithe == 'white' and me.hoistlist[name]) or (conf.autowrithe == 'black' and not me.hoistlist[name]) then return end

  svo.checkaction(svo.dict.hoisted.aff, true)
  lifevision.add(actions.hoisted_aff.p)
end

svo.valid.simpleprone = function ()
  svo.checkaction(svo.dict.prone.aff, true)
  lifevision.add(actions.prone_aff.p)

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

svo.valid.simplewebbed = function ()
  svo.checkaction(svo.dict.webbed.aff, true)
  lifevision.add(actions.webbed_aff.p)

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

svo.valid.simpleblackout = function()
  svo.checkaction(svo.dict.blackout.aff, true)
  -- add it first, before others - so stun checking doesn't delay blackout
  lifevision.addcust(actions.blackout_aff.p, 1)
end

svo.valid.simplebleeding = function (amount)
  if not conf.preclot then return end

  svo.checkaction(svo.dict.bleeding.aff, true)
  if lifevision.l.bleeding_aff then
    lifevision.add(actions.bleeding_aff.p, nil, svo.dict.bleeding.count + (amount or 200) + (lifevision.l.bleeding_aff.arg or 0))
  else
    lifevision.add(actions.bleeding_aff.p, nil, svo.dict.bleeding.count + (amount or 200))
  end
end

svo.valid.simplelovers = function (name)
  svo.assert(name)

  if (conf.autoreject == 'white' and me.lustlist[name]) or (conf.autoreject == 'black' and not me.lustlist[name]) then return end

  svo.checkaction(svo.dict.lovers.aff, true)
  svo.dict.lovers.tempmap[#svo.dict.lovers.tempmap+1] = name -- hack to allow multiple names on ALLIES
  lifevision.add(actions.lovers_aff.p, nil)
end

svo.valid.simpleunknowncrippledleg = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleunknowncrippledleg: how many affs do you want to add? Must be a number&quot;)

  svo.checkaction(svo.dict.unknowncrippledleg.aff, true)

  if lifevision.l.unknowncrippledleg_aff then
    lifevision.add(actions.unknowncrippledleg_aff.p, nil, (number or 1) + (lifevision.l.unknowncrippledleg_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledleg_aff.p, nil, (number or 1))
  end
end

svo.valid.simpleunknowncrippledarm = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleunknowncrippledarm: how many affs do you want to add? Must be a number&quot;)

  svo.checkaction(svo.dict.unknowncrippledarm.aff, true)

  if lifevision.l.unknowncrippledarm_aff then
    lifevision.add(actions.unknowncrippledarm_aff.p, nil, (number or 1) + (lifevision.l.unknowncrippledarm_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledarm_aff.p, nil, (number or 1))
  end
end

svo.valid.simpleunknowncrippledlimb = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleunknowncrippledlimb: how many affs do you want to add? Must be a number&quot;)

  svo.checkaction(svo.dict.unknowncrippledlimb.aff, true)

  if lifevision.l.unknowncrippledlimb_aff then
    lifevision.add(actions.unknowncrippledlimb_aff.p, nil, (number or 1) +(lifevision.l.unknowncrippledlimb_aff.arg or 1))
  else
    lifevision.add(actions.unknowncrippledlimb_aff.p, nil, (number or 1))
  end
end

svo.valid.simpleunknownany = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleunknownany: how many affs do you want to add? Must be a number&quot;)
  if number then svo.assert(number &gt; 0, &quot;svo.valid.simpleunknownany: number must be positive&quot;) end

  svo.checkaction(svo.dict.unknownany.aff, true)
  if lifevision.l.unknownany_aff then
    lifevision.add(actions.unknownany_aff.p, nil, (number or 1) +(lifevision.l.unknownany_aff.arg or 1))
  else
    lifevision.add(actions.unknownany_aff.p, nil, (number or 1))
  end

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    svo.dict.unknownany.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    svo.dict.unknownany.reckmana = true end
end

svo.valid.simpleunknownmental = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleunknownany: how many affs do you want to add? Must be a number&quot;)
  if number then svo.assert(number &gt; 0, &quot;svo.valid.simpleunknownmental: number must be positive&quot;) end

  svo.checkaction(svo.dict.unknownmental.aff, true)
  if lifevision.l.unknownmental_aff then
    lifevision.add(actions.unknownmental_aff.p, nil, (number or 1) +(lifevision.l.unknownmental_aff.arg or 1))
  else
    lifevision.add(actions.unknownmental_aff.p, nil, (number or 1))
  end

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    svo.dict.unknownmental.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    svo.dict.unknownmental.reckmana = true end
end

for _, affname in ipairs({'skullfractures', 'crackedribs', 'wristfractures', 'torntendons'}) do
  valid['simple'..affname] = function (number)
    svo.assert(not number or tonumber(number), &quot;svo.valid.simple&quot;..affname..&quot;: how many affs do you want to add? Must be a number&quot;)

    svo.checkaction(svo.dict[affname].aff, true)

    if lifevision.l[affname..'_aff'] then
      lifevision.add(actions[affname..'_aff'].p, nil, (number or 1) +(lifevision.l[affname..'_aff'].arg or 1))
    else
      lifevision.add(actions[affname..'_aff'].p, nil, (number or 1))
    end
  end
end

-- historical API compatibility
svo.valid.proper_crippledleftleg = valid.simplecrippledrightleg
svo.valid.proper_crippledrightleg = valid.simplecrippledrightleg
svo.valid.proper_crippledrightarm = valid.simplecrippledrightarm
svo.valid.proper_crippledleftarm = valid.simplecrippledleftarm

if svo.haveskillset('aeonics') then
  valid.simpleage = function(value)
    svo.checkaction(svo.dict.age.happened, true)
    lifevision.add(actions.age_happened.p, nil, tonumber(value))
  end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Main trigger functions</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local conf, sk, me, defs, defc = svo.conf, svo.sk, svo.me, svo.defs, svo.defc
local defences, stats, cnrl, rift = svo.defences, svo.stats, svo.cnrl, svo.rift
local bals, pipes, valid, actions = svo.bals, svo.pipes, svo.valid, svo.actions
local lifevision = svo.lifevision

function svo.valid.caught_illusion()
  sys.flawedillusion = true
  me.haveillusion = true
end

function svo.not_illusion(reason)
  sys.not_illusion = reason or true
end

function svo.ignore_illusion(reason, moveback)
  -- don't spam with multiple (i)'s
  if sys.flawedillusion then return end

  sys.flawedillusion = true
  me.haveillusion = reason or true
  local currentline = getLineNumber()

  if reason == &quot;not first&quot; then
    local previousline = getLines(currentline-1, currentline)[1]
    moveCursor(#getCurrentLine(), currentline)
    insertText(&quot; &quot;) moveCursor(#getCurrentLine(), currentline) insertLink(&quot;(i)&quot;, '', string.format(&quot;Ignored this illusion because '%s' can't come together with '%s' at once.&quot;, line, previousline))
  else
    if moveback then moveCursor(0, currentline-1) end
    moveCursor(#getCurrentLine(), currentline)
    insertText(&quot; &quot;) moveCursor(#getCurrentLine(), currentline) insertLink(&quot;(i)&quot;, '', reason or '')
  end

  moveCursorEnd('main')
  svo.debugf(&quot;svo.ignore_illusion()&quot;)
end

function svo.show_info(shortmsg, message, moveback)
  if moveback then moveCursor(0, getLineNumber()-1) end
  moveCursor(#getCurrentLine(), getLineNumber())
  insertText(&quot; &quot;) moveCursor(#getCurrentLine(), getLineNumber())
  deselect()
  fg('green')
  insertLink(&quot;(&quot;..shortmsg..&quot;)&quot;, '', message or '') -- can't format, https://bugs.launchpad.net/mudlet/+bug/1027732
  resetFormat()
end

-- +2 if we do stuff on the prompt
function svo.vm.last_line_was_prompt()
  return (svo.paragraph_length == 1) and true or false
end

function svo.valid.symp_asleep()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then
    svo.ignore_illusion(&quot;not first&quot;)
    return
  end

  if not affs.sleep and not actions.sleep_aff then
    svo.checkaction(svo.dict.sleep.aff, true)
    lifevision.add(actions['sleep_aff'].p, 'symptom', nil, 1)
  end

  -- svo.reset non-wait things we were doing, because they got cancelled by the sleep
  if affs.asleep or actions.asleep_aff then
    for _,v in actions:iter() do
      if v.p.balance ~= 'waitingfor' and v.p.balance ~= 'aff' then
        svo.killaction(svo.dict[v.p.action_name][v.p.balance])
      end
    end
  end
end

function svo.valid.cured_lovers()
  svo.checkaction(svo.dict.lovers.physical)
  if actions.lovers_physical then
    lifevision.add(actions.lovers_physical.p, nil, multimatches[2][2])
  end
end

function svo.valid.cured_lovers_nobody()
  svo.checkaction(svo.dict.lovers.physical)
  if actions.lovers_physical then
    lifevision.add(actions.lovers_physical.p, 'nobody')
  end
end


function svo.valid.bloodsworn_gone()
if svo.haveskillset('devotion') then
  svo.checkaction(svo.dict.bloodsworntoggle.misc)
  if actions.bloodsworntoggle_misc then
    lifevision.add(actions.bloodsworntoggle_misc.p)
  end
end
end

function svo.defs.sileris_start()
  svo.checkaction(svo.dict.sileris.misc)
  if actions.sileris_misc then
    lifevision.add(actions.sileris_misc.p)
  end
end

function svo.defs.sileris_finished()
  svo.checkaction(svo.dict.waitingforsileris.waitingfor)
  if actions.waitingforsileris_waitingfor then
    lifevision.add(actions.waitingforsileris_waitingfor.p)
  end
end

function svo.defs.sileris_slickness()
  svo.checkaction(svo.dict.sileris.misc)
  if actions.sileris_misc then
    if svo.dict.sileris.applying == 'quicksilver' and not line:find('quicksilver', 1, true) then
      svo.ignore_illusion(&quot;Ignored this illusion because we're applying quicksilver, not sileris right now (or we were forced).&quot;)
    elseif svo.dict.sileris.applying == 'sileris' and not line:find('berry', 1, true) then
      svo.ignore_illusion(&quot;Ignored this illusion because we're applying sileris, not quicksilver right now (or we were forced).&quot;)
    else
      lifevision.add(actions.sileris_misc.p, 'slick', nil, 1)
    end
  end
end

function svo.valid.sileris_flayed()
  if not conf.aillusion then
    defs.lost_sileris()
  elseif svo.paragraph_length == 1 then
    svo.checkaction(svo.dict.sileris.gone, true)
    lifevision.add(actions.sileris_gone.p, nil, getLastLineNumber('main'), 1)
  else
    svo.ignore_illusion(&quot;not first&quot;)
  end
end

function svo.valid.insomnia_relaxed()
  if not conf.aillusion then
    defs.lost_insomnia()
  else
    svo.checkaction(svo.dict.insomnia.gone, true)
    lifevision.add(actions.insomnia_gone.p, 'relaxed', getLastLineNumber('main'))
  end
end

function svo.valid.insomnia_healed()
  if not conf.aillusion then
    defs.lost_insomnia()
  elseif affs.blackout or svo.paragraph_length &gt; 1 then
    defs.lost_insomnia()
  else
    svo.ignore_illusion(&quot;The heal line doesn't seem to be on it's own as it should be.&quot;)
  end
end

function svo.defs.got_block(dir)
  svo.checkaction(svo.dict.block.physical)
  if actions.block_physical then
    lifevision.add(actions.block_physical.p, nil, dir)
  end
end

function svo.valid.smoke_stillgot_inquisition()
  svo.checkaction(svo.dict.hellsight.smoke)
  if actions.hellsight_smoke then
    lifevision.add(actions.hellsight_smoke.p, 'inquisition')
  end
end

function svo.valid.smoke_stillhave_madness()
  svo.checkaction(svo.dict.madness.smoke)
  if actions.madness_smoke then
    lifevision.add(actions.madness_smoke.p, 'hecate')
  end
end

function svo.valid.smoke_have_rebounding()
  svo.checkaction(svo.dict.rebounding.smoke)
  if actions.rebounding_smoke then
    svo.smoke_cure = true
    lifevision.add(actions.rebounding_smoke.p, 'alreadygot')
  end
end

if svo.haveskillset('chivalry') or svo.haveskillset('shindo') or svo.haveskillset('kaido') or svo.haveskillset('metamorphosis') then
  function svo.defs.got_fitness()
    svo.checkaction(svo.dict.fitness.physical)
    if actions.fitness_physical then
      lifevision.add(actions.fitness_physical.p)
    end
  end

  function svo.valid.fitness_cured_asthma()
    svo.checkaction(svo.dict.fitness.physical)
    if actions.fitness_physical then
      lifevision.add(actions.fitness_physical.p, 'curedasthma')
    end
  end

  function svo.valid.fitness_weakness()
    svo.checkaction(svo.dict.fitness.physical)
    if actions.fitness_physical then
      lifevision.add(actions.fitness_physical.p, 'weakness')
    end
  end

  function svo.valid.fitness_allgood()
    svo.checkaction(svo.dict.fitness.physical)
    if actions.fitness_physical then
      lifevision.add(actions.fitness_physical.p, 'allgood')
    end
  end

  function svo.valid.usedfitnessbalance()
    svo.checkaction(svo.dict.stolebalance.happened, true)
    lifevision.add(actions.stolebalance_happened.p, nil, 'fitness')
  end

  function svo.valid.gotfitnessbalance()
    svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'fitness' -- hack to allow multiple balances at once
    lifevision.add(actions.gotbalance_happened.p)
  end
else
  function svo.defs.got_fitness() end
  function svo.valid.fitness_cured_asthma() end
  function svo.valid.fitness_weariness() end
  function svo.valid.fitness_allgood() end
end

if svo.haveskillset('chivalry') then
function svo.valid.gotragebalance()
  svo.checkaction(svo.dict.gotbalance.happened, true)
  svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'rage' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

function svo.valid.dragonform_riding()
  if actions.riding_physical then
    lifevision.add(actions.riding_physical.p, 'dragonform')
  end
end

function svo.defs.started_dragonform()
  if actions.dragonform_physical then
    lifevision.add(actions.dragonform_physical.p)
  end
end

-- set the Elder dragon colour - but only when we are mid-dragonforming, so as not to get tricked by illusions
function svo.valid.dragonformingcolour(colour)
  if not conf.aillusion or actions.waitingfordragonform_waitingfor then
    colour = colour:lower()

    local t = {
       ['red'] = 'dragonfire',
       ['black'] = 'acid',
       ['silver'] = 'lightning',
       -- it is 'golden' and not 'gold' for this message
       ['golden'] = 'psi',
       ['blue'] = 'ice',
       ['green'] = 'venom'
    }

    conf.dragonbreath = t[colour]
    raiseEvent(&quot;svo config changed&quot;, 'dragonbreath')
  end
end

function svo.defs.got_dragonform()
  svo.checkaction(svo.dict.waitingfordragonform.waitingfor)
  if actions.waitingfordragonform_waitingfor then
    lifevision.add(actions.waitingfordragonform_waitingfor.p)
  end
end

function svo.defs.cancelled_dragonform()
  if actions.waitingfordragonform_waitingfor then
    lifevision.add(actions.waitingfordragonform_waitingfor.p, 'cancelled')
  end
end

if svo.haveskillset('groves') then
function svo.valid.started_rejuvenate()
  if actions.rejuvenate_physical then
    lifevision.add(actions.rejuvenate_physical.p)
  end
end

function svo.valid.completed_rejuvenate()
  svo.checkaction(svo.dict.waitingforrejuvenate.waitingfor)
  if actions.waitingforrejuvenate_waitingfor then
    lifevision.add(actions.waitingforrejuvenate_waitingfor.p)
  end
end

function svo.valid.cancelled_rejuvenate()
  if actions.waitingforrejuvenate_waitingfor then
    lifevision.add(actions.waitingforrejuvenate_waitingfor.p, 'cancelled')
  end
end
end

if svo.haveskillset('spirituality') then
function svo.defs.started_mace()
  if actions.mace_physical then
    lifevision.add(actions.mace_physical.p)
  end
end

function svo.defs.have_mace()
  if actions.mace_physical then
    lifevision.add(actions.mace_physical.p, 'alreadyhave')
  end
end

function svo.defs.got_mace()
  svo.checkaction(svo.dict.waitingformace.waitingfor)
  if actions.waitingformace_waitingfor then
    lifevision.add(actions.waitingformace_waitingfor.p)
  end
end

function svo.defs.cancelled_mace()
  if actions.waitingformace_waitingfor then
    lifevision.add(actions.waitingformace_waitingfor.p, 'cancelled')
  end
end

function svo.valid.sacrificed_angel()
  if not conf.aillusion or actions.sacrifice_physical then
    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()

    svo.reset.affs()
    svo.reset.general()
  else
    svo.ignore_illusion(&quot;Didn't send the 'angel sacrifice' command recently.&quot;)
  end
end
end

if svo.haveskillset('shindo') then
function svo.valid.shin_phoenix()
  if not conf.aillusion or actions.phoenix_physical then
    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()

    svo.reset.affs()
  else
    svo.ignore_illusion(&quot;Didn't send the 'shin phoenix' command recently.&quot;)
  end
end
end

if svo.haveskillset('propagation') then
function svo.defs.notonland_viridian()
  if actions.viridian_physical then
    lifevision.add(actions.viridian_physical.p, 'notonland')
  end
end
function svo.defs.viridian_inside()
  if actions.viridian_physical then
    lifevision.add(actions.viridian_physical.p, 'indoors')
  end
end
function svo.defs.viridian_cancelled()
  if actions.waitingforviridian_waitingfor then
    lifevision.add(actions.waitingforviridian_waitingfor.p, 'cancelled')
  end
end
function svo.defs.got_viridian()
  if actions.waitingforviridian_waitingfor then
    lifevision.add(actions.waitingforviridian_waitingfor.p)
  end
end
function svo.defs.started_viridian()
  if actions.viridian_physical then
    lifevision.add(actions.viridian_physical.p)
  end
end
function svo.defs.alreadyhave_viridian()
  if actions.viridian_physical then
    lifevision.add(actions.viridian_physical.p, 'alreadyhave')
  end
end
end

function svo.valid.alreadyhave_dragonbreath()
  if actions.dragonbreath_physical then
    lifevision.add(actions.dragonbreath_physical.p, 'alreadygot')
  end
end

function svo.defs.alreadyhave_dragonform()
  if actions.dragonform_physical then
    lifevision.add(actions.dragonform_physical.p, 'alreadyhave')
  end
end

function svo.defs.started_dragonbreath()
  if actions.dragonbreath_physical then
    lifevision.add(actions.dragonbreath_physical.p)
  end
end

function svo.defs.got_dragonbreath()
  svo.checkaction(svo.dict.waitingfordragonbreath.waitingfor)
  if actions.waitingfordragonbreath_waitingfor then
    lifevision.add(actions.waitingfordragonbreath_waitingfor.p)
  end
end
-- hallucinations symptoms
function svo.valid.swandive()
  local have_pflag = svo.pflags.p
  sk.onprompt_beforeaction_add('swandive', function ()
    if not have_pflag and svo.pflags.p then
      valid.simpleprone()
      valid.simplehallucinations()
    end
  end)
end

-- detect conf/dizzy, or amnesia/amnesia at worst
function sk.check_evileye()
  if svo.find_until_last_paragraph(&quot;Your curseward has been breached!&quot;, 'exact') then
    sk.tempevileye.count = sk.tempevileye.count - 1
  end

  -- fails when they give the same aff twice
  --[[local affcount = 0
  for action in lifevision.l:iter() do
    if string.ends(action, '_aff') or string.find(action, 'check') then affcount = affcount + 1 end
  end

  local diff = sk.tempevileye.count - affcount]]

  local diff = sk.tempevileye.hiddencount

  if diff == 1 then
    valid.simpleunknownmental()
    svo.echof(&quot;assuming focusable aff.&quot;)
  elseif diff == 2 then
    valid.simpleconfusion()
    valid.simpleunknownmental()
    svo.echof(&quot;assuming confusion and focusable aff.&quot;)
  end
  -- diff of 0 is OK

  sk.tempevileye = nil
  signals.before_prompt_processing:disconnect(sk.check_evileye)
end

function svo.valid.hidden_evileye()
  if line:find(&quot;stares at you, giving you the evil eye&quot;, 1, true) or isPrompt() then
    sk.tempevileye.hiddencount = (sk.tempevileye.hiddencount or 0) + 1
  end
end

function svo.valid.evileye()
  -- check next line to see if it's
  if sk.tempevileye then sk.tempevileye.count = sk.tempevileye.count + 1 return end -- don't set it if the first line already did
  sk.tempevileye = {startline = getLastLineNumber('main'), count = 1}
  signals.before_prompt_processing:connect(sk.check_evileye, 'check evileye count before prompt')
end

function sk.check_trip()
  if not svo.find_until_last_paragraph(&quot;You parry the attack with a deft manoeuvre.&quot;, 'exact') and not svo.find_until_last_paragraph(&quot;You step into the attack,&quot;, 'substring') then
    valid.simpleprone()
  end

  signals.before_prompt_processing:disconnect(sk.check_trip)
end

function svo.valid.trip_prone()
  signals.before_prompt_processing:connect(sk.check_trip, 'check if we have actually been tripped')
end

function svo.valid.spiders_all_overme()
  valid.simplefear()
  valid.simplehallucinations()
end

function svo.valid.symp_impale()
  if affs.blackout then
    valid.proper_impale()
  elseif not conf.aillusion then
    valid.simpleimpale()
  else
    sk.impale_symptom()
  end
end

function svo.valid.symp_stupidity()
  sk.stupidity_symptom()
end

function svo.valid.symp_transfixed()
  sk.transfixed_symptom()
end


function svo.valid.symp_paralysis()
  if actions.fillskullcap_physical then
    svo.killaction(svo.dict.fillskullcap.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(svo.getDefaultColor()..&quot; (paralysis confirmed)&quot;)
    end
    return
  elseif actions.fillelm_physical then
    svo.killaction(svo.dict.fillelm.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(svo.getDefaultColor()..&quot; (paralysis confirmed)&quot;)
    end
    return
  elseif actions.fillvalerian_physical then
    svo.killaction(svo.dict.fillvalerian.physical)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(svo.getDefaultColor()..&quot; (paralysis confirmed)&quot;)
    end
    return
  end

  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, 'paralysed')
    decho(svo.getDefaultColor()..&quot; (paralysis confirmed)&quot;)
  elseif not conf.aillusion then
    valid.simpleparalysis()
  elseif not affs.paralysis then
    svo.checkaction(svo.dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p)
  end

  if actions.prone_misc then
    svo.killaction(svo.dict.prone.misc)
    if not affs.paralysis then
      valid.simpleparalysis()
      decho(svo.getDefaultColor()..&quot; (paralysis confirmed)&quot;)
    end
  end

  -- in slowcuring only (for AI safety for now), count all balanceful actions for paralysis
  if sys.sync and svo.usingbal'physical' then
    valid.simpleparalysis()
  end
end

function svo.valid.symp_stun()
  if not conf.aillusion then
    valid.simplestun()
  elseif actions.checkstun_misc then
    lifevision.add(actions.checkstun_misc.p)
  else
    sk.stun_symptom()
  end

  -- svo.reset non-wait things we were doing, because they got cancelled by the stun
  if affs.stun or actions.stun_aff then
    for _,v in actions:iter() do
      if v.p.balance ~= 'waitingfor' and v.p.balance ~= 'aff' then
        svo.killaction(svo.dict[v.p.action_name][v.p.balance])
      end
    end
  end
end

function svo.valid.symp_illness_constitution()
  sk.illness_constitution_symptom()
end

function svo.valid.saidnothing()
  if actions.checkslows_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkslows_misc.p, 'onclear')
  elseif affs.aeon or affs.retardation or affs.stun then
    svo.deleteLineP()
  end
end
valid.silence_vibe = valid.saidnothing

function svo.valid.jump()
  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, 'onclear')
    svo.deleteLineP()
  end
end

function svo.valid.nobalance()
  if actions.checkparalysis_misc then
    lifevision.add(actions.checkparalysis_misc.p, 'paralysed')
    svo.deleteLineP()
  end

  if actions.checkasthma_misc then
    lifevision.add(actions.checkasthma_misc.p, 'weakbreath', nil, 1)
  end

  -- cancel standing if we can't due to no balance
  if actions.prone_misc then
    svo.killaction(svo.dict.prone.misc)
    if bals.balance then
      bals.balance = false -- unset balance, in case of blackout, where we don't see prompt
      raiseEvent(&quot;svo lost balance&quot;, 'balance')
    end
  end

  -- this might not be necessary for this case of getting hit off balance
  -- elseif actions.breath_physical and not affs.asthma and svo.affsp.asthma then
  --   svo.checkaction(svo.dict.checkasthma.misc, true)
  --   lifevision.add(actions.checkasthma_misc.p, 'weakbreath', nil, 1)
  -- end
end

function svo.valid.nothingtowield()
  if actions.checkparalysis_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkparalysis_misc.p, 'onclear')
  end
end

function svo.valid.nosymptom()
  if actions.checkwrithes_misc then
    tempLineTrigger(0,3,[[deleteLine()]])
    lifevision.add(actions.checkwrithes_misc.p, 'onclear')
  end
end

function svo.valid.nothingtoeat()
  if actions.checkanorexia_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkanorexia_misc.p, 'onclear')
  elseif actions.checkstun_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkstun_misc.p, 'onclear')
  elseif affs.anorexia or affs.stun then
    svo.deleteLineP()
  end
end

function svo.valid.lungsokay()
  if actions.checkasthma_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkasthma_misc.p, 'onclear')
  end
end

-- given a sluggish symptom, either confirms sluggish if we're checking for it already
-- or goes out and tests it
function svo.valid.webeslow()
  sk.sawsluggish = getLastLineNumber('main') -- for retardation going away auto-detection
  if sk.sluggishtimer then killTimer(sk.sluggishtimer); sk.sluggishtimer = nil end

  -- if triggered by curing, don't consider it retardation
  if sk.sawcuring() then return end

  -- if we suspect aeon, and aren't checking it yet, add the action in
  if svo.affsp.aeon and not actions.checkslows_misc then
    svo.checkaction(svo.dict.checkslows.misc, true)
  end

  -- confirm that we're sluggish if we were checking for slows
  if actions.checkslows_misc then
    lifevision.add(actions.checkslows_misc.p, 'sluggish')
    return
  end

  -- if we have aeon or retardation already, do nothing then
  if affs.aeon or affs.retardation then return end

  if affs.blackout and not affs.retardation then
    valid.simpleaeon()
  elseif not affs.retardation then
    -- confirm aeon out of the blue, treat it as retardation over aeon
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'retardation')
    -- sk.retardation_symptom()
  end
end

function svo.valid.webbily()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, 'webbily')
  end
end

function svo.valid.symp_webbed()
  if not conf.aillusion then
    valid.simplewebbed()
  else
    sk.webbed_symptom()
  end
end

function svo.valid.symp_impaled()
  if not conf.aillusion then
    valid.simpleimpale()
  else
    sk.impaled_symptom()
  end
end

function svo.valid.transfixily()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, 'transfixily')
  end

  -- special workaround for waking up not showing up in blackout: clear sleep if we saw this msg
  -- it's an issue otherwise to miss the sleep msg from a totem while in blackout and think you're still asleep
  if affs.asleep then svo.rmaff('asleep') end
end

function svo.valid.symp_roped()
  if not conf.aillusion then
    valid.simpleroped()
  else
    sk.roped_symptom()
  end
end

function svo.valid.symp_transfixed()
  if not conf.aillusion then
    valid.simpletransfixed()
  else
    sk.transfixed_symptom()
  end
end

function svo.valid.weakbreath()
  if actions.checkasthma_misc then
    lifevision.add(actions.checkasthma_misc.p, 'weakbreath', nil, 1)
  elseif actions.breath_physical and not affs.asthma then
    svo.checkaction(svo.dict.checkasthma.misc, true)
    lifevision.add(actions.checkasthma_misc.p, 'weakbreath', nil, 1)
  elseif conf.aillusion and (not actions.breath_physical and not affs.asthma) then
    svo.ignore_illusion(&quot;Ignored this illusion because we aren't trying to hold breath right now (or we were forced).&quot;)
  else
    svo.checkaction(svo.dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p)
  end
end

function svo.valid.impaly()
  if actions.checkwrithes_misc then
    lifevision.add(actions.checkwrithes_misc.p, 'impaly')
  end
end

function svo.valid.chimera_stun()
  if conf.aillusion and (not defc.deaf or not affs.deafaff or not actions.deafaff_aff) then return end

  valid.simplestun(2)
end

function svo.valid.restore()
  svo.checkaction(svo.dict.restore.physical)
  if actions.restore_physical then
    -- prevent against a well-timed restore use, which when empty, forces us to clear all afflictions
    if conf.aillusion then
      local time, lat = getStopWatchTime(actions.restore_physical.p.actionwatch), svo.getping()

      if time &lt; (lat/2) then
        svo.ignore_illusion(&quot;This looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
        return
      end
    end

    valid.passive_cure()
    lifevision.add(actions.restore_physical.p, nil, getLineNumber())

    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()
  end
end

function svo.valid.dragonheal()
  svo.checkaction(svo.dict.dragonheal.physical)
  if actions.dragonheal_physical then
    valid.passive_cure()
    lifevision.add(actions.dragonheal_physical.p, nil, getLineNumber())

    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()
  end
end

function svo.valid.nodragonheal()
  svo.checkaction(svo.dict.dragonheal.physical)
  if actions.dragonheal_physical then
    lifevision.add(actions.dragonheal_physical.p, 'nobalance')
  end
end

function svo.valid.knighthood_disembowel()
  local result = svo.checkany(svo.dict.curingimpale.waitingfor)

  -- we won't get curing* if we didn't even start to writhe, so fake it for these purposes
  if not result and affs.impale then
    svo.checkaction(svo.dict.curingimpale.waitingfor, true)
    result = { name = 'curingimpale_waitingfor' }
  end

  if result and actions[result.name] then
    lifevision.add(actions[result.name].p, 'withdrew')
  end
end

valid.impale_withdrew = valid.knighthood_disembowel

function svo.valid.fell_sleep()
  svo.checkaction(svo.dict.sleep.aff, true)
  svo.checkaction(svo.dict.prone.aff, true)

  lifevision.add(actions.sleep_aff.p)
  lifevision.add(actions.prone_aff.p)
end

function svo.valid.proper_sleep()
  if defc.insomnia then
    defs.lost_insomnia()
  else
    svo.checkaction(svo.dict.sleep.aff, true)
    svo.checkaction(svo.dict.prone.aff, true)

    lifevision.add(actions.sleep_aff.p)
    lifevision.add(actions.prone_aff.p)
  end
end

function svo.valid.disruptingshiver()
  if conf.aillusion and bals.equilibrium then
    sk.onprompt_beforeaction_add('disruptingshiver', function ()
      if not bals.equilibrium  then
        svo.checkaction(svo.dict.shivering.aff, true)
        svo.checkaction(svo.dict.disrupt.aff, true)
        lifevision.add(actions.shivering_aff.p)
        lifevision.add(actions.disrupt_aff.p)
        defs.lost_caloric()
      end
    end)
  else
    svo.checkaction(svo.dict.shivering.aff, true)
    svo.checkaction(svo.dict.disrupt.aff, true)
    lifevision.add(actions.shivering_aff.p)
    lifevision.add(actions.disrupt_aff.p)
    defs.lost_caloric()
  end
end

function svo.valid.check_dragonform()
  -- show xp? ignore!
  if svo.lastpromptnumber+1 == getLastLineNumber('main') or not svo.find_until_last_paragraph(me.name, 'substring') then return end

  if defc.dragonform and not svo.find_until_last_paragraph(&quot;Dragon)&quot;, 'substring') then
    echo&quot;\n&quot; svo.echof(&quot;Apparently we aren't in Dragon.&quot;)
    svo.defs.lost_dragonform()
    svo.defs.lost_dragonarmour()
    svo.defs.lost_dragonbreath()
  elseif not defc.dragonform and svo.find_until_last_paragraph(&quot;Dragon)&quot;, 'substring') then
    echo&quot;\n&quot; svo.echof(&quot;Apparently we're in Dragon.&quot;)
    svo.defs.got_dragonform()
  end
end

svo.defs.got_dragonform = svo.dict.waitingfordragonform.waitingfor.oncompleted

function svo.valid.proper_impale()
  if not conf.aillusion then
    valid.simpleimpale()
  else
    svo.checkaction(svo.dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, 'impale', stats.currenthealth)
  end
end

function svo.valid.swachbuckling_pesante()
  if (not svo.find_until_last_paragraph(&quot;The attack rebounds back onto&quot;, 'substring')) and (svo.find_until_last_paragraph('jabs', 'substring')) and (svo.find_until_last_paragraph('you', 'substring')) then
    if (not conf.aillusion) or (defc.deaf or affs.deafaff) then
      valid.simplestun(.5)
    end
  end
end

--[[
  Martellato can get tricked by the following, avoid it:

  Lightning-quick, Bob jabs you with a Soulpiercer.
  A prickly, stinging sensation spreads through your body.
  The songblessing upon the rapier sings out with a piercing high note.
  Mary viciously jabs an elegant Mhaldorian rapier into Bob.
  The songblessing upon the rapier swells with a rich, vibrant hum.

]]
function svo.valid.swachbuckling_martellato()
  if not svo.find_until_last_paragraph(&quot;The attack rebounds back onto&quot;, 'substring') and
     svo.find_until_last_paragraph('jabs', 'substring') and
     svo.find_until_last_paragraph('you', 'substring') and
     not svo.find_until_last_paragraph(&quot;^%w+ viciously jabs&quot;, 'pattern') then
    valid.simpleprone()
  end
end

local last_jabber = &quot;&quot;
function svo.valid.swashbuckling_jab(name)
  if sk.swashbuckling_jab then killTimer(sk.swashbuckling_jab) end
  sk.swashbuckling_jab = tempTimer(.5, function() sk.swashbuckling_jab = nil end)
  last_jabber = name
end

function svo.valid.voicecraft_tremolo(name, side)
  local known_class = (ndb and ndb.getclass(name))
  if not conf.aillusion or ((affs['crippled'..side..'leg'] or sk['delayvenom_'..side..'leg'] or sk['delayacciaccatura_'..side..'leg']) and ((sk.swashbuckling_jab and last_jabber == name) or known_class == 'bard')) then

    -- when we've accepted that the Tremolo is legitimate, record the side - to be checked later in the mangle trigger for verification
    sk.tremoloside = sk.tremoloside or {}
    sk.tremoloside[side] = true
    svo.prompttrigger(&quot;clear tremolo&quot;, function()
      -- the svo.prompttrigger happens after the mangle should have been processed:
      -- so if we still have tremoloside setup, it means no mangle happened as the
      -- mangle would have cleared it. Hence, make the venom timer go off at the
      -- earlist possible time.
      if sk.tremoloside and sk.tremoloside[side] and sk['delayvenom_'..side..'leg'] then
        killTimer(sk['delayvenom_'..side..'leg'])
        sk['delayvenom_'..side..'leg'] = nil
        -- we can't use valid here, but we can use addaff
        svo.addaffdict(svo.dict['crippled'..side..'leg'])

        signals.after_lifevision_processing:unblock(cnrl.checkwarning)
        signals.canoutr:emit()
      end

      sk.tremoloside = nil
    end)
  end
end

function svo.valid.voicecraft_vibrato(name, side)
  local known_class = (ndb and ndb.getclass(name))
  if not conf.aillusion or ((affs['crippled'..side..'arm'] or sk['delayvenom_'..side..'arm'] or sk['delayacciaccatura_'..side..'arm']) and ((sk.swashbuckling_jab and last_jabber == name) or known_class == 'bard')) then
    valid['simplemangled'..side..'arm']()
  end
end

-- for a Bard tremolo/vibrato hit, avoid curing the crippled limb right away
-- because that will use up our salve balance and delay the mangled break, which
-- follows soon after. Hence this, upon detecting a jab form a Bard with
-- epteth/epseth, delays adding the crippled affliction until after the tremolo
-- or vibrato
function svo.valid.swashbuckling_poison()
  if not conf.aillusion or (svo.paragraph_length == 2 and not conf.batch) then
    for _, limb in ipairs{'rightleg', 'rightarm', 'leftarm', 'leftleg'} do
      if actions['crippled'..limb..'_aff'] then
        svo.killaction(svo.dict['crippled'..limb].aff)

        sk['delayvenom_'..limb] = tempTimer(.25, function()
          if not affs['mangled'..limb] then
            svo.addaffdict(svo.dict['crippled'..limb])

            signals.after_lifevision_processing:unblock(cnrl.checkwarning)
            signals.canoutr:emit()
            svo.make_gnomes_work()
          end

          sk['delayvenom_'..limb] = nil
        end)
        break
      end
    end
  end
end

function svo.valid.swashbuckling_acciaccatura(side, limb)
  local aff = side..limb

  sk['delayacciaccatura_'..aff] = tempTimer(.25, function()
    if not affs['mangled'..aff] then
      svo.addaffdict(svo.dict['crippled'..aff])

      signals.after_lifevision_processing:unblock(cnrl.checkwarning)
      signals.canoutr:emit()
      svo.make_gnomes_work()
    end

    sk['delayacciaccatura_'..aff] = nil
  end)
end

-- handle cancelling of delayvenom in case of this being a DSL:
-- apply the cripples right away, so the cure of a potential mangled limb in the
-- dsl, the venoms and the limb break get computed for cure at once on the prompt
signals.limbhit:connect(function(attacktype)
  if attacktype ~= 'weapon' then return end

  sk.weapon_hits = (sk.weapon_hits or 0) + 1
  sk.onprompt_beforeaction_add(&quot;track a dsl&quot;, function()
    -- if we got a DSL, apply the delayvenoms right now
    if sk.weapon_hits == 2 then
      for _, aff in ipairs{'rightleg', 'rightarm', 'leftarm', 'leftleg'} do
        if sk['delayvenom_'..aff] then
          if not affs['mangled'..aff] then
            svo.addaffdict(svo.dict['crippled'..aff])
            signals.after_lifevision_processing:unblock(cnrl.checkwarning)
            signals.canoutr:emit()
          end

          killTimer(sk['delayvenom_'..aff])
          sk['delayvenom_'..aff] = nil
        end
      end
    end

    sk.weapon_hits = nil
  end)
end, 'handle mangle/venom combo')

function svo.valid.bloodleech()
  sk.bloodleech_hit = true
  sk.onprompt_beforeaction_add(&quot;unset bloodleech&quot;, function()
    sk.bloodleech_hit = nil
  end)
end

function svo.valid.defstrip(which)
  svo.assert(which, &quot;svo.valid.defstrip: which defence was stripped?&quot;)

  local t = {
    [&quot;anti-weapon field&quot;]      = 'rebounding',
    [&quot;caloric salve&quot;]          = 'caloric',
    [&quot;cold resistance&quot;]        = 'coldresist',
    ['density']                = 'mass',
    [&quot;electricity resistance&quot;] = 'electricresist',
    [&quot;fire resistance&quot;]        = 'fireresist',
    ['gripping']               = 'grip',
    [&quot;held breath&quot;]            = 'breath',
    ['insulation']             = 'caloric',
    ['levitating']             = 'levitation',
    [&quot;magic resistance&quot;]       = 'magicresist',
    ['scholasticism']          = 'myrrh',
    [&quot;soft focus&quot;]             = 'softfocus',
    [&quot;soft focusing&quot;]          = 'softfocus',
    [&quot;speed defence&quot;]          = 'speed', -- typo in game was showing 'speed defence defence'
    ['temperance']             = 'frost',
    [&quot;third eye&quot;]              = 'thirdeye'
  }

  if svo.haveskillset('apostasy') then
    t[&quot;demon armour&quot;]           = 'demonarmour'
  end
  if svo.haveskillset('necromancy') then
    t[&quot;death aura&quot;]             = 'deathaura'
  end
  if svo.haveskillset('healing') then
    t[&quot;earth spiritshield&quot;]     = 'earthblessing'
    t[&quot;endurance spiritshield&quot;] = 'enduranceblessing'
    t[&quot;frost spiritshield&quot;]     = 'frostblessing'
    t[&quot;thermal spiritshield&quot;]   = 'thermalblessing'
    t[&quot;willpower spiritshield&quot;] = 'willpowerblessing'
  end
  if svo.haveskillset('pranks') or svo.haveskillset('swashbuckling') then
    t[&quot;arrow catching&quot;]         = 'arrowcatch'
  end
  if svo.haveskillset('metamorphosis') then
    t[&quot;spirit bonding&quot;]         = 'bonding'
  end
  if svo.haveskillset('groves') then
    t[&quot;wild growth&quot;]            = 'wildgrowth'
  end

  if t[which] then which = t[which] end

  if defs['lost_'..which] then
    defs['lost_'..which]()
  end
end

function svo.valid.truename()
  if not conf.aillusion then
    valid.simpleaeon()
    defs.lost_lyre()
  elseif (svo.paragraph_length == 1 or (svo.find_until_last_paragraph(&quot;is unable to resist the force of your faith&quot;, 'substring') or svo.find_until_last_paragraph(&quot;aura of weapons rebounding disappears&quot;, 'substring'))) then
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, 'truename')
    defs.lost_lyre()
  else
    svo.ignore_illusion(&quot;not first&quot;)
  end
end

function svo.valid.just_aeon()
  svo.checkaction(svo.dict.checkslows.aff, true)
  lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
end

function svo.valid.proper_aeon()
  if defc.speed then
    defs.lost_speed()
  elseif not conf.aillusion then
    valid.simpleaeon()
  else
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
  end
end
valid.bashing_aeon = valid.proper_aeon

function svo.valid.proper_retardation()
  if conf.aillusion then
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'retardation')
  else
    valid.simpleretardation()
  end
end

function svo.valid.proper_stun(num)
  if not conf.aillusion then
    valid.simplestun(num)
  else
    svo.checkaction(svo.dict.checkstun.aff, true)
    lifevision.add(actions.checkstun_aff.p, nil, num)
  end
end

function svo.valid.proper_paralysis()
  -- if not conf.aillusion or (not (bals.balance and bals.equilibrium and bals.leftarm and bals.rightarm) or ignore.checkparalysis) then
  if not conf.aillusion or svo.ignore.checkparalysis then
    valid.simpleparalysis()
  elseif not affs.paralysis then
    svo.checkaction(svo.dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p)
  end

  if conf.paused and conf.hinderpausecolour then
    selectCurrentLine()
    fg(conf.hinderpausecolour)
    resetFormat()
    deselect()
  end
end

function svo.valid.proper_hypersomnia()
  if not conf.aillusion or svo.ignore.checkhypersomnia then
    valid.simplehypersomnia()
  elseif not affs.hypersomnia then
    svo.checkaction(svo.dict.checkhypersomnia.aff, true)
    lifevision.add(actions.checkhypersomnia_aff.p)
  end
end

function svo.valid.proper_asthma()
  if not conf.aillusion or svo.ignore.checkasthma then
    valid.simpleasthma()
    svo.affsp.asthma = nil
  elseif not affs.asthma then
    svo.checkaction(svo.dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p, nil, stats.currenthealth)
  end
end

function svo.valid.proper_asthma_smoking()
  if conf.aillusion and svo.paragraph_length &lt;= 1 and not conf.batch then return end

  if not conf.aillusion or svo.ignore.checkasthma then
    valid.simpleasthma()
    svo.affsp.asthma = nil
  else
    svo.checkaction(svo.dict.checkasthma.aff, true)
    lifevision.add(actions.checkasthma_aff.p, nil, stats.currenthealth)
  end
end

function svo.valid.darkshade_paralysis()
  if not conf.aillusion then
    valid.simpleparalysis()
    valid.simpledarkshade()
  else
    svo.checkaction(svo.dict.checkparalysis.aff, true)
    lifevision.add(actions.checkparalysis_aff.p, nil, 'darkshade')
  end
end

function svo.valid.darkshade_sun()
  svo.checkaction(svo.dict.darkshade.aff, true)
  if actions.darkshade_aff then
    lifevision.add(actions.darkshade_aff.p, nil, stats.currenthealth)
  end
end

function svo.valid.maybe_impatience()
  svo.checkaction(svo.dict.checkimpatience.aff, true)
  lifevision.add(actions.checkimpatience_aff.p, nil, 'quiet')
end

function svo.valid.proper_impatience()
  if not conf.aillusion or svo.ignore.checkimpatience then
    valid.simpleimpatience()
  else
     -- limerick because songbirds will make lg 2
     -- maggots isn't a full line, because on sw80 it will wrap
    local previousline = (svo.find_until_last_paragraph(&quot;glares at you and your brain suddenly feels slower&quot;, 'substring') or svo.find_until_last_paragraph(&quot;evil eye&quot;, 'substring') or svo.find_until_last_paragraph('wracks', 'substring') or svo.find_until_last_paragraph(&quot;You recoil in horror as countless maggots squirm over your flesh&quot;, 'substring') or line:find(&quot;jaunty limerick&quot;, 1, true) or svo.find_until_last_paragraph(&quot;points an imperious finger at you&quot;, 'substring') or svo.find_until_last_paragraph(&quot;glowers at you with a look of repressed disgust before making a slight gesture toward you.&quot;, 'substring') or svo.find_until_last_paragraph(&quot;hand at you, a wash of cold causing your blood to evolve into something new.&quot;, 'substring') or svo.find_until_last_paragraph(&quot;Horror overcomes you as you realise that the curse of impatience&quot;, 'substring') or svo.find_until_last_paragraph(&quot;palm towards your face.&quot;, 'substring')) and true or false
    if svo.paragraph_length == 1 or previousline then
      svo.checkaction(svo.dict.checkimpatience.aff, true)
      if previousline then
        lifevision.add(actions.checkimpatience_aff.p)
      else
        lifevision.add(actions.checkimpatience_aff.p, nil, nil, 1)
      end
    else
      svo.ignore_illusion(&quot;not first&quot;)
    end
  end
end

function svo.valid.curse_dispel()
  if defc.ghost then defs.lost_ghost() return end
  if defc.shroud then defs.lost_shroud() return end
end

function svo.valid.subterfuge_hallucinations()
  if getLineNumber('main') ~= svo.lastpromptnumber+2 then return end
  valid.simplehallucinations()
end

function svo.valid.subterfuge_confusion()
  if getLineNumber('main') ~= svo.lastpromptnumber+2 then return end
  valid.simpleconfusion()
end

function svo.valid.subterfuge_bite()
  -- should use affs.from field to track what did you get the venom from, then if it's confirmed, strip sileris
end

function svo.valid.subterfuge_camus()
  svo.checkaction(svo.dict.sileris.gone, true)
  lifevision.add(actions.sileris_gone.p, 'camusbite', stats.currenthealth)
end

function svo.valid.subterfuge_sumac()
  svo.checkaction(svo.dict.sileris.gone, true)
  lifevision.add(actions.sileris_gone.p, 'sumacbite', stats.currenthealth)
end

function svo.valid.proper_relapsing()
  if not conf.aillusion then
    valid.simplerelapsing()
  else
    svo.checkaction(svo.dict.relapsing.aff, true)
    lifevision.add(actions.relapsing_aff.p)
  end
end

function svo.valid.relapsing_camus()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'camus', stats.currenthealth)
end

function svo.valid.relapsing_sumac()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'sumac', stats.currenthealth)
end

function svo.valid.relapsing_vitality()
  svo.dict.relapsing.aff.hitvitality = true
end

function svo.valid.relapsing_oleander()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'oleander', (defc.blind or affs.blindaff))
end

function svo.valid.relapsing_colocasia()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'colocasia', (defc.blind or affs.blindaff or defc.deaf or affs.deafaff))
end

function svo.valid.relapsing_oculus()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'oculus', (defc.blind or affs.blindaff or defc.deaf or affs.deafaff))
end

function svo.valid.relapsing_oculus()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'oculus', (defc.blind or affs.blindaff))
end

function svo.valid.relapsing_prefarar()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'prefarar', (defc.deaf or affs.deafaff))
end

function svo.valid.relapsing_asthma()
  svo.checkaction(svo.dict.relapsing.aff, true)
  lifevision.add(actions.relapsing_aff.p, 'asthma')
end

function svo.valid.subterfuge_bind()
  if not conf.aillusion or affs.sleep then
    valid.simplebound()
  end
end

function svo.valid.kaido_choke()
  if conf.breath and conf.keepup and not defkeepup[defs.mode].breath then
    defs.keepup('breath', true)
    echo(&quot;\n&quot;)
    if math.random(1, 10) == 1 then
      svo.echof(&quot;Run away! Run away! ('br' to turn off breath)&quot;)
    elseif math.random(1, 10) == 1 then
      svo.echof(&quot;We'll get through this. *determined* ('br' to turn off breath)&quot;)
    else
      svo.echof(&quot;Eep... holding our breath ('br' to turn off).&quot;)
    end
  end
end
valid.noose_trap = valid.kaido_choke
valid.vodun_throttle = valid.kaido

function svo.valid.proper_sensitivity()
  svo.checkaction(svo.dict.sensitivity.aff, true)
  lifevision.add(actions.sensitivity_aff.p, 'checkdeaf')
end

function svo.valid.webbed_buckawns()
  if conf.buckawns then return
  else
    if not conf.aillusion then
      valid.simplewebbed()
    else
      svo.checkaction(svo.dict.checkwrithes.aff, true)
      lifevision.add(actions.checkwrithes_aff.p, nil, 'webbed', 1)
    end
  end
end

function svo.valid.proper_webbed()
  if not conf.aillusion then
    valid.simplewebbed()
  else
    svo.checkaction(svo.dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, nil, 'webbed')
  end
end

function svo.valid.proper_chill()
  local aff

  if defc.caloric then defs.lost_caloric() return end

  if not affs.shivering then aff = 'shivering' else aff = 'frozen' end

  svo.checkaction(svo.dict[aff].aff, true)
  if actions[aff .. '_aff'] then
    lifevision.add(actions[aff .. '_aff'].p)
  end
end

function svo.valid.magi_deepfreeze()
  if defc.caloric then
    defs.lost_caloric()
    valid.simpleshivering()
  else
    valid.simpleshivering()
    valid.simplefrozen()
  end
end

-- logic is done inside receivers
function svo.valid.proper_transfix()
  if not conf.aillusion or svo.paragraph_length &gt; 2 then
    valid.simpletransfixed()
  else
    svo.checkaction(svo.dict.checkwrithes.aff, true)
    lifevision.add(actions.checkwrithes_aff.p, nil, 'transfixed')
  end
end

valid.proper_transfixed = valid.proper_transfix

function svo.valid.failed_transfix()
  defs.lost_blind()

  if actions.transfixed_aff then
    svo.killaction(svo.dict.transfixed.aff)
  end
  if actions.checkwrithes_aff and lifevision.l.checkwrithes_aff and lifevision.l.checkwrithes_aff.arg == 'transfixed' then
    svo.killaction(svo.dict.checkwrithes.aff)
  end
end

function svo.valid.parry_limb(limb)
  if not svo.sp_limbs[limb] then return end

  if svo.find_until_last_paragraph(&quot;You feel your will manipulated by the soulmaster entity.&quot;, 'exact') or svo.find_until_last_paragraph(&quot;You cannot help but obey.&quot;, 'exact') then
    svo.checkaction(svo.dict.doparry.physical, true)
  else
    svo.checkaction(svo.dict.doparry.physical)
  end

  if actions.doparry_physical then
    lifevision.add(actions.doparry_physical.p, nil, limb)
  end
end

function svo.valid.parry_none()
  svo.checkaction(svo.dict.doparry.physical)
  if actions.doparry_physical then
    lifevision.add(actions.doparry_physical.p, 'none')
  end
end

function svo.valid.cant_parry()
  valid.parry_none()

  if not conf.aillusion then
    sk.cant_parry()
  else
    sk.unparryable_symptom()
  end
end

function svo.valid.bad_legs()
  if affs.crippledrightleg or affs.crippledleftleg or affs.mangledleftleg or affs.mangledrightleg or affs.mutilatedrightleg or affs.mutilatedleftleg then return end

  valid.simpleunknownany()
end


do
  local afflist = {'hamstring', 'galed', 'voided', 'inquisition', 'burning', 'icing', 'phlogistication', 'vitrification', 'corrupted', 'mucous', 'rixil', 'palpatar', 'cadmus', 'hecate', 'ninkharsag', 'swellskin', 'pinshot', 'dehydrated', 'timeflux', 'lullaby', 'numbedleftarm', 'numbedrightarm', 'unconsciousness', 'degenerate', 'deteriorate', 'hatred'}
  if svo.haveskillset('metamorphosis') then
    afflist[#afflist+1] = 'cantmorph'
  end

  for _, aff in ipairs(afflist) do
    valid[aff..'_woreoff'] = function()
      svo.checkaction(svo.dict[aff].waitingfor, true)
      if actions[aff..'_waitingfor'] then
        lifevision.add(actions[aff..'_waitingfor'].p)
      end
    end
  end
end

function svo.valid.stun_woreoff()
  -- not only stun, but checkstun maybe was waiting, didn't get to check -&gt; needs to restore lifevision
  svo.checkaction(svo.dict.stun.waitingfor)
  if actions.stun_waitingfor then
    lifevision.add(actions.stun_waitingfor.p)
  elseif actions.checkstun_misc then
    lifevision.add(actions.checkstun_misc.p, nil, 'fromstun')
  end
end

for _, aff in ipairs({'heartseed', 'hypothermia'}) do
valid[aff..'_cured'] = function()
  svo.checkaction(svo.dict['curing'..aff].waitingfor)
  if actions['curing'..aff..'_waitingfor'] then
    lifevision.add(actions['curing'..aff..'_waitingfor'].p)
  end
end
end

function svo.valid.aeon_woreoff()
  local result = svo.checkany(svo.dict.aeon.smoke)

  if not result then
    if conf.aillusion and not svo.passive_cure_paragraph and not svo.find_until_last_paragraph(&quot;You touch the tree of life tattoo.&quot;, 'exact') then
      svo.checkaction(svo.dict.aeon.gone, true)
      lifevision.add(actions.aeon_gone.p, nil, nil, 1)
    else
      -- clear the lineguard if we previously set it via aeon_gone
      if table.contains(lifevision.l:keys(), 'aeon_gone') and lifevision.getlineguard() then
        lifevision.clearlineguard()
      end
      svo.checkaction(svo.dict.aeon.gone, true)
      lifevision.add(actions.aeon_gone.p)
    end
  else
    -- if it was a smoke cure, can't lineguard 1 then, it'll be 2
    svo.smoke_cure = true
    lifevision.add(actions[result.name].p)
  end
end

function svo.valid.destroy_retardation()
  svo.checkaction(svo.dict.retardation.gone, true)
  lifevision.add(actions.retardation_gone.p)

  valid.simpleaeon()
end

function svo.valid.ablaze_woreoff()
  svo.checkaction(svo.dict.ablaze.gone, true)
  lifevision.add(actions.ablaze_gone.p)
end

function svo.valid.wake_start()
  svo.checkaction(svo.dict.sleep.misc)
  if actions.sleep_misc then
    lifevision.add(actions.sleep_misc.p)
  end
end

function svo.valid.wake_done()
  svo.checkaction(svo.dict.curingsleep.waitingfor, true)
  lifevision.add(actions.curingsleep_waitingfor.p)
end

function svo.valid.symp_dizziness_fell()
  -- if not conf.aillusion then
    valid.simpledizziness()
    valid.simpleprone()
  -- elseif affs.dizziness then
  --   valid.simpleprone()
  -- end
end

function svo.valid.cured_fear()
  svo.checkaction(svo.dict.fear.misc)
  if actions.fear_misc then
    lifevision.add(actions.fear_misc.p)
  end
end

function svo.valid.tootired_focus()
  local r = svo.findbybal('focus')
  if not r then return end

  svo.focus_cure = true

  -- in case of double-applies, don't overwrite the first successful application
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'offbalance')
  end
end

function svo.valid.mickey()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;not first&quot;) return end

  local r = svo.findbybal('herb')
  if not r then return end

  lifevision.add(actions[r.name].p, 'mickey')
end

function svo.valid.focus_choleric()
  local r = svo.findbybal('focus')
  if not r then svo.ignore_illusion(&quot;Ignored the illusion because we aren't actually focusing right now (or we were forced).&quot;) return end

  svo.checkaction(svo.dict.stolebalance.happened, true)
  lifevision.add(actions.stolebalance_happened.p, nil, 'focus')

  svo.focus_cure = true
  svo.killaction(svo.dict[r.action_name].focus)
end

function svo.valid.nomana_focus()
  local r = svo.findbybal('focus')
  if not r then return end

  lifevision.add(actions[r.name].p, 'nomana')
end

function svo.valid.nomana_clot()
  svo.checkaction(svo.dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p, 'nomana')
  end
end

function svo.valid.stoodup()
  svo.checkaction(svo.dict.prone.misc)
  if actions.prone_misc then
    lifevision.add(actions.prone_misc.p)
  end
end

function svo.valid.sippedhealth()
  svo.checkaction(svo.dict.healhealth.sip)
  if actions.healhealth_sip then
    svo.sip_cure = true
    lifevision.add(actions.healhealth_sip.p)
  end
end
function svo.valid.sippedmana()
  svo.checkaction(svo.dict.healmana.sip)
  if actions.healmana_sip then
    svo.sip_cure = true
    lifevision.add(actions.healmana_sip.p)
  end
end

function svo.valid.gotherb()
  if not conf.aillusion or not sk.blockherbbal then
    svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'herb' -- hack to allow multiple balances at once
    lifevision.add(actions.gotbalance_happened.p)
    selectCurrentLine()
    setFgColor(0, 170, 0)
    deselect()
  else
    svo.ignore_illusion(&quot;Couldnt've possibly recovered herb balance so soon - &quot;..(svo.watch.herb_block and getStopWatchTime(svo.watch.herb_block) or '?')..&quot;s after eating.&quot;)
  end
end

for _, balance in ipairs{'moss', 'focus', 'sip', 'purgative', 'dragonheal', 'smoke', 'tree'} do
valid['got'..balance] = function()
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = balance -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

function svo.valid.gotsalve()
  if conf.aillusion and svo.paragraph_length ~= 1 then
    local lastline = getLines(getLineNumber()-1, getLineNumber())[1]

    local lines = {
      [&quot;Your left leg feels stronger and healthier.&quot;] = {affs = {'curingmutilatedrightleg', 'curingmutilatedleftleg', 'curingmangledrightleg', 'curingmangledleftleg', 'curingparestolegs'}, location = 'legs'},
      [&quot;Your right leg feels stronger and healthier.&quot;] = {affs = {'curingmutilatedrightleg', 'curingmutilatedleftleg', 'curingmangledrightleg', 'curingmangledleftleg', 'curingparestolegs'}, location = 'legs'},
      [&quot;Your left arm feels stronger and healthier.&quot;] = {affs = {'curingmutilatedrightarm', 'curingmutilatedleftarm', 'curingmangledrightarm', 'curingmangledleftarm', 'curingparestoarms'}, location = 'arms'},
      [&quot;Your right arm feels stronger and healthier.&quot;] = {affs = {'curingmutilatedrightarm', 'curingmutilatedleftarm', 'curingmangledrightarm', 'curingmangledleftarm', 'curingparestoarms'}, location = 'arms'},
    }

    if lines[lastline] then
      local had
      for _, aff in ipairs(lines[lastline].affs) do
        if actions[aff..'_waitingfor'] then
          local afftime = getStopWatchTime(actions[aff..'_waitingfor'].p.actionwatch)
          if afftime &gt;= conf.ai_minrestorecure then
            had = true; break
          else
            svo.ignore_illusion(string.format(&quot;%s cure couldnt've possibly finished so soon, in %ss - minimum allowed is %ss. This seems like an illusion to trick you.&quot;, aff, afftime, conf.ai_minrestorecure))
            return
          end
        end
      end

      if not had then
        svo.ignore_illusion(&quot;We aren't applying restoration to &quot;..lines[lastline].location..&quot; right now&quot;)
      end
    end
  end
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'salve' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function svo.valid.gotpurgative()
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'purgative' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function svo.valid.forcesalve()
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'salve' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function svo.valid.forcefocus()
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'focus' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function svo.valid.forceherb()
  svo.checkaction(svo.dict.gotbalance.happened, true)
    svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'herb' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end

function svo.valid.got_rebounding()
  svo.checkaction(svo.dict.waitingonrebounding.waitingfor)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p)
  end
end

function svo.valid.rebounding_deathtarot()
  svo.checkaction(svo.dict.waitingonrebounding.waitingfor, false)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p, 'deathtarot')
  end
end

-- palpatar line will be before this if you've had it
function svo.defs.got_speed()
  svo.checkaction(svo.dict.curingspeed.waitingfor)
  if actions.curingspeed_waitingfor then
    lifevision.add(actions.curingspeed_waitingfor.p)
  end
end

function svo.valid.bled()
  -- we don't actually care about the bleeding here, but we want the reckless crosscheck
  if affs.unknownany and stats.hp == 100 and stats.mana == 100 then
    valid.simplerecklessness()
  end
end

function svo.valid.clot1()
  svo.checkaction(svo.dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p)
  end

  if conf.gagclot and not sys.sync then svo.deleteLineP() end
end

function svo.valid.clot2()
  svo.checkaction(svo.dict.bleeding.misc)
  if actions.bleeding_misc then
    lifevision.add(actions.bleeding_misc.p, 'oncured')
  end

  if conf.gagclot and not sys.sync then svo.deleteLineP() end
end

function svo.valid.symp_haemophilia()
  if not conf.aillusion and actions.bleeding_misc then
    valid.remove_unknownany('haemophilia')
    valid.simplehaemophilia()
  else
    svo.checkaction(svo.dict.bleeding.misc, false)
    if actions.bleeding_misc then
      valid.remove_unknownany('haemophilia')
      lifevision.add(actions.bleeding_misc.p, 'haemophilia', nil, 1)
    elseif not affs.haemophilia then
      svo.ignore_illusion(&quot;Ignored this illusion because we aren't trying to clot right now (or we were forced).&quot;)
    end
  end
end

function svo.valid.proper_haemophilia()
  if not conf.aillusion then
    valid.simplehaemophilia()
  elseif svo.find_until_last_paragraph('wracks', 'substring') and svo.paragraph_length &gt;= 3 then
    valid.simplehaemophilia()
  elseif svo.find_until_last_paragraph(&quot;glowers at you with a look of repressed disgust&quot;, 'substring') or svo.find_until_last_paragraph(&quot;stares menacingly at you, its eyes flashing brightly.&quot;, 'substring') then
    valid.simplehaemophilia()
  elseif svo.find_until_last_paragraph(&quot;points an imperious finger at you.&quot;, 'substring') then
    -- shamanism
    valid.simplehaemophilia()
  elseif svo.find_until_last_paragraph(&quot;makes a quick, sharp gesture toward you.&quot;, 'substring') then
    -- occultism instill
    valid.simplehaemophilia()
  elseif line:starts(&quot;A bloodleech leaps at you, clamping with teeth onto exposed flesh and secreting some foul toxin into your bloodstream. You stumble as you are afflicted&quot;) then
    -- domination bloodleech
    valid.simplehaemophilia()
  else
    svo.ignore_illusion(&quot;Doesn't seem to be an Alchemist wrack or Occultism instill - going to see if it's real off symptoms.&quot;)
  end
end

function svo.valid.humour_wrack()
  svo.checkaction(svo.dict.unknownany.aff, true)
  lifevision.add(actions['unknownany_aff'].p, 'wrack', nil)

  -- to check if we got reckless!
  if stats.currenthealth ~= stats.maxhealth then
    svo.dict.unknownany.reckhp = true end
  if stats.currentmana ~= stats.maxmana then
    svo.dict.unknownany.reckmana = true end
end

-- detect how many wracks (of the 2 available in a truewrack) were hidden (that is - humour-based wrack, which is hidden)
-- vs affliction-based wrack, which is visible
function svo.valid.humour_truewrack()
  local sawaffs = 0
  for _, action in pairs(lifevision.l:keys()) do
    if action:find('_aff', 1, true) then
      sawaffs = sawaffs + 1
    end
  end

  -- limit to 2 in case we saw more - we don't want to add more than 2 unknowns
  if sawaffs &gt; 2 then sawaffs = 2 end

  -- add the appropriate amount of missing unknowns, up to 2. If we saw an affliction, don't add an unknown for it.
  for _ = 1, 2-sawaffs do
    valid.simpleunknownany()
  end
end

function svo.valid.got_humour(which)
  svo.assert(svo.dict[which..'humour'], &quot;svo.valid.got_humour: which humour to add?&quot;)

  local function countaffs(humour)
    local affs_in_a_humour = 3

    local t = {
      choleric    = {'illness', 'sensitivity', 'slickness'},
      melancholic = {'anorexia', 'impatience', 'stupidity'},
      phlegmatic  = {'asthma', 'clumsiness', 'disloyalty'},
      sanguine    = {'haemophilia', 'recklessness',  'paralysis'}
    }

    -- add the amount of focusables in a humour as the 4th argument, to check for as well
    for humour, data in pairs(t) do
      local focusables_in_humour = 0
      for i = 1, affs_in_a_humour do
        if svo.dict[data[i]].focus then focusables_in_humour = focusables_in_humour + 1 end
      end
      data[affs_in_a_humour+1] = focusables_in_humour
    end

    -- update temper count according to known humour-related affs we've got
    local count = 0
    for i = 1, affs_in_a_humour do
      if affs[t[humour][i]] then count = count + 1 end
    end

    -- update temper count according to unknown focusable affs we've got, limited by the max
    -- amount of focusable affs we can have
    if affs.unknownmental then
      local max_focusable_affs_in_humour = t[humour][affs_in_a_humour+1]
      count = count + (svo.dict.unknownmental.count &gt; max_focusable_affs_in_humour and max_focusable_affs_in_humour or svo.dict.unknownmental.count)
    end

    -- and lastly, unknown affs
    if affs.unknownany then
      count = count + svo.dict.unknownany.count
    end

    return count
  end

  -- humours give up to 3 levels in one go, depending on which relevant afflictions have you got. account for unknown afflictions as well!
  -- 1 for the temper, + any more affs
  local humourlevels = 1 + countaffs(which)
  -- trim the max we counted down to 3, which is the most possible right now
  if humourlevels &gt; 3 then humourlevels = 3 end

  svo.checkaction(svo.dict[which..'humour'].aff, true)
  lifevision.add(actions[which..'humour_aff'].p, nil, humourlevels)
end

function svo.valid.sanguine_inundate()
  svo.checkaction(svo.dict.sanguinehumour.herb, true)
  if actions.sanguinehumour_herb then
    lifevision.add(actions.sanguinehumour_herb.p, 'inundated')
  end
end

function svo.valid.choleric_inundate()
  svo.checkaction(svo.dict.cholerichumour.herb, true)
  if actions.cholerichumour_herb then
    lifevision.add(actions.cholerichumour_herb.p, 'inundated')
  end
end

function svo.valid.melancholic_inundate()
  svo.checkaction(svo.dict.melancholichumour.herb, true)
  if actions.melancholichumour_herb then
    lifevision.add(actions.melancholichumour_herb.p, 'inundated')
  end
end

function svo.valid.phlegmatic_inundate()
  svo.checkaction(svo.dict.phlegmatichumour.herb, true)
  if actions.phlegmatichumour_herb then
    lifevision.add(actions.phlegmatichumour_herb.p, 'inundated')
  end
end

for _, aff in ipairs({'skullfractures', 'crackedribs', 'wristfractures', 'torntendons'}) do
valid[aff..'_apply'] = function()
  svo.applyelixir_cure = true

  svo.checkaction(svo.dict[aff].sip, true)
  lifevision.add(actions[aff..'_sip'].p)
end

valid[aff..'_cured'] = function()
  svo.applyelixir_cure = true

  svo.checkaction(svo.dict[aff].sip, true)
  lifevision.add(actions[aff..'_sip'].p, 'cured')
end
end

function svo.valid.tarot_aeon()
  -- speed -can- be stripped in blackout
  -- if conf.aillusion and defc.speed and not actions.speed_gone and svo.paragraph_length &lt;= 2 then return end

  if not conf.aillusion or svo.paragraph_length &gt; 2 then
    valid.simpleaeon()
  else
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
  end
end

function svo.valid.refilled(what)
  local shortname = svo.es_shortnamesr[what]
  if not shortname or svo.es_categories[what] == 'venom' then return end

  if svo.es_potions[svo.es_categories[what]][what].sips == 0 then
    svo.es_potions[svo.es_categories[what]][what].sips = svo.es_potions[svo.es_categories[what]][what].sips + 50
    svo.es_potions[svo.es_categories[what]][what].vials = svo.es_potions[svo.es_categories[what]][what].vials + 1
    echo&quot;\n&quot; svo.echof(&quot;We refilled %s - will use it for cures now.&quot;, what)
  end
end

function svo.valid.missing_herb()
  if actions.checkstun_misc then
    svo.deleteLineP()
    lifevision.add(actions.checkstun_misc.p, 'onclear')
  end

  -- don't echo anything for serverside failing to svo.eat a herb
  if conf.serverside then return end

  local eating = svo.findbybals ({'herb', 'moss'})
  if not eating then return end
  local action = select(2, next(eating))
  eating = next(eating)

  if sys.last_used[eating] then
    rift.invcontents[sys.last_used[eating]] = 0

    -- echo only if temporarily ran out and have more in rift
    if rift.riftcontents[sys.last_used[eating]] ~= 0 and sys.canoutr then
      echo&quot;\n&quot; svo.echof(&quot;(don't have %s in inventory for %s as I thought)&quot;, sys.last_used[eating], action.action_name)
    end
    -- SHOULD cancel action, but that can also cause us to get into an infinite loop of eating nothing
    -- needs to be fixed after better herb tracking
  end
end

function svo.valid.symp_anorexia()
  if not conf.aillusion then -- ai is off? go-ahead then
    valid.simpleanorexia()
    return
  end

  local eating = svo.findbybal ('herb')
  if eating then
    valid.simpleanorexia()
    svo.killaction(svo.dict[eating.action_name].herb)
  elseif svo.findbybals({'sip', 'purgative', 'herb', 'moss'}) then
    valid.simpleanorexia()
  elseif actions.checkanorexia_misc then
    lifevision.add(actions.checkanorexia_misc.p, 'blehfood')
  end
end

function svo.valid.salve_fizzled(limb)
  local r = svo.checkany(svo.dict.crippledleftarm.salve, svo.dict.crippledleftleg.salve, svo.dict.crippledrightarm.salve, svo.dict.crippledrightleg.salve, svo.dict.unknowncrippledlimb.salve, svo.dict.unknowncrippledarm.salve, svo.dict.unknowncrippledleg.salve)
  if not r then return end

  svo.apply_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'fizzled', limb)
  end
end

function svo.valid.health_fizzled()
  local r = svo.checkany(svo.dict.skullfractures.sip, svo.dict.crackedribs.sip, svo.dict.wristfractures.sip, svo.dict.torntendons.sip)
  if not r then return end

  svo.applyelixir_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'fizzled')
  end
end

function svo.valid.health_noeffect()
  local r = svo.checkany(svo.dict.skullfractures.sip, svo.dict.crackedribs.sip, svo.dict.wristfractures.sip, svo.dict.torntendons.sip)
  if not r then return end

  svo.applyelixir_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

-- this can happen on a restore or a mending application
-- handle upgrading of the limb
function svo.valid.update_break(limb)
  local r = svo.checkany(svo.dict.crippledleftarm.salve, svo.dict.crippledleftleg.salve, svo.dict.crippledrightarm.salve, svo.dict.crippledrightleg.salve, svo.dict.unknowncrippledlimb.salve, svo.dict.unknowncrippledarm.salve, svo.dict.unknowncrippledleg.salve)
  if not r and not actions.restore_physical then return end

  if actions.restore_physical then
    if not affs['mangled'..limb] then
      valid.simple['mangled'..limb]()
    end
  else
    svo.apply_cure = true
    if not lifevision.l[r.name] then
      lifevision.add(actions[r.name].p, 'fizzled', limb)
    end
  end
end

function svo.valid.salve_offbalance()
  local r = svo.findbybal('salve')
  if not r then return end

  svo.apply_cure = true

  -- in case of double-applies, don't overwrite the first successful application
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'offbalance')
  end
end

function svo.valid.force_aeon()
  svo.vaff('aeon')
end

function svo.valid.herb_cured_insomnia()
  local r = svo.checkany(svo.dict.dissonance.herb, svo.dict.impatience.herb, svo.dict.stupidity.herb, svo.dict.dizziness.herb, svo.dict.epilepsy.herb, svo.dict.shyness.herb)
  if conf.aillusion and not (r or svo.find_until_last_paragraph(&quot;You feel irresistibly compelled&quot;, 'substring') or svo.find_until_last_paragraph(&quot;You cannot help but obey.&quot;, 'exact')) then svo.ignore_illusion(&quot;We aren't eating goldenseal at the moment.&quot;) return end

  if r then
    svo.killaction(svo.dict[r.action_name].herb)
  end

  defs.lost_insomnia()
  svo.lostbal_herb()

  if r then
    svo.checkaction(svo.dict[r.action_name].gone, true)
    lifevision.add(actions[r.action_name..'_gone'].p)
  end

  svo.checkaction(svo.dict.checkimpatience.misc, true)
  lifevision.add(actions.checkimpatience_misc.p, 'onclear')
end

function svo.valid.fillskullcap()
  svo.checkaction(svo.dict.fillskullcap.physical)
  if actions.fillskullcap_physical then
    lifevision.add(actions.fillskullcap_physical.p)
  end
end

function svo.valid.fillelm()
  svo.checkaction(svo.dict.fillelm.physical)
  if actions.fillelm_physical then
    lifevision.add(actions.fillelm_physical.p)
  end
end

function svo.valid.fillvalerian()
  svo.checkaction(svo.dict.fillvalerian.physical)
  if actions.fillvalerian_physical then
    lifevision.add(actions.fillvalerian_physical.p)
  end
end

function svo.valid.alreadyfull()
  local result = svo.checkany(svo.dict.fillskullcap.physical, svo.dict.fillelm.physical, svo.dict.fillvalerian.physical)

  if not result then return end

  lifevision.add(actions[result.name].p)
end

function svo.valid.litpipe(gag2)
  if not sys.sync then
    if conf.gagrelight then svo.deleteLineP() end
    if conf.gagrelight and gag2 then deleteLine() end
  end

  local result = svo.checkany(
    svo.dict.lightelm.physical, svo.dict.lightvalerian.physical, svo.dict.lightskullcap.physical)

  if not result then return end
  lifevision.add(actions[result.name].p)
end

function svo.valid.litallpipes()
  if not sys.sync and conf.gagrelight then svo.deleteLineP() end

  svo.checkaction(svo.dict.lightpipes.physical)
  if actions.lightpipes_physical then
    lifevision.add(actions.lightpipes_physical.p)
  end
end

function svo.valid.paradox_aff(herb)
  svo.checkaction(svo.dict.paradox.aff, true)
  lifevision.add(actions.paradox_aff.p, nil, herb)
end

function svo.valid.paradox_boosted()
  svo.checkaction(svo.dict.paradox.boosted, true)
  lifevision.add(actions.paradox_boosted.p)
end

function svo.valid.paradox_weakened()
  if svo.find_until_last_paragraph(svo.dict.paradox.blocked_herb, 'substring') or svo.find_until_last_paragraph(rift.herb_conversions[svo.dict.paradox.blocked_herb], 'substring') then return end
  svo.checkaction(svo.dict.paradox.weakened, true)
  lifevision.add(actions.paradox_weakened.p)
end

function svo.valid.paradox_faded()
  svo.checkaction(svo.dict.paradox.gone, true)
  lifevision.add(actions.paradox_gone.p)
end

svo.herb_cure = false
 -- svo.reset the flag tracking whenever we got a cure for what we ate (svo.herb_cure) at the start
function svo.valid.ate1()
  if svo.paragraph_length == 1 then
    svo.herb_cure = false
  end

  -- see if we need to enable arena mode for some reason
  local t = sk.arena_areas
  local area = atcp.RoomArea or (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.area)
  if area and t[area] and not conf.arena then
    conf.arena = true
    raiseEvent(&quot;svo config changed&quot;, 'arena')
    svo.prompttrigger(&quot;arena echo&quot;, function()
      echo'\n'svo.echof(&quot;Looks like you're actually in the arena - enabled arena mode.\n&quot;) svo.showprompt()
    end)
  end

  -- check anti-illusion with GMCP's herb removal
  if conf.aillusion and not conf.arena and not affs.dementia and sys.enabledgmcp and not sk.removed_something and not svo.find_until_last_paragraph(&quot;You feel irresistibly compelled&quot;, 'substring') and not svo.find_until_last_paragraph(&quot;You cannot help but obey.&quot;, 'exact') then
    -- let nicer tooltips come first before this one
    svo.aiprompt(&quot;nothing removed, but ate&quot;, function() svo.ignore_illusion(&quot;We didn't svo.eat that!&quot;, true) end)
  end

  -- check if we need to add or remove addiction - but not if we are ginseng/ferrum as that doesn't go off on addiction
  if (not conf.aillusion or svo.findbybal('herb')) and not svo.find_until_last_paragraph(&quot;ginseng root&quot;, 'substring') and not svo.find_until_last_paragraph(&quot;ferrum flake&quot;, 'substring') then
    sk.onprompt_beforelifevision_add(&quot;add/remove addiction&quot;, function()
      if not affs.addiction and svo.find_until_last_paragraph(&quot;Your addiction can never be sated.&quot;, 'exact') then
        valid.simpleaddiction()
      elseif affs.addiction and not svo.find_until_last_paragraph(&quot;Your addiction can never be sated.&quot;, 'exact') then
        svo.checkaction(svo.dict.addiction.gone, true)
        lifevision.add(actions.addiction_gone.p)
      end
    end)
  end
end

-- see if the herb we ate actually cured us: if no, register the herb eating action as 'empty'
function svo.valid.ate2()
  -- cadmus comes on the next line after
  tempLineTrigger(1,1,[[
    if line == &quot;The vile curse of Cadmus leaves you.&quot; then
      svo.valid.cadmus_woreoff()
    elseif line == &quot;The paradox affecting you weakens.&quot; then
      svo.valid.paradox_weakened()
    elseif line == &quot;The paradox fades.&quot; then
      svo.valid.paradox_faded()
    end
  ]])

  -- if it's addition or swellskin stretching the eating - don't go off now, but on the next one
  if line == &quot;Your addiction can never be sated.&quot; or line == &quot;Eating is suddenly less difficult again.&quot; then return end

  if not svo.herb_cure then
    local eating = svo.findbybal('herb')
    if not eating then return end

    -- check timers here! should not be less than half of svo.getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions[eating.name].p.actionwatch), svo.getping()

      if time &lt; (lat/2) then
        svo.ignore_illusion(&quot;This looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
        return
      end
    end

    -- addiction needs to stretch the lineguard to 2, since it is You svo.eat/Your addiction/prompt.
    -- [Curing] does not show up for svo.find_until_last_paragraph when it is gagged, so track it otherwise
    if conf.aillusion then
      lifevision.add(actions[eating.name].p, 'empty', nil, ((svo.find_until_last_paragraph(&quot;Your addiction can never be sated.&quot;, 'exact') or svo.find_until_last_paragraph(&quot;Eating is suddenly less difficult again.&quot;, 'exact') or sk.sawcuringcommand) and 2 or 1))
    else
      lifevision.add(actions[eating.name].p, 'empty')
    end
  end

  svo.herb_cure = false
end

svo.sip_cure = false

function svo.valid.sip1()
  svo.sip_cure = false
end

function svo.valid.sip2()
  if not svo.sip_cure then
  local sipping = svo.findbybal('purgative')

  if not sipping then
    -- special case for speed, which is a sip but balanceless
    if svo.doingaction'speed' then
      lifevision.add(actions.speed_purgative.p)
    end
  return end

    lifevision.add(actions[sipping.name].p, 'empty')
  end

  svo.sip_cure = false
end

local tree_cure = false

function svo.valid.tree1()
  tree_cure = false
end

function svo.valid.tree2()
  if not tree_cure then
    if conf.aillusion and not actions.touchtree_misc then
      svo.ignore_illusion(&quot;We aren't actually touching tree right now (or we were forced).&quot;, true)
      return
    end

    -- prevent against a well-timed tree illusion, which when empty, forces us to clear all afflictions
    if conf.aillusion then
      local time, lat = getStopWatchTime(actions.touchtree_misc.p.actionwatch), svo.getping()

      if time &lt; (lat/2) then
        svo.ignore_illusion(&quot;This looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
        return
      end
    end

    svo.checkaction(svo.dict.touchtree.misc, true)

    -- add it anyway, as the illusion could get cancelled later on
    lifevision.add(actions.touchtree_misc.p, 'empty')
  end

  tree_cure = false
end

svo.apply_cure = false

function svo.valid.apply1()
  svo.apply_cure = false
end

function svo.valid.apply2()
  if not svo.apply_cure then
  local r = svo.findbybal('salve')
  if not r then return end

    lifevision.add(actions[r.name].p, 'empty')
  end

  svo.apply_cure = false
end

svo.smoke_cure = false

function svo.valid.smoke1()
  svo.smoke_cure = false
end

function svo.valid.smoke2()
  if not svo.smoke_cure then
    local r = svo.findbybal('smoke')
    if r then
      lifevision.add(actions[r.name].p, 'empty')
    elseif actions.checkasthma_smoke then
      lifevision.add(actions.checkasthma_smoke.p, 'onclear')
    end
  end

  svo.smoke_cure = false
end

svo.applyelixir_cure = false

function svo.valid.applyelixir1()
  svo.applyelixir_cure = false
end

function svo.valid.applyelixir2()
  if not svo.applyelixir_cure then
    local r = svo.findbybal('sip')
    if not r then return end

      lifevision.add(actions[r.name].p, 'empty')
  end

  svo.applyelixir_cure = false
end

svo.focus_cure = false

-- note: rixil fading will be inbetween here
function svo.valid.focus1()
  svo.focus_cure = false
end

-- this should go off on the line where a focus cure would have otherwise seen
function svo.valid.focus2()
  -- ignore spirit disrupt tick and affliction lines, as they will trigger an 'empty'
  local spiritdisrupt = {
    &quot;The elemental energy about you fluctuates.&quot;,
    &quot;Your throat grows suddenly dry.&quot;,
    &quot;Your skin begins to grow uncomfortably hot.&quot;,
    &quot;A sudden feeling of nausea overtakes you.&quot;,
    &quot;Your lungs suddenly constrict and dizziness overtakes you.&quot;
  }

  if table.contains(spiritdisrupt, line) then return end

  if actions.checkimpatience_misc then
    lifevision.add(actions.checkimpatience_misc.p, 'onclear')
  end

  if not svo.focus_cure then
    svo.focus_cure = false

    local r = svo.findbybal('focus')

    if not r then return end

    -- check timers here! should not be less than half of svo.getping(). Check *action*, not affliction timer as well
    if conf.aillusion and not conf.serverside then
      local time, lat = getStopWatchTime(actions[r.name].p.actionwatch), svo.getping()

      if time &lt; (lat/2) then
        svo.ignore_illusion(&quot;This 'cure' looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
        return
      end
    end

    lifevision.add(actions[r.name].p, 'empty')
  end
end

function svo.valid.salve_had_no_effect()
  local r = svo.findbybal('salve')
  if not r then return end

  svo.apply_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

function svo.valid.plant_had_no_effect()
  local r = svo.findbybal('herb')
  if not r then return end

  svo.herb_cure = true

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

function svo.valid.salve_slickness()
  local r = svo.findbybal('salve')
  if not r then return end

  svo.apply_cure = true
  valid.simpleslickness()
  svo.killaction(svo.dict[r.action_name].salve)
end

function svo.valid.potion_slickness()
  local r = svo.findbybal('salve')
  if not r then return end

  svo.apply_cure = true
  valid.simpleslickness()
  svo.killaction(svo.dict[r.action_name].salve)
end

function svo.valid.sip_had_no_effect()
  local function kill(r)
    svo.sip_cure = true
    if not lifevision.l[r.name] then
      lifevision.add(actions[r.name].p, 'noeffect')
    end
  end

  local r = svo.findbybal('sip')
  if r then kill(r) else
    r = svo.findbybal('purgative')
    if not r then return end

    kill(r)
  end
end

function svo.valid.removed_from_rift()
  -- we're only interested in this while in sync mode
  if not sys.sync then return end

  local eating = svo.findbybal('herb')
  if eating then svo.killaction(eating) return end

  local outring = svo.findbybal('physical')
  if outring then svo.killaction(outring) end
end
signals.removed_from_rift:connect(valid.removed_from_rift, 'validate rift getting emptier')

function svo.valid.no_refill_herb()
  for _, herb in ipairs{'elm', 'valerian', 'skullcap'} do
    if actions['fill'..herb..'_physical'] then
      rift.invcontents[pipes[herb].filledwith] = 0
      svo.killaction(svo.dict['fill'..herb].physical)
    end
  end
end

function svo.valid.no_outr_herb(what)
  svo.assert(what, &quot;svo.valid.no_outr_herb: requires a single argument&quot;)
  if actions.doprecache_misc and rift.precache[what] ~= 0 and rift.riftcontents[what] ~= 0 and (rift.invcontents[what] &lt; rift.precache[what]) then
    rift.riftcontents[what] = 0
    echo&quot;\n&quot; svo.echof(&quot;Apparently we're out of %s! Can't precache it.&quot;, what)
  else
    local eating = svo.findbybals ({'herb', 'moss', 'misc'})
    if not eating then
      -- check pipes instead
      local r = svo.checkany(svo.dict.fillskullcap.physical, svo.dict.fillelm.physical, svo.dict.fillvalerian.physical)

      if not r then return end

      rift.riftcontents[sys.last_used[r.name]] = 0
      return
    end

    local action = select(2, next(eating))
    eating = next(eating)

    -- check against what we actually ate as well in case of overlaps (ie sileris/irid)
    if sys.last_used[eating] and what:find(sys.last_used[eating]) then
      local eaten = sys.last_used[eating]
      rift.riftcontents[eaten] = 0

      local alternative
      if action.eatcure[1] == eaten then alternative = action.eatcure[2]
      else alternative = action.eatcure[1] end

      echo'\n' svo.echof(&quot;Don't have %s, will try %s next time.&quot;, eaten, alternative)

      if rift.riftcontents[alternative] &lt;= 0 then
        rift.riftcontents[alternative] = 1
      end
    end
  end
end

function svo.valid.cureddisrupt()
  svo.checkaction(svo.dict.disrupt.misc)
  if actions.disrupt_misc then
    lifevision.add(actions.disrupt_misc.p)
  end
end


function svo.valid.failed_focus_impatience()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;not first&quot;) return end
  local r = svo.findbybal('focus')
  if r or not conf.aillusion or actions.checkimpatience_misc then
    if r then svo.killaction(svo.dict[r.action_name].focus) end

    if actions.checkimpatience_misc then
      lifevision.add(actions.checkimpatience_misc.p, 'impatient', nil, 1)
    else
      valid.simpleimpatience()
    end
  -- don't show a false (i) when we already know we've got impatience
  elseif conf.aillusion and not affs.impatience then
    svo.ignore_illusion(&quot;Not actually trying to focus right now (or we were forced).&quot;)
  end
end

function svo.valid.smoke_failed_asthma()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;not first&quot;) return end

  if actions.checkasthma_smoke then
    lifevision.add(actions.checkasthma_smoke.p, 'badlungs', nil, 1)
  end

  local r = svo.findbybal('smoke')
  if r or not conf.aillusion then

    if not affs.asthma then
      svo.checkaction(svo.dict.asthma.aff, true)
      lifevision.add(actions['asthma_aff'].p, nil, nil, 1)
      svo.affsp.asthma = nil
    end
  elseif conf.aillusion and not affs.asthma then -- don't show (i) on delays + already have valid asthma
    svo.ignore_illusion(&quot;Not actually trying to smoke anything right now (or we were forced).&quot;)
  end
end

function svo.valid.got_mucous()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;not first&quot;) return end

  if actions.checkasthma_smoke then
    lifevision.add(actions.checkasthma_smoke.p, 'mucous', nil, 1)
  end

  local r = svo.findbybal('smoke')
  if r or not conf.aillusion then

    if not affs.mucous then
      svo.checkaction(svo.dict.mucous.aff, true)
      lifevision.add(actions['mucous_aff'].p, nil, nil, 1)
    end
  elseif conf.aillusion then
    svo.ignore_illusion(&quot;Not actually trying to smoke anything right now (or we were forced).&quot;)
  end
end

function svo.valid.have_mucous()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;not first&quot;) return end

  local r = svo.findbybal('smoke')
  if r or not conf.aillusion then

    if not affs.mucous then
      svo.checkaction(svo.dict.mucous.aff, true)
      lifevision.add(actions['mucous_aff'].p, nil, nil, 1)
    end
  elseif conf.aillusion then
    svo.ignore_illusion(&quot;Not actually trying to smoke anything right now (or we were forced).&quot;)
  end
end

function svo.valid.unlit_pipe()
  local r = svo.findbybal('smoke')
  if not r then return end

  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then
    svo.ignore_illusion(&quot;not first&quot;)
    return
  end

  if type(svo.dict[r.action_name].smoke.smokecure) == 'string' then
    pipes[svo.dict[r.action_name].smoke.smokecure].lit = false
    svo.show_info(&quot;unlit &quot;..svo.dict[r.action_name].smoke.smokecure, &quot;Apparently the &quot;..svo.dict[r.action_name].smoke.smokecure..&quot; pipe was out&quot;)
    svo.killaction(svo.dict[r.action_name].smoke)
  elseif type(svo.dict[r.action_name].smoke.smokecure) == 'table' then
    for _, herb in pairs(svo.dict[r.action_name].smoke.smokecure) do
      if pipes[herb] and pipes[herb].lit then
        pipes[herb].lit = false
        svo.show_info(&quot;unlit &quot;..herb, &quot;Apparently the &quot;..herb..&quot; pipe was out&quot;)
        if pipes[herb].arty then
          pipes[herb].arty = false
          svo.show_info(&quot;not an artefact&quot;, &quot;It's not an artefact pipe, either. I've made it be a normal one for you&quot;)
        end
        svo.killaction(svo.dict[r.action_name].smoke)
      end
    end
  end
end

function svo.valid.necromancy_shrivel()
  valid['simplecrippled'..matches[2]..matches[3]]()
end

function svo.valid.got_aeon()
  if conf.aillusion and not defc.speed then
    valid.simpleaeon()
  elseif not conf.aillusion then
    if not conf.aillusion then
      valid.simpleaeon()
    else
      svo.checkaction(svo.dict.checkslows.aff, true)
      lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
    end

    defs.lost_speed()
  end
end

function svo.valid.empty_pipe()
  local r = svo.findbybal('smoke')
  if not r then
    if conf.aillusion and not (actions.fillskullcap_physical or actions.fillelm_physical or actions.fillvalerian_physical)
      then svo.ignore_illusion(&quot;Not actually trying to smoke anything right now (or we were forced).&quot;) end
    return
  end

  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then
    svo.ignore_illusion(&quot;not first&quot;)
    return
  end

-- TODO: turn this into a svo.dict. action validated by lifevision w/ a lifeguard
  if type(svo.dict[r.action_name].smoke.smokecure) == 'string' then
    pipes[svo.dict[r.action_name].smoke.smokecure].puffs = 0
  elseif type(svo.dict[r.action_name].smoke.smokecure) == 'table' then
    for _, herb in pairs(svo.dict[r.action_name].smoke.smokecure) do
      if pipes[herb] and pipes[herb].puffs then
        pipes[herb].puffs = 0
      end
    end
  end

  svo.killaction(svo.dict[r.action_name].smoke)

  if svo.dict[r.action_name].smoke.smokecure[1] == 'valerian' and not (bals.balance and bals.equilibrium) then
    sk.warn('emptyvalerianpipe')
  end
end

function svo.valid.pipe_emptied()
  local r = svo.checkany(svo.dict.fillskullcap.physical, svo.dict.fillelm.physical, svo.dict.fillvalerian.physical)

  if not r then return end

  if svo.dict[r.action_name].fillingid == pipes[svo.dict[r.action_name].physical.herb].id then
    pipes[svo.dict[r.action_name].physical.herb].puffs = 0
  else
    pipes[svo.dict[r.action_name].physical.herb].puffs2 = 0
  end

  if sys.sync then
    svo.killaction(svo.dict[r.action_name].physical)
  end
end

function svo.valid.empty_light()
  local r = svo.checkany(svo.dict.lightskullcap.physical, svo.dict.lightelm.physical, svo.dict.lightvalerian.physical)

  if not r then return end

  if svo.dict[r.action_name].fillingid == pipes[svo.dict[r.action_name].physical.herb].id then
    pipes[svo.dict[r.action_name].physical.herb].puffs = 0
  else
    pipes[svo.dict[r.action_name].physical.herb].puffs2 = 0
  end
  svo.killaction(svo.dict[r.action_name].physical)
end

-- bindings
for _,aff in ipairs({'bound', 'webbed', 'roped', 'transfixed', 'impale', 'hoisted'}) do
valid['writhed'..aff] = function()
  if not affs[aff] then return end

  local result = svo.checkany(svo.dict.curingbound.waitingfor, svo.dict.curingwebbed.waitingfor, svo.dict.curingroped.waitingfor, svo.dict.curingtransfixed.waitingfor, svo.dict.curingimpale.waitingfor, svo.dict.curinghoisted.waitingfor)

  if not result then return end

  -- if we were writhing what we expected from to writhe, continue
  if actions['curing'..aff..'_waitingfor'] then
    lifevision.add(svo.dict['curing'..aff].waitingfor)
  -- otherwise if we writhed from something we were not - kill if we were doing anything else and add the new
  else
    svo.killaction(svo.dict[result.action_name].waitingfor)
    svo.checkaction(svo.dict['curing'..aff].waitingfor, true)
    lifevision.add(svo.dict['curing'..aff].waitingfor)
  end
end
end

function svo.valid.writhe()
  local result = svo.checkany(svo.dict.bound.misc, svo.dict.webbed.misc, svo.dict.roped.misc, svo.dict.transfixed.misc, svo.dict.hoisted.misc, svo.dict.impale.misc)

  if not result then return end
  if actions[result.name] then
    lifevision.add(actions[result.name].p)
  end
end


function svo.valid.writheimpale()
  local result = svo.checkany(svo.dict.impale.misc, svo.dict.transfixed.misc, svo.dict.webbed.misc, svo.dict.roped.misc, svo.dict.hoisted.misc, svo.dict.bound.misc)

  if not result then return end

  if result.name == 'impale_misc' then
    lifevision.add(actions[result.name].p)
  else
    lifevision.add(actions[result.name].p, 'impale')
  end
end

function svo.valid.writhe_helpless()
  local result = svo.checkany(svo.dict.bound.misc, svo.dict.webbed.misc, svo.dict.roped.misc, svo.dict.impale.misc, svo.dict.transfixed.misc, svo.dict.hoisted.misc)

  if not result then svo.ignore_illusion(&quot;We aren't actually writhing from anything right now (or we were forced).&quot;) return end
  if actions[result.name] then
    lifevision.add(actions[result.name].p, 'helpless')
  end
end

-- restoration cures
for _, restoration in pairs({
  restorationlegs = {'mutilatedrightleg', 'mutilatedleftleg', 'mangledrightleg', 'mangledleftleg', 'parestolegs'},
  restorationarms = {'mutilatedrightarm', 'mutilatedleftarm', 'mangledrightarm', 'mangledleftarm', 'parestoarms'},
  restorationother = {'mildtrauma', 'serioustrauma', 'mildconcussion', 'seriousconcussion', 'laceratedthroat', 'heartseed'}}) do
  local other_restoration_affs = {}

  -- compile a list of other things we can cure but aren't intending to with this action
  for _, aff in pairs(restoration) do
    other_restoration_affs[#other_restoration_affs+1] = svo.dict['curing'..aff].waitingfor
  end

  for _, aff in pairs(restoration) do
    valid['curing'..aff] = function()
      local result = svo.checkany(svo.dict['curing'..aff].waitingfor, unpack(other_restoration_affs))

      if not result then return end

      if result.name == 'curing'..aff..'_waitingfor' then
        lifevision.add(actions['curing'..aff..'_waitingfor'].p)
      elseif (aff:find('leg') and (not conf.aillusion or affs[aff] or affs.parestolegs)) or
        (aff:find('arm') and (not conf.aillusion or affs[aff] or affs.parestoarms)) then
        svo.checkaction(svo.dict['curing'..aff].waitingfor, true)
        lifevision.add(svo.dict['curing'..aff].waitingfor)
      else
        svo.ignore_illusion(&quot;We don't have a &quot;..aff..&quot; right now.&quot;)
      end
    end
  end
end

-- salve cures - instantaneous only
for _, regeneration in pairs({
  caloric   = {'frozen', 'shivering', 'caloric'},
  epidermal = {'anorexia', 'itching', 'stuttering', 'slashedthroat', 'blindaff', 'deafaff', 'scalded'},
  mending   = {'selarnia', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'ablaze', 'unknowncrippledarm', 'unknowncrippledleg', 'unknowncrippledlimb'}}) do
  local other_regeneration_affs = {}

  for _, aff in pairs(regeneration) do
    other_regeneration_affs[#other_regeneration_affs+1] = svo.dict[aff].salve
  end

  for _, aff in pairs(regeneration) do
    valid['salve_cured_'..aff] = function()
      local result = svo.checkany(svo.dict[aff].salve, unpack(other_regeneration_affs))

      if not result then return end

      svo.apply_cure = true
      if result.name == aff..'_salve' then
        lifevision.add(actions[aff..'_salve'].p)
      else
        svo.killaction(svo.dict[result.action_name].salve)
        svo.checkaction(svo.dict[aff].salve, true)
        lifevision.add(svo.dict[aff].salve)
      end
    end
  end
end


-- focus
do
  local afflist = {'claustrophobia', 'masochism', 'dizziness', 'confusion', 'stupidity', 'generosity', 'loneliness', 'agoraphobia', 'recklessness', 'epilepsy', 'pacifism', 'anorexia', 'shyness', 'vertigo', 'fear', 'airdisrupt', 'firedisrupt', 'waterdisrupt', 'dementia', 'paranoia', 'hallucinations'}
  local other_focus_affs = {}

  for _, aff in pairs(afflist) do
    other_focus_affs[#other_focus_affs+1] = svo.dict[aff].focus
  end

  for _, aff in pairs(afflist) do
    valid['focus_cured_'..aff] = function()
      local result = svo.checkany(svo.dict[aff].focus, unpack(other_focus_affs))
      if not result then return end

      svo.focus_cure = true

      if result.name == aff..'_focus' then
        lifevision.add(actions[aff..'_focus'].p)

        -- check timers here! should not be less than half of svo.getping(). Check *action*, not affliction timer as well
        if conf.aillusion and not conf.serverside then
          local time, lat = getStopWatchTime(actions[aff..'_focus'].p.actionwatch), svo.getping()

          if time &lt; (lat/2) then
            svo.ignore_illusion(&quot;This 'cure' looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
            return
          end
        end
      else
        svo.killaction(svo.dict[result.action_name].focus)
        svo.checkaction(svo.dict[aff].focus, true)
        lifevision.add(svo.dict[aff].focus)
      end
    end

  end
end


-- normal smokes
for _, smoke in pairs({
  valerian = {'disloyalty', 'slickness', 'manaleech'},
  elm = {'deadening', 'hellsight', 'madness', 'aeon'}}) do
  local other_smoke_cures = {}

  for _, aff in pairs(smoke) do
    other_smoke_cures[#other_smoke_cures+1] = svo.dict[aff].smoke
  end

  for _, aff in pairs(smoke) do
    valid['smoke_cured_'..aff] = function()
      local result = svo.checkany(svo.dict[aff].smoke, unpack(other_smoke_cures))
     -- aff twice in the svo.checkany list, first so most cases it gets returned first when it's the only aff

      if not result then return end

      svo.smoke_cure = true
      if result.name == aff&quot;.._smoke&quot; then
        lifevision.add(actions[aff..'_smoke'].p)
      else
        svo.killaction(svo.dict[result.action_name].smoke)
        svo.checkaction(svo.dict[aff].smoke, true)
        lifevision.add(svo.dict[aff].smoke)
      end
    end

  end
end

-- normal herbs
for _, herb in pairs({
  ash        = {'hallucinations', 'hypersomnia', 'confusion', 'paranoia', 'dementia'},
  bellwort   = {'generosity', 'pacifism', 'justice', 'inlove', 'peace', 'retribution', 'timeloop'},
  bloodroot  = {'paralysis', 'slickness'},
  ginger     = {'melancholichumour', 'cholerichumour', 'phlegmatichumour', 'sanguinehumour'},
  ginseng    = {'haemophilia', 'darkshade', 'relapsing', 'addiction', 'illness', 'lethargy'},
  goldenseal = {'dissonance', 'impatience', 'stupidity', 'dizziness', 'epilepsy', 'shyness', 'depression', 'shadowmadness'},
  kelp       = {'asthma', 'hypochondria', 'healthleech', 'sensitivity', 'clumsiness', 'weakness', 'parasite'},
  lobelia    = {'claustrophobia', 'recklessness', 'agoraphobia', 'loneliness', 'masochism', 'vertigo', 'spiritdisrupt', 'airdisrupt', 'waterdisrupt', 'earthdisrupt', 'firedisrupt'}}) do
  local other_herb_cures = {}

  for _, aff in pairs(herb) do
    other_herb_cures[#other_herb_cures+1] = svo.dict[aff].herb
  end

  for _, aff in pairs(herb) do
    valid['herb_cured_'..aff] = function()
      local result = svo.checkany(svo.dict[aff].herb, unpack(other_herb_cures))

      if not result then return end

      svo.herb_cure = true
      if result.name == aff..'_herb' then
        -- check timers here! should not be less than half of svo.getping(). Check *action*, not affliction timer as well
        if conf.aillusion and not conf.serverside then
          local time, lat = getStopWatchTime(actions[aff..'_herb'].p.actionwatch), svo.getping()

          if time &lt; (lat/2) then
            svo.ignore_illusion(&quot;This 'cure' looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
            return
          end
        end

        lifevision.add(actions[aff..'_herb'].p)
      -- with AI on, don't accept cures for affs that we don't have (although do consider check*s)
      elseif (not conf.aillusion or (conf.aillusion and (affs[aff] or affs.unknownany or affs.unknownmental or svo.affsp[aff]))) then
        svo.killaction(svo.dict[result.action_name].herb)
        svo.checkaction(svo.dict[aff].herb, true)
        lifevision.add(svo.dict[aff].herb)
      elseif not sk.sawcuringcommand then
        moveCursor(0, getLineNumber()-1)
        moveCursor(#getCurrentLine(), getLineNumber())
        insertLink(&quot; (i)&quot;, '', &quot;Ignored the &quot;..aff..&quot; herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.&quot;)
        moveCursorEnd()
      end
    end

  end
end

-- tree touches
for _, tree in pairs({
  tree = {'ablaze', 'addiction', 'aeon', 'agoraphobia', 'anorexia', 'asthma', 'blackout', 'bleeding', 'bound', 'burning', 'claustrophobia', 'clumsiness', 'mildconcussion', 'confusion', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'darkshade', 'deadening', 'dementia', 'disloyalty', 'dissonance', 'dizziness', 'epilepsy', 'fear', 'galed', 'generosity', 'haemophilia', 'hallucinations', 'healthleech', 'hellsight', 'hypersomnia', 'hypochondria', 'icing', 'illness', 'impatience', 'inlove', 'itching', 'justice', 'laceratedthroat', 'lethargy', 'loneliness', 'madness', 'masochism','pacifism', 'paranoia', 'peace', 'prone', 'recklessness', 'relapsing', 'selarnia', 'sensitivity', 'shyness', 'slashedthroat', 'slickness', 'stupidity', 'stuttering',  'vertigo', 'voided', 'voyria', 'weakness', 'hamstring', 'shivering', 'frozen', 'spiritdisrupt', 'airdisrupt', 'firedisrupt', 'earthdisrupt', 'waterdisrupt', 'depression', 'parasite', 'retribution', 'shadowmadness', 'timeloop', 'degenerate', 'deteriorate'}}) do

  for _, aff in pairs(tree) do
    valid['tree_cured_'..aff] = function()
      svo.checkaction(svo.dict.touchtree.misc)
      if actions.touchtree_misc then
        lifevision.add(actions.touchtree_misc.p, nil, aff)
        tree_cure = true
      end
    end
  end
end

-- humour cures
for _, herb in pairs({
  ginger     = {'melancholichumour', 'cholerichumour', 'phlegmatichumour', 'sanguinehumour'}}) do
  local other_humour_cures = {}
  for _, aff in pairs(herb) do
    other_humour_cures[#other_humour_cures+1] = svo.dict[aff].herb
  end

  for _, aff in pairs(herb) do
    valid['herb_helped_'..aff] = function()
      local result = svo.checkany(svo.dict[aff].herb, unpack(other_humour_cures))

      if not result then return end

      svo.herb_cure = true
      if result.name == aff..'_herb' then
        -- check timers here! should not be less than half of svo.getping(). Check *action*, not affliction timer as well
        if conf.aillusion and not conf.serverside then
          local time, lat = getStopWatchTime(actions[aff..'_herb'].p.actionwatch), svo.getping()

          if time &lt; (lat/2) then
            svo.ignore_illusion(&quot;This 'cure' looks fake - finished way too quickly, in &quot;..time..&quot;s, while our ping is &quot;..lat)
            return
          end
        end

        lifevision.add(actions[aff..'_herb'].p, 'cured')
      elseif (not conf.aillusion or (conf.aillusion and (affs[aff] or (affs.unknownany or affs.unknownmental)))) then -- with AI on, don't accept cures for affs that we don't have
        svo.killaction(svo.dict[result.action_name].herb)
        svo.checkaction(svo.dict[aff].herb, true)
        lifevision.add(svo.dict[aff].herb, 'cured')
      else
        moveCursor(0, getLineNumber()-1)
        moveCursor(#getCurrentLine(), getLineNumber())
        insertLink(&quot; (i)&quot;, '', &quot;Ignored the &quot;..aff..&quot; herb cure, because I don't think we have this affliction atm, and we don't have any unknown affs either - so seems it's an illusion.&quot;)
        moveCursorEnd()
      end
    end

  end
end

-- common ninkharsag code across tree and passive cures
function sk.ninkharsag()
  svo.checkaction(svo.dict.ninkharsag.gone, true)

  if lifevision.l.ninkharsag_gone then
    lifevision.add(actions.ninkharsag_gone.p, 'hiddencures', 1 + (lifevision.l.ninkharsag_gone.arg or 1))
  else
    lifevision.add(actions.ninkharsag_gone.p, 'hiddencures', 1)
  end
end

-- ninkharsag doesn't show us what we cured - so atm, we'll assume it cured nothing (and not clear all our affs either)
function svo.valid.tree_ninkharsag()
  if conf.aillusion and not actions.touchtree_misc then return end

  tree_cure = true
  sk.ninkharsag()
end

function svo.valid.ninkharsag()
  -- ignore if we don't actually have ninkharsag or we aren't getting a passive cure
  if conf.aillusion and not (affs.ninkharsag and svo.passive_cure_paragraph) then return end

  sk.ninkharsag()
end


function svo.valid.touched_treeoffbal()
  svo.checkaction(svo.dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, 'offbal')
  end
end

-- special defences
function svo.defs.got_deaf()
  svo.checkaction(svo.dict.waitingondeaf.waitingfor)
  if actions.waitingondeaf_waitingfor then
    lifevision.add(actions.waitingondeaf_waitingfor.p)
  end
end

if svo.haveskillset('shindo') then
function svo.defs.shindo_blind_start()
  svo.checkaction(svo.dict.blind.misc)
  if actions.blind_misc then
    lifevision.add(actions.blind_misc.p)
  end
end
function svo.defs.shindo_blind_got()
  svo.checkaction(svo.dict.waitingonblind.waitingfor)
  if actions.waitingonblind_waitingfor then
    lifevision.add(actions.waitingonblind_waitingfor.p)
  end
end

function svo.defs.shindo_deaf_start()
  svo.checkaction(svo.dict.deaf.misc)
  if actions.deaf_misc then
    lifevision.add(actions.deaf_misc.p)
  end
end
end
if svo.haveskillset('kaido') then
function svo.defs.kaido_blind_start()
  svo.checkaction(svo.dict.blind.misc)
  if actions.blind_misc then
    lifevision.add(actions.blind_misc.p)
  end
end
function svo.defs.kaido_blind_got()
  svo.checkaction(svo.dict.waitingonblind.waitingfor)
  if actions.waitingonblind_waitingfor then
    lifevision.add(actions.waitingonblind_waitingfor.p)
  end
end

function svo.defs.kaido_deaf_start()
  svo.checkaction(svo.dict.deaf.misc)
  if actions.deaf_misc then
    lifevision.add(actions.deaf_misc.p)
  end
end
end

function svo.defs.got_blind()
  local r = svo.checkany(svo.dict.blind.herb)

  if not r then return end

  svo.herb_cure = true
  lifevision.add(actions[r.name].p)
end

function svo.defs.already_blind()
  local r = svo.checkany(svo.dict.blind.herb)

  if not r then return end

  svo.herb_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

-- a function to properly assign and ignore missing enchants - works with svo's &quot;do all enchants at once&quot; feature.
function svo.missing_enchant()
  -- find out which actions are we doing, sort them - and see which one is missing (the top one)
  local t = {}
  if actions.magicresist_physical then t[#t+1] = 'magicresist' end
  if actions.fireresist_physical then t[#t+1] = 'fireresist' end
  if actions.coldresist_physical then t[#t+1] = 'coldresist' end
  if actions.electricresist_physical then t[#t+1] = 'electricresist' end

  if #t == 0 then return end

  t = svo.prio.sortlist(t, 'physical')

  local result = t[1]

  if not svo.ignore[result] then
    svo.setignore(result, { because = &quot;you were missing the enchantment&quot; })

    echo'\n' svo.echofn(&quot;Looks like you don't have %s anymore - I'll put it on ignore then, take it off later with '&quot;, result)

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)

    echoLink(&quot;vignore &quot;..result, 'svo.ignore.'..result..' = nil svo.echof(&quot;Removed '..result..' from the ignore list (will be doing it now).&quot;)', 'Click here take '..result..' off the ignore list', true)
    setUnderline(false)
    echo&quot;'.\n&quot;

    svo.killaction(svo.dict[result].physical)
  end
end

-- a function to stop any light* actions and put all current non-artefact pipes on ignore
function svo.missing_tinderbox()
  -- find which pipes were we lighting and kill those actions. We we were lighting at least one, figure out which pipes are non-arty, get a list, put them on ignore and say which ones we've added to ignore now

  local gotaction
  if actions.lightvalerian_physical then
    svo.killaction(svo.dict.lightvalerian.physical); gotaction = true
  end
  if actions.lightelm_physical then
    svo.killaction(svo.dict.lightelm.physical); gotaction = true
  end
  if actions.lightskullcap_physical then
    svo.killaction(svo.dict.lightskullcap.physical); gotaction = true
  end

  -- if we weren't lighting - then... this might not be real!
  if not gotaction then return end

  -- find out which pipes are not artefact &amp; ignore
  local realthing, assumedname = {}, {}
  for id = 1, #pipes.pnames do
    local herb, pipe = pipes.pnames[id], pipes[pipes.pnames[id]]
    if not pipe.arty and not svo.ignore['light'..herb] then
      realthing[#realthing+1] = 'light'..herb
      assumedname[#assumedname+1] = pipe.filledwith
      svo.setignore('light'..herb, { because = &quot;you were missing a tinderbox&quot; })
    end
  end

  if realthing[1] then
    echo&quot;\n&quot; svo.echof(&quot;Looks like you don't have a tinderbox! I've put non-artefact pipes - %s on the ignore list (under the names of %s). To unignore them, check vshow ignore.&quot;, svo.concatand(assumedname), svo.concatand(realthing))
  end
end

function svo.valid.restoration_noeffect()
  local r = svo.checkany(
  svo.dict.curingheartseed.waitingfor, svo.dict.curingmangledleftleg.waitingfor, svo.dict.curingmangledrightleg.waitingfor, svo.dict.curingmangledrightarm.waitingfor, svo.dict.curingmangledleftarm.waitingfor, svo.dict.curingmutilatedrightarm.waitingfor, svo.dict.curingmutilatedleftarm.waitingfor, svo.dict.curingparestolegs.waitingfor, svo.dict.curingmildtrauma.waitingfor, svo.dict.curingserioustrauma.waitingfor, svo.dict.curingmutilatedrightleg.waitingfor, svo.dict.curingmutilatedleftleg.waitingfor, svo.dict.curingseriousconcussion.waitingfor, svo.dict.curingmildconcussion.waitingfor, svo.dict.curinglaceratedthroat.waitingfor)

  if not r then return end

  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

function svo.valid.ate_moss()
  local result = svo.checkany(svo.dict.healhealth.moss, svo.dict.healmana.moss)

  if not result then return end

  svo.herb_cure = true
  lifevision.add(actions[result.name].p)
end
valid.generic_ate_moss = valid.ate_moss

function svo.valid.noeffect_moss()
  local r = svo.checkany(svo.dict.healhealth.moss, svo.dict.healmana.moss)
  if not r then return end

  svo.herb_cure = true
  if not lifevision.l[r.name] then
    lifevision.add(actions[r.name].p, 'noeffect')
  end
end

function svo.valid.got_waterbubble()
  svo.checkaction(svo.dict.waterbubble.herb)

  svo.herb_cure = true
  if actions.waterbubble_herb then
    lifevision.add(actions.waterbubble_herb.p)
  end
end

function svo.defs.gotherb_myrrh()
  svo.checkaction(svo.dict.myrrh.herb)

  svo.herb_cure = true
  if actions.myrrh_herb then
    lifevision.add(actions.myrrh_herb.p)
  end
end

function svo.defs.gotherb_kola()
  svo.checkaction(svo.dict.kola.herb)

  svo.herb_cure = true
  if actions.kola_herb then
    lifevision.add(actions.kola_herb.p)
  end
end

function svo.defs.gotherb_deathsight()
  svo.checkaction(svo.dict.deathsight.herb)

  svo.herb_cure = true
  if actions.deathsight_herb then
    lifevision.add(actions.deathsight_herb.p)
  end
end

function svo.defs.gotskill_deathsight()
  svo.checkaction(svo.dict.deathsight.physical)
  if actions.deathsight_physical then
    lifevision.add(actions.deathsight_physical.p)
  end
end

function svo.defs.gotherb_thirdeye()
  svo.checkaction(svo.dict.thirdeye.herb)

  svo.herb_cure = true
  if actions.thirdeye_herb then
    lifevision.add(actions.thirdeye_herb.p)
  end
end

function svo.defs.gotskill_thirdeye()
  svo.checkaction(svo.dict.thirdeye.misc)
  if actions.thirdeye_misc then
    lifevision.add(actions.thirdeye_misc.p)
  end
end

function svo.defs.gotherb_insomnia()
  svo.checkaction(svo.dict.insomnia.herb)

  svo.herb_cure = true
  if actions.insomnia_herb then
    lifevision.add(actions.insomnia_herb.p)
  end
end

function svo.defs.gotskill_insomnia()
  if actions.checkhypersomnia_misc then
    lifevision.add(actions.checkhypersomnia_misc.p, 'onclear')
  end


  svo.checkaction(svo.dict.insomnia.misc)
  if actions.insomnia_misc then
    lifevision.add(actions.insomnia_misc.p)
  end
end

function svo.valid.generic_insomnia()
  local r = svo.checkany(svo.dict.insomnia.herb, svo.dict.insomnia.misc)

  if not r then return end

  svo.herb_cure = true
  lifevision.add(actions[r.name].p)
end

function svo.valid.insomnia_hypersomnia()
  local r = svo.checkany(svo.dict.insomnia.herb, svo.dict.insomnia.misc)

  if r then
    svo.herb_cure = true
    lifevision.add(actions[r.name].p, 'hypersomnia')
  elseif actions.checkhypersomnia_misc then
    lifevision.add(actions.checkhypersomnia_misc.p, 'hypersomnia')
    decho(svo.getDefaultColor()..&quot; (hypersomnia confirmed)&quot;)
  elseif not conf.aillusion then
    valid.simplehypersomnia()
  elseif not affs.hypersomnia then
    svo.checkaction(svo.dict.checkhypersomnia.aff, true)
    lifevision.add(actions.checkhypersomnia_aff.p)
  end
end

function svo.defs.salve_got_caloric()
  local r = svo.checkany(svo.dict.frozen.salve, svo.dict.shivering.salve, svo.dict.caloric.salve)

  if not r then return end

  svo.apply_cure = true
  local hypothermia = svo.find_until_last_paragraph(&quot;You are far too frozen to relieve your shivers.&quot;, 'exact')
  lifevision.add(actions[r.name].p, 'gotcaloricdef', hypothermia)
end

function svo.defs.salve_got_mass()
  svo.checkaction(svo.dict.mass.salve)
  svo.apply_cure = true
  if actions.mass_salve then
    lifevision.add(actions.mass_salve.p)
  end
end


local generic_cures_data = {
  'ablaze', 'addiction', 'aeon', 'agoraphobia', 'anorexia', 'asthma', 'blackout', 'bleeding', 'bound', 'burning', 'claustrophobia', 'clumsiness', 'mildconcussion', 'confusion', 'crippledleftarm', 'crippledleftleg', 'crippledrightarm', 'crippledrightleg', 'darkshade', 'deadening', 'dementia', 'disloyalty', 'disrupt', 'dissonance', 'dizziness', 'epilepsy', 'fear', 'galed', 'generosity', 'haemophilia', 'hallucinations', 'healthleech', 'heartseed', 'hellsight', 'hypersomnia', 'hypochondria', 'icing', 'illness', 'impale', 'impatience', 'inlove', 'inquisition', 'itching', 'justice', 'laceratedthroat', 'lethargy', 'loneliness', 'lovers', 'madness', 'mangledleftarm', 'mangledleftleg', 'mangledrightarm', 'mangledrightleg', 'masochism', 'mildtrauma', 'mutilatedleftarm', 'mutilatedleftleg', 'mutilatedrightarm', 'mutilatedrightleg', 'pacifism', 'paralysis', 'paranoia', 'peace', 'prone', 'recklessness', 'relapsing', 'roped', 'selarnia', 'sensitivity', 'seriousconcussion', 'serioustrauma', 'shyness', 'slashedthroat', 'slickness', 'stun', 'stupidity', 'stuttering', 'transfixed', 'unknownany', 'unknowncrippledarm', 'unknowncrippledleg', 'unknownmental', 'vertigo', 'voided', 'voyria', 'weakness', 'webbed', 'healhealth', 'healmana', 'hamstring', 'shivering', 'frozen', 'hallucinations', 'stain', 'rixil', 'palpatar', 'cadmus', 'hecate', 'spiritdisrupt', 'airdisrupt', 'firedisrupt', 'earthdisrupt', 'waterdisrupt', 'depression', 'parasite', 'retribution', 'shadowmadness', 'timeloop', 'degenerate', 'deteriorate', 'hatred'
}

for i = 1, #generic_cures_data do
  local aff = generic_cures_data[i]

  valid['generic_'..aff] = function ()

    -- passive curing...
    if svo.passive_cure_paragraph and svo.dict[aff].gone then
      svo.checkaction(svo.dict[aff].gone, true)
      if actions[aff .. '_gone'] then
        lifevision.add(actions[aff .. '_gone'].p)
      end
      return
    end

    -- ... or something we caused.
    if svo.actions_performed[aff] then
      lifevision.add(actions[svo.actions_performed[aff].name].p)

    -- if it's not something we were directly doing, try to link by balances
    else
      local result

      for j,k in actions:iter() do
        if not k then
          svo.debugf(&quot;[svo error]: no k here, j is %s. Actions list:&quot;, tostring(j))
          for m,n in actions:iter() do
            svo.debugf(&quot;%s - %s&quot;, tostring(m), tostring(n))
          end
        end
        if k and k.p.balance ~= 'waitingfor' and k.p.balance ~= 'aff' and svo.dict[aff][k.p.balance] then result = k.p break end
      end

      if not result then -- maybe tree?
        if actions.touchtree_misc then
          lifevision.add(actions.touchtree_misc.p, nil, aff)
          tree_cure = true
        elseif actions.restore_physical then
          lifevision.add(actions.restore_physical.p)
          valid.passive_cure()
        end
        return
      end

      svo.debugf(&quot;Result is %s&quot;, tostring(result.action_name))
      svo.killaction(svo.dict[result.action_name][result.balance])

      svo.checkaction(svo.dict[aff][result.balance], true)
      lifevision.add(svo.dict[aff][result.balance])
    end
  end
end

svo.disable_generic_trigs = function ()
  disableTrigger(&quot;General cures&quot;)
  enableTrigger('Ate')
  enableTrigger('Sip')
  enableTrigger('Applied')
  enableTrigger('Smoke')
  enableTrigger(&quot;Focus mind&quot;)
end

svo.enable_generic_trigs = function ()
  enableTrigger(&quot;General cures&quot;)
  disableTrigger('Ate')
  disableTrigger('Sip')
  disableTrigger('Applied')
  disableTrigger('Smoke')
  disableTrigger(&quot;Focus mind&quot;)
end

svo.check_generics = function ()
  if affs.blackout and not svo.generics_enabled then
    svo.generics_enabled = true
    svo.generics_enabled_for_blackout = true
    svo.enable_generic_trigs()
    echo(&quot;\n&quot;)
    svo.echof(&quot;Enabled blackout curing.&quot;)
  elseif svo.generics_enabled and svo.generics_enabled_for_blackout and not affs.blackout and not actions.blackout_aff then
    svo.generics_enabled_for_blackout, svo.generics_enabled = false, false
    svo.disable_generic_trigs()
    echo(&quot;\n&quot;)
    svo.echof(&quot;Out of blackout, disabled blackout curing.&quot;)
  elseif svo.passive_cure_paragraph and not svo.generics_enabled and not svo.generics_enabled_for_passive then
    svo.generics_enabled_for_passive, svo.generics_enabled = true, true
    svo.enable_generic_trigs ()
  elseif not svo.passive_cure_paragraph and svo.generics_enabled and svo.generics_enabled_for_passive then
    svo.generics_enabled_for_passive, svo.generics_enabled = false, false
    svo.disable_generic_trigs ()
  end
end
svo.disable_generic_trigs()
svo.check_generics()

signals.systemstart:connect(function ()
  disableTrigger(&quot;General cures&quot;)
  if conf.aillusion then enableTrigger(&quot;Pre-parse anti-illusion&quot;)
  else disableTrigger(&quot;Pre-parse anti-illusion&quot;) end
end, 'update trigger folder status')

-- passive cures
function svo.valid.passive_cure()
  local affn = table.size(affs)
  svo.passive_cure_paragraph = true
  svo.check_generics()
  sk.onprompt_beforeaction_add(&quot;check for unknowns&quot;, function ()
    -- if the counts are the same, then we cured something we didn't know about
    -- this does not need lifevision validation, being done post-fact
    if affn == table.size(affs) then
      if affs.unknownmental then
        svo.dict.unknownmental.count = svo.dict.unknownmental.count - 1
        if svo.dict.unknownmental.count &lt;= 0 then svo.rmaff('unknownmental'); svo.dict.unknownmental.count = 0
        else svo.updateaffcount(svo.dict.unknownmental) end
      elseif affs.unknownany then
        svo.dict.unknownany.count = svo.dict.unknownany.count - 1
        if svo.dict.unknownany.count &lt;= 0 then svo.rmaff('unknownany'); svo.dict.unknownany.count = 0 else
          svo.updateaffcount(svo.dict.unknownany)
        end
      end
    end
  end)
  sk.onprompt_beforeaction_add(&quot;check generics&quot;, function () svo.passive_cure_paragraph = false; svo.check_generics() end)
  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
end

function svo.valid.underwater_nopear()
  if not conf.aillusion then svo.eat(svo.dict.waterbubble.herb) else
    local oldhealth = stats.currenthealth
    sk.onprompt_beforeaction_add(&quot;check for pear damage&quot;, function ()
      if stats.currenthealth &lt; oldhealth then
        svo.eat(svo.dict.waterbubble.herb)
      end
    end)
  end
end

-- the voided timer at the moment account for multiple pommelstrikes occuring
function svo.valid.pommelstrike()
end

function svo.valid.dragonflex()
  svo.checkaction (svo.dict.dragonflex.misc)
  if actions.dragonflex_misc then
    lifevision.add(actions.dragonflex_misc.p)
  end
end

function svo.valid.dwinnu()
  svo.checkaction (svo.dict.dwinnu.misc)
  if actions.dwinnu_misc then
    lifevision.add(actions.dwinnu_misc.p)
  end
end

function svo.valid.got_blind()
  sk.onprompt_beforeaction_add('hypochondria_blind', function ()
    if not affs.blindaff and not defs.blind then
      valid.simplehypochondria()
    end
  end)
end

function svo.valid.venom_crippledrightleg()
  if svo.paragraph_length ~= 1 then
    valid.simplecrippledrightleg()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.venom_crippledleftleg()
  if svo.paragraph_length ~= 1 then
    valid.simplecrippledleftleg()
  else
    sk.hypochondria_symptom()
  end
end
-- might not be hypochondria, but plague vibe
function svo.valid.proper_clumsiness()
    valid.simpleclumsiness()
end
function svo.valid.proper_weakness()
  if svo.paragraph_length ~= 1 then
    valid.simpleweakness()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.proper_disloyalty()
  if svo.paragraph_length ~= 1 then
    valid.simpledisloyalty()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.proper_illness()
  if svo.paragraph_length ~= 1 then
    valid.simpleillness()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.proper_lethargy()
  if svo.paragraph_length ~= 1 or affs.torntendons or svo.find_until_last_paragraph(&quot;You stumble as you are afflicted with&quot;, 'substring') then
    valid.simplelethargy()
  else
    sk.hypochondria_symptom()
  end
end
-- skullfractures makes the affliction come back on its own
function svo.valid.proper_addiction()
  if svo.paragraph_length ~= 1 or affs.skullfractures then
    valid.simpleaddiction()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.proper_anorexia()
  if not conf.aillusion then
    if svo.paragraph_length ~= 1 or svo.find_until_last_paragraph(&quot;With a characteristic Jaziran trill&quot;, 'substring') then
      valid.simpleanorexia()
    else
      sk.hypochondria_symptom()
    end
  else
    svo.checkaction(svo.dict.checkanorexia.aff, true)
    lifevision.add(actions.checkanorexia_aff.p)
  end
end

-- traps can give this
function svo.valid.proper_slickness()
  if svo.paragraph_length ~= 1 then
    valid.simpleslickness()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.proper_recklessness(attacktype)
  if not conf.aillusion then
    valid.simplerecklessness()
  else
    svo.checkaction(svo.dict.recklessness.aff, true)
    if actions.recklessness_aff then
      lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, oldmana = stats.currentmana, attacktype = attacktype, atline = getLastLineNumber('main')})
    end
  end
end
function svo.valid.proper_recklessness2(attacktype)
  if not conf.aillusion then
    valid.simplerecklessness()
  else
    svo.checkaction(svo.dict.recklessness.aff, true)
    if actions.recklessness_aff then
      if svo.find_until_last_paragraph('wracks', 'substring') or svo.find_until_last_paragraph(&quot;points an imperious finger at you&quot;, 'substring') or svo.find_until_last_paragraph(&quot;A heavy burden descends upon your soul as&quot;, 'substring') or svo.find_until_last_paragraph(&quot;stares at you, giving you the evil eye&quot;, 'substring') or svo.find_until_last_paragraph(&quot;glowers at you with a look of repressed disgust before making a slight gesture toward you.&quot;, 'substring') or svo.find_until_last_paragraph(&quot;smashing your temple with a backhanded blow&quot;, 'substring') then
        lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, attacktype = attacktype, atline = getLastLineNumber('main')})
      else
        lifevision.add(actions.recklessness_aff.p, nil, {oldhp = stats.currenthealth, attacktype = attacktype, atline = getLastLineNumber('main')}, 1)
      end
    end
  end
end
function svo.valid.venom_crippledleftarm()
  if svo.paragraph_length ~= 1 then
    valid.simplecrippledleftarm()
  else
    sk.hypochondria_symptom()
  end
end
function svo.valid.venom_crippledrightarm()
  if svo.paragraph_length ~= 1 then
    valid.simplecrippledrightarm()
  else
    sk.hypochondria_symptom()
  end
end

function svo.valid.lost_arena()
  echo&quot;\n&quot;
  svo.echof(&quot;I'm sorry =(&quot;)

  svo.reset.affs()
  svo.reset.general()
  svo.reset.defs()
end

function svo.valid.lost_ffa()
  local oldroom = (atcp.RoomNum or gmcp.Room.Info.num)
  sk.onprompt_beforeaction_add('arena_death',
    function ()
      if oldroom ~= (atcp.RoomNum or gmcp.Room.Info.num) then
        svo.reset.affs()
        svo.reset.general()
        svo.reset.defs()
      end
    end)
end

function svo.valid.won_arena()
  echo&quot;\n&quot;
  if math.random(10) == 1 then svo.echof(&quot;Winnar!&quot;)
  else svo.echof(&quot;You won!&quot;) end

  -- rebounding coming up gets killed
  if actions.waitingonrebounding_waitingfor then
    svo.killaction(svo.dict.waitingonrebounding.waitingfor)
  end

  svo.reset.affs()

  -- blind/insomnia/deaf get svo.reset too
  defences.lost('blind') defences.lost('deaf') defences.lost('insomnia')
end

if svo.haveskillset('necromancy') then
  function svo.valid.soulcaged()
    svo.reset.affs()
    svo.reset.general()
    svo.reset.defs()
    if type(conf.burstmode) == 'string' then
      echo&quot;\n&quot;svo.echof(&quot;Auto-switching to %s defences mode.&quot;, conf.burstmode)
      defs.switch(conf.burstmode, false)
    end
  end
elseif svo.haveskillset('occultism') then
  function svo.valid.transmogged()
    svo.reset.affs()
    svo.reset.general()
    svo.reset.defs()
    if type(conf.burstmode) == 'string' then
      echo&quot;\n&quot;svo.echof(&quot;Auto-switching to %s defences mode.&quot;, conf.burstmode)
      defs.switch(conf.burstmode, false)
    end
  end
else
  function svo.valid.soulcaged() end
  function svo.valid.transmogged() end
end

function svo.valid.died()
  if line == &quot;Your starburst tattoo flares as the world is momentarily tinted red.&quot; then
    sk.onprompt_beforeaction_add('death',
      function ()
        if affs.recklessness or (stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana) then
          svo.reset.affs()
          svo.reset.general()
          svo.reset.defs()
          rift.resetinvcontents()
          echo &quot;\n&quot; svo.echof(&quot;We hit starburst!&quot;)
          signals.before_prompt_processing:unblock(valid.check_life)
          if type(conf.burstmode) == 'string' then
            svo.echof(&quot;Auto-switching to %s defences mode.&quot;, conf.burstmode)
            defs.switch(conf.burstmode, false)
          end

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then svo.killaction(svo.dict.waitingonrebounding.waitingfor) end

          raiseEvent(&quot;svo died&quot;, 'starburst')
        end
      end)
  elseif not conf.paused then
    sk.onprompt_beforeaction_add('death',
      function ()
        if affs.recklessness or stats.currenthealth == 0 then
          svo.reset.affs()
          svo.reset.general()
          svo.reset.defs()
          rift.resetinvcontents()

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then svo.killaction(svo.dict.waitingonrebounding.waitingfor) end

          echo &quot;\n&quot;
          if math.random(1,10) == 1 then
            echo[[



                   __, _ __,   _, _ __,
                   |_) | |_)   |\/| |_
                   | \ | |     |  | |
                   ~ ~ ~ ~     ~  ~ ~~~


 ]]
          elseif math.random(1, 25) == 1 then
            echo[[


             _     _      _     _      _     _      _     _
            (c).-.(c)    (c).-.(c)    (c).-.(c)    (c).-.(c)
             / x_x \      / x_x \      / x_x \      / x_x \
           __\( Y )/__  __\( Y )/__  __\( Y )/__  __\( Y )/__
          (_.-/'-'\-._)(_.-/'-'\-._)(_.-/'-'\-._)(_.-/'-'\-._)
             || D ||      || E ||      || A ||      || D ||
           _.' `-' '._  _.' `-' '._  _.' `-' '._  _.' `-' '._
          (.-./`-'\.-.)(.-./`-'\.-.)(.-./`-'\.-.)(.-./`-'\.-.)
           `-'     `-'  `-'     `-'  `-'     `-'  `-'     `-'


            ]]
          else
            echo&quot;\n&quot;svo.echof(&quot;We died.&quot;) end
          conf.paused = true
          signals.before_prompt_processing:unblock(valid.check_life)
          raiseEvent(&quot;svo died&quot;)
          raiseEvent(&quot;svo config changed&quot;, 'paused')
        elseif stats.currenthealth == stats.maxhealth and stats.currentmana == stats.maxmana and svo.find_until_last_paragraph(&quot;Your starburst tattoo flares as the world is momentarily tinted red.&quot;, 'exact') then -- in case something else came between &quot;you died&quot; and starburst
          svo.reset.affs()
          svo.reset.general()
          svo.reset.defs()
          rift.resetinvcontents()

          -- rebounding coming up gets cancelled
          if actions.waitingonrebounding_waitingfor then svo.killaction(svo.dict.waitingonrebounding.waitingfor) end

          echo &quot;\n&quot; svo.echof(&quot;We hit starburst!&quot;)
          signals.before_prompt_processing:unblock(valid.check_life)
          if type(conf.burstmode) == 'string' then
            svo.echof(&quot;Auto-switching to %s defences mode.&quot;, conf.burstmode)
            defs.switch(conf.burstmode, false)
          end
          raiseEvent(&quot;svo died&quot;, 'starburst')
        end
      end)
  end
end

function svo.valid.check_life()
  if stats.currenthealth ~= 0 then
    echo&quot;\n&quot; svo.echof(&quot;Welcome back to life! System unpaused.&quot;)
    conf.paused = false
    raiseEvent(&quot;svo config changed&quot;, 'paused')
    signals.before_prompt_processing:block(valid.check_life)
  end
end
signals.before_prompt_processing:connect(valid.check_life, 'check if we are alive again')
signals.before_prompt_processing:block(valid.check_life)


function svo.valid.check_recklessness()
  local vitals = gmcp.Char.Vitals

  -- check against GMCP, as Svof modifies them
  if affs.recklessness and (vitals.mp &lt; vitals.maxmp or vitals.hp &lt; vitals.maxhp) then
    svo.rmaff('recklessness')
  end
end
signals.before_prompt_processing:connect(valid.check_recklessness, 'check for recklessness')
-- toggled inside svo.dict
signals.before_prompt_processing:block(valid.check_recklessness)


function svo.valid.limb_hit(which, attacktype)
  if not svo.sp_limbs[which] then return end

  me.lasthitlimb = which

  if selectString(which, 1) ~= -1 then
    fg(conf.highlightparryfg)
    bg(conf.highlightparrybg)
    deselect()
    resetFormat()
  else -- things like BM slashes don't say the limb, but say the plural name of it - legs, arms.
    local plural = which:sub(-3)..'s'

    if selectString(plural, 1) ~= -1 then
      fg(conf.highlightparryfg)
      bg(conf.highlightparrybg)
      deselect()
      resetFormat()
    end
  end

  signals.after_lifevision_processing:unblock(svo.sp_checksp)
  signals.limbhit:emit(which, attacktype)
  raiseEvent(&quot;svo limb hit&quot;, which, attacktype)
end

local function saw_tekura_in_paragraph()
  return
    -- punches
    svo.find_until_last_paragraph(&quot;balls up one fist and hammerfists you&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;forms a spear hand and stabs out at you&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;launches a powerful uppercut at you&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;unleashes a powerful hook towards you&quot;, 'substring') or

    -- kicks
    svo.find_until_last_paragraph(&quot;lets fly at you with a snap kick&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;towards you with a lightning-fast moon kick&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;leg high and scythes downwards at you&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;pumps out at you with a powerful side kick&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;spins into the air and throws a whirlwind kick towards you&quot;, 'substring') or
    svo.find_until_last_paragraph(&quot;The blow sends a shock of pain through you, your muscles reflexively locking in response.&quot;, 'exact')
end

-- count up how much tekura stuff have we seen in the paragraph so far. If more than two things, then count this as a combo.
local function all_in_one_tekura()
  local c =
    -- punches
    svo.count_until_last_paragraph(&quot;balls up one fist and hammerfists you&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;forms a spear hand and stabs out at you&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;launches a powerful uppercut at you&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;unleashes a powerful hook towards you&quot;, 'substring') +

    -- kicks
    svo.count_until_last_paragraph(&quot;lets fly at you with a snap kick&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;drops to the floor and sweeps his legs round at you.&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;drops to the floor and sweeps her legs round at you.&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;knocks your legs out from under you and sends you sprawling to the floor.&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;towards you with a lightning-fast moon kick&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;leg high and scythes downwards at you&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;pumps out at you with a powerful side kick&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;spins into the air and throws a whirlwind kick towards you&quot;, 'substring') +
    svo.count_until_last_paragraph(&quot;The blow sends a shock of pain through you, your muscles reflexively locking in response.&quot;, 'exact')

    return (c &gt;= 2) and true or false
end


for _,name in ipairs({'rightarm', 'leftarm', 'leftleg', 'rightleg'}) do
  for _, status in ipairs({'mangled', 'mutilated'}) do
    valid['proper_'..status..name] = function ()
      -- idea: see if any previous lines contain the limb name; it would have to be included in the msg
      if conf.aillusion then
        local limb = string.format(&quot;%s %s&quot;, string.match(name, &quot;(%w+)(%w%w%w)&quot;))
        local plural = name:sub(-3)..'s'

        -- last line doesn't work with stuff like bm breaks, where it is limb\anothermsg\actualbreak. So go until the prompt.
        local previouslinenumber, currentlinenumber = svo.lastpromptnumber+1, getLastLineNumber('main')

        -- workaround for deleteLine() making svo.lastpromptnumber's tracking get invalidated
        if currentlinenumber &lt;= previouslinenumber then
          previouslinenumber = currentlinenumber - 1
        end

        -- this, with short enough wrapping, might not get the line that the rend starts on. So if this line doesn't start with a capital, pull in one more line
        local combined = table.concat(getLines(previouslinenumber, currentlinenumber))

        if not combined:sub(1,1):match(&quot;%u&quot;) then
          combined = table.concat(getLines(previouslinenumber-1, currentlinenumber))
        end

        -- remember blackout, don't check this in it
        if not affs.blackout and (combined:find(limb, 1, true) or combined:find(plural, 1, true)) then
          -- special exception for blademaster breaks, which do so little damage, you can regen it:
          --[[Spinning to the right as he draws 11 11 from its sheath, 11 delivers a precise slash across your arms.
              Your left arm is greatly damaged from the beating. (+65h, 0.8%, +75m, 1.1%) ]]
          if svo.find_until_last_paragraph(&quot;^Spinning to the right as s?he draws %w+ %w+ from its sheath, %w+ delivers a precise slash across your arms%.$&quot;, 'pattern') then
            valid['simple'..status..name]()
          elseif saw_tekura_in_paragraph() then
            svo.checkaction(svo.dict[status..name].aff, true)
            lifevision.add(actions[status..name..'_aff'].p, 'tekura', stats.currenthealth)
          else
            svo.checkaction(svo.dict[status..name].aff, true)
            lifevision.add(actions[status..name..'_aff'].p, nil, stats.currenthealth)
          end

          tempLineTrigger(1,1, [[
            if line == &quot;Your shield completely absorbs the damage.&quot; then
              svo.valid.simple]]..status..name..[[() end]]
          )
        else
          svo.debugf(&quot;Didn't find limb (%s) or plural (%s) in combined (%s)&quot;, limb, plural, combined)
        end
      else -- anti-illusion off
        -- when we see a tekura combo, try to add all the mangles at the end of it, so the priorities take effect - instead of being dictated by first-hit
        if saw_tekura_in_paragraph() then

          -- if this is an all-in-one combo, don't queue up the hits
          if all_in_one_tekura() then
            svo.checkaction(svo.dict[status..name].aff, true)
            lifevision.add(actions[status..name..'_aff'].p, nil, stats.currenthealth)

            -- clear a delayed break if there was one
            if sk.delaying_break then
              killTimer(sk.delaying_break); sk.delaying_break = nil
              for _, aff in ipairs(sk.tekura_mangles) do
                svo.addaffdict(svo.dict[aff])
              end
              sk.tekura_mangles = nil
            end
          else
            -- not an all-in-one combo, or the first hit of it
            if not sk.delaying_break then
              sk.delaying_break = tempTimer(getNetworkLatency() + conf.tekura_delay, function() -- from the first hit, it's approximately getNetworkLatency() time until the second - add the conf.tekura_delay to allow for variation in ping
                sk.delaying_break = nil

                for _, aff in ipairs(sk.tekura_mangles) do
                  svo.addaffdict(svo.dict[aff])
                end
                sk.tekura_mangles = nil
                signals.after_lifevision_processing:unblock(cnrl.checkwarning)
                signals.canoutr:emit()
                svo.make_gnomes_work()
              end)
            end

            sk.tekura_mangles = sk.tekura_mangles or {}
            sk.tekura_mangles[#sk.tekura_mangles+1] = status..name
          end
        else
          svo.checkaction(svo.dict[status..name].aff, true)
          lifevision.add(actions[status..name..'_aff'].p, nil, stats.currenthealth)
        end
      end
    end
  end
end

for _, name in ipairs({'serioustrauma', 'mildtrauma', 'mildconcussion', 'seriousconcussion'}) do
  valid['proper_'..name] = function ()
    svo.checkaction(svo.dict[name].aff, true)
    lifevision.add(actions[name..'_aff'].p, nil, stats.currenthealth)
    tempLineTrigger(1,1, [[
      if line == &quot;Your shield completely absorbs the damage.&quot; then
        svo.valid.simple]]..name..[[()
      end
    ]])
  end
end

valid.generic_burn = function (number)
  svo.assert(not number or tonumber(number), &quot;svo.valid.simpleburn: how many removals do you want to do? Must be a number&quot;)

  svo.checkaction(svo.dict.ablaze.gone, true)

  if lifevision.l.ablaze_gone then
    lifevision.add(actions.ablaze_gone.p, 'generic_reducelevel', (number or 1) +(lifevision.l.ablaze_gone.arg or 1))
  else
    lifevision.add(actions.ablaze_gone.p, 'generic_reducelevel', (number or 1))
  end
end

valid.low_willpower = sk.checkwillpower

if svo.haveskillset('healing') then
  sk.check_emptyhealingheal = function ()
    if sk.currenthealinghealcount+1 == getLineCount() then
      lifevision.add(actions.usehealing_misc.p, 'empty')
    else
      lifevision.add(actions.usehealing_misc.p)
    end

    signals.before_prompt_processing:disconnect(sk.check_emptyhealingheal)
  end

  valid.healercure = function ()
    svo.checkaction(svo.dict.usehealing.misc)
    if actions.usehealing_misc then
      sk.currenthealinghealcount = getLineCount()
      signals.before_prompt_processing:connect(sk.check_emptyhealingheal, 'check for priest heal not curing anything')
      valid.passive_cure()
    end
  end


  valid.emptyheal = function ()
    if actions.usehealing_misc then
      lifevision.add(actions.usehealing_misc.p, 'empty')
    end
  end

  valid.healing_cured_insomnia = function ()
    svo.checkaction(svo.dict.usehealing.misc)
    if actions.usehealing_misc then
      defs.lost_insomnia()
      lifevision.add(actions.usehealing_misc.p, 'empty')
    end
  end

  -- valid.healercure = function ()
  --   svo.checkaction(svo.dict.usehealing.misc)
  --   if actions.usehealing_misc then
  --     valid.passive_cure()
  --     lifevision.add(actions.usehealing_misc.p)
  --   end
  -- end

  valid.nohealbalance = function ()
    svo.checkaction(svo.dict.usehealing.misc)
    if actions.usehealing_misc then
      lifevision.add(actions.usehealing_misc.p, 'nobalance')
    end
  end

  valid.bedevilheal = function ()
    svo.checkaction(svo.dict.usehealing.misc)
    if actions.usehealing_misc then
      lifevision.add(actions.usehealing_misc.p, 'bedevilheal')
    end
  end
else
  valid.healercure = function () end
  valid.healing_cured_insomnia = valid.healercure
  valid.nohealbalance = valid.healercure
  valid.bedevilheal = valid.healercure
end

if svo.haveskillset('chivalry') then
  sk.check_emptyrage = function ()
    if sk.currentragecount+1 == getLineCount() then
      lifevision.add(actions.rage_misc.p, 'empty')
    else
      lifevision.add(actions.rage_misc.p)
    end

    signals.before_prompt_processing:disconnect(sk.check_emptyrage)
  end

  valid.ragecure = function ()
    svo.checkaction(svo.dict.rage.misc)
    if actions.rage_misc then
      sk.currentragecount = getLineCount()
      signals.before_prompt_processing:connect(sk.check_emptyrage, 'check for chivalry rage not curing anything')
      valid.passive_cure()
    end
  end
else
  valid.ragecure = function() end
end

if svo.haveskillset('kaido') then
  valid.transmuted = function ()
    -- always check transmute so we can count how many we did (to cancel timer if we can)
    svo.checkaction(svo.dict.transmute.physical, true)
    lifevision.add(actions.transmute_physical.p)
  end
else
  valid.transmuted = function() end
end

-- possibly suspectible to sylvans double-doing it, or a sylvan doing &amp; illusioning it?
function svo.valid.sylvan_heartseed()
  if not conf.aillusion or affs.mildtrauma then
    valid.simpleheartseed()
  else
    tempTimer(5, function () sk.heartseed2window = true end)
    tempTimer(10, function () sk.heartseed2window = false end)
  end
end

function svo.valid.sylvan_heartseed2()
  if not affs.heartseed and (not conf.aillusion or sk.heartseed2window) then
    valid.simpleheartseed()
  end
end

function svo.valid.sylvan_eclipse()
  sk.sylvan_eclipse = true
  tempTimer(10, function () sk.sylvan_eclipse = nil end)
end

function svo.valid.sylvan_lacerate1()
  svo.checkaction(svo.dict.slashedthroat.aff, true)
  lifevision.add(actions.slashedthroat_aff.p, 'sylvanhit', stats.currenthealth)
end

function svo.valid.sylvan_lacerate2()
  svo.checkaction(svo.dict.laceratedthroat.aff, true)
  lifevision.add(actions.laceratedthroat_aff.p, 'sylvanhit', stats.currenthealth)
end

function svo.connected()
  signals.connected:emit()
end

function svo.valid.stripped_caloric()
  svo.checkaction(svo.dict.caloric.gone, true)
  if actions.unknownany_aff then
    lifevision.add(actions.caloric_gone.p, nil, 'unknownany')
  elseif actions.unknownmental_aff then
    lifevision.add(actions.caloric_gone.p, nil, 'unknownmental')
  else
    lifevision.add(actions.caloric_gone.p)
  end
end

function svo.valid.stripped_insomnia()
  svo.checkaction(svo.dict.insomnia.gone, true)
  if actions.unknownany_aff then
    lifevision.add(actions.insomnia_gone.p, nil, 'unknownany')
  elseif actions.unknownmental_aff then
    lifevision.add(actions.insomnia_gone.p, nil, 'unknownmental')
  else
    lifevision.add(actions.insomnia_gone.p)
  end
end

if svo.haveskillset('elementalism') or svo.haveskillset('healing') then
  function svo.valid.lacking_channels()
    if svo.usingbal('physical') then
      defs.lost_simultaneity()
    end
  end
else
  valid.lacking_channels = function() end
end

function svo.valid.bubbleout()
  if not conf.aillusion then svo.eat(svo.dict.waterbubble.herb) end
end

-- check if we're the ones who got hit with it
function svo.valid.aeon_card()
  if not affs.blackout then return end

  -- if sk.aeon_thrown then killTimer(sk.aeon_thrown) end
  -- sk.aeon_thrown = tempTimer(4, function() sk.aeon_thrown = nil end)

  -- account for lag between shuffle and throw, try and check for aeon
  tempTimer(0.2, function()
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
  end)

  tempTimer(0.7, function()
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'aeon')
  end)
end

function svo.valid.lust_card()
  if not affs.blackout then return end

  -- if sk.aeon_thrown then killTimer(sk.aeon_thrown) end
  -- sk.aeon_thrown = tempTimer(4, function() sk.aeon_thrown = nil end)

  -- account for lag between shuffle and throw, try and check for aeon
  tempTimer(0.2+getNetworkLatency(), function()
    if not sys.sync then svo.echof(&quot;Checking allies for potential lust...&quot;) send('allies', conf.commandecho) end
  end)

  svo.dict.blackout.check_lust = true
end

function svo.defs.cant_empower()
  if actions.empower_physical then
    local off = {}

    if defkeepup[defs.mode].empower then
      svo.defs.keepup('empower', false)
      off[#off+1] = 'keepup'
    end

    if defdefup[defs.mode].empower then
      svo.defs.defup('empower', false)
      off[#off+1] = 'defup'
    end

    echo&quot;\n&quot; svo.echof(&quot;Seems that you can't empower yet - so I took it off %s for you.&quot;, table.concat(off, &quot;, &quot;))
  end
end

function svo.ignore_snake_bite()
  if not svo.find_until_last_paragraph(&quot;You scream out in agony as a vicious venom tears through your body.&quot;, 'exact')
    and not svo.find_until_last_paragraph(&quot;You gasp as a terrible aching strikes all your limbs.&quot;, 'exact')
   then svo.ignore_illusion(&quot;Ignored the single-aff bite (vconfig ignoresinglebites is on)&quot;, true) return end
end

function svo.valid.stop_wielding()
  svo.checkaction(svo.dict.rewield.physical)
  if actions.rewield_physical then
    lifevision.add(actions.rewield_physical.p, 'clear')
  end
end

function svo.valid.reflection_cancelled()
  if conf.aillusion and svo.paragraph_length == 1 and not conf.batch then return end

  for _, action in pairs(lifevision.l:keys()) do
    if action:find('_aff', 1, true) then
      svo.killaction(svo.dict[action:match(&quot;(%w+)_&quot;)].aff)

      -- typically, you'd only have one aff per prompt - so no need to complicate by optimizing
      selectCurrentLine()
      fg('MediumSlateBlue')
      deselect()
      resetFormat()
    end
  end
end

function svo.valid.homunculus_throat()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;This needs to be on it's own line.&quot;) return end

  svo.lostbal_focus()
end

function svo.valid.retardation_gone()
  svo.checkaction(svo.dict.retardation.gone, true)
  lifevision.add(actions['retardation_gone'].p)

  -- re-check to make sure it's true
  if conf.aillusion then
    svo.checkaction(svo.dict.checkslows.aff, true)
    lifevision.add(actions.checkslows_aff.p, nil, 'retardation')
  end
end

function svo.valid.soa()
  if not conf.aillusion then return end

  if svo.paragraph_length == 2 and (svo.find_until_last_paragraph(&quot;greatly damaged from the beating&quot;, 'substring') or svo.find_until_last_paragraph(&quot;has been mutilated beyond repair by ordinary means&quot;, 'substring')) then
    svo.ignore_illusion(&quot;This looks pretty fake - can't get a limb-break and an SoA hit without anyone poking it&quot;, true)
  end
end

function svo.valid.enmesh_start()
  if conf.aillusion and svo.paragraph_length ~= 1 and not conf.batch then svo.ignore_illusion(&quot;Enmesh can't be chained with other things at once&quot;) return end

  -- kill previous timers and set them for future. An enmesh hits at 5s after it was started
  if sys.enmesh1timer then killTimer(sys.enmesh1timer) end
  if sys.enmesh2timer then killTimer(sys.enmesh2timer) end

  sys.enmesh1timer = tempTimer(3, function() sys.enmesh1timer = nil end)

  sys.enmesh2timer = tempTimer(7+getNetworkLatency(), function() sys.enmesh2timer = nil end)
end

function svo.valid.enmesh_hit()
  if not conf.aillusion or (sys.enmesh2timer and not sys.enmesh1timer) then
    valid.simpleroped()
  else
    svo.ignore_illusion(&quot;We weren't getting enmeshed, this looks fake.&quot;)
  end
end

function svo.valid.chaosrays()
  if not conf.aillusion then return end

  -- first and easiest case: you got hit by it directly, nobody died and bugged the game out
  if svo.find_until_last_paragraph(&quot;Seven rays of different coloured light spring out from&quot;, 'substring') then return end

  -- second, more difficult case - somebody died, go back until the previous prompt, see if anyone else died too
  if svo.paragraph_length == 1 then
    local checking, getLines = getLineNumber()-1, getLines -- start checking lines 2 back, as 1 back will be prompt

    local line = getLines(checking-1, checking)[1]
    if line:find(&quot;Unable to withstand the rays of chaos&quot;, 1, true) or line:find(&quot;falls from&quot;, 1, true) then return end
  end

  svo.ignore_illusion(&quot;This looks fake!&quot;)
end

function svo.valid.proper_stain()
  if not conf.aillusion then
    valid.simplestain()
  else
    svo.checkaction(svo.dict.stain.aff, true)
    lifevision.add(actions.stain_aff.p, nil, stats.maxhealth)
  end
end

function svo.valid.gothit(class, name)
  svo.checkaction(svo.dict.gothit.happened, true)
  svo.dict.gothit.happened.tempmap[name or &quot;?&quot;] = class
  lifevision.add(actions.gothit_happened.p)
end

function svo.valid.dcurse_start(whom)
  if not conf.aillusion or sk.dcurse_start then return end

  sk.dcurse_start = {tempTimer(10.5+getNetworkLatency(), function() sk.dcurse_start = nil end), whom}
end

function svo.valid.dcurse_hit(aff)
  if conf.aillusion and not sk.dcurse_start then return end

  (valid['proper_'..aff] or valid['simple'..aff])()
end

function svo.valid.broken_legs()
  if not affs.crippledrightleg and not affs.mangledrightleg and not affs.mutilatedrightleg
    and not affs.crippledleftleg and not affs.mangledleftleg and not affs.mutilatedleftleg and not affs.unknowncrippledlimb and not affs.unknowncrippledleg and not affs.hamstring then
    valid.simpleunknowncrippledleg()

    -- cancel potential stand
    if actions.prone_misc then
      svo.killaction(svo.dict.prone.misc)
    end
  end
end

-- remove unknown level if the affliction from a symptom was not present before
valid.remove_unknownmental = function (affliction)
  if affs[affliction] then return end

  svo.checkaction(svo.dict.unknownmental.gone, true)
  lifevision.add(actions.unknownmental_gone.p, 'lost_level')
end
valid.remove_unknownany = function (affliction)
  if affs[affliction] then return end

  svo.checkaction(svo.dict.unknownany.gone, true)
  lifevision.add(actions.unknownany_gone.p, 'lost_level')
end

function svo.valid.loki()
  valid.simpleunknownany()
end

--[[

|exp|91%H|93%M|cdb|[sleep st maso pr par hecate rop cl mad con ra1]
Your blood regains its ability to clot. -&gt; claustrop
Thank Maya, the Great Mother! Your clumsiness has been cured. -&gt; shyness
As a firelord glares at you, sudden agonising heat ignites in your veins. It is gone as swiftly as
it came, but you feel suddenly lightheaded. (i)

]]

-- Clumsiness to Shyness - Lethargy to Recklessness - Haemophilia to Claustrophobia - Health Leech to Agoraphobia - Sensitivity to Paranoia - Darkshade to Confusion
function svo.valid.pyradius()
  local affmap = {
    ['clumsiness']  = 'shyness',
    ['darkshade']   = 'confusion',
    ['haemophilia'] = 'claustrophobia',
    ['healthleech'] = 'agoraphobia',
    ['lethargy']    = 'recklessness',
    ['sensitivity'] = 'paranoia',
  }

  local cures = sk.getuntilprompt()
  local startline = getLineNumber()

  -- no affs cured?
  if #cures == 0 then return end

  for i = 1, #cures do
    moveCursor(0, startline-i)
    deleteLine()
  end
  moveCursorEnd()

  svo.valid.passive_cure() feedTriggers(table.concat(cures, &quot;\n&quot;)..&quot;\n&quot;)

  sk.onprompt_beforelifevision_add(&quot;update pyradius&quot;, function()
    for _, action in pairs(lifevision.l:keys()) do
      local aff = action:match(&quot;^(%w+)&quot;)
      if affmap[aff] then
        (valid['proper_'..affmap[aff]] or valid['simple'..affmap[aff]])()
      end
    end
  end)

  -- have to force lifevision and all, since feedTriggers happens after the prompt
  send(&quot;\n&quot;)
end

if svo.haveskillset('healing') then
function svo.valid.usedhealingbalance()
  svo.checkaction(svo.dict.stolebalance.happened, true)
  lifevision.add(actions.stolebalance_happened.p, nil, 'healing')
end

function svo.valid.gothealingbalance()
  svo.checkaction(svo.dict.gotbalance.happened, true)
  svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'healing' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

if svo.haveskillset('venom') then
function svo.valid.shrugging()
  svo.checkaction(svo.dict.shrugging.physical)
  if actions.shrugging_physical then
    valid.passive_cure()
    lifevision.add(actions.shrugging_physical.p, nil, getLineNumber())

    selectCurrentLine()
    setBgColor(0,0,0)
    setFgColor(0,170,255)
    resetFormat()
  end
end

function svo.valid.noshruggingbalance()
  svo.checkaction(svo.dict.shrugging.physical)
  if actions.shrugging_physical then
    lifevision.add(actions.shrugging_physical.p, 'offbal')
  end
end

function svo.valid.gotshruggingbalance()
  svo.checkaction(svo.dict.gotbalance.happened, true)
  svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'shrugging' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

if svo.haveskillset('voicecraft') then
function svo.valid.usedvoicebalance()
  svo.checkaction(svo.dict.stolebalance.happened, true)
  lifevision.add(actions.stolebalance_happened.p, nil, 'voice')
end

function svo.valid.gotvoicebalance()
  svo.checkaction(svo.dict.gotbalance.happened, true)
  svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'voice' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

if svo.haveskillset('terminus') then
function svo.valid.usedwordbalance()
  svo.checkaction(svo.dict.stolebalance.happened, true)
  lifevision.add(actions.stolebalance_happened.p, nil, 'word')
end

function svo.valid.gotwordbalance()
  svo.checkaction(svo.dict.gotbalance.happened, true)
  svo.dict.gotbalance.happened.tempmap[#svo.dict.gotbalance.happened.tempmap+1] = 'word' -- hack to allow multiple balances at once
  lifevision.add(actions.gotbalance_happened.p)
end
end

function svo.valid.proper_hamstring()
  svo.checkaction(svo.dict.hamstring.aff, true)
  lifevision.add(actions['hamstring_aff'].p, 'renew')
end

function svo.valid.alreadyprone()
  valid.simpleprone()

  if actions.lyre_physical then svo.killaction(svo.dict.lyre.physical) end
end

function svo.valid.negation_gem()
  if not conf.aillusion then
    me.manualdefcheck = true
    defences.lost('shield')
  else
    svo.prompttrigger(&quot;check negation gem&quot;, function()
      -- in cases where classes have +con/health adjusting buffs, test the line for a max health drop
      -- pending investigation on what happens to current health
    end)
  end
end

function svo.valid.meta_glare()
  svo.prompttrigger(&quot;check for stupidity or impatience&quot;, function()
    if svo.find_until_last_paragraph(&quot;You shuffle your feet noisily, suddenly bored.&quot;, 'exact') then
      svo.addaffdict(svo.dict.impatience)
    else
      svo.addaffdict(svo.dict.stupidity)
    end
  end)
end

function svo.valid.bind_totem()
  if conf.aillusion and svo.paragraph_length &lt;= 1 and not conf.batch then svo.ignore_illusion(&quot;This can't appear on its own, should only happen when you enter a room&quot;) end

  defs.lost_kola()
  valid.simplesleep()
  valid.simpletransfixed()
end

function svo.valid.pummel()
  local oldhp = stats.hp
  svo.aiprompt(&quot;check pummel damage&quot;, function()
    -- if the damage taken is more than 30%, then we are frozen
    if (oldhp - stats.hp) &gt;= 25 then
      valid.simpleshivering()
      valid.simplefrozen()
    end
  end)
end

function svo.valid.skirmish_drag()
  local result = svo.checkany(svo.dict.impale.misc, svo.dict.curingimpale.waitingfor)

  if not result then return end
  lifevision.add(actions[result.name].p, 'dragged')
end

function svo.valid.cured_burn_health()
  local result = svo.checkany(svo.dict.ablaze.salve, svo.dict.severeburn.salve, svo.dict.extremeburn.salve, svo.dict.charredburn.salve, svo.dict.meltingburn.salve)

  if not result then return end

  svo.apply_cure = true
  if actions[result.name] then
    lifevision.add(actions[result.name].p)
  end
end

function svo.valid.cured_burns_health()
  local result = svo.checkany(svo.dict.ablaze.salve, svo.dict.severeburn.salve, svo.dict.extremeburn.salve, svo.dict.charredburn.salve, svo.dict.meltingburn.salve)

  if not result then return end

  svo.apply_cure = true
  if actions[result.name] then
    lifevision.add(actions[result.name].p, 'all')
  end
end

function svo.valid.tree_cured_burn()
  svo.checkaction(svo.dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, 'burn')
    tree_cure = true
  end
end

function svo.valid.tree_cured_burns()
  svo.checkaction(svo.dict.touchtree.misc)
  if actions.touchtree_misc then
    lifevision.add(actions.touchtree_misc.p, nil, &quot;all burns&quot;)
    tree_cure = true
  end
end

for _, aff in ipairs({'skullfractures', 'crackedribs', 'wristfractures', 'torntendons'}) do
  valid['tree_cure_'..aff] = function()
    svo.checkaction(svo.dict.touchtree.misc)
    if actions.touchtree_misc then
      tree_cure = true
      lifevision.add(actions.touchtree_misc.p, nil, aff)
    end
  end

  valid['tree_cured_'..aff] = function()
    svo.checkaction(svo.dict.touchtree.misc)
    if actions.touchtree_misc then
      lifevision.add(actions.touchtree_misc.p, nil, aff..&quot; cured&quot;)
      tree_cure = true
    end
  end

  valid['generic_cure_'..aff] = function()
    svo.checkaction(svo.dict[aff].gone, true)
    if lifevision.l[aff..'_gone'] then
      lifevision.add(actions[aff..'_gone'].p, 'general_cure', 1 + (lifevision.l[aff..'_gone'].arg or 1))
    else
      lifevision.add(actions[aff..'_gone'].p, 'general_cure', 1)
    end
  end

  valid['generic_cured_'..aff] = function()
    svo.checkaction(svo.dict[aff].gone, true)
    lifevision.add(actions[aff..'_gone'].p, 'general_cured')
  end
end

function svo.valid.expend_torso()
  svo.checkaction(svo.dict.waitingonrebounding.waitingfor)
  if actions.waitingonrebounding_waitingfor then
    lifevision.add(actions.waitingonrebounding_waitingfor.p, 'expend')
  end
end

-- happens on wrist fracture levels 1-3
function svo.valid.devastate_arms_cripple()
  svo.checkaction(svo.dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  valid.simplecrippledrightarm()
  valid.simplecrippledleftarm()
end

-- happens on wrist fracture levels 4,5
-- edit: This ability can also mutilate a mangled limb.
function svo.valid.devastate_arms_mangle()
  svo.checkaction(svo.dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  if affs.mangledrightarm then
    svo.rmaff('mangledrightarm')
    valid.simplemutilatedrightarm()
  else
    valid.simplemangledrightarm()
  end
  if affs.mangledleftarm then
    svo.rmaff('mangledleftarm')
    valid.simplemutilatedleftarm()
  else
    valid.simplemangledleftarm()
  end
end

-- happens on wrist fracture levels 6,7
function svo.valid.devastate_arms_mutilate()
  svo.checkaction(svo.dict.wristfractures.gone, true)
  lifevision.add(actions.wristfractures_gone.p)

  valid.simplemutilatedrightarm()
  valid.simplemutilatedleftarm()
end

-- happens on torn tendon levels 1-3
function svo.valid.devastate_legs_cripple()
  svo.checkaction(svo.dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)

  valid.simplecrippledrightleg()
  valid.simplecrippledleftleg()
end

-- happens on torn tendon levels 4,5
-- edit: This ability can also mutilate a mangled limb.
function svo.valid.devastate_legs_mangle()
  svo.checkaction(svo.dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)


  if affs.mangledrightleg then
    svo.rmaff('mangledrightleg')
    valid.simplemutilatedrightleg()
  else
    valid.simplemangledrightleg()
  end
  if affs.mangledleftleg then
    svo.rmaff('mangledleftleg')
    valid.simplemutilatedleftleg()
  else
    valid.simplemangledleftleg()
  end
end

-- happens on torn tendon levels 6,7
function svo.valid.devastate_legs_mutilate()
  svo.checkaction(svo.dict.torntendons.gone, true)
  lifevision.add(actions.torntendons_gone.p)

  valid.simplemutilatedrightleg()
  valid.simplemutilatedleftleg()
end

function svo.valid.smash_high()
  svo.lostbal_focus()
end

function svo.valid.proper_ablaze()
  if not affs.severeburn and not affs.extremeburn and not affs.charredburn and not affs.meltingburn then
    valid.simpleablaze()
  end
end

function svo.valid.riding_alreadyon()
  svo.checkaction(svo.dict.riding.physical, true)
  lifevision.add(actions.riding_physical.p, 'alreadyon')
end

function svo.valid.recoverable_attack()
  svo.checkaction(svo.dict.footingattack.happened, true)
  lifevision.add(actions.footingattack_happened.p)
end

valid.recovered_footing = valid.stoodup

function svo.knight_focused(who)
  me.focusedknights[who] = true
end
function svo.valid.doublehander_hit(who)
  if me.focusedknights[who] then
    sk.doubleknightaff = true
    me.focusedknights[who] = nil
    svo.prompttrigger(&quot;clear double knight affs&quot;, function() sk.doubleknightaff = false end)
  end
end

function svo.valid.skirmish_lacerate()
  svo.prompttrigger(&quot;check lacerate rebounding&quot;, function()
    if not svo.find_until_last_paragraph(&quot;The attack rebounds back onto&quot;, 'substring') then
      valid.simplehaemophilia()
    end
  end)
end

function svo.valid.skirmish_gouge()
  svo.prompttrigger(&quot;check gouge deafness&quot;, function()
    if not svo.find_until_last_paragraph(&quot;Your hearing is suddenly restored.&quot;, 'exact') then
      valid.simplesensitivity()
    end
  end)
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Config system</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, defdefup, signals = svo.sys, svo.defdefup, svo.signals
local conf, sk, me, defs = svo.conf, svo.sk, svo.me, svo.defs
local defences, cnrl, rift = svo.defences, svo.cnrl, svo.rift
local pipes = svo.pipes

svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/config&quot;)

-- conf has actual values, config data for them

svo.wait_tbl = {
  [0] = {n = 0.7, m = &quot;Systems lag tolerance level set to normal.&quot;},
  [1] = {n = 1.1, m = &quot;The lag level was set to \&quot;decent\&quot; - make sure to set it to normal when it clears up.&quot;},
  [2] = {n = 1.9, m = &quot;The lag level was set to \&quot;severe\&quot; - make sure to set it to normal when it clears up.&quot;},
  [3] = {n = 3.5, m = &quot;The lag level was set to \&quot;awfully terrible\&quot; - make sure to set it to normal when it clears up. Don't even think about fighting in this lag.&quot;},
  [4] = {n = 3.5, m = &quot;The lag level was set to \&quot;you're on a mobile in the middle of nowhere\&quot; - make sure to set it to normal when it clears up. Don't even think about fighting in this lag. Don't use this for bashing with dor either - use 3 instead. This is more useful for scripts that rely on do - enchanting and etc.&quot;}
}

svo.conf_printinstallhint = function (which)
  svo.assert(svo.config_dict[which] and svo.config_dict[which].type, which..&quot; is missing a type&quot;)

  if svo.config_dict[which].type == 'boolean' then
    svo.echof(&quot;Use %s to answer.&quot;, tostring(svo.green(&quot;vconfig &quot;..which..&quot; yep/nope&quot;)))
  elseif svo.config_dict[which].type == 'string' then
    svo.echof(&quot;Use %s to answer.&quot;, tostring(svo.green(&quot;vconfig &quot;..which..&quot; (option)&quot;)))
  elseif svo.config_dict[which].type == 'number' and svo.config_dict[which].percentage then
    svo.echof(&quot;Use %s to answer.&quot;, tostring(svo.green(&quot;vconfig &quot;..which..&quot; (percent)&quot;)))
  elseif svo.config_dict[which].type == 'number' then
    svo.echof(&quot;Use %s to answer.&quot;, tostring(svo.green(&quot;vconfig &quot;..which..&quot; (number)&quot;)))
  end
end

local conf_installhint = function (which)
  svo.assert(svo.config_dict[which] and svo.config_dict[which].type, which..&quot; is missing a type&quot;)

  if svo.config_dict[which].type == 'boolean' then
    return &quot;Use vconfig &quot;..which..&quot; yep/nope to answer.&quot;
  elseif svo.config_dict[which].type == 'string' then
    return &quot;Use vconfig &quot;..which..&quot; (option) to answer.&quot;
  elseif svo.config_dict[which].type == 'number' and svo.config_dict[which].percentage then
    return &quot;Use vconfig &quot;..which..&quot; (percent) to answer.&quot;
  elseif svo.config_dict[which].type == 'number' then
    return &quot;Use vconfig &quot;..which..&quot; (number) to answer.&quot;
  else return &quot;&quot;
  end
end

svo.config_dict = svo.pl.OrderedMap {
  {blockcommands = {
    vconfig2 = true,
    type = 'boolean',
    onenabled = function ()
      svo.echof(&quot;&lt;0,250,0&gt;Will%s block your commands in slow curing mode (aeon/retardation) if the system is doing something.&quot;, svo.getDefaultColor())
      if not denyCurrentSend then svo.echof(&quot;Warning: your version of Mudlet doesn't support this, so blockcommands won't actually work. Update to 1.2.0+&quot;) end
    end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s block your commands in slow curing mode, but instead allow them to override what the system is doing.&quot;, svo.getDefaultColor())
    if not denyCurrentSend then svo.echof(&quot;Warning: your version of Mudlet doesn't support this, so blockcommands won't actually work.&quot;) end end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if denyCurrentSend then
        echo &quot;Override commands in slow-curing mode.\n&quot; return
      else
        echo &quot;Override commands in slow-curing mode (requires Mudlet 1.2.0+).\n&quot; return end
    end,
    installstart = function () conf.blockcommands = true end,
  }},
  {autoslick = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Automatically prioritise slickness&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically swap asthma herb priority in times of danger - when you have paralysis or impatience above asthma in prios, and you have asthma+slickness on you, getting hit with a herbstack.&quot;, svo.getDefaultColor()) end,
    ondisabled = function ()
      if svo.swapped_asthma then
        svo.prio_swap('asthma', 'herb', svo.swapped_asthma)
        svo.swapped_asthma = nil
        svo.echof(&quot;Swapped asthma priority back down.&quot;)
      end

      svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically swap asthma herb priority in times of danger.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.autoslick = true end
  }},
  {focus = {
    type = 'boolean',
    vconfig1 = 'focus',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use Focus to cure.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use Focus to cure.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.focus = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Focus skill?&quot;) end
  }},
  {siprandom = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s sip by random vial IDs of a potion - note that this requires the elist sorter to know which vial IDs have which potions - and you'll need to check 'elist' after a vial runs out.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s make use of random vials - will be sipping the first available one by name.&quot;, svo.getDefaultColor()) end,
  }},
  {autoclasses = {
      type = 'boolean',
      onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically enable the classes you seem to be fighting (used for class tricks).&quot;, svo.getDefaultColor()) end,
      ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically enable classes that you seem to be fighting (you can use tn/tf class instead).&quot;, svo.getDefaultColor()) end,

      vconfig2 = true,
      onshow = function (defaultcolour)
        fg(defaultcolour)
        if conf.autoclasses then
          echo &quot;Will auto-enable classes.\n&quot;
        else
          echo &quot;Won't auto-enable classes.\n&quot;
        end
      end,
    }},
  {havelifevision = {
    type = 'boolean',
    onenabled = function () defences.enablelifevision() svo.echof(&quot;&lt;0,250,0&gt;Have%s Lifevision mask - added it to defup/keepup.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have Lifevision mask - won't be adding it to defup/keepup.&quot;, svo.getDefaultColor()) end,
  }},
  {autoarena = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically enable/disable arena mode as you enter into the arena.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically enable/disable arena mode as you enter/leave the arena..&quot;, svo.getDefaultColor()) end,
  }},
  {haveshroud = {
    type = 'boolean',
    onenabled = function () defences.enableshroud() svo.echof(&quot;&lt;0,250,0&gt;Have%s a Shroudcloak - added it to defup/keepup.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have a Shroudcloak - won't be adding it to defup/keepup.&quot;, svo.getDefaultColor()) end,
  }},
  {focuswithcadmus = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use Focus while you have cadmus&quot;
      if conf.focuswithcadmus then
        echo&quot;    (&quot;
        echoLink(&quot;adjust affs&quot;, &quot;svo.config.set'cadmusaffs'&quot;, &quot;View, enable and disable afflictions for which focus is allowed to be used while you've got cadmus&quot;)
        fg(defaultcolour) echo &quot;)&quot;
      end
      echo&quot;\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s focus for mental afflictions when you've got cadmus (this'll give you a physical affliction when you do).&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s focus when you've got cadmus.&quot;, svo.getDefaultColor()) end,
  }},
  {cadmusaffs = {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echofn(&quot;Afflictions for which we will use focus even though we have &quot;)
      underline(true)
      setFgColor(unpack(svo.getDefaultColorNums))
      echoLink('cadmus', '', &quot;Cadmus will give you a physical affliction if you focus with it (and still cure the mental one)&quot;, true)
      underline(false)
      echo(&quot;:\n&quot;)

      local temp = svo.prio.getlist('focus')

      -- clear gaps so we can sort and display in 2 columns
      local t = {}
      for _, focusaff in ipairs(temp) do t[#t+1] = focusaff end

      table.sort(t) -- display alphabetically

      for i = 1, #t, 2 do
        local focusaff, nextaff = t[i], t[i+1]

        if me.cadmusaffs[focusaff] then
          dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.cadmusaffs[&quot;]]..focusaff..[[&quot;] = false; svo.config.set'cadmusaffs']], &quot;Click to stop focusing for &quot;..focusaff..&quot; when you have camus&quot;, true)
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %s&quot;, focusaff))
        else
          dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.cadmusaffs[&quot;]]..focusaff..[[&quot;] = true; svo.config.set'cadmusaffs']], &quot;Click to start focusing for &quot;..focusaff..&quot; when you have camus and are able to focus&quot;, true)
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %s&quot;, focusaff))
        end

        -- equal out the spacing on the second column
        echo((&quot; &quot;):rep(30-#focusaff))

        if nextaff and me.cadmusaffs[nextaff] then
          dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.cadmusaffs[&quot;]]..nextaff..[[&quot;] = false; svo.config.set'cadmusaffs']], &quot;Click to stop focusing for &quot;..nextaff..&quot; when you have camus&quot;, true)
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %s\n&quot;, nextaff))
        elseif nextaff then
          dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.cadmusaffs[&quot;]]..nextaff..[[&quot;] = true; svo.config.set'cadmusaffs']], &quot;Click to start focusing for &quot;..nextaff..&quot; when you have camus and are able to focus&quot;, true)
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %s\n&quot;, nextaff))
        end
      end

      _G.setUnderline = underline
      echo'\n'
    end
  }},
  {lyre = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Lyre mode&quot;,
    onenabled = function () defs.keepup('lyre', 'on') svo.echof(&quot;Lyre mode &lt;0,250,0&gt;ON%s.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () defs.keepup('lyre', 'off') svo.app('off', true) svo.echof(&quot;Lyre mode &lt;250,0,0&gt;OFF%s.&quot;, svo.getDefaultColor()) end,
  }},
  {ninkharsag = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Experimental Nin'kharsag tracking&quot;,
    onenabled = function () svo.echof(&quot;Experimental Nin'kharsag tracking &lt;0,250,0&gt;enabled%s - will attempt to work out which affs Nin'kharsag hides, and diagnose otherwise.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;Experimental Nin'kharsag &lt;250,0,0&gt;disabled%s.&quot;, svo.getDefaultColor()) end,
  }},
  {shipmode = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Ship mode&quot;,
    onenabled = function () signals.newroom:connect(sk.check_shipmode, 'check shipmode on room move') svo.echof(&quot;Ship mode &lt;0,250,0&gt;enabled%s - this will allow the system to work properly with the 2-3 line prompts.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () signals.newroom:disconnect(sk.check_shipmode) svo.echof(&quot;Ship mode &lt;250,0,0&gt;disabled%s.&quot;, svo.getDefaultColor()) end,
  }},
  {lyrecmd = {
    type = 'string',
    onset = function ()
      svo.dict.lyre.physical.action = conf.lyrecmd
      svo.echof(&quot;Will use the '%s' for the Lyre mode.&quot;, tostring(conf.lyrecmd))
    end
  }},
  {commandseparator = {
    type = 'string',
    onset = function ()
      svo.echof(&quot;Will use &lt;0,250,0&gt;%s%s as the in-game command separator.&quot;, tostring(conf.commandseparator), svo.getDefaultColor())
    end
  }},
  {buckawns = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Have buckawns&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Do%s have buckawns.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have buckawns.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.buckawns = nil end,
    installcheck = function () svo.echof(&quot;Have you got the buckawns artifact?&quot;) end
  }},
  {burrowpause = {
    type = 'boolean',
    onenabled = function () signals.gmcproominfo:connect(sk.check_burrow_pause, 'check if we need to pause for burrow') svo.echof(&quot;&lt;0,250,0&gt;Will%s auto-pause when we burrow.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () signals.gmcproominfo:disconnect(sk.check_burrow_pause) svo.echof(&quot;&lt;250,0,0&gt;Won't%s auto-pause when we burrow.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.burrowpause = true end,
  }},
  {freevault = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Vaulting doesn't take balance&quot;,
    onenabled = function ()
      if conf.freevault and svo.dict.riding.physical.balanceful_act then
        svo.dict.riding.physical.balanceless_act = true
        svo.dict.riding.physical.balanceful_act = nil
        signals.dragonform:emit()
      elseif not conf.freevault and svo.dict.riding.physical.balanceless_act then
        svo.dict.riding.physical.balanceless_act = nil
        svo.dict.riding.physical.balanceful_act = true
        signals.dragonform:emit()
      end
      svo.echof(&quot;&lt;0,250,0&gt;Do%s have balanceless vaulting.&quot;, svo.getDefaultColor())
    end,
    ondisabled = function ()
      if conf.freevault and svo.dict.riding.physical.balanceful_act then
        svo.dict.riding.physical.balanceless_act = true
        svo.dict.riding.physical.balanceful_act = nil
        signals.dragonform:emit()
      elseif not conf.freevault and svo.dict.riding.physical.balanceless_act then
        svo.dict.riding.physical.balanceless_act = nil
        svo.dict.riding.physical.balanceful_act = true
        signals.dragonform:emit()
      end
      svo.echof(&quot;&lt;250,0,0&gt;Don't%s have balanceless vaulting.&quot;, svo.getDefaultColor())
    end,
  }},
  {deathsight = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Have deathsight&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Do%s have deathsight.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have deathsight.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.deathsight = nil end,
    installcheck = function () svo.echof(&quot;Have you got the deathsight skill?&quot;) end
  }},
  {tree = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use tree       (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'treefunc'&quot;, &quot;View, enable and disable scenarios in which tree will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use of tree.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use of tree.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.tree = nil end,
    installcheck = function () svo.echof(&quot;Do you have a Tree tattoo?&quot;) end
  }},
  {treebalance = {
    type = 'number',
    min = 0,
    max = 100000,
    onset = function ()
      if conf.treebalance == 0 then
        svo.echof(&quot;Will use the default settings for tree balance length.&quot;)
      else
        svo.echof(&quot;Set tree balance to be %ds - if it doesn't come back after that, I'll reset it.&quot;, conf.treebalance)
      end
    end,
    installstart = function () conf.treebalance = 0 end
  }},
  {restore = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use restore    (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'restorefunc'&quot;, &quot;View, enable and disable scenarios in which restore will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use Restore to cure limbs when necessary.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use Restore to cure.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.restore = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Restore skill?&quot;) end
  }},
  {dragonheal = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use dragonheal (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'dragonhealfunc'&quot;, &quot;View, enable and disable scenarios in which dragonheal will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use dragonheal to cure when necessary.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use dragonheal to cure.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.dragonheal = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Dragonheal?&quot;) end
  }},
  {breath = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Auto-enable breathing on Kai Choke&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically enabling breathing against Kai Choke and to check for asthma.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use survival breathing.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.breath = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the survival breath skill?&quot;) end
  }},
  {ignoresinglebites = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Ignore single serpent bites&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s ignore all serpent bites that deliver only one affliction - most likely they'll be illusions, but may also be not against a smart Serpent who realizes that you're ignoring. So if you see them only biting, that's a warning sign that they're *really* biting, and you'd want to toggle this off &amp; diagnose.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s ignore serpent bites that deliver only one affliction.&quot;, svo.getDefaultColor()) end
  }},
  {ignoresinglestabs = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Ignore single serpent doublestabs&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s ignore all serpent doublestabs that deliver only one affliction (most likely they'll be illusions, but may also be not).&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s ignore serpent doublestabs that deliver only one affliction.&quot;, svo.getDefaultColor()) end
  }},
  {efficiency = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Have survival efficiency&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Have%s survival efficiency - tree tattoo balance will take shorter to come back.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have efficiency - tree tattoo balance will take longer to come back.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.efficiency = nil end,
    installcheck = function () svo.echof(&quot;Do you have the survival efficiency skill?&quot;) end
  }},
  {clot = {
    type = 'boolean',
    vconfig1 = 'clot',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use clot to control bleeding.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use clot for bleeding.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.clot = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Clot skill?&quot;) end
  }},
  {insomnia = {
    type = 'boolean',
    vconfig1 = 'insomnia',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the Insomnia skill for insomnia.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the Insomnia skill for insomnia, and will use cohosh instead.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.insomnia = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Insomnia skill?&quot;) end
  }},
  {thirdeye = {
    type = 'boolean',
    vconfig1 = 'thirdeye',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the thirdeye skill for thirdeye instead of echinacea.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the thirdeye skill for thirdeye, and will use echinacea instead.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.thirdeye = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Thirdeye skill?&quot;) end
  }},
  {moss = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s make use of moss/potash to heal.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s make use of moss/potash to heal.&quot;, svo.getDefaultColor()) end,
    installstart = function ()
      conf.moss = nil end,
    installcheck = function ()
      svo.echof(&quot;Do you want to make use of moss/potash to heal?&quot;) end,
  }},
  {showchanges = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s show changes in health/mana on the prompt.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s show changes in health/mana on the prompt.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Show h/m changes (in &quot;..tostring(conf.changestype)..&quot; format).\n&quot;)
    end,
    installstart = function () conf.showchanges = nil end,
    installcheck = function () svo.echof(&quot;Do you want to show changes about your health/mana in the prompt?&quot;) end
  }},
  {changestype = {
    type = 'string',
    check = function (what)
      if what == 'full' or what == 'short' or what == 'fullpercent' or what == 'shortpercent' then return true end
    end,
    onset = function ()
      svo.echof(&quot;Will use the %s health/mana loss echoes.&quot;, conf.changestype)
    end,
    installstart = function () conf.changestype = 'shortpercent' end
  }},
  {log = {
    type = 'string',
    check = function (what)
      if what == 'off' or what == 'file' or what == 'echo' or what == 'both' then return true end
    end,
    onset = function ()
      svo.updateloggingconfig()
      if conf.log == 'off' then
        svo.echof(&quot;Logging disabled.&quot;)
      elseif conf.log == 'file' then
        if Logger then
          svo.echof(&quot;Will log to the file in %s.&quot;, (getMudletHomeDir() .. &quot;/log/svof.txt&quot;))
        else
          svo.echof(&quot;Please install the Simple logger first (https://forums.mudlet.org/viewtopic.php?f=6&amp;t=1424), then restart.&quot;)
          svo.conf.log = 'off'
          svo.updateloggingconfig()
        end
      elseif conf.log == 'echo' then
        svo.echof(&quot;Will log to your screen.&quot;)
      else
        svo.echof(&quot;Will log to both screen and file in %s.&quot;, (getMudletHomeDir() .. &quot;/log/svof.txt&quot;))
      end
    end,
    installstart = function () conf.log = 'off' end
  }},
  {showbaltimes = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s show balance times for balance, equilibrium and herbs.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s show balance times.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Show how long balances took.\n&quot;
    end,
    installstart = function () conf.showbaltimes = true end,
    -- installcheck = function () svo.echof(&quot;Do you want to show how long your balances take?&quot;) end
  }},
  {showafftimes = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s show how long afflictions took to cure.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s show times for curing afflictions.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Show how quickly afflictions are cured.\n&quot;
    end,
    installstart = function () conf.showafftimes = true end,
  }},
  {doubledo = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s do actions twice under stupidity.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s do actions twice under stupidity.&quot;, svo.getDefaultColor()) end,
    onshow = &quot;Double do actions in stupidity&quot;,
    vconfig2 = true
  }},
  {repeatcmd = {
    type = 'number',
    min = 0,
    max = 100000,
    onset = function ()
      if conf.repeatcmd == 0 then svo.echof(&quot;Will not repeat commands.&quot;)
      elseif conf.repeatcmd == 1 then svo.echof(&quot;Will repeat each command one more time.&quot;)
      else svo.echof(&quot;Will repeat each command %d more times.&quot;, conf.repeatcmd)
    end end,
    installstart = function () conf.repeatcmd = 0 end
  }},
  {singleprompt = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if conf.singleprompt then
        echo(string.format(&quot;Use a singleprompt%s&quot;, (conf.singlepromptblank and ' (with a blank line)' or '')))
      else
        echo(&quot;Not using a singleprompt&quot;)
      end
      echo'.\n'
      resetFormat()
    end,
    onenabled = function ()
      svo.echof(&quot;&lt;0,250,0&gt;Enabled%s the use of a single prompt.&quot;, svo.getDefaultColor())

      sk.enable_single_prompt()
    end,
    ondisabled = function ()
      svo.echof(&quot;&lt;250,0,0&gt;Disabled%s the use a single prompt.&quot;, svo.getDefaultColor())
      if svo.moveprompt then killTrigger(svo.moveprompt) end
      if svo.bottomprompt then svo.bottomprompt:hide(); svo.bottomprompt.reposition = function() end end
      setBorderBottom(0)
      svo.bottom_border = 0
    end
  }},
  {singlepromptsize = {
    type = 'number',
    min = 0,
    max = 100,
    onset = function ()
      if svo.bottomprompt then
        svo.bottomprompt:setFontSize(conf.singlepromptsize)
        if conf.singleprompt then
          -- svo.config.set('singleprompt', 'off', false)
          -- svo.config.set('singleprompt', 'on', false)

          if svo.moveprompt then killTrigger(svo.moveprompt) end
          if svo.bottomprompt then svo.bottomprompt:hide(); svo.bottomprompt.reposition = function() end end
          setBorderBottom(0)
          svo.bottom_border = 0

          sk.enable_single_prompt()
          clearWindow(&quot;svo.bottomprompt&quot;)
        end
      end

      svo.echof(&quot;Will be displaying the font at size %d.&quot;, conf.singlepromptsize)
    end
  }},
  {singlepromptblank = {
    type = 'boolean',
    onenabled = function ()
      svo.echof(&quot;&lt;0,250,0&gt;Enabled%s the single prompt to show a blank line for the prompt.&quot;, svo.getDefaultColor())
      svo.config.set('singlepromptkeep', false, false)
    end,
    ondisabled = function ()
      svo.echof(&quot;&lt;250,0,0&gt;Disabled%s the blank line, will be deleting the prompt instead.&quot;, svo.getDefaultColor())
    end
  }},
  {singlepromptkeep = {
    type = 'boolean',
    onenabled = function ()
      svo.echof(&quot;&lt;0,250,0&gt;Enabled%s the single prompt to keep the prompt%s.&quot;, svo.getDefaultColor(), (conf.singleprompt and '' or ' (when vconfig singleprompt is on)'))
      svo.config.set('singlepromptblank', false, false)
    end,
    ondisabled = function ()
      svo.echof(&quot;&lt;250,0,0&gt;Disabled%s keeping the prompt, will be removing it.&quot;, svo.getDefaultColor())
    end
  }},
  {waitherbai = {
    type = 'boolean',
    vconfig2 = true,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s pause eating of herbs while checking herb-cured illusions.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s pause eating of herbs while checking herb-cured illusions.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo (&quot;Don't eat while checking herb-cured illusions.\n&quot;)
    end,
    installstart = function () conf.waitherbai = true end
  }},
  {waitparalysisai = {
    type = 'boolean',
    vconfig2 = true,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s wait for balance/eq to confirm a suspect paralysis instead of accepting it - so if we get a suspect paralysis while off bal/eq, we'll cure other things and check the paralysis when we can.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s wait for balance/eq to confirm a possible paralysis - if we get one off bal/eq, we'll eat bloodroot asap. Otherwise if we have bal/eq, we'll check first.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo (&quot;Wait for balance/eq to check suspicious paralysis.\n&quot;)
    end,
    installstart = function () conf.waitparalysisai = false end
  }},
  {commandecho = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s show commands the system is doing.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s show commands the system is doing.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour) echo (&quot;Show system commands (&quot;..tostring(conf.commandechotype)..&quot;)\n&quot;)
    end,
    installstart = function () conf.commandecho = true end
  }},
  {commandechotype = {
    type = 'string',
    check = function (what)
      if what == 'plain' or what == 'fancy' or what == 'fancynewline' then return true end
    end,
    onset = function ()
      svo.echof(&quot;Will use the %s command echoes.&quot;, conf.commandechotype)
    end,
    installstart = function () conf.commandechotype = 'fancy' end
  }},
  {curemethod = {
    type = 'string',
    check = function (what)
      if table.contains({'conconly', 'transonly', 'preferconc', 'prefertrans', 'prefercustom'}, what) then return true end
    end,
    onset = function ()
      signals.curemethodchanged:emit()
      if conf.curemethod == 'conconly' then
        svo.echof(&quot;Will only use the usual Concoctions herbs/potions/salve for curing.&quot;)
      elseif conf.curemethod == 'transonly' then
        svo.echof(&quot;Will only use Transmutation minerals for curing.&quot;)
      elseif conf.curemethod == 'preferconc' then
        svo.echof(&quot;Will use Concoctions and Transmutation cures as you have them, but prefer Concoctions cures.&quot;)
      elseif conf.curemethod == 'prefertrans' then
        svo.echof(&quot;Will use Concoctions and Transmutation cures as you have them, but prefer Transmutation cures.&quot;)
      elseif conf.curemethod == 'prefercustom' then
        svo.echof(&quot;Will use your preferred Concoctions or Transmutation cures, falling back to the alternatives if you run out. See 'vshow curelist' for the adjustment menu.&quot;)
      else
        svo.echof(&quot;Will use Concoctions and Transmutation cures as you have them.&quot;)
      end
    end,
    -- onshow: done in vshow
    installstart = function () conf.curemethod = nil end,
    installcheck = function () svo.echof(&quot;Would you like to use Concoctions or Transmutation cures?\n\n  You can answer with 'conconly' - which'll mean that you'd like to use Concoctions cures only, 'transonly' - which'll mean that you'd like to use Transmutation cures only, 'preferconc' - prefer Concoctions cures, but fall back to Transmutation cures should you run out, and lastly, 'prefertrans' - prefer Transmutation cures, but fall back to Concoctions should you run out.&quot;) end
  }},
  {customprompt = {
    type = 'string',
    vconfig2 = true,
    onset = function ()
      if conf.customprompt == 'none' or conf.customprompt == 'off' or conf.customprompt == 'of' then
        conf.customprompt = false
        svo.echof(&quot;Custom prompt disabled.&quot;)
      elseif conf.customprompt == 'on' then
        if conf.oldcustomprompt ~= 'off' and conf.oldcustomprompt ~= 'of' then
          conf.customprompt = conf.oldcustomprompt
          svo.cp.makefunction()
          svo.echof(&quot;Custom prompt restored.&quot;)
          if svo.innews then
            svo.innews = false
            svo.echof(&quot;Disabled the news status and re-enabled the prompt.&quot;)
          end
        else
          svo.echof(&quot;You haven't set a custom prompt before, so we can't revert back to it. Set it with 'vconfig customprompt &lt;prompt line&gt;.&quot;)
          conf.customprompt = false
        end
      else
        svo.cp.makefunction()
        conf.oldcustomprompt = conf.customprompt
        svo.echof(&quot;Custom prompt enabled and set; will replace the standard one with yours now.&quot;)
      end
    end,
    installstart = function () conf.customprompt = nil; conf.setdefaultprompt = nil end
  }},
  {relight = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s auto-relight non-artifact pipes.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s auto-relight pipes.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.relight = true end,
    installcheck = function () svo.echof(&quot;Should we keep non-artifact pipes lit?&quot;) end
  }},
  {gagrelight = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide relighting of pipes.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide relighting pipes.&quot;, svo.getDefaultColor()) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(string.format(&quot;Re-light pipes quietly%s.\n&quot;, not conf.relight and &quot; (when relighting is on)&quot; or &quot;&quot;))
    end,
    installstart = function () conf.gagrelight = true end,
    installcheck = function () svo.echof(&quot;Should we hide it when pipes are relit (it can get spammy)?&quot;) end
  }},
  {gagotherbreath = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide others breathing.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide others breathing.&quot;, svo.getDefaultColor()) end,
    onshow = &quot;Completely gag others breathing&quot;,
    installstart = function () conf.gagotherbreath = true end
  }},
  {gagbreath = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide the breathing defence.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide the breathing defence.&quot;, svo.getDefaultColor()) end,
    onshow = &quot;Completely gag breathing&quot;,
    installstart = function () conf.gagbreath = true end,
    -- installcheck = function () svo.echof(&quot;Should we hide it when you use the breathing defence?&quot;) end
  }},
  {gageqbal = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide the 'you're off eq/bal' messages.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide the 'you're off eq/bal' messages.&quot;, svo.getDefaultColor()) end,
    onshow = &quot;Completely gag off eq/bal messages&quot;,
    installstart = function () conf.gageqbal = true end,
    installcheck = function () svo.echof(&quot;Should we hide the messages you get when you try and spam something off balance or equilibrium?&quot;) end
  }},
  {gagserverside = {
    type = 'boolean',
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Gag Svof's use of serverside priorities/toggles.\n&quot;)
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide info lines from the serverside curing system.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide info lines from the serverside curing system.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.gagserverside = true end,
  }},
  {gagservercuring = {
    type = 'boolean',
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Gag serverside [CURING] messages.\n&quot;)
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s hide serverside's [CURING] messages.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s hide serverside's [CURING] messages.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.gagservercuring = false end,
  }},
  {ccto = {
    type = 'string',
    onset = function ()
      conf.ccto = conf.ccto:lower()
      if conf.ccto == 'pt' or conf.ccto == 'party' then
        svo.echof(&quot;Will report stuff to party.&quot;)
      elseif conf.ccto == 'clt' then
        svo.echof(&quot;Will report stuff to the current selected clan.&quot;)
      elseif conf.ccto:find(&quot;^tell %w+&quot;) then
        svo.echof(&quot;Will report stuff to %s via tells.&quot;, conf.ccto:match(&quot;^tell (%w+)&quot;):title())
      elseif conf.ccto == 'ot' then
        svo.echof(&quot;Will report stuff to the Order channel.&quot;)
      elseif conf.ccto == 'team' then
        svo.echof(&quot;Will report stuff to the team channel.&quot;)
      elseif conf.ccto == 'army' then
        svo.echof(&quot;Will report stuff to the army channel.&quot;)
      elseif conf.ccto == 'echo' then
        svo.echof(&quot;Will echo ccto stuff back to you, instead of announcing it anywhere.&quot;)
      else
        svo.echof(&quot;Will report stuff to the %s clan.&quot;, conf.ccto)
      end
    end,
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(string.format(&quot;Reporting stuff to %s.\n&quot;, tostring(conf.ccto)))
    end,
    installstart = function ()
      conf.ccto = 'pt' end
  }},
  {mosshealth = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() svo.echof(&quot;Will eat moss/potash for health if it falls below %d%% (%dh).&quot;, conf.mosshealth, sys.mosshealth) end,
    installstart = function () conf.mosshealth = nil end,
    installcheck = function () svo.echof(&quot;At what %% of health do you want to start using moss/potash to heal, if enabled?&quot;) end
  }},
  {pagelength = {
    type = 'number',
    vconfig2string = true,
    min = 1,
    max = 250,
    onset = function () svo.echof(&quot;Will reset your pagelength to %d after changing it.&quot;, conf.pagelength) end,
    installstart = function () conf.pagelength = 20 end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Default pagelength to reset to is &quot;) fg('a_cyan')
      echoLink(tostring(conf.pagelength), 'printCmdLine&quot;vconfig pagelength &quot;',
      &quot;Set the default pagelength to reset to after changing it&quot;,
       true)
      cecho(&quot;&lt;a_grey&gt; lines.\n&quot;)
    end,
  }},
  {herbstatsize = {
    type = 'number',
    min = 1,
    max = 100,
    onset = function () rift.update_riftlabel(); svo.echof(&quot;Set the font size in the herbstat window to %d.&quot;, conf.herbstatsize) end,
    installstart = function () conf.herbstatsize = 9 end
  }},
  {mossmana = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() svo.echof(&quot;Will eat moss/potash for mana if it falls below %d%% (%dm).&quot;, conf.mossmana, sys.mossmana) end,
    installstart = function () conf.mossmana = nil end,
    installcheck = function () svo.echof(&quot;At what %% of mana do you want to start using moss/potash to heal, if enabled?&quot;) end
  }},
  {siphealth = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() svo.echof(&quot;Will start sipping health if it falls below %d%% (%dh).&quot;, conf.siphealth, sys.siphealth) end,
    installstart = function () conf.siphealth = nil end,
    installcheck = function () svo.echof(&quot;At what %% of health do you want to start sipping health?&quot;) end
  }},
  {sipmana = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() svo.echof(&quot;Will start sipping mana if it falls below %d%% (%dm).&quot;, conf.sipmana, sys.sipmana) end,
    installstart = function () conf.sipmana = nil end,
    installcheck = function () svo.echof(&quot;At what %% of mana do you want to start sipping mana?&quot;) end
  }},
  {refillat = {
    type = 'number',
    min = 0,
    max = 30,
    onset = function () svo.echof(&quot;Will start refilling pipes when they're at %d puffs.&quot;, conf.refillat) end,
    installstart = function () conf.refillat = 1 end
  }},
  {manause = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxmana:emit() svo.echof(&quot;Will use mana-draining skills if only above %d%% mana (%d).&quot;, conf.manause, sys.manause) end,
    installstart = function () conf.manause = 35 end,
    installcheck = function () svo.echof(&quot;Above which %% of mana is the system allowed to use mana skills? Like focus, insomnia, etc. If you got below this %%, it'll revert to normal cures.&quot;) end
  }},
  {lag = {
    type = 'number',
    min = 0,
    max = 4,
    onset = function () cnrl.update_wait() svo.echof(svo.wait_tbl[conf.lag].m) end,
    installstart = function () conf.lag = 0 end
  }},
  {unknownfocus = {
    type = 'number',
    min = 0,
    onset = function () svo.echof(&quot;Will diagnose after we have %d or more unknown, but focusable afflictions.&quot;, conf.unknownfocus) end,
    installstart = function ()
      if svo.haveskillset('healing') then
        conf.unknownfocus = 1
      else
        conf.unknownfocus = 2
      end
    end,
  }},
  {unknownany = {
    type = 'number',
    min = 0,
    onset = function () svo.echof(&quot;Will diagnose after we have %d or more unknown affs.&quot;, conf.unknownany) end,
    installstart = function ()
      if svo.haveskillset('healing') then
        conf.unknownany = 1
      else
        conf.unknownany = 2
      end
    end,
  }},
  {bleedamount = {
    type = 'number',
    vconfig2string = true,
    min = 0,
    onset = function () svo.echof(&quot;Will start clotting if bleeding for more than %d health.&quot;, conf.bleedamount) end,
    installstart = function () conf.bleedamount = 60 end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Will clot if bleeding for over &quot;) fg('a_cyan')
      echoLink(tostring(conf.bleedamount), 'printCmdLine&quot;vconfig bleedamount &quot;', &quot;Set the # of health bleeding above which the system will start clotting&quot;, true)
      fg(defaultcolour) echo(&quot; health or &quot;) fg('a_cyan')
      echoLink(tostring(conf.manableedamount), 'printCmdLine&quot;vconfig manableedamount &quot;', &quot;Set the # of mana bleeding above which the system will start clotting&quot;, true)
      fg(defaultcolour) echo(&quot; mana (and over &quot;) fg('a_cyan')
      echoLink(tostring(conf.corruptedhealthmin)..&quot;%&quot;, 'printCmdLine&quot;vconfig corruptedhealthmin &quot;', &quot;Set the % of health below which the system will not clot your mana bleeding (due tp Alchemist corruption, which makes bleeding lose mana and clotting it will use health)&quot;, true)
      fg(defaultcolour) echo(&quot; health)\n&quot;)
    end,
  }},
  {manableedamount = {
    type = 'number',
    vconfig2string = true,
    min = 0,
    onset = function () svo.echof(&quot;Will start clotting if bleeding for more than %d mana.&quot;, conf.manableedamount) end,
    installstart = function () conf.manableedamount = 60 end,
  }},
  {corruptedhealthmin = {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit() svo.echof(&quot;Will not clot your mana bleeding if your health falls below %d%% (%dh).&quot;, conf.corruptedhealthmin, sys.corruptedhealthmin) end,
    installstart = function () conf.corruptedhealthmin = 70 end
  }},
  {valerianid = {
    type = 'number',
    min = 0,
    installstart = function () conf.valerianid = nil; pipes.valerian.id = 0 end,
    installcheck = function () svo.echof(&quot;What pipe should we use for valerian? Answer with the ID, please.&quot;) end,
    onset = function ()
      pipes.valerian.id = tonumber(conf.valerianid)
      svo.echof(&quot;Set the valerian pipe id to %d.&quot;, pipes.valerian.id) end,
  }},
  {skullcapid = {
    type = 'number',
    min = 0,
    installstart = function () conf.skullcapid = nil; pipes.skullcap.id = 0 end,
    installcheck = function () svo.echof(&quot;What pipe should we use for skullcap? Answer with the ID, please.&quot;) end,
    onset = function ()
      pipes.skullcap.id = tonumber(conf.skullcapid)
      svo.echof(&quot;Set the skullcap pipe id to %d.&quot;, pipes.skullcap.id) end,
  }},
  {treefunc = {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use tree in:&quot;)
      local sortednames = svo.keystolist(svo.tree)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.tree[fname]

        if not me.disabledtreefunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disabledtreefunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'treefunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disabledtreefunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'treefunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline

      svo.showprompt()
    end
  }},
  {restorefunc = {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use restore in:&quot;)
      local sortednames = svo.keystolist(svo.restore)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.restore[fname]

        if not me.disabledrestorefunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disabledrestorefunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'restorefunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disabledrestorefunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'restorefunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline
      svo.showprompt()
    end
  }},
  {dragonhealfunc = {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use dragonheal in:&quot;)

      local sortednames = svo.keystolist(svo.dragonheal)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.dragonheal[fname]
        if not me.disableddragonhealfunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disableddragonhealfunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'dragonhealfunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disableddragonhealfunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'dragonhealfunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline
    end
  }},
  {elmid = {
    type = 'number',
    min = 0,
    installstart = function () conf.elmid = nil; pipes.elm.id = 0 end,
    installcheck = function () svo.echof(&quot;What pipe should we use for elm? Answer with the ID, please.&quot;) end,
    onset = function ()
      pipes.elm.id = tonumber(conf.elmid)
      svo.echof(&quot;Set the elm pipe id to %d.&quot;, pipes.elm.id) end,
  }},
  {eventaffs = {
    type = 'boolean',
    -- vconfig2 = true,
    -- onshow = &quot;Raise Mudlet events on each affliction&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s raise Mudlet events for gained/lost afflictions.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () conf.eventaffs = true svo.echof(&quot;eventaffs are on by default now - and this option is depreciated; there's no point in turning it off.&quot;) end,
    installstart = function () conf.eventaffs = true end
  }},
  {gagclot = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Gag clotting&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s gag the clotting spam.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s gag the clotting spam.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.gagclot = true end,
  }},
  {autorewield = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if next(gmcp) then
        echo &quot;Rewield forced unwield.\n&quot;
      else
        echo &quot;Rewield forced unwield (requires GMCP)\n&quot;
      end
    end,
    onenabled = function ()
      if sys.enabledgmcp then
        svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically rewield items that we've been forced to unwield.&quot;, svo.getDefaultColor())
      else
        svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically rewield items that we've been forced to unwield (requires GMCP being enabled).&quot;, svo.getDefaultColor())
      end
    end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically rewield things.&quot;, svo.getDefaultColor()) end
  }},
  {preclot = {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      if conf.preclot and conf.clot then
        echo &quot;Will preclot bleeding.\n&quot;
      elseif conf.preclot and not conf.clot then
        echo &quot;Will do preclotting (when clotting is enabled).\n&quot;
      else
        echo &quot;Won't preclot bleeding.\n&quot;
      end
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s do preclotting (saves health at expense of willpower).&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s do preclotting (saves willpwer at expense of health).&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.preclot = true end,
    installcheck = function () svo.echof(&quot;Should the system do preclotting? Doing so will save you from some bleeding damage, at the cost of more willpower.&quot;) end
  }},
  {org = {
    type = 'string',
    check = function (what)
      if svo.contains({'Ashtan', 'Hashan', 'Mhaldor', 'Targossas', 'Cyrene', 'Eleusis', 'None', 'Rogue'}, what:title()) then return true end
    end,
    onset = function ()
      if conf.org == 'none' or conf.org == 'rogue' then
        conf.org = 'none'
        -- reset echotype so the org change can have effect on echoes
        conf.echotype = nil
        signals.orgchanged:emit()
        svo.echof(&quot;Will use the default plain echoes.&quot;)
      else
        conf.org = string.title(conf.org)
        -- reset echotype so the org change can have effect on echoes
        conf.echotype = nil

        -- if NameDB is present, set own city to be allied - in case you weren't a citizen of this city before and it was an enemy to you
        if ndb and ndb.conf and type(ndb.conf.citypolitics) == 'table' then
          ndb.conf.citypolitics[conf.org] = 'ally'
        end

        signals.orgchanged:emit()
        svo.echof(&quot;Will use %s-styled echoes.&quot;, conf.org)
      end

    end,
    installstart = function ()
      conf.org = nil end,
    installcheck = function ()
      svo.echof(&quot;What city do you live in? Select from: Ashtan, Hashan, Mhaldor, Targossas, Cyrene, Eleusis or none.&quot;) end
  }},
  {slowcurecolour = {
    type = 'string',
    vconfig2string = true,
    check = function (what)
      if color_table[what] or what == 'off' then return true end
    end,
    onset = function ()
      local r,g,b = unpack(color_table[conf.slowcurecolour])
      svo.echof(&quot;Will colour your actions in &lt;%d,%d,%d&gt;%s%s when in aeon or retardation.&quot;, r,g,b, conf.slowcurecolour, svo.getDefaultColor())
    end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Colouring aeon/retardation curing lines in &quot;) fg(conf.slowcurecolour)
      echoLink(tostring(conf.slowcurecolour), 'printCmdLine&quot;vconfig slowcurecolour &quot;',
      &quot;Set which colour you'd like curing lines to show as in aeon / retardation&quot;,
       true)
      cecho(&quot;&lt;a_grey&gt;.\n&quot;)
    end,
    installstart = function ()
      conf.slowcurecolour = 'blue' end
  }},
  {hinderpausecolour = {
    type = 'string',
    vconfig2string = true,
    check = function (what)
      if color_table[what] or what == 'off' then return true end
    end,
    onset = function ()
      local r,g,b = unpack(color_table[conf.hinderpausecolour])
      svo.echof(&quot;Will colour hindering afflictions in &lt;%d,%d,%d&gt;%s%s when paused.&quot;, r,g,b, conf.hinderpausecolour, svo.getDefaultColor())
    end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Colouring hindering lines in &quot;) fg(conf.hinderpausecolour)
      echoLink(tostring(conf.hinderpausecolour), 'printCmdLine&quot;vconfig hinderpausecolour &quot;',
      &quot;Set which colour you'd like to see hindering lines in when paused&quot;,
       true)
      cecho(&quot;&lt;a_grey&gt; when paused.\n&quot;)
    end,
    installstart = function ()
      conf.hinderpausecolour = 'orange' end
  }},
  {autoreject = {
    type = 'string',
    check = function (what)
      if svo.contains({'black', 'white', 'off', 'on'}, what:sub(1,5):lower()) then sk.oldautoreject = conf.autoreject return true end
    end,
    onset = function ()
      conf.autoreject = string.lower(conf.autoreject):sub(1,5)

      if conf.autoreject == 'off' then
        svo.ignore.lovers = true
        conf.autoreject = sk.oldautoreject; sk.oldautoreject = nil
        svo.echof(&quot;Disabled autoreject completely (ie, will ignore curing lovers aff).&quot;)
      elseif conf.autoreject == 'on' then
        svo.ignore.lovers = nil
        conf.autoreject = sk.oldautoreject; sk.oldautoreject = nil
        svo.echof(&quot;Enabled autoreject (won't ignore curing lovers anymore) - right now it's in %slist mode.&quot;, conf.autoreject)
      elseif conf.autoreject == 'white' then
        local c = table.size(me.lustlist)
        svo.echof(&quot;Autoreject has been set to whitelist mode - that means we will be automatically rejecting everybody, except those on the lust list (%d %s).&quot;, c, (c == 1 and 'person' or 'people'))
      elseif conf.autoreject == 'black' then
        local c = table.size(me.lustlist)
        svo.echof(&quot;Autoreject has been set to blacklist mode - that means we will only be rejecting people on the lust list (%d %s).&quot;, c, (c == 1 and 'person' or 'people'))
      else
        svo.echof(&quot;... how did you manage to set the option to '%s'?&quot;, tostring(conf.autoreject))
      end
    end,
    installstart = function ()
      conf.autoreject = 'white' end
  }},
  {lustlist = {
    type = 'string',
    check = function(what)
      if what:find(&quot;^%w+$&quot;) then return true end
    end,
    onset = function ()
      local name = string.title(conf.lustlist)
      if not me.lustlist[name] then me.lustlist[name] = true else me.lustlist[name] = nil end

      if me.lustlist[name] then
        if conf.autoreject == 'black' then
          svo.echof(&quot;Added %s to the lust list (so we will be autorejecting them).&quot;, name)
        elseif conf.autoreject == 'white' then
          svo.echof(&quot;Added %s to the lust list (so we won't be autorejecting them).&quot;, name)
        else
          svo.echof(&quot;Added %s to the lust list.&quot;, name)
        end
      else
        if conf.autoreject == 'black' then
          svo.echof(&quot;Removed %s from the lust list (so we will not be autorejecting them now).&quot;, name)
        elseif conf.autoreject == 'white' then
          svo.echof(&quot;Removed %s from the lust list (so we will be autorejecting them).&quot;, name)
        else
          svo.echof(&quot;Removed %s from the lust list.&quot;, name)
        end
      end
    end
  }},
  {autowrithe = {
    type = 'string',
    check = function (what)
      if svo.contains({'black', 'white', 'off', 'on'}, what:sub(1,5):lower()) then sk.oldautowrithe = conf.autowrithe return true end
    end,
    onset = function ()
      conf.autowrithe = string.lower(conf.autowrithe):sub(1,5)

      if conf.autowrithe == 'off' then
        svo.ignore.hoisted = true
        conf.autowrithe = sk.oldautowrithe; sk.oldautowrithe = nil
        svo.echof(&quot;Disabled autowrithe completely (ie, will ignore curing hoisted aff).&quot;)
      elseif conf.autowrithe == 'on' then
        svo.ignore.hoisted = nil
        conf.autowrithe = sk.oldautowrithe; sk.oldautowrithe = nil
        svo.echof(&quot;Enabled autowrithe (won't ignore curing hoisted anymore) - right now it's in %slist mode.&quot;, conf.autowrithe)
      elseif conf.autowrithe == 'white' then
        local c = table.size(me.hoistlist)
        svo.echof(&quot;Autowrithe has been set to whitelist mode - that means we will be automatically writhing against everybody, except those on the hoist list (%d %s).&quot;, c, (c == 1 and 'person' or 'people'))
      elseif conf.autowrithe == 'black' then
        local c = table.size(me.hoistlist)
        svo.echof(&quot;Autowrithe has been set to blacklist mode - that means we will only be writhing against people on the hoist list (%d %s).&quot;, c, (c == 1 and 'person' or 'people'))
      else
        svo.echof(&quot;... how did you manage to set the option to '%s'?&quot;, tostring(conf.autowrithe))
      end
    end,
    installstart = function ()
      conf.autowrithe = 'white' end
  }},
  {hoistlist = {
    type = 'string',
    check = function(what)
      if what:find(&quot;^%w+$&quot;) then return true end
    end,
    onset = function ()
      local name = string.title(conf.hoistlist)
      if not me.hoistlist[name] then me.hoistlist[name] = true else me.hoistlist[name] = nil end

      if me.hoistlist[name] then
        if conf.autowrithe == 'black' then
          svo.echof(&quot;Added %s to the hoist list (so we will autowrithe against them).&quot;, name)
        elseif conf.autowrithe == 'white' then
          svo.echof(&quot;Added %s to the hoist list (so we won't autowrithe against them).&quot;, name)
        else
          svo.echof(&quot;Added %s to the hoist list.&quot;, name)
        end
      else
        if conf.autowrithe == 'black' then
          svo.echof(&quot;Removed %s from the hoist list (so we will not autowrithe against them now).&quot;, name)
        elseif conf.autowrithe == 'white' then
          svo.echof(&quot;Removed %s from the hoist list (so we will autowrithe against them).&quot;, name)
        else
          svo.echof(&quot;Removed %s from the hoist list.&quot;, name)
        end
      end
    end
  }},
  {echotype = {
    type = 'string',
    check = function (what)
      if svo.echos[what:title()] or svo.echos[what] then return true end
    end,
    onset = function ()
      conf.echotype = svo.echos[conf.echotype:title()] and conf.echotype:title() or conf.echotype
      signals.orgchanged:emit()
      svo.echof(&quot;This is how system messages will look like now :)&quot;)
    end,
    vconfig2 = true,
    installstart = function ()
      conf.org = nil end,
  }},
  {dragonflex = {
    type = 'boolean',
    vconfig1 = 'dragonflex',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use dragonflex when we have balance.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use dragonflex.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.dragonflex = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Dragonflex skill?&quot;) end
  }},
  {assumestats = {
    type = 'number',
    vconfig2 = true,
    min = 0,
    max = 100,
    onset = function () svo.echof(&quot;Will assume we're at %d%% of health and mana when under blackout or recklessness.&quot;, conf.assumestats) end,
    installstart = function () conf.assumestats = 15 end,
  }},
  {healthaffsabove = {
    type = 'number',
    vconfig2 = true,
    min = 0,
    max = 100,
    onset = function () svo.echof(&quot;Will apply health to cure afflictions only when above %d%% health.&quot;, conf.healthaffsabove) end,
    installstart = function () conf.healthaffsabove = 70 end,
  }},
  {warningtype = {
    type = 'string',
    vconfig2 = true,
    check = function (what)
      if svo.contains({'all', 'prompt', 'none', 'right', 'off'}, what) then return true end
    end,
    onset = function ()
      if conf.warningtype == 'none' or conf.warningtype == 'off' then
        conf.warningtype = false
        svo.echof(&quot;Disabled extended instakill warnings.&quot;)
      elseif conf.warningtype == 'all' then
        svo.echof(&quot;Will prefix instakill warnings to all lines.&quot;)
        if math.random(1, 10) == 1 then svo.echof(&quot;(muahah(&quot;) end
      elseif conf.warningtype == 'prompt' then
        svo.echof(&quot;Will prefix instakill warnings only to prompt lines.&quot;)
      elseif conf.warningtype == 'right' then
        svo.echof(&quot;Will place instakill warnings on all lines, aligned on the right side.&quot;)
      end
    end,
    installstart = function ()
      conf.warningtype = 'right' end,
  }},
  {burstmode = {
    type = 'string',
    vconfig2string = true,
    check = function (what)
      if defdefup[what:lower()] then return true end
    end,
    onshow = function (defaultcolour)
      local tooltip

      if svo.haveskillset('necromancy') then
        tooltip = &quot;Set the defences mode system should autoswitch to upon starburst/soulcage&quot;
      elseif svo.haveskillset('occultism') then
        tooltip = &quot;Set the defences mode system should autoswitch to upon starburst/transmog&quot;
      else
        tooltip = &quot;Set the defences mode system should autoswitch to upon starburst&quot;
      end

      fg(defaultcolour)
      echo(&quot;Upon starbursting, will go into &quot;) fg('a_cyan')
      echoLink(tostring(conf.burstmode), 'printCmdLine&quot;vconfig burstmode &quot;', tooltip, true)
      cecho(&quot;&lt;a_grey&gt; defences mode.\n&quot;)
    end,
    onset = function ()
      conf.burstmode = conf.burstmode:lower()
      if svo.haveskillset('necromancy') then
            svo.echof(&quot;Upon starburst/soulcage, will go into %s defences mode.&quot;, conf.burstmode)
      elseif svo.haveskillset('occultism') then
            svo.echof(&quot;Upon starburst/transmogrify, will go into %s defences mode.&quot;, conf.burstmode)
      else
            svo.echof(&quot;Upon starburst, will go into %s defences mode.&quot;, conf.burstmode)
      end
    end,
    installstart = function ()
      conf.burstmode = 'empty' end
  }},
  {oldts = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Touch shield only once on ts&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use oldschool ts - using ts one will shield once.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use oldschool ts - using ts will enable shield keepup.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.oldts = false end,
    installcheck = function () svo.echof(&quot;In Svof, &lt;0,255,0&gt;ts%s is a toggle for &lt;0,255,0&gt;vkeep shield%s - it'll reshield you if the shield gets stripped. Previously it used to shield you once only. Would you like to be a toggle (&lt;0,255,0&gt;vconfig oldts no%s) or a one-time thing (&lt;0,255,0&gt;vconfig oldts yes%s)?&quot;, svo.getDefaultColor(), svo.getDefaultColor(), svo.getDefaultColor(), svo.getDefaultColor()) end
  }},
  {batch = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Batch multiple curing commands&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s batch multiple curing commands to be done at once, without prompts inbetween.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s batch curing commands to be done at once, but instead send them separately at once.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.batch = true end,
  }},
  {steedfollow = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Auto-order steed to follow us&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s make the steed follow us when we dismount (via va).&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s make the steed follow us anymore when we dismount (via va).&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.steedfollow = true end
  }},
  {autotsc = {
    type = 'boolean',
    vconfig2 = true,
    onshow = &quot;Automatically toggle tsc in aeon/ret&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically toggle tsc - overrides in retardation and denies in aeon.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically toggle tsc.&quot;, svo.getDefaultColor()) end,
  }},
  {medprone = {
    type = 'boolean',
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg('a_cyan')
      echoLink((conf.medprone and 'Do' or &quot;Don't&quot;), 'printCmdLine&quot;vconfig medprone '..(conf.medprone and 'nope' or 'yep')..'&quot;',
      &quot;Click to set whenever you'd like the system to put prone on ignore while meditating for you, so you can sit down while doing it. The drawback is that if you're trying to meditate in combat and get proned, the system won't get up&quot;,
       true)
      fg(defaultcolour)
      echo(&quot; ignore prone while meditating, and &quot;)
      fg('a_cyan')
      echoLink((conf.unmed and 'do' or &quot;don't&quot;), 'printCmdLine&quot;vconfig unmed '..(conf.unmed and 'nope' or 'yep')..'&quot;',
      &quot;Click to set whenever you'd like the system take meditate off keepup when you reach full willpower&quot;,
       true)
      fg(defaultcolour)
      echo(&quot; stop at full willpower.\n&quot;)
    end,
    installstart = function() conf.medprone = false end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s put prone on ignore when meditating, so you can be sitting.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s put prone on ignore when meditating.&quot;, svo.getDefaultColor()) end,
  }},
  {unmed = {
    type = 'boolean',
    onshow = &quot;Automatically disable med with full wp&quot;,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s take meditate off keepup when you reach full willpower.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s take meditate off keepup when you reach full willpower - so we'll meditate again if you lose any mana/willpower.&quot;, svo.getDefaultColor()) end,
  }},
  {classattacksamount = {
    type = 'number',
    min = 0,
    vconfig2string = true,
    onset = function () svo.echof(&quot;Will enable a class after they hit us with %d attacks (within %d seconds).&quot;, conf.classattacksamount, conf.classattackswithin) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      -- Enable class as fighting with after x attacks in x seconds
      echo(&quot;Enable class as fighting with after&quot;) fg('a_cyan')
      echoLink(&quot; &quot;..tostring(conf.classattacksamount), 'printCmdLine&quot;vconfig classattacksamount &quot;',
      &quot;Set the amount of attacks an enemy will do to you within &quot;..tostring(conf.classattackswithin)..&quot; seconds to enable the class tricks&quot;,
       true)
      cecho(&quot;&lt;a_grey&gt; attacks in&quot;) fg('a_cyan')
      echoLink(&quot; &quot;..tostring(conf.classattackswithin), 'printCmdLine&quot;vconfig classattackswithin &quot;',
      &quot;Set the time within &quot;.. tostring(conf.classattacksamount).. &quot; attacks from a class will enable tricks for it&quot;,
       true)
      cecho(&quot; seconds.\n&quot;)
    end,
    installstart = function () conf.classattacksamount = 3 end
  }},
  {classattackswithin = {
    type = 'number',
    min = 0,
    onset = function () svo.echof(&quot;Will enable a class when they hit us within %d seconds (with %d attacks).&quot;, conf.classattackswithin, conf.classattacksamount) end,
    installstart = function () conf.classattackswithin = 15 end
  }},
  {enableclassesfor = {
    type = 'number',
    min = 0,
    vconfig2string = true,
    onset = function () svo.echof(&quot;Will keep the class enabled for %s minutes after the fighting ends.&quot;, conf.enableclassesfor) end,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      -- Keep a class enabled for x minutes after fighting
      echo(&quot;Keep a class enabled for&quot;) fg('a_cyan')
      echoLink(&quot; &quot;..tostring(conf.enableclassesfor), 'printCmdLine&quot;vconfig enableclassesfor &quot;',
      &quot;Set (in minutes) how long to keep a class enabled for after the fighting ends&quot;,
       true)
      cecho(&quot;&lt;a_grey&gt; minutes after fighting.\n&quot;)
    end,
    installstart = function () conf.enableclassesfor = 2 end
  }},
  {gmcpaffechoes = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s notify you when GMCP updates your afflictions.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s notify you when GMCP updates your afflictions.&quot;, svo.getDefaultColor()) end,
  }},
  {gmcpdefechoes = {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s notify you when GMCP updates your defences.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s notify you when GMCP updates your defences.&quot;, svo.getDefaultColor()) end,
  }},
  {releasechannel = {
    type = 'string',
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(&quot;Will use the &quot;)
      fg('a_cyan')
      echoLink(tostring(conf.releasechannel),
        'printCmdLine(&quot;vconfig releasechannel &quot;)',
        &quot;Set the release channel to use for updates.&quot;,
        true
      )
      fg(defaultcolour)
      echo(&quot; channel for downloading updates.\n&quot;)
    end,
    check = function (what)
      if what == 'stable' or what == 'testing' then return true end
    end,
    onset = function ()
      conf.releasechannel = conf.releasechannel:lower()
      svo.echof(&quot;Will use the '%s' release channel for updates.&quot;,
        conf.releasechannel)
    end,
    installstart = function ()
      conf.releasechannel = 'stable'
    end
  }},
}

if svo.haveskillset('healing') then
  svo.config_dict:insert(1, 'healingskill', {
    type = 'string',
    check = function (what)
      if table.contains({'blindness', 'paralysis', 'deafness', 'fear', 'confusion', 'insomnia', 'slickness', 'stuttering', 'paranoia', 'shyness', 'hallucinations', 'generosity', 'loneliness', 'impatience', 'unconsciousness', 'claustrophobia', 'vertigo', 'sensitivity', 'dizziness', 'arms', 'dementia', 'clumsiness', 'ablaze', 'recklessness', 'anorexia', 'agoraphobia', 'disloyalty', 'hypersomnia', 'darkshade', 'masochism', 'epilepsy', 'asthma', 'stupidity', 'vomiting', 'weariness', 'haemophilia', 'legs', 'hypochondria'}, what:lower()) then return true end
    end,
    onset = function ()
      conf.healingskill = conf.healingskill:lower()
      signals.healingskillchanged:emit()
      svo.echof(&quot;Thanks! That means that you can now cure:  \n%s&quot;, svo.oneconcat(sk.healingmap))
    end,
    vconfig2 = true,
    installstart = function ()
      conf.healingskill = nil end,
    installcheck = function ()
      svo.echof(&quot;What is the highest possible affliction that you can cure with Healing? If you don't have it yet, answer with 'blindness' and set 'none' for the 'usehealing' option.&quot;) end
  })
  svo.config_dict:insert(1, 'usehealing', {
    type = 'string',
    check = function (what)
      if table.contains({'full', 'partial', 'none', 'off'}, what:lower()) then return true end
    end,
    onset = function ()
      conf.usehealing = conf.usehealing:lower()
      if conf.usehealing == 'off' then conf.usehealing = 'none' end
      svo.echof(&quot;Will use Healing in the '%s' mode.&quot;, conf.usehealing)
    end,
    vconfig2 = true,
    installstart = function ()
      conf.usehealing = nil end,
    installcheck = function ()
      svo.echof(&quot;Do you want to use Healing skillset in the full, partial or none mode? Full would mean that it'll use Healing for everything that it can and supplement it with normal cures. Partial would mean that it'll use normal cures and supplement it with Healing, while none means it won't make use of Healing at all.&quot;) end
  })
end
if svo.haveskillset('kaido') then
  svo.config_dict:insert(1, 'transmute', {
    type = 'string',
    check = function (what)
      if svo.convert_string(what) == false then return true end
      if table.contains({'replaceall', 'replacehealth', 'supplement', 'none', 'off'}, what:lower()) then return true end
    end,
    onset = function ()
      conf.transmute = conf.transmute:lower()
      if svo.convert_string(conf.transmute) == false or conf.transmute == 'none' then
        conf.transmute = 'none'
      end

      if conf.transmute == 'off' then conf.transmute = 'none' end

      if conf.transmute == 'none' then
        svo.echof(&quot;Won't use transmute for anything.&quot;)
      else
        svo.echof(&quot;Will use transmute in the '%s' mode.&quot;, conf.transmute) end
    end,
    vconfig2 = true,
    installstart = function () conf.transmute = nil end,
    installcheck = function ()
      svo.echof(&quot;Do you want to use transmute skill in the replaceall, replacehealth, supplement or none mode? replaceall means that it won't sip health nor eat moss/potash to heal your health, but only use transmute. replacehealth will mean that it will not sip health, but use moss/potash and transmute. supplement means that it'll use all three ways to heal you, and none means that it won't use transmute.&quot;) end
  })
  svo.config_dict:insert(1, 'transmuteamount', {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    onset = function () signals.changed_maxhealth:emit()
      svo.echof(&quot;Will start transmuting for health if it falls below %d%% (%dh)%s.&quot;, conf.transmuteamount, sys.transmuteamount, (conf.transmute ~= 'none' and &quot;&quot; or &quot;, when you enable a transmute mode&quot;))
    end,
    installstart = function () conf.transmuteamount = nil end,
    installcheck = function () svo.echof(&quot;At what %% of health do you want to start transmuting for health?&quot;) end
  })
  svo.config_dict:insert(1, 'transsipprone', {
      type = 'boolean',
      vconfig2 = &quot;Transmute while prone&quot;,
      onenabled = function () svo.echof(&quot;If you're prone and using transmute in a replaceall or replacehealth mode, we &lt;0,250,0&gt;will%s sip health or vitality instead of waiting on transmute to be usable. This is most optimal for PK.&quot;, svo.getDefaultColor()) end,
      ondisabled = function () svo.echof(&quot;If you're prone and using transmute in a replaceall or replacehealth mode, we'll keep sipping mana and wait until we can use transmute again to heal our health. This is mainly good for bashing.&quot;, svo.getDefaultColor()) end,
      installstart = function () conf.transsipprone = true end
    })
end
if svo.haveskillset('voicecraft') then
  svo.config_dict:insert(1, 'dwinnu', {
    type = 'boolean',
    vconfig1 = 'dwinnu',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use dwinnu for writhing.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use dwinnu.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.dwinnu = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Wwinnu skill?&quot;) end
  })
end
if svo.haveskillset('weaponmastery') then
  svo.config_dict:insert(1, 'recoverfooting', {
      type = 'boolean',
      vconfig1 = &quot;recover footing&quot;,
      onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use Recover Footing to get up faster when we can.&quot;, svo.getDefaultColor()) end,
      ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use Recover Footing.&quot;, svo.getDefaultColor()) end,
      installstart = function () conf.recoverfooting = nil end,
      installcheck = function () svo.echof(&quot;Can you make use of the Recover Footing skill?&quot;) end
    })
end
if svo.haveskillset('venom') then
  svo.config_dict:insert(1, 'shruggingfunc', {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use shrugging in:&quot;)

      local sortednames = svo.keystolist(svo.shrugging)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.shrugging[fname]

        if not me.disabledshruggingfunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disabledshruggingfunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'shruggingfunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disabledshruggingfunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'shruggingfunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline
    end
  })
end
if svo.haveskillset('devotion') then
  svo.config_dict:insert(1, 'bloodswornoff', {
    type = 'number',
    percentage = true,
    min = 0,
    max = 100,
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo(string.format(&quot;Unlinking Bloodsworn at %s%% (%sh).\n&quot;, conf.bloodswornoff or '?', sys.bloodswornoff or '?'))
    end,
    onset = function () signals.changed_maxhealth:emit() svo.echof(&quot;Will unlink from bloodsworn if below %d%% (%dh).&quot;, conf.bloodswornoff, sys.bloodswornoff) end,
    installstart = function () conf.bloodswornoff = 30 end
  })
end
if svo.haveskillset('woodlore') then
  svo.config_dict:insert(1, 'weapon', {
    type = 'string',
    onset = function ()
      conf.weapon = conf.weapon:lower()
      svo.echof(&quot;Set your weapon to '%s'.&quot;, conf.weapon)
    end,
    vconfig2 = true,
    onshow = string.format(&quot;Using a %s as a weapon&quot;, (conf.weapon and tostring(conf.weapon) or &quot;(nothing)&quot;)),
    installstart = function ()
      conf.weapon = nil end,
    installcheck = function ()
      svo.echof(&quot;Are you using a spear or a trident as a weapon?&quot;) end
  })
end
if svo.haveskillset('metamorphosis') then
  svo.config_dict:insert(1, 'transmorph', {
    type = 'boolean',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Have%s transmorph - won't go human between morphing.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Don't%s have transmorph - will go human between morphing.&quot;, svo.getDefaultColor()) end,
    onshow = &quot;Have transmorph&quot;,
    installstart = function () conf.transmorph = nil end,
    installcheck = function () svo.echof(&quot;Do you have the Metamorphosis Transmorph skill?&quot;) end
  })
  svo.config_dict:insert(1, 'morphskill', {
    type = 'string',
    check = function (what)
      return sk.validmorphskill(what)
    end,
    onset = function ()
      conf.morphskill = conf.morphskill:lower()
      local t = {powers = 'squirrel', bonding = 'bear', transmorph = 'elephant', affinity = 'icewyrm'}
      if svo.me.class == 'Druid' then
            t.truemorph = 'hydra'
      else
            t.truemorph = 'icewyrm'
      end
      if t[conf.morphskill] then
        svo.echof(&quot;Thanks! I've set your morphskill to '%s' though, because %s isn't a morph.&quot;, t[conf.morphskill], conf.morphskill)
        conf.morphskill = t[conf.morphskill]
      end
      signals.morphskillchanged:emit()
      svo.echof(&quot;Given your morph skill, these are all defences you can put up: %s.&quot;, svo.concatand(svo.keystolist(sk.morphsforskill)) ~= &quot;&quot; and svo.concatand(svo.keystolist(sk.morphsforskill)) or &quot;(... none, actually. Nevermind!)&quot;)
    end,
    installstart = function () svo.sp_config.morphskill = nil end,
    installcheck = function () svo.echof(&quot;What is the highest available morph that you can go into?&quot;) end
  })
end
if not svo.haveskillset('tekura') then
  svo.config_dict:insert(1, 'parry', {
    type = 'boolean',
    vconfig1 = 'parry',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s make use of parry.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s make use of parry.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.parry = nil end,
    installcheck = function () svo.echof(&quot;Are you able to use parry?&quot;) end
  })
else
  svo.config_dict:insert(1, 'guarding', {
    type = 'boolean',
    vconfig1 = 'guarding',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s make use of guarding.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s make use of guarding.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.guarding = nil end,
    installcheck = function () svo.echof(&quot;Are you able to use guarding?&quot;) end
  })
end
if svo.haveskillset('shindo') then
  svo.config_dict:insert(1, 'shindodeaf', {
    type = 'boolean',
    vconfig1 = 'shindodeaf',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the Shindo deaf skill for deaf.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the Shindo deaf skill for deaf.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.shindodeaf = nil end,
    installcheck = function () svo.echof(&quot;Would you like to use Shindo deaf for deafness?&quot;) end
  })
  svo.config_dict:insert(1, 'shindoblind', {
    type = 'boolean',
    vconfig1 = 'shindoblind',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the Shindo blind skill for blind.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the Shindo blind skill for blind.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.shindoblind = nil end,
    installcheck = function () svo.echof(&quot;Would you like to use Shindo blind for blindness?&quot;) end
  })
end
if svo.haveskillset('kaido') then
  svo.config_dict:insert(1, 'kaidodeaf', {
    type = 'boolean',
    vconfig1 = 'kaidodeaf',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the kaido deaf skill for deaf.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the kaido deaf skill for deaf.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.kaidodeaf = nil end,
    installcheck = function () svo.echof(&quot;Would you like to use kaido deaf for deafness?&quot;) end
  })
  svo.config_dict:insert(1, 'kaidoblind', {
    type = 'boolean',
    vconfig1 = 'kaidoblind',
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use the kaido blind skill for blind.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use the kaido blind skill for blind.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.kaidoblind = nil end,
    installcheck = function () svo.echof(&quot;Would you like to use kaido blind for blindness?&quot;) end
  })
end
if svo.haveskillset('chivalry') or svo.haveskillset('shindo') or svo.haveskillset('kaido') or svo.haveskillset('metamorphosis') then
  svo.config_dict:insert(1, 'fitness', {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use fitness       (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'fitnessfunc'&quot;, &quot;View, enable and disable scenarios in which fitness will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use of Fitness.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use of Fitness.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.fitness = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Fitness skill?&quot;) end
  })
  svo.config_dict:insert(1, 'fitnessfunc', {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use fitness in:&quot;)
      local sortednames = svo.keystolist(svo.fitness)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.fitness[fname]

        if not me.disabledfitnessfunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disabledfitnessfunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'fitnessfunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disabledfitnessfunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'fitnessfunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline

      svo.showprompt()
    end
  })
end
if svo.haveskillset('venom') then
  svo.config_dict:insert(1, 'shrugging', {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use shrugging  (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'shruggingfunc'&quot;, &quot;View, enable and disable scenarios in which shrugging will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use shrugging to cure when necessary.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use shrugging to cure.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.shrugging = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the shrugging?&quot;) end
  })
end
if svo.haveskillset('chivalry') then
  svo.config_dict:insert(1, 'rage', {
    type = 'boolean',
    vconfig2 = true,
    onshow = function (defaultcolour)
      fg(defaultcolour)
      echo &quot;Use rage       (&quot;
      echoLink(&quot;view scenarios&quot;, &quot;svo.config.set'ragefunc'&quot;, &quot;View, enable and disable scenarios in which rage will be used&quot;)
      fg(defaultcolour) echo &quot;)\n&quot;
      resetFormat()
    end,
    onenabled = function () svo.echof(&quot;&lt;0,250,0&gt;Will%s use of Rage.&quot;, svo.getDefaultColor()) end,
    ondisabled = function () svo.echof(&quot;&lt;250,0,0&gt;Won't%s use of Rage.&quot;, svo.getDefaultColor()) end,
    installstart = function () conf.rage = nil end,
    installcheck = function () svo.echof(&quot;Can you make use of the Rage skill?&quot;) end
  })
  svo.config_dict:insert(1, 'ragefunc', {
    type = 'custom',
    onmenu = function ()
      local underline = setUnderline; _G.setUnderline = function () end

      svo.echof(&quot;Scenarios to use rage in:&quot;)
      local sortednames = svo.keystolist(svo.rage)
      table.sort(sortednames)
      local longestfname = svo.longeststring(sortednames)

      for i = 1, #sortednames do
        local fname = sortednames[i]
        local t = svo.rage[fname]

        if not me.disabledragefunc[fname] then
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;, [[svo.me.disabledragefunc[&quot;]]..fname..[[&quot;] = true; svo.config.set'ragefunc']], &quot;Disable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        else
          if dechoLink then
            dechoLink(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;, [[svo.me.disabledragefunc[&quot;]]..fname..[[&quot;] = false; svo.config.set'ragefunc']], &quot;Enable &quot;..fname, true)
          else
            decho(&quot;  &lt;153,204,204&gt;[&lt;0,204,0&gt; &lt;153,204,204&gt;]&quot;)
          end
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(string.format(&quot; %-&quot;..longestfname..&quot;s - %s\n&quot;, fname, tostring(t.desc)))
        end
      end

      _G.setUnderline = underline

      svo.showprompt()
    end
  })
end

if not conf.releasechannel then
  conf.releasechannel = 'stable'
end

if not conf.autowrithe then
  conf.autowrithe = 'white'
end

do
  local conf_t = {}
  local conf_path = getMudletHomeDir() .. &quot;/svo/config/conf&quot;

  if lfs.attributes(conf_path) then
    local ok, msg = pcall(table.load,conf_path, conf_t)
    if ok then
      svo.update(conf, conf_t)
    else
      os.remove(conf_path)
      tempTimer(10, function()
        svo.echof(&quot;Your vconfig file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-set all of the vconfig options again, though. (%q)&quot;, msg)
      end)
    end
  end

  if conf.ai_minherbbal == 0.7 or conf.ai_minherbbal == 1.2 then conf.ai_minherbbal = 1.1 end
  if conf.ai_resetherbbal == 5 then conf.ai_resetherbbal = 2.5 end
  -- recovered at 7.4s for Hirst for twohander aff
  if conf.ai_resetsipbal == 5 then conf.ai_resetsipbal = 7 end
  if conf.ai_resetsipbal == 7 then conf.ai_resetsipbal = 10 end
  if conf.org == 'Shallam' then conf.org = 'Targossas' end
  -- recovery was renamed as efficiency
  if conf.recovery then conf.efficiency = true; conf.recovery = nil end

  if conf.gagserverside == nil then conf.gagserverside = true end

  -- purgative used to be set at a default 5 before it was even used, it is now 7 for voyria
  if conf.ai_resetpurgativebal == 5 then conf.ai_resetpurgativebal = 10 end

  conf.eventaffs = true

  cnrl.update_wait()

  if conf.bashing then enableTrigger&quot;svo Bashing triggers&quot;
  else disableTrigger&quot;svo Bashing triggers&quot; end

  -- update whenever our riding takes up balance. If it doens't, then balanceless actions should be done asap
  if conf.freevault and svo.dict.riding.physical.balanceful_act then
    svo.dict.riding.physical.balanceless_act = true
    svo.dict.riding.physical.balanceful_act = nil
    signals.dragonform:emit()
  elseif not conf.freevault and svo.dict.riding.physical.balanceless_act then
    svo.dict.riding.physical.balanceless_act = nil
    svo.dict.riding.physical.balanceful_act = true
    signals.dragonform:emit()
  end

  if conf.burrowpause then
    signals.gmcproominfo:connect(sk.check_burrow_pause, 'check if we need to pause for burrow')
  end

  if not conf.customprompt and not conf.setdefaultprompt then
    tempTimer(math.random(10, 15), function()
      conf.setdefaultprompt = true
      svo.setdefaultprompt()
      -- disabled -- spammy for new users
      -- echo&quot;\n&quot; svo.echof(&quot;I've setup a custom prompt for you that mimics the normal Achaean one, but also displays which afflictions have you got. See http://doc.svo.vadisystems.com/#setting-a-custom-prompt on how to customize it if you'd like, or if you don't like it, do 'vconfig customprompt off' to disable it.&quot;)
      end)
  end

  if conf.singleprompt then
    sk.enable_single_prompt()
  end

  if conf.riftlabel then
    tempTimer(0, function()
      svo.riftlabel:show()
      rift.update_riftlabel()
    end)
  end
  svo.updateloggingconfig()
end

for k,v in svo.config_dict:iter() do
  -- pre-initialize values not declared
  if conf[k] == nil and v.type == 'number' then
    conf[k] = 0
  elseif conf[k] == nil then
    conf[k] = false
  end
end

local tntf_tbl
tntf_tbl = {
  aillusion = { -- is used to change appropriate conf. option
    shortcuts = {'ai', &quot;anti-illusion&quot;, 'a', 'antiillusion'},
    on = function () enableTrigger &quot;Pre-parse anti-illusion&quot;;
          svo.echof&quot;Anti-illusion enabled.&quot; end,
    alreadyon = function () enableTrigger &quot;Pre-parse anti-illusion&quot;;
          svo.echof&quot;Anti-illusion is already enabled.&quot; end,
    off = function () disableTrigger &quot;Pre-parse anti-illusion&quot;;
          svo.echof&quot;Anti-illusion disabled.&quot; end,
    alreadyoff = function () disableTrigger &quot;Pre-parse anti-illusion&quot;;
          svo.echof&quot;Anti-illusion is already disabled.&quot; end,
  },
  arena = {
    on = function()
      local echos = {&quot;Arena mode enabled. Good luck!&quot;, &quot;Beat 'em up! Arena mode enabled.&quot;, &quot;Arena mode on.&quot;, &quot;Arena mode enabled. Kill them all!&quot;}
            svo.echof(echos[math.random(#echos)])
    end,
    alreadyon = function() svo.echof(&quot;Arena mode is already on.&quot;) end,
    off = function() svo.echof(&quot;Arena mode disabled.&quot;) end,
    alreadyoff = function() svo.echof(&quot;Arena mode is already off.&quot;) end
  },
  keepup = {
    on = function () svo.echof&quot;Auto keepup on.&quot; svo.make_gnomes_work() end,
    alreadyon = function () svo.echof&quot;Auto keepup is already on.&quot; end,
    off = function () svo.echof&quot;Auto keepup is now off.&quot;svo.make_gnomes_work() end,
    alreadyoff = function() svo.echof&quot;Auto keepup is already off.&quot; end
  },
  bashing = {
    on = function () enableTrigger&quot;svo Bashing triggers&quot; svo.echof(&quot;Enabled bashing triggers.&quot;) end,
    alreadyon = function () svo.echof(&quot;Bashing triggers are already on.&quot;) end,
    off = function() disableTrigger&quot;svo Bashing triggers&quot; svo.echof(&quot;Disabled bashing triggers.&quot;) end,
    alreadyoff = function() svo.echof(&quot;Bashing triggers are already off.&quot;) end,
  },
  raid = {
    on = function ()
      svo.tntf_set('keepup', true, true)
      defs.switch('combat', true)
      svo.echof(&quot;Switched into combat defence mode and keeping mass, cloak, insomnia, rebounding defences up.&quot;)
      defs.keepup('mass', true)
      defs.keepup('cloak', true)
      defs.keepup('mass', true)
      defs.keepup('insomnia', true)
      defs.keepup('rebounding', true)
    end,
    off = function ()
      defs.switch('basic', true)
      svo.echof(&quot;Switched to basic defence mode.&quot;)
    end
  },
  serverside = {
    shortcuts = {'ss'},
    on = function()
      do
        -- if we've got nothing on the list, setup these defaults
        if not next(svo.serverignore) then
          local list = sk.getallserversideactions()

          for _, action in ipairs(list) do
            svo.serverignore[action] = true
          end

          svo.serverignore.impale     = false -- serverside does not stack writhing atm
          svo.serverignore.lovers     = false -- lust not handled by serverside
          svo.serverignore.selfishness = false -- doesn't take selfish off
        end
      end

      -- take previous ignores off
      local removelist = {}
      for action, data in pairs(svo.ignore) do
        if type(data) == 'table' and data.because == &quot;using server-side curing&quot; then
          removelist[#removelist+1] = action
        end
      end

      for _, action in ipairs(removelist) do
        svo.ignore[action] = nil
      end

      if next(removelist) then
        tempTimer(5, [[svo.echof(&quot;Took all affs set for serverside curing off ignore. 'vshow ignore' really means ignore again (both in Svof and serverside), use 'vshow server' to toggle what should be done by serverside or Svof.&quot;)]])
      end

      svo.echof(&quot;Serverside curing enabled (augmented with Svof's).&quot;)
      svo.setupserverside()
      svo.sendcuring(&quot;afflictions on&quot;)
      svo.sendcuring(&quot;sipping on&quot;)
      svo.sendcuring(&quot;defences on&quot;)
      svo.sendcuring(&quot;focus &quot; .. (conf.focus and 'on' or 'off'))
      svo.sendcuring(&quot;batch on&quot;)
      svo.sendc(&quot;config advancedcuring on&quot;)
      svo.sendcuring(&quot;reporting on&quot;)
      if not conf.paused then svo.sendcuring('on') end
    end,
    off = function()
      svo.echof(&quot;Serverside curing disabled.&quot;)
      svo.sendcuring('off')
    end,
    alreadyon = function() svo.echof(&quot;Serverside affliction curing is already on.&quot;) end,
    alreadyoff = function() svo.echof(&quot;Serverside affliction curing is already off.&quot;) end,
  }
}

for k,v in pairs(tntf_tbl) do
  if v.shortcuts then
    for _,shortcut in pairs(v.shortcuts) do
      tntf_tbl[shortcut] = k
    end
    v.real = k
  end
end

function svo.tntf_set(what, option, echoback)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end

  option = svo.convert_string(option)
  svo.assert(what and (option ~= nil), &quot;syntax is: svo.tntf(what, option)&quot;, sendf)

  if not tntf_tbl[what] then
    if echoback ~= 'noerrors' then sendf(&quot;%s isn't something you can change.&quot;, what) end
    return
  end

  local oldechof, oldshowprompt = svo.echof, svo.showprompt

  if echoback == false then
    svo.echof = function() end
    oldshowprompt = svo.echof
  end

  if type(tntf_tbl[what]) == 'string' then what = tntf_tbl[what] end
  if option and conf[what] then
    (tntf_tbl[what].alreadyon or tntf_tbl[what].on)()
  elseif not option and not conf[what] then
    (tntf_tbl[what].alreadyoff or tntf_tbl[what].off)()
  elseif not option then
    conf[what] = false
    tntf_tbl[what].off()
    raiseEvent(&quot;svo config changed&quot;, what)
  else
    conf[what] = true
    tntf_tbl[what].on()
    raiseEvent(&quot;svo config changed&quot;, what)
  end

  if echoback == false then
    svo.echof = oldechof
    svo.showprompt = oldshowprompt
  end

  if echoback then svo.showprompt() end

  return true
end

-- just display all options in 4 tabs
function svo.sk.show_all_confs()
  local count = 0
  local t = {}; for name, _ in svo.config_dict:iter() do t[#t+1] = name end; table.sort(t)

  for _, name in ipairs(t) do
    if printCmdLine then
      echoLink(string.format(&quot;%-20s&quot;, tostring(name)), 'printCmdLine(&quot;vconfig '..name..' &quot;)', conf_installhint(name), true)
    else
      echo(string.format(&quot;%-20s&quot;, tostring(name))) end
    count = count + 1
    if count % 4 == 0 then echo &quot;\n&quot; end
  end
end

function svo.config.setoption(name, data)
  svo.config_dict:set(name, data)
  if conf[name] == nil and svo.config_dict[name].type == 'number' then
    conf[name] = conf[name] or 0
  elseif conf[name] == nil then
    conf[name] = conf[name] or false
  end
end

function svo.config.deloption(name)
  if svo.config_dict[name] then
    svo.config_dict:set(name, nil)
  end
end

function svo.config.set(what, option, echoback)
  local sendf
  local showprompt = svo.showprompt
  local oldechof
  if echoback then
    sendf = svo.echof
  else
    sendf = svo.errorf
    -- hide echoes and prompt
    showprompt = function() end
    oldechof = svo.echof
    svo.echof = function() end
  end

  local function raiseevent(optionname)
    tempTimer(0, function() raiseEvent(&quot;svo config changed&quot;, optionname) end)
  end

  if not svo.config_dict[what] or what == 'list' or what == 'options' then
    sendf(&quot;%s - available ones are:&quot;, (what == 'list' or what == 'option') and &quot;Listing all options&quot; or &quot;Don't know about such an option&quot;)
    sk.show_all_confs()
    echo&quot;\n&quot;
    showprompt()
    if not echoback then svo.echof = oldechof end
    return
  end
  if svo.config_dict[what].type == 'boolean' then
    if (type(option) == 'boolean' and option == true) or svo.convert_string(option) or (option == nil and not conf[what]) then
      conf[what] = true
      svo.config_dict[what].onenabled()
      raiseevent(what)
    elseif (type(option) == 'boolean' and option == false) or not svo.convert_string(option) or (option == nil and conf[what]) then
      conf[what] = false
      svo.config_dict[what].ondisabled()
      raiseevent(what)
    else
      sendf(&quot;don't know about that option - try 'yes' or 'no' for %s.&quot;, what)
    end

  elseif svo.config_dict[what].type == 'number' then
    if not option or tonumber(option) == nil then
      if svo.config_dict[what].percentage then
        sendf(&quot;What percentage do you want to set %s to?&quot;, what)
      else
        sendf(&quot;What number do you want to set %s to?&quot;, what)
      end
      if not echoback then svo.echof = oldechof end
      return
    end

    local num = tonumber(option)
    if svo.config_dict[what].max and num &gt; svo.config_dict[what].max then
      sendf(&quot;%s can't be higher than %s.&quot;, what, svo.config_dict[what].max)
    elseif svo.config_dict[what].min and num &lt; svo.config_dict[what].min then
      sendf(&quot;%s can't be lower than %s.&quot;, what, svo.config_dict[what].min)
    else
      conf[what] = num
      svo.config_dict[what].onset()
      raiseevent(what)
    end

  elseif svo.config_dict[what].type == 'string' then
    if not option then sendf(&quot;What do you want to set %s to?&quot;, what)
      showprompt()
      if not echoback then svo.echof = oldechof end
      return
    end

    if svo.config_dict[what].check and not svo.config_dict[what].check(option) then
      sendf(&quot;%s isn't something you can set %s to be.&quot;, option, what)
      showprompt()
      if not echoback then svo.echof = oldechof end
      return
    end

    conf[what] = option
    svo.config_dict[what].onset()
    raiseevent(what)

  elseif svo.config_dict[what].type == 'custom' then
    if not option then
      if svo.config_dict[what].onmenu then
        svo.config_dict[what].onmenu()
      else
        sendf(&quot;What do you want to set %s to?&quot;, what)
        showprompt()
      end

    else
      if svo.config_dict[what].onset then
        svo.config_dict[what].onset()
        raiseevent(what)
      end
    end

  else
    sendf(&quot;meep... %s doesn't have a type associated with it. Tis broken.&quot;, what)
    showprompt()
  end

  if not echoback then svo.echof = oldechof end
  showprompt()
  if svo.install.installing_system then svo.install.check_install_step() end
  svo.make_gnomes_work()
end


signals.saveconfig:connect(function () svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/conf&quot;, conf) end, 'save settings config')

function svo.config.showcolours()
  svo.echof(&quot;Here's a list of available colors you can pick. To select, click on the name or use the %s command.&quot;, svo.green(&quot;vconfig echotype &lt;name&gt;&quot;))

  for name, f in pairs(svo.echos) do
    local s = &quot;  pick &quot;..tostring(name)..&quot; -  &quot;
    echo(&quot;  pick &quot;)
    echoLink(tostring(name), 'svo.config.set([[echotype]], &quot;'.. tostring(name) ..'&quot;, true)', 'Set it to '..tostring(name)..' colour style.', true)
    echo(&quot; -  &quot;)
    echo((&quot; &quot;):rep(30-#s)) f(true, &quot;this is how it'll look&quot;)
  end
end

function svo.config.showprompt()
  if not conf.customprompt then
    svo.echof(&quot;You don't have a custom prompt set currently.&quot;)
  else
    svo.echof(&quot;This is the script behind your custom prompt:\n&quot;)
    echo(conf.customprompt)
  end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Install system</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, signals = svo.sys, svo.signals
local conf, sk = svo.conf, svo.sk
local pipes, install = svo.pipes, svo.install

install.ids = install.ids or {}

-- same name as conf
-- function to say have/don't have
local installdata = {
  thirdeye = {
    gmcp = {group = 'vision', name = 'thirdeye'},
  },
  deathsight = {
    gmcp = {group = 'vision', name = 'deathsight'},
  },
  focus = {
    gmcp = {group = 'survival', name = 'focusing'},
  },
  efficiency = {
    gmcp = {group = 'survival', name = 'efficiency'}
  },
  restore = {
    gmcp = {group = 'survival', name = 'restoration'},
  },
  breath = {
    gmcp = {group = 'survival', name = 'breathing'},
  },
  pipes = {
    command = &quot;ii pipe&quot;,
    item = true,
    other = {
      pattern = [[^You are wielding:$]],
      script = [[
        svo.deleteAllP()
        svo.pipetrig = tempRegexTrigger([=[^ +pipe(\d+)]=],
          [=[
            tempTimer(0.02, [==[
              local r = svo.pipe_assignid(]==]..matches[2]..[==[)
              killTrigger(svo.pipetrig)
              if r then send(&quot;empty &quot;..r, false) svo.echof(&quot;Set the %s pipe id to %d.&quot;, r, ]==]..matches[2]..[==[) end
            ]==])
          ]=])
      ]]
    }
  },
  insomnia = {
    gmcp = {group = 'survival', name = 'insomnia'},
  },
  clot = {
    gmcp = {group = 'survival', name = 'clotting'},
  }
}

if svo.haveskillset('chivalry') then
  installdata.fitness = {
    command = &quot;ab chivalry fitness&quot;,
    gmcp = {group = 'chivalry', name = 'fitness'}}
elseif svo.haveskillset('kaido') then
  installdata.fitness = {
    command = &quot;ab kaido fitness&quot;,
    gmcp = {group = 'kaido', name = 'fitness'}}
elseif svo.haveskillset('shindo') then
  installdata.fitness = {
    command = &quot;ab striking fitness&quot;,
    gmcp = {group = 'striking', name = 'fitness'}}
end

if svo.haveskillset('venom') then
  installdata.shrugging = {
    gmcp = {group = 'venom', name = 'shrugging'}
  }
end
if svo.haveskillset('voicecraft') then
  installdata.dwinnu = {
    gmcp = {group = 'voicecraft', name = 'dwinnu'},
  }
end
if not svo.haveskillset('tekura') then
  installdata.parry = {
    gmcp = {group = 'weaponry', name = 'parrying'},
  }
else
  installdata.parry = {
    gmcp = {group = 'tekura', name = 'guarding'},
  }
end
if svo.haveskillset('chivalry') then
  installdata.rage = {
    gmcp = {group = 'chivalry', name = 'rage'},
  }
end
if svo.haveskillset('shindo') then
  installdata.shindodeaf = {
    gmcp = {group = 'shindo', name = 'deaf'},
  }
  installdata.shindoblind = {
    gmcp = {group = 'shindo', name = 'blind'},
  }
end
if svo.haveskillset('weaponmastery') then
  installdata.recoverfooting = {
    gmcp = {group = 'weaponmastery', name = 'recover'},
  }
end

function svo.installclear(what)
  if type(install.ids[what]) == 'table' then

    for _, id in pairs(install.ids[what]) do
      killTrigger(id)
      install.ids[what][_] = nil
    end
    install.ids[what] = nil

  else
    install.ids[what] = nil
  end

  if svo.installtimer then killTimer(svo.installtimer) end
  tempTimer(5+getNetworkLatency(), function ()
    if next(install.ids) then
      for thing, _ in pairs(install.ids) do
        if svo.config_dict[thing] and svo.config_dict[thing].type == 'boolean' then
          svo.config.set(thing, false, true)
        end

        svo.installclear(thing)
      end
    end

    svo.installtimer = nil

    if not next(install.ids) and not install.installing_system then
      echo&quot;\n&quot;
      svo.echof(&quot;auto-configuration done. :) question time!&quot;)
      echo&quot;\n&quot;
      install.ask_install_questions()
    end
  end)
end

function svo.installstart(fresh)
  if fresh and not sk.installwarning then
    svo.echof(&quot;Are you really sure you want to wipe everything (all remove all non-default defence modes, clear basic+combat defup/keepup to blank, remove all configuration options)? If yes, do vinstall fresh again.&quot;)
    if selectString('really', 1) ~= -1 then setUnderline(true) resetFormat() end
    svo.sk.installwarning = true
    return
  elseif fresh and sk.installwarning then
    local s, m = os.remove(getMudletHomeDir() .. &quot;/svo&quot;)
    if not s then svo.echof(&quot;Couldn't remove svo folder because of: %s&quot;, m) end

    svo.defdefup = {
      basic = {},
      combat = {},
    }

    svo.defkeepup = {
      basic = {},
      combat = {},
    }

    svo.echof(&quot;Vacuumed everything up!&quot;)
    svo.sk.installwarning = nil
  end

  for _, skill in pairs(install.ids) do
    if type(skill) == 'table' then
      for _, id in pairs(skill) do
        svo.installclear(id)
      end
    end
  end

  install.ids = {}
  local ids = install.ids

    for skill, skilldata in pairs(installdata) do
      if skilldata.gmcp then
        sendGMCP(&quot;Char.Skills.Get &quot;..yajl.to_string(skilldata.gmcp))
        ids[skill] = true
      end
    end

    sendGMCP(&quot;Char.Skills.Get &quot;..yajl.to_string{group = 'survival'})
    sendGMCP(&quot;Char.Items.Inv&quot;)
if svo.haveskillset('metamorphosis') then
    sendGMCP(&quot;Char.Skills.Get &quot;..yajl.to_string{group = 'metamorphosis'})
end
    signals.gmcpcharskillsinfo:unblock(install.checkskillgmcp)
    signals.gmcpcharitemslist:unblock(install.checkinvgmcp)
    signals.gmcpcharskillslist:unblock(install.checkskilllist)


  if sys.enabledgmcp then
    svo.echof(&quot;Starting auto-configuration - going to detect which skills and pipes you've got. Please wait 5 seconds for the questions to start.&quot;)
    printCmdLine(&quot;Please wait, doing auto-configuration...&quot;)
    echo&quot;\n&quot;
  else
    svo.echof(&quot;Please enable GMCP in Mudlet settings and restart before installing.&quot;)

    signals.gmcpcharskillsinfo:block(install.checkskillgmcp)
    signals.gmcpcharitemslist:block(install.checkinvgmcp)
    signals.gmcpcharskillslist:block(install.checkskilllist)

    for _, skill in pairs(install.ids) do
      if type(skill) == 'table' then
        for _, id in pairs(skill) do
          svo.installclear(id)
        end
      end
    end

    install.ids = {}

    return
  end

  send(&quot;config screenwidth 0&quot;, true)
  -- some newbies don't have the full prompt, just a -, which does not have the required info for the system
  -- for priests, make the balance show on the prompt - as healing others of blind/deaf takes no balance, while other other similar-looking lines do
  -- anyone else can see the class balance
  send(sys.ingamecustomprompt, false)

  -- defaults/reset
  for name, tbl in svo.config_dict:iter() do
    if tbl.installstart then tbl.installstart(); raiseEvent(&quot;svo config changed&quot;, name) end
  end
  pipes.elm.id, pipes.skullcap.id, pipes.valerian.id = 0,0,0

  if sys.enabledgmcp then
    local city = gmcp.Char.Status.city:match(&quot;^(%w+)&quot;)
    if city then svo.config.set('org', city, true) end

    if gmcp.Char.Status.level and tonumber(gmcp.Char.Status.level:match(&quot;^(%d+)&quot;)) &gt;= 99 then
      svo.config.set('dragonflex', true, true)
      svo.config.set('dragonheal', true, true)
    else
      svo.config.set('dragonflex', false, true)
      svo.config.set('dragonheal', false, true)
    end
  end
end

-- logic: set relevant conf's to nil, go through a table of specific ones - if one is nil, ask the relevant question for it. inside alias to toggle it, call install again.

svo.install.ask_install_questions = function ()
  if install.installing_system then return end

  install.installing_system = true
  install.check_install_step()
end

svo.install.check_install_step = function()
  for name, tbl in svo.config_dict:iter() do
    if conf[name] == nil and tbl.installcheck then
      echo &quot;\n&quot;
      tbl.installcheck()
      svo.conf_printinstallhint(name)

      if printCmdLine then
        printCmdLine(&quot;vconfig &quot;..name..&quot; &quot;)
      end

      return
    end
  end

  install.installing_system = false
  signals.gmcpcharskillsinfo:block(install.checkskillgmcp)
  signals.gmcpcharitemslist:block(install.checkinvgmcp)
  signals.gmcpcharskillslist:block(install.checkskilllist)
  echo&quot;\n&quot;
  svo.echof(&quot;All done installing! Congrats.&quot;)
  signals.saveconfig:emit()

  decho(svo.getDefaultColor()..&quot;If you'd like, you can also optionally setup the &quot;)
  echoLink('parry', 'svo.sp.setup()', 'parry')
  decho(svo.getDefaultColor()..&quot; system and the &quot;)
  echoLink(&quot;herb precache&quot;, 'svo.showprecache()', 'herb precache')
  decho(svo.getDefaultColor()..&quot; system. You can adjust the &quot;)
  echoLink(&quot;echo colours&quot;, 'svo.config.showcolours()', 'echo colours')
  decho(svo.getDefaultColor()..&quot; as well!&quot;)
  echo &quot;\n&quot;
  svo.echof(&quot;I'd recommend that you at least glimpse through my docs as well so you sort of know what are you doing :)&quot;)

  if not conf.customprompt and not conf.setdefaultprompt then
    svo.conf.setdefaultprompt = true
    svo.setdefaultprompt()
    echo&quot;\n&quot; svo.echof(&quot;I've setup a custom prompt for you that mimics the normal Achaean one, but also displays which afflictions have you got. See http://doc.svo.vadisystems.com/#setting-a-custom-prompt on how to customize it if you'd like, or if you don't like it, do 'vconfig customprompt off' to disable it.&quot;)
  end

  tempTimer(math.random(1,2), function ()
    echo&quot;\n&quot;
    svo.echof(&quot;Oh, and one last thing - QQ, restart Mudlet and login again, so all changes can take effect properly.&quot;)
  end)
end

function svo.install.checkskillgmcp()
  local t = _G.gmcp.Char.Skills.Info
  if not t then return end

  if t.skill == 'clotting' then t.skill = 'clot' end
  if t.skill == 'parrying' then t.skill = 'parry' end

  if conf[t.skill] == nil and (t.info == &quot;&quot; or t.info:find(&quot;You have not yet learned this ability&quot;)) then
    conf[t.skill] = false
    svo.echof(&quot;Don't have %s, so &lt;250,0,0&gt;won't%s be using it whenever possible.&quot;, t.skill, svo.getDefaultColor())
    raiseEvent(&quot;svo config changed&quot;, t.skill)
  elseif conf[t.skill] == nil then
    conf[t.skill] = true
    svo.echof(&quot;Have %s, so &lt;0,250,0&gt;will%s be using it whenever possible.&quot;, t.skill, svo.getDefaultColor())
    raiseEvent(&quot;svo config changed&quot;, t.skill)
  end

  svo.installclear(t.skill)
end
signals.gmcpcharskillsinfo:connect(install.checkskillgmcp, 'checkskillgmcp')
signals.gmcpcharskillsinfo:block(install.checkskillgmcp)

function svo.install.checkinvgmcp()
  local t = _G.gmcp.Char.Items.List
  if not t.location == 'inv' then return end

  -- feh! Easier to hardcode it for such a miniscule amount of items.
  -- If list enlarges, fix appopriately.
  for _, it in pairs(t.items) do
    if string.find(it.name, &quot;%f[%a]pipe%f[%A]&quot;) then
      local r = svo.pipe_assignid(it.id)
      if r then svo.echof(&quot;Set the %s pipe id to %d.&quot;, r, it.id) end
    end
  end

end
signals.gmcpcharitemslist:connect(install.checkinvgmcp, 'checkinvgmcp')
signals.gmcpcharitemslist:block(install.checkinvgmcp)


function svo.install.checkskilllist()
  local t = _G.gmcp.Char.Skills.List
  if t.group == 'survival' then
    for _, k in ipairs{{'focus', 'focusing'}, {'restore', 'restoration'}, {'insomnia', 'insomnia'}, {'clot', 'clotting'}, {'breath', 'breathing'}, {'efficiency', 'efficiency'}} do
      if svo.contains(t.list, k[2]:title()) then
        svo.config.set(k[1], true, true)
        svo.installclear(k[1])
      end
    end
  end

if svo.haveskillset('metamorphosis') then
  if t.group == 'metamorphosis' then
    for _, k in ipairs{'truemorph', 'hydra', 'wyvern', 'affinity', 'icewyrm', 'gorilla', 'eagle', 'jaguar', 'wolverine', 'transmorph', 'elephant', 'nightingale', 'bonding', 'bear', 'basilisk', 'sloth', 'gopher', 'condor', 'hyena', 'owl', 'cheetah', 'jackdaw', 'turtle', 'wolf', 'wildcat', 'powers', 'squirrel'} do
    if svo.contains(t.list, k:title()) then
      svo.config.set('morphskill', k, true)
      break
    end
  end

  svo.installclear('morphskill')
end
  end
end
signals.gmcpcharskillslist:connect(install.checkskilllist, 'checkskilllist')
signals.gmcpcharskillslist:block(install.checkskilllist)
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Alias functions</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, signals = svo.sys, svo.affs, svo.signals
local conf, sk, me, defc = svo.conf, svo.sk, svo.me, svo.defc
local defences, stats, cnrl, rift = svo.defences, svo.stats, svo.cnrl, svo.rift
local bals, pipes, valid = svo.bals, svo.pipes, svo.valid
local lifevision = svo.lifevision

function svo.togglesip(what)
  svo.assert(what == nil or what == 'health' or what == 'mana', &quot;svo.togglesip wants 'health' or 'mana' as an argument&quot;)

  local beforestate = sk.getbeforestateprios()

  local hp = svo.dict.healhealth.sip.aspriority
  local mp = svo.dict.healmana.sip.aspriority
  if what == nil or
    what == 'health' and hp &lt; mp or
    what == 'mana' and mp &lt; hp then
      hp, mp = mp, hp
  end
  svo.dict.healhealth.sip.aspriority = hp
  svo.dict.healmana.sip.aspriority = mp

  local function getstring(name)
    if name == 'healmana_sip' then return &quot;&lt;13,19,180&gt;mana&quot;
    elseif name == 'healhealth_sip' then return &quot;&lt;18,181,13&gt;health&quot;
    end
  end

  local prios = {}
  for _, j in ipairs({svo.dict.healhealth.sip, svo.dict.healmana.sip}) do
    prios[j.name] = j.aspriority
  end

  local result = svo.getHighestKey(prios)

  svo.echof(&quot;Swapped to &quot;  .. getstring(result) .. svo.getDefaultColor() .. &quot; sipping priority.&quot;)

  svo.make_gnomes_work()

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)
end

function svo.aupdate()
  openUrl(&quot;http://doc.svo.vadisystems.com/#updating-the-system&quot;)
  -- svo.echof(&quot;While we can't automatically update yet, here's the URL for you to download it at:&quot;)

  -- setFgColor(unpack(svo.getDefaultColorNums))
  -- for os, url in pairs(sys.downloadurl) do
  --   echo(&quot;  &quot;..os..&quot; - &quot;)
  --   setUnderline(true) echoLink(url, [[(openURL or openUrl)(&quot;]]..url..[[&quot;)]], &quot;Download &quot;..os..&quot; version&quot;, true) setUnderline(false)
  -- end
  -- resetFormat()
  -- svo.showprompt()
end

function svo.toggle_ignore(action)
  if not svo.dict[action] then
    svo.echofn(&quot;%s isn't something you can ignore - see &quot;, action)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;vshow ignorelist&quot;, 'svo.ignorelist()', 'Click to see things you can ignore', true)
    setUnderline(false)
    echo(&quot;.\n&quot;)
    svo.showprompt()
    return
  end

  if svo.ignore[action] then
    svo.unsetignore(action)
    svo.echof(&quot;Won't ignore %s anymore.&quot;, action)
  else
    svo.setignore(action)
    svo.echof(&quot;Will ignore curing %s now.&quot;, action)
  end
  svo.showprompt()
  svo.make_gnomes_work()
end

function svo.show_ignore()
  svo.echof(&quot;Things we're ignoring:%s&quot;, not next(svo.ignore) and &quot; (none)&quot; or '')

  setFgColor(unpack(svo.getDefaultColorNums))
  for key in pairs(svo.ignore) do
    echo(string.format(&quot;  %-18s&quot;, tostring(key)))
    echo(&quot;(&quot;)
    setUnderline(true)
    echoLink('remove', 'svo.ignore.'..tostring(key)..' = nil; svo.echof(&quot;Took '..tostring(key)..' off ignore.&quot;)', 'Remove '..tostring(key)..' from the ignore list', true)
    setUnderline(false)
    echo(&quot;)&quot;)

    if svo.dict[key] and svo.dict[key].description then
      echo(&quot; - &quot;..svo.dict[key].description)

      if type(svo.ignore[key]) == 'table' and svo.ignore[key].because then
        echo(&quot;, ignoring because &quot;..svo.ignore[key].because)
      end
      echo(&quot;\n&quot;)
    else
      if type(svo.ignore[key]) == 'table' and svo.ignore[key].because then
        echo(&quot; - because &quot;..svo.ignore[key].because)
      end
      echo(&quot;\n&quot;)
    end
  end
  svo.showprompt()
end

function svo.aconfigs()
  svo.echof(&quot;Doesn't do anything yet!&quot;)
end

function svo.aconfig()
  cecho(&quot;&lt;a_darkblue&gt;--&lt;purple&gt;(svo) &lt;a_grey&gt;Configuration&lt;a_darkblue&gt;&quot; .. (&quot;-&quot;):rep(59) .. &quot;\n&quot;)

  cecho(&quot;&lt;a_darkcyan&gt;  Automated healing:\n&quot;)
  cecho(&quot;&lt;a_darkgrey&gt;    Sipping:              Moss:\n&quot;)

  cecho(string.format(
    &quot;%s    (%s%-2d%%%s) %s%-4d %shealth%s %-4s&quot;
  ..&quot;(%s%-2d%%%s) %s%-4d %shealth%s %-4s\n&quot;,
    &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_darkcyan&gt;&quot;, tostring(conf.siphealth), &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, tostring(sys.siphealth), &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_darkgrey&gt;&quot;, &quot; &quot;,
    &quot;&lt;a_darkcyan&gt;&quot;, tostring(conf.mosshealth), &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, tostring(sys.mosshealth), &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_darkgrey&gt;&quot;, &quot; &quot;
  ))

  cecho(string.format(
    &quot;%s    (%s%-2d%%%s) %s%-4d %smana%s %-6s&quot;
  ..&quot;(%s%-2d%%%s) %s%-4d %smana%s %-6s\n&quot;,
    &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_darkcyan&gt;&quot;, conf.sipmana, &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, sys.sipmana, &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_darkgrey&gt;&quot;, &quot; &quot;,
    &quot;&lt;a_darkcyan&gt;&quot;, conf.mossmana, &quot;&lt;a_darkgrey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, sys.mossmana, &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_darkgrey&gt;&quot;, &quot; &quot;
  ))

  echo(&quot;\n&quot;)

  cecho(&quot;&lt;a_darkcyan&gt;  Curing status:\n&quot;)

  for k,v in svo.config_dict:iter() do
    if v.vconfig1 and conf[k] and not v.vconfig2 then
      cecho(&quot;  &quot;) fg('a_green')
      echoLink('  o  ', 'svo.config.set(&quot;'..k..'&quot;, false, true)', 'Click to disable '..k, true)
      cecho(&quot;&lt;a_grey&gt;Use &quot;..(type(v.vconfig1) == 'string' and v.vconfig1 or v.vconfig1())..&quot;.\n&quot;)
    elseif v.vconfig1 and not conf[k] and not v.vconfig2 then
      cecho(&quot;  &quot;) fg('a_red')
      echoLink('  x  ', 'svo.config.set(&quot;'..k..'&quot;, true, true)', 'Click to enable '..k, true)
      cecho(&quot;&lt;a_darkgrey&gt;Use &quot;..(type(v.vconfig1) == 'string' and v.vconfig1 or v.vconfig1())..&quot;.\n&quot;)
    end
  end

  echo&quot;\n&quot;

  for k,v in svo.config_dict:iter() do
    if not v.vconfig1 and type(v.onshow) == 'string' and conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_green')
      echoLink('  o  ', 'svo.config.set(&quot;'..k..'&quot;, false, true)', 'Click to disable '..k, true)
      cecho(&quot;&lt;a_grey&gt;&quot;..v.onshow..&quot;.\n&quot;)
    elseif not v.vconfig1 and type(v.onshow) == 'string' and not conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_red')
      echoLink('  x  ', 'svo.config.set(&quot;'..k..'&quot;, true, true)', 'Click to enable '..k, true)
      cecho(&quot;&lt;a_darkgrey&gt;&quot;..v.onshow..&quot;.\n&quot;)
    elseif not v.vconfig1 and type(v.onshow) == 'function' and conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_green')
      echoLink('  o  ', 'svo.config.set(&quot;'..k..'&quot;, false, true)', 'Click to disable '..k, true)
      v.onshow('a_grey')
    elseif not v.vconfig1 and type(v.onshow) == 'function' and not conf[k] and not v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_red')
      echoLink('  x  ', 'svo.config.set(&quot;'..k..'&quot;, true, true)', 'Click to enable '..k, true)
      v.onshow('a_darkgrey')
    end
  end

  echo&quot;\n&quot;

  if not printCmdLine or not type(conf.unknownany) == 'number' then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Diagnosing after &lt;a_cyan&gt;%s &lt;a_grey&gt;unknown (any) afflictions.\n&quot;, tostring(conf.unknownany)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Diagnosing after&quot;) fg('a_cyan')
    echoLink(' '..conf.unknownany..' ', &quot;printCmdLine'vconfig unknownany '&quot;, &quot;Click to set the # of any affs to diagnose at&quot;, true)
    cecho(&quot;&lt;a_grey&gt;unknown (any) afflictions.\n&quot;)
  end
  if not printCmdLine or not type(conf.unknownfocus) == 'number' then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Diagnosing after &lt;a_cyan&gt;%s &lt;a_grey&gt;unknown (focusable) afflictions.\n&quot;, tostring(conf.unknownfocus)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Diagnosing after&quot;) fg('a_cyan')
    echoLink(' '..conf.unknownfocus..' ', &quot;printCmdLine'vconfig unknownfocus '&quot;, &quot;Click to set the # of focusable affs to diagnose at - this is in addition to focusing on each unknown, but focusable affliction&quot;, true)
    cecho(&quot;&lt;a_grey&gt;unknown (focusable) afflictions.\n&quot;)
  end

  fg('a_darkblue')
  echo(string.rep(&quot;-&quot;, 62))
  fg('purple') setUnderline(true) echoLink('vconfig2', [[svo.aconfig2()]], &quot;View vconfig2 for advanced options&quot;, true) setUnderline(false)
  fg('a_darkblue') echo(string.rep(&quot;-&quot;, 9))
  resetFormat()
  echo&quot;\n&quot;
  svo.showprompt()
  echo&quot;\n&quot;
end

function svo.aconfig2()
  cecho(&quot;&lt;a_darkblue&gt;--&lt;purple&gt;(svo) &lt;a_grey&gt;Configuration, continued&lt;a_darkblue&gt;&quot; .. string.rep(&quot;-&quot;, 48) .. &quot;\n&quot;)

  cecho(&quot;&lt;a_darkcyan&gt;  Pipes:\n&quot;)
  -- cecho(&quot;&lt;a_darkgrey&gt;    Skullcap           Valerian           Elm\n&quot;)
  cecho(string.format(
    &quot;%s    %-21s&quot;
  ..&quot;   %-21s&quot;
  ..&quot;   %s\n&quot;,
    &quot;&lt;a_darkgrey&gt;&quot;,
    (pipes.skullcap.filledwith and pipes.skullcap.filledwith:title() or 'Skullcap') .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.filledwith2:title()..')'),
    (pipes.valerian.filledwith and pipes.valerian.filledwith:title() or 'Valerian') .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.filledwith2:title()..')'),
    (pipes.elm.filledwith and pipes.elm.filledwith:title() or 'Elm') .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.filledwith2:title()..')')
  ))

  cecho(string.format(
    &quot;%s    ID %s%-21s&quot;
  ..&quot;%sID %s%-21s&quot;
  ..&quot;%sID %s%s\n&quot;,
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.skullcap.id .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.id2..')'),
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.valerian.id .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.id2..')'),
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.elm.id .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.id2..')')
  ))

  cecho(string.format(
    &quot;%s    Puffs %s%-18s&quot;
  ..&quot;%sPuffs %s%-18s&quot;
  ..&quot;%sPuffs %s%-2s\n&quot;,
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.skullcap.puffs .. (pipes.skullcap.id2 == 0 and '' or ' ('..pipes.skullcap.puffs2..')'),
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.valerian.puffs .. (pipes.valerian.id2 == 0 and '' or ' ('..pipes.valerian.puffs2..')'),
    &quot;&lt;a_grey&gt;&quot;, &quot;&lt;a_cyan&gt;&quot;, pipes.elm.puffs .. (pipes.elm.id2 == 0 and '' or ' ('..pipes.elm.puffs2..')')
  ))

local c1,s1 =
    unpack(pipes.skullcap.arty and
        {&quot;&lt;gold&gt;&quot;, 'Arty'} or
            (pipes.skullcap.lit and {&quot;&lt;a_yellow&gt;&quot;, &quot;Lit!&quot;} or {&quot;&lt;a_darkgrey&gt;&quot;, &quot;Unlit.&quot;})

    )
local c2,s2 =
    unpack(pipes.valerian.arty and
        {&quot;&lt;gold&gt;&quot;, 'Arty'} or
            (pipes.valerian.lit and {&quot;&lt;a_yellow&gt;&quot;, &quot;Lit!&quot;} or {&quot;&lt;a_darkgrey&gt;&quot;, &quot;Unlit.&quot;})

    )
local c3,s3 =
    unpack(pipes.elm.arty and
        {&quot;&lt;gold&gt;&quot;, 'Arty'} or
            (pipes.elm.lit and {&quot;&lt;a_yellow&gt;&quot;, &quot;Lit!&quot;} or {&quot;&lt;a_darkgrey&gt;&quot;, &quot;Unlit.&quot;})

    )

  cecho(string.format(&quot;    %s%-24s%s%-24s%s%s\n\n&quot;,
    c1,s1,
    c2,s2,
    c3,s3
   ))

  cecho(&quot;&lt;a_darkcyan&gt;  Advanced options:\n&quot;)

  for k,v in svo.config_dict:iter() do
    if not v.vconfig1 and type(v.onshow) == 'string' and conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_green')
      echoLink('  o  ', 'svo.config.set(&quot;'..k..'&quot;, false, true)', 'Click to disable '..k, true)
      cecho(&quot;&lt;a_grey&gt;&quot;..v.onshow..&quot;.\n&quot;)
    elseif not v.vconfig1 and type(v.onshow) == 'string' and not conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_red')
      echoLink('  x  ', 'svo.config.set(&quot;'..k..'&quot;, true, true)', 'Click to enable '..k, true)
      cecho(&quot;&lt;a_darkgrey&gt;&quot;..v.onshow..&quot;.\n&quot;)
    elseif not v.vconfig1 and type(v.onshow) == 'function' and conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_green')
      echoLink('  o  ', 'svo.config.set(&quot;'..k..'&quot;, false, true)', 'Click to disable '..k, true)
      v.onshow('a_grey')
    elseif not v.vconfig1 and type(v.onshow) == 'function' and not conf[k] and v.vconfig2 and not v.vconfig2string then
      cecho(&quot;  &quot;) fg('a_red')
      echoLink('  x  ', 'svo.config.set(&quot;'..k..'&quot;, true, true)', 'Click to enable '..k, true)
      v.onshow('a_darkgrey')
    end
  end

  echo&quot;\n&quot;

  cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Using &quot;) setFgColor(unpack(svo.getDefaultColorNums))
  echoLink(tostring(conf.echotype and conf.echotype or conf.org), 'svo.config.showcolours()', &quot;View other available styles&quot;, true)
  cecho(&quot;&lt;a_grey&gt;-style echos.\n&quot;)

  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;%s\n&quot;, (function ()
      if not conf.warningtype then
        return &quot;Extended instakill warnings are disabled.&quot;
      elseif conf.warningtype == 'all' then
        if math.random(1, 10) == 1 then
          return &quot;Will prefix instakill warnings to all lines on the left. (muahah)&quot;
        else
          return &quot;Will prefix instakill warnings to all lines on the left.&quot; end
      elseif conf.warningtype == 'prompt' then
        return &quot;Will prefix instakill warnings only to prompt lines.&quot;
      elseif conf.warningtype == 'right' then
        return &quot;Will align instakill warnings to all lines on the right.&quot;
      end
    end)()))
  else
    cecho(&quot;    &lt;a_blue&gt;- &quot;)
    fg('a_grey')
    echoLink((function ()
      if not conf.warningtype then
        return &quot;Extended instakill warnings are disabled.&quot;
      elseif conf.warningtype == 'all' then
        if math.random(1, 10) == 1 then
          return &quot;Will prefix instakill warnings to all lines on the left. (muahah)&quot;
        else
          return &quot;Will prefix instakill warnings to all lines on the left.&quot; end
      elseif conf.warningtype == 'prompt' then
        return &quot;Will prefix instakill warnings only to prompt lines.&quot;
      elseif conf.warningtype == 'right' then
        return &quot;Will align instakill warnings to all lines on the right.&quot;
      end
    end)(), 'printCmdLine&quot;vconfig warningtype &quot;', &quot;Change the warningtype - can be all, prompt, right or none&quot;, true)
    cecho(&quot;\n&quot;)
  end

  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Assuming &lt;a_cyan&gt;%s%% &lt;a_grey&gt;of stats under blackout/recklessness.\n&quot;, tostring(conf.assumestats)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Assuming &quot;) fg('a_cyan')
    echoLink(tostring(conf.assumestats)..&quot;%&quot;, 'printCmdLine&quot;vconfig assumestats &quot;', &quot;Set the % of health and mana to assume under blackout or recklessness&quot;, true)
    cecho(&quot; &lt;a_grey&gt;of stats under blackout/recklessness.\n&quot;)
  end

  cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Applying for health affs only above &quot;) fg('a_cyan')
  echoLink(tostring(conf.healthaffsabove)..&quot;%&quot;, 'printCmdLine&quot;vconfig healthaffsabove &quot;', &quot;Set the % of health below which we'll be sipping, and above we'll be applying for health afflictions&quot;, true)
  cecho(&quot; &lt;a_grey&gt;health.\n&quot;)

  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Won't use mana skills below &lt;a_cyan&gt;%s%%&lt;a_grey&gt; mana.\n&quot;, tostring(conf.manause)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Won't use mana skills below &quot;) fg('a_cyan')
    echoLink(tostring(conf.manause)..&quot;%&quot;, 'printCmdLine&quot;vconfig manause &quot;', &quot;Set the % of mana below which the system won't use mana-draining skills&quot;, true)
    cecho(&quot;&lt;a_grey&gt; mana.\n&quot;)
  end

if svo.haveskillset('healing') then
  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Your highest Healing skill is &lt;a_darkgrey&gt;%s&lt;a_grey&gt;; using &lt;a_darkgrey&gt;%s&lt;a_grey&gt; Healing mode.\n&quot;, (conf.healingskill and conf.healingskill or &quot;(none set)&quot;), tostring(conf.usehealing)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Your highest Healing skill is &quot;) fg('a_darkgrey')
    echoLink(conf.healingskill and conf.healingskill or &quot;(none set)&quot;, 'printCmdLine&quot;vconfig healingskill &quot;', &quot;Click to change your healingskill&quot;, true)
    cecho(&quot;&lt;a_grey&gt;; using &quot;) fg('a_darkgrey')
    echoLink(tostring(conf.usehealing), 'printCmdLine&quot;vconfig usehealing &quot;', &quot;Click to change your healing mode - can be full, partial or none&quot;, true)
    cecho(&quot;&lt;a_grey&gt; Healing mode.\n&quot;)
  end
end
if svo.haveskillset('kaido') then
  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Transmuting if below &lt;a_cyan&gt;%d%%&lt;a_grey&gt; (&lt;a_cyan&gt;%dh&lt;a_grey&gt;); using &lt;a_darkgrey&gt;%s&lt;a_grey&gt; mode.\n&quot;, (conf.transmuteamount or &quot;?&quot;), (sys.transmuteamount or &quot;?&quot;), tostring(conf.transmute)))
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Transmuting if below&quot;) fg('a_cyan')
    echoLink(' '..(conf.transmuteamount or &quot;?&quot;)..'%', 'printCmdLine&quot;vconfig transmuteamount &quot;', &quot;Set the amount percent of max health below which transmute will be used&quot;, true)
    cecho(&quot;&lt;a_grey&gt; (&quot;) fg('a_cyan')
    echoLink((sys.transmuteamount or &quot;?&quot;)..'h', 'printCmdLine&quot;vconfig transmuteamount &quot;', &quot;Set the amount percent of max health below which transmute will be used&quot;, true)
    cecho(&quot;&lt;a_grey&gt;); using &quot;) fg('a_darkgrey')
    echoLink(tostring(conf.transmute), 'printCmdLine&quot;vconfig transmute &quot;', &quot;Set the mode in which to use transmute in - can be replaceall, replacehealth, supplement or none.  \nreplaceall means that it won't sip health nor eat moss to heal your health, but only use transmute.  \nreplacehealth will mean that it will not sip health, but use moss and transmute.  \nsupplement means that it'll use all three ways to heal you, and none means that it won't use transmute.&quot;, true)
    cecho(&quot;&lt;a_grey&gt; mode.\n&quot;)
  end
end
if svo.haveskillset('metamorphosis') then
  if not printCmdLine then
    cecho(string.format(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Your highest morph skill is &lt;a_darkgrey&gt;%s&lt;a_grey&gt; (&quot;, (conf.morphskill and conf.morphskill or &quot;(none set)&quot;)))
    echoLink(&quot;view defs you can do&quot;, 'svo.viewmetadefs()', &quot;View defences you can put up&quot;)
    echo(&quot;).\n&quot;)
  else
    cecho(&quot;    &lt;a_blue&gt;- &lt;a_grey&gt;Your highest morph skill is &quot;) fg('a_darkgrey')
    echoLink(conf.morphskill and conf.morphskill or &quot;(none set)&quot;, 'printCmdLine&quot;vconfig morphskill &quot;', &quot;Change the highest morph skill you have&quot;, true)
    cecho(&quot;&lt;a_grey&gt; (&quot;)
    echoLink(&quot;view defs you can do&quot;, 'svo.viewmetadefs()', &quot;View defences you can put up&quot;)
    echo(&quot;).\n&quot;)
  end
end
  if not conf.customprompt then
    cecho(&quot;    &lt;a_blue&gt;- &quot;) fg('a_grey')
    echoLink(&quot;Standard prompt is in use.&quot;, 'svo.config.set([[customprompt]], [[on]], true)', &quot;Enable custom prompt&quot;, true)
    echo(&quot;\n&quot;)
  else
    cecho(&quot;    &lt;a_blue&gt;- &quot;) fg('a_grey')
    echoLink(&quot;Custom prompt is in use&quot;, 'svo.config.set([[customprompt]], [[off]], true)', &quot;Disable custom prompt&quot;, true)
    echo(&quot; (&quot;)
    echoLink('view', 'svo.config.showprompt(); printCmdLine(&quot;vconfig customprompt &quot;..tostring(svo.conf.customprompt))', &quot;View the custom prompt you've currently set&quot;)
    echo(&quot;)&quot;)

    echo(&quot; (&quot;)
    echoLink(&quot;reset&quot;, 'svo.setdefaultprompt(); svo.echof(&quot;Default custom prompt restored.&quot;)', &quot;reset the custom prompt to default&quot;)
    cecho(&quot;&lt;a_grey&gt;)\n&quot;)
  end

  for _,v in svo.config_dict:iter() do
    if v.vconfig2string and type(v.onshow) == 'string' then
      cecho(&quot;    &lt;a_blue&gt;- &quot;)
      cecho(&quot;&lt;a_grey&gt;&quot;..v.onshow..&quot;.\n&quot;)

    elseif v.vconfig2string and type(v.onshow) == 'function' then
      cecho(&quot;    &lt;a_blue&gt;- &quot;)
      v.onshow('a_grey')
    end
  end


  fg('a_darkblue')
  echo(string.rep(&quot;-&quot;, 62))
  fg('purple') setUnderline(true) echoLink('vconfig', [[svo.aconfig()]], &quot;View vconfig for basic options&quot;, true) setUnderline(false)
  fg('a_darkblue') echo(string.rep(&quot;-&quot;, 10))
  resetFormat()

  echo&quot;\n&quot;
  svo.showprompt()
  echo&quot;\n&quot;
end

if svo.haveskillset('metamorphosis') then
function svo.viewmetadefs()
  svo.echof(&quot;You can put up any of these defences, given your morph skill:\n  %s&quot;, svo.oneconcat(sk.morphsforskill) ~= &quot;&quot; and svo.oneconcat(sk.morphsforskill) or &quot;(none, actually)&quot;)
end
end

function svo.asave()
  signals.saveconfig:emit()
  svo.showprompt()
end

function svo.ashow()
  svo.echof(&quot;Defence modes:&quot;)
  echo &quot;  &quot; defences.print_def_list()

  if sys.deffing then
    svo.echof(&quot;Currently deffing up; waiting on %s to come up.&quot;, sk.showwaitingdefup())
  end

  echo&quot;\n&quot;

  svo.echofn(&quot;View priorities (&quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(&quot;svo.reset all to default&quot;, 'svo.prio.usedefault(true)', &quot;Click here to svo.reset all of the systems curing/defup priorities back to default&quot;, true)
  setUnderline(false)
  echo(&quot;, &quot;)
  setUnderline(true)
  echoLink('import', 'svo.prio.list(true); printCmdLine&quot;vimportprio &quot;', &quot;Click here select a priority list to import&quot;, true)
  setUnderline(false)
  echo(&quot;, &quot;)
  setUnderline(true)
  echoLink('export', 'printCmdLine&quot;vexportprio &quot; ', &quot;Click here to give your priorities a name &amp; export them&quot;, true)
  setUnderline(false)
  echo(&quot;):\n&quot;)
  echo(&quot;  &quot;)
  setUnderline(true)
  echoLink('herb', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;herb&quot;)]])', 'View herb balance priorities', true)
  setUnderline(false) setUnderline(false) echo&quot;, &quot; setUnderline(true) setUnderline(true)
  echoLink('focus', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;focus&quot;)]])', 'View focus balance priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('salve', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;salve&quot;)]])', 'View salve balance priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('purgative', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;purgative&quot;)]])', 'View purgative balance priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('smoke', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;smoke&quot;)]])', 'View smoke priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('sip', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;sip&quot;)]])', 'View sip balance priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink(&quot;balance/equilibrium&quot;, 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;physical&quot;)]])', 'View balance priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('misc', 'tempTimer(0, [[echo([=[ \n]=]); svo.printorder(&quot;misc&quot;)]])', 'View miscellaneous priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink(&quot;aeon/retardation&quot;, 'tempTimer(0, [[echo([=[ \n]=]); svo.printordersync()]])', 'View slow curing priorities', true)
  setUnderline(false) echo&quot;, &quot; setUnderline(true)
  echoLink('parry', 'tempTimer(0, [[echo([=[ \n]=]); svo.sp.show()]])', 'View the parry setup', true)
  resetFormat()
  echo&quot;\n&quot;

  svo.echofn(&quot;Serverside use:   &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.serverside and 'enabled' or 'disabled', &quot;svo.tntf_set('serverside', &quot;..(conf.serverside and 'false' or 'true').. ', false); svo.ashow()', (conf.serverside and 'Disable' or 'Enable')..' use of serverside by Svof', true)
  resetFormat()
  echo&quot;\n&quot;


  svo.echofn(&quot;Anti-illusion:    &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.aillusion and 'enabled' or 'disabled', &quot;svo.tntf_set('ai', &quot;..(conf.aillusion and 'false' or 'true').. ', false); svo.ashow()', (conf.aillusion and 'Disable' or 'Enable')..' anti-illusion', true)
  resetFormat()
  echo&quot;\n&quot;

  svo.echofn(&quot;Defence keepup:   &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.keepup and 'enabled' or 'disabled', &quot;svo.tntf_set('keepup', &quot;..(conf.keepup and 'false' or 'true').. ', false); svo.ashow()', (conf.keepup and 'Disable' or 'Enable')..' keepup', true)
  resetFormat()
  echo&quot;\n&quot;

  svo.echofn(&quot;Bashing triggers: &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.bashing and 'enabled' or 'disabled', &quot;svo.tntf_set('bashing', &quot;..(conf.bashing and 'false' or 'true').. ', false); svo.ashow()', (conf.bashing and 'Disable' or 'Enable')..' bashing triggers', true)
  resetFormat()
  echo&quot;\n&quot;

  svo.echofn(&quot;Arena mode:       &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(conf.arena and 'enabled' or 'disabled', &quot;svo.tntf_set('arena', &quot;..(conf.arena and 'false' or 'true').. ', false); svo.ashow()', (conf.arena and 'Disable' or 'Enable')..' arena triggers', true)
  resetFormat()
  echo&quot;\n&quot;

echo&quot;\n&quot;
  svo.echofn(&quot;Cure method: &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(tostring(conf.curemethod), [=[
    svo.echof([[Possible options are:
  * conconly - default - uses only the usual Concoctionist potions, salves and herbs
  * transonly - uses only the new Alchemy cures
  * preferconc - uses either available cures that you have, but prefers Concoctions ones. This method does optimize for curing speed - if you don't have a herb in your inventory but have an equivalent mineral, it'll eat the mineral since it's quicker (don't have to outr the herb)
  * prefertrans - similar to preferconc, but prefers Transmutation cures
  * prefercustom - allows you to individually select which cures would you prefer over which, using the vshow curelist menu. Similar to other prefers, the system will use your preferred cure if you have it and fall back to the alternative if you don't. If the cure is a herb/mineral and your preferred cure is in the rift but the alternative is already available in the inventory, then the system will eat the alternative, because that is faster than outring it.]]);
    printCmdLine&quot;vconfig curemethod &quot;]=], &quot;Set the curemethod to use - conconly, transonly, preferconc, prefertrans or prefercustom&quot;, true)
  setUnderline(false)

  if conf.curemethod and conf.curemethod == 'prefercustom' then
    echo(&quot; (&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;configure it&quot;, 'svo.showcurelist()', &quot;Setup which cures would you prefer over which for prefercustom - also accessible via vshow curelist&quot;, true)
    setUnderline(false)
    setFgColor(unpack(svo.getDefaultColorNums))
    echo(&quot;)&quot;)
  end
  echo&quot;\n&quot;

  svo.echofn(&quot;Current parry strategy is:  &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  local spname
  if not svo.sp_config.parry or svo.sp_config.parry == '' then
    spname = &quot;(none)&quot;
  elseif type(svo.sp_config.parry) == 'function' then
    spname = &quot;(custom &quot;..tostring(svo.sp_config.parry)..&quot;)&quot;
  else
    spname = tostring(svo.sp_config.parry)
  end

  echoLink(spname, 'svo.sp.setparry(nil, true)', 'Click to change the parry strategy. When in &quot;manual&quot;, use the p* (pra, pla, ph, etc...) alises to parry/guard with', true)
  setUnderline(false)
  echo'\n'

  if me.doqueue.repeating then
    svo.echof(&quot;Do-Repeat is enabled: %s&quot;, tostring(me.doqueue[1]) or &quot;(nothing yet)&quot;) end


  if conf.curemethod and (conf.curemethod == 'preferconc' or conf.curemethod == 'prefertrans') then
    svo.echofn(&quot;Cure method is %s: &quot;, tostring(conf.curemethod))
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;svo.reset sip alternatives&quot;, [[
      svo.es_potions = svo.es_potions or {}
      for thing, category in pairs(svo.es_categories) do
        svo.es_potions[category] = svo.es_potions[category] or {}
        if category ~= 'venom' then
          svo.es_potions[category][thing] = {sips = 1, vials = 1, decays = 0}
        end
      end
      svo.echof(&quot;svo.reset alternatives, will use the preferred potions now.&quot;)
    ]], 'svo.reset sipping alternatives for '..tostring(conf.curemethod)  , true)
    setUnderline(false)
    echo(&quot;\n&quot;)
  end

  if conf.lag ~= 0 then
    svo.echof(&quot;Lag tolerance level: %d&quot;, conf.lag)
  end

  local c = table.size(me.lustlist)
  if conf.autoreject == 'black' then
    svo.echofn(&quot;People we're autorejecting:  %s &quot;, (c ~= 0 and c or 'none'))
  elseif conf.autoreject == 'white' then
    svo.echofn(&quot;People we're not autorejecting: %s &quot;, (c ~= 0 and c or 'none'))
  end

  if conf.autoreject ~= 'off' then
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(view)&quot;, 'echo&quot;\\n&quot; expandAlias&quot;vshow lustlist&quot;', 'Click here view the names', true)
    echo&quot;\n&quot;
  end

  c = table.size(me.hoistlist)
  if conf.autowrithe == 'black' then
    svo.echofn(&quot;People we're writhing against:  %s &quot;, (c ~= 0 and c or 'none'))
  elseif conf.autowrithe == 'white' then
    svo.echofn(&quot;People we're not writhing against: %s &quot;, (c ~= 0 and c or 'none'))
  end

  if conf.autowrithe ~= 'off' then
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(view)&quot;, 'echo&quot;\\n&quot; expandAlias&quot;vshow hoistlist&quot;', 'Click here view the names', true)
    echo&quot;\n&quot;
  end

  if next(me.unparryables) then
    svo.echofn(&quot;Things we can't use for parrying: %s &quot;, svo.oneconcat(me.unparryables))

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(svo.reset)&quot;, 'echo&quot;\\n&quot; svo.me.unparryables = {} svo.echof&quot;Cleared list of stuff we can\'t parry with.&quot;', 'Click here to svo.reset', true)
    echo&quot;\n&quot;
  end

  do
    local herbcount = 0
    for _, count in pairs(rift.precache) do
      herbcount = herbcount + count
    end

    svo.echofn(&quot;# of herbs we're precaching: %d &quot;, herbcount)

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(view)&quot;, 'echo&quot;\\n&quot; svo.showprecache()', 'Click here open the menu for precache', true)
    echo&quot;\n&quot;
  end

  do
    local ignorecount = table.size(svo.ignore)

    svo.echofn(&quot;# of things we're ignoring:  %d &quot;, ignorecount)

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(view)&quot;, 'echo&quot;\\n&quot; svo.show_ignore()', 'Click here open the ignore list menu', true)
    echo&quot;\n&quot;
  end

  if next(affs) then
    svo.showaffs()
  end

  if conf.customprompt and (affs.blackout or svo.innews) then
    svo.echofn(&quot;Custom prompt is enabled, but not showing due to %s. &quot;,
      (function ()
        local t = {}
        if affs.blackout then t[#t+1] = 'blackout' end
        if svo.innews then t[#t+1] = &quot;being in the editor&quot; end
        return svo.concatand(t)
      end
    )())
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;(svo.reset)&quot;, 'svo.config.set(&quot;customprompt&quot;, &quot;on&quot;)', 'Click here to re-enable the custom prompt', true)
    echo&quot;\n&quot;
  end

  if conf.paused then
    svo.echof(&quot;System is currently paused.&quot;) end
  if me.dopaused then
    svo.echof(&quot;Do system is currently paused.&quot;) end

  if sk.gettingfullstats then
    svo.echof(&quot;Healing health and mana to up to full stats (cancel).&quot;) end

  -- warn people if they have mana above health as sip priority by accident
  if svo.prio.getnumber('healmana', 'sip') &gt; svo.prio.getnumber('healhealth', 'sip') then
    svo.echofn(&quot;Your mana sip priority is above health sipping (&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true) echoLink('change', 'svo.togglesip(&quot;health&quot;)', 'Click to change to health', true) setUnderline(false)
    echo(&quot;)\n&quot;)
  end

  raiseEvent(&quot;svo onshow&quot;)

  svo.showprompt()
end


function svo.showaffs(window)
  if sys.sync then svo.echof(window or 'main', &quot;Slow curing mode enabled.&quot;) end
  svo.echof(window or 'main', &quot;Current list of affs: &quot; .. tostring(affs))
end

function svo.showbals(window)
  svo.echof(window or 'main', &quot;Balance state: &quot; ..
    (function (tbl)
      local result = {}
      for i,j in pairs(tbl) do
        if j then
          result[#result+1] = string.format(&quot;&lt;50,205,50&gt;%s%s&quot;, i,svo.getDefaultColor())
        else
          result[#result+1] = string.format(&quot;&lt;205,201,201&gt;%s (off)%s&quot;, i,svo.getDefaultColor())
        end
      end

      table.sort(result)
      return table.concat(result, &quot;, &quot;)
    end)(bals))
    svo.showprompt()
end

function svo.showserverside()
  local function echoaction(action, last)
    dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;%s&lt;153,204,204&gt;] %&quot;..(last and '' or '-23')..'s',
      svo.serverignore[action] and ' ' or 'x', action),
      string.format([[svo.%ssetserverignore(&quot;%s&quot;); svo.showserverside()]], svo.serverignore[action] and 'un' or '', action),
      svo.serverignore[action] and ('Make Svof handle '..action..' instead of serverside') or ('Make serverside handle '..action..' instead of Svof'), true)
  end

  local actions = sk.getallserversideactions()

  svo.echof(&quot;Things serverside can do but Svof will be handling instead:&quot;)
  for i = 1, #actions, 3 do
    local action1, action2, action3 = actions[i], actions[i+1], actions[i+2]

    echoaction(action1)
    if action2 then echoaction(action2) end
    if action3 then echoaction(action3, true) end
    echo'\n'
  end

  echo'\n'

  if not conf.serverside then
    dechoLink(svo.getDefaultColor()..&quot;  (enable serverside use)&quot;, 'svo.tntf_set(&quot;serverside&quot;, true)', 'Serverside use is disabled - click here to enable it', true)
    echo'\n'
  end

  dechoLink(svo.getDefaultColor()..&quot;  (disable all)&quot;, 'svo.enableallserverside()', 'Click here to make serverside handle everything', true)
  dechoLink(svo.getDefaultColor()..&quot;  (restore defaults)&quot;, 'svo.enabledefaultserverside()', 'Click here to restore default options', true)
  echo'\n'
  svo.showprompt()
end

function svo.enableallserverside()
  local actions = sk.getallserversideactions()

  for i = 1, #actions do
    local action = actions[i]

    svo.setserverignore(action)
  end

  svo.echof(&quot;Disabled all serverside overrides; serverside will now handle everything.&quot;)
  svo.showprompt()
end

function svo.enabledefaultserverside()
  svo.unsetserverignore'impale'
  svo.unsetserverignore'lovers'
  svo.unsetserverignore'roped'
  svo.unsetserverignore'transfixed'
  svo.unsetserverignore'webbed'
  svo.unsetserverignore'selfishness'

  svo.echof(&quot;Restored defaults on what should Svof handle instead of serverside.&quot;)
  svo.showprompt()
end

function svo.showcurelist()
  local herb_list  = rift.curativeherbs
  local herbs      = rift.herb_conversions

  local function showfor(list, conversion)
    for i = 1, #list do
      local forestal, alchy = list[i], conversion[list[i]]
      local preferred = me.curelist[forestal]

      if forestal == preferred then -- split the logic instead of stuffing into one uncomprehensible string.format
        cecho(string.format(&quot;&lt;white&gt;%15s&quot;, forestal))
      else
        cechoLink(string.format(&quot;&lt;dim_grey&gt;%15s&quot;, forestal), [[svo.me.curelist.]]..forestal..[[ = &quot;]]..forestal..[[&quot;; svo.showcurelist()]], &quot;Click to prefer &quot;..forestal..&quot; over &quot;..alchy, true)
      end

      cechoLink(&quot; &lt;royal_blue&gt;&lt;&lt;BlueViolet&gt;-&lt;royal_blue&gt;&gt; &quot;, [[svo.me.curelist.]]..forestal..[[ = &quot;]]..(forestal == preferred and alchy or forestal)..[[&quot;; svo.showcurelist()]], &quot;Click to swap &quot;..forestal..&quot; and &quot;..alchy..&quot; cures&quot;, true)

      if alchy == preferred then
        cecho(string.format(&quot;&lt;white&gt;%-15s&quot;, alchy))
      else
        cechoLink(string.format(&quot;&lt;dim_grey&gt;%-15s&quot;, alchy), [[svo.me.curelist.]]..forestal..[[ = &quot;]]..alchy..[[&quot;; svo.showcurelist()]], &quot;Click to prefer &quot;..alchy..&quot; over &quot;..forestal, true)
      end

      echo(&quot;\n&quot;)
    end
  end

  svo.echof(&quot;Click on what you'd like to be preferred in prefercustom curemethod:\n&quot;)
  decho(string.format(&quot;%s            herbs/minerals\n&quot;, svo.getDefaultColor()))

  showfor(herb_list, herbs)

  if conf.curemethod ~= 'prefercustom' then
    echo&quot;\n&quot;
    svo.echofn(&quot;This is the setup for the prefercustom curemethod - which you aren't currently using (you're using %s).\n  Do you want to change to prefercustom? Click here if so: &quot;, conf.curemethod)

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;vconfig curemethod prefercustom&quot;, 'svo.config.set(&quot;curemethod&quot;, &quot;prefercustom&quot;, true); svo.showcurelist()', 'Click to change the curemethod from '..conf.curemethod..' to prefercustom, which allows you to individually specify which cures you prefer', true)
    setUnderline(false)
    echo'\n'
  end

  echo&quot;\n&quot;
  svo.showprompt()
end


function svo.app(what, quiet)
  svo.assert(what == nil or what == 'on' or what == 'off' or type(what) == 'boolean', &quot;svo.app wants 'on' or 'off' as an argument&quot;)

  if what == 'on' or what == true or (what == nil and not conf.paused) then
    conf.paused = true
  elseif what == 'off' or what == false or (what == nil and conf.paused) then
    conf.paused = false
    sk.paused_for_burrow = nil
  end

  if not quiet then svo.echof(&quot;System &quot; .. (conf.paused and 'paused' or 'unpaused') .. &quot;.&quot;) end
  raiseEvent(&quot;svo config changed&quot;, 'paused')

  svo.make_gnomes_work()
end

function svo.dop(what, echoback)
  svo.assert(what == nil or what == 'on' or what == 'off' or type(what) == 'boolean', &quot;svo.dop wants 'on' or 'off' as an argument&quot;)

  if what == 'on' or what == true or (what == nil and not me.dopaused) then
    me.dopaused = true
  elseif what == 'off' or what == false or (what == nil and me.dopaused) then
    me.dopaused = false
  end

  if echoback then svo.echof(&quot;Do system &quot; .. (me.dopaused and 'paused' or 'unpaused') .. &quot;.&quot;) end

  svo.make_gnomes_work()
end

function svo.dv()
  sys.manualdiag = true
  svo.make_gnomes_work()
end

function svo.inra()
  if not sys.enabledgmcp then svo.echof(&quot;You need to enable GMCP for this alias to work.&quot;) return end

  sk.inring = true
  sendGMCP(&quot;Char.Items.Inv&quot;)
  sendSocket&quot;\n&quot;
end

function svo.get_herbs()
  if not sys.enabledgmcp then svo.echof(&quot;You need to enable GMCP for this alias to work.&quot;) return end

  if (affs.blindaff or defc.blind) and not defc.mindseye then svo.echof(&quot;vget herbs doesn't work when you're true blind (if you do have mindseye, perhaps check def?)&quot;) return end

  sk.retrieving_herbs = true
  send('ql', false)
end

function svo.adf()
  me.manualdefcheck = true
  svo.make_gnomes_work()
end

function svo.manualdef()
  svo.doaction(svo.dict.defcheck.physical)
end

function svo.manualdiag()
  if sys.sync then sk.gnomes_are_working = true end
  svo.killaction(svo.dict.diag.physical)
  svo.doaction(svo.dict.diag.physical)
  if sys.sync then sk.gnomes_are_working = false end
end

function svo.reset.affs(echoback)
  for aff in pairs(affs) do
    if aff ~= 'lovers' then
      svo.rmaff(aff)
    end
  end

  svo.affsp = {}

  if echoback then
    if math.random(10) == 1 then
      svo.echof(&quot;BEEP BEEP! Affs svo.reset.&quot;)
    else
      svo.echof(&quot;All afflictions svo.reset.&quot;)
    end
  end
end

function svo.reset.general()
  svo.actions = svo.pl.OrderedMap()
  svo.lifevision.l = svo.pl.OrderedMap()

  for bal in pairs(svo.bals_in_use) do
    svo.bals_in_use[bal] = {}
  end

  svo.actions_performed = {}
  sk.onpromptfuncs = {}
  sk.checkaeony()
  signals.aeony:emit()
  signals.canoutr:emit()
  svo.innews = false
  svo.passive_cure_paragraph = false
  svo.check_generics()
end

function svo.reset.defs(echoback)
  for def, _ in pairs(defc) do
    if not svo.defs_data[def] or (svo.defs_data[def] and not svo.defs_data[def].stays_on_death) then
      svo.defc[def] = nil
    end
  end

  -- parry is also counted as a def and is svo.reset on burst/death, so clear it here as well
  local t = svo.sps.parry_currently
  for limb, _ in pairs(t) do t[limb] = false end

  if echoback then svo.echof(&quot;all defences svo.reset.&quot;) end
end

svo.signals.charname:connect(svo.reset.defs, 'reset defs on login')
svo.signals.gmcpcharname:connect(svo.reset.defs, 'reset defs on login')

function svo.reset.bals(echoback)
  -- create a new table instead of resetting the values in the old, because if you
  -- screw up and delete some balances - you'd expect svo.reset to restore them
  svo.bals.herb = true
  svo.bals.sip = true
  svo.bals.moss = true
  svo.bals.purgative = true
  svo.bals.salve = true
  svo.bals.balance = true
  svo.bals.equilibrium = true
  svo.bals.focus = true
  svo.bals.tree = true
  svo.bals.leftarm = 'unset'
  svo.bals.rightarm = 'unset'
  svo.bals.dragonheal = true
  svo.bals.smoke = true

if svo.haveskillset('voicecraft') then
  svo.bals.voice = true
end
if svo.me.class == 'Druid' then
  svo.bals.hydra = true
end
if svo.haveskillset('domination') then
  svo.bals.entities = true
end
if svo.haveskillset('healing') then
  svo.bals.healing = true
end
if svo.haveskillset('venom') then
  svo.bals.shrugging = true
end
if svo.haveskillset('chivalry') or svo.haveskillset('shindo') or
  svo.haveskillset('kaido') or svo.haveskillset('metamorphosis') then
  svo.bals.fitness = true
end
if svo.haveskillset('chivalry') then
  svo.bals.rage = true
end
if svo.haveskillset('physiology') then
  svo.bals.humour = true
  svo.bals.homunculus = true
end
if svo.haveskillset('terminus') then
  svo.bals.word = true
end

  for balance in pairs(svo.bals) do raiseEvent(&quot;svo got balance&quot;, balance) end

  if echoback then svo.echof(&quot;All balances svo.reset.&quot;) end
end
svo.signals.systemstart:connect(svo.reset.bals, 'reset bals on login')

function svo.ignorelist()
  local t = {}
  local count = 0

  local skip
  for k,v in pairs(svo.dict) do
    for balance, _ in pairs(v) do
      if balance == 'waitingfor' or balance == 'happened' then skip = true end
    end

    if not skip then t[#t+1] = k end
    skip = false
  end
  table.sort(t)
  svo.echof(&quot;Things we can ignore:&quot;) echo&quot;  &quot;

  for _, name in ipairs(t) do
    echo(string.format(&quot;%-20s&quot;, name))
    count = count + 1
    if count % 4 == 0 then echo &quot;\n  &quot; end
  end
  echo'\n' svo.showprompt()
end

function svo.afflist()
  local function getaffs()
    local t = {}

    for k,v in pairs(svo.dict) do
      if v.aff and not v.aff.notagameaff then t[#t+1] = k end
    end
    table.sort(t)

    return t
  end

  -- key-value table with an explanation message
  local function getuncurables(afflictions)
    local uncurables = {}
    local type = type

    -- check all balances, and if any get flagged, add with a message listing all balances
    for _, affname in ipairs(afflictions) do
      local uncurablebalances = {}
      for balancename, balancedata in pairs(svo.dict[affname]) do
        if type(balancedata) == 'table' and balancedata.uncurable then uncurablebalances[#uncurablebalances+1] = balancename end
      end

      if uncurablebalances[1] then
        uncurables[affname] = string.format(&quot;%s affliction doesn't have a cure on the %s balance%s&quot;, affname, svo.concatand(uncurablebalances), (#uncurablebalances &gt; 1 and 's' or ''))
      end
    end

    return uncurables
  end

  local t = getaffs()
  local uncurables = getuncurables(t)
  local count = 0

  svo.echof(&quot;Affliction list (%d):&quot;, #t) echo&quot;  &quot;

  local underline = setUnderline; _G.setUnderline = function () end

  local function getspacecount(name)
    if not valid['proper_'..name] and not uncurables[name] then
      return 23
    elseif valid['proper_'..name] and not uncurables[name] then
      return 37
    elseif valid['proper_'..name] and uncurables[name] then
      return 47
    elseif not valid['proper_'..name] and uncurables[name] then
      return 37
    end
  end

  local function gettext(name)
    if not valid['proper_'..name] and not uncurables[name] then
      return name
    elseif valid['proper_'..name] and not uncurables[name] then
      return name..&quot; &lt;0,128,128&gt;pr&lt;r&gt;&quot;
    elseif valid['proper_'..name] and uncurables[name] then
      return name..&quot; &lt;0,128,128&gt;pr uc&lt;r&gt;&quot;
    elseif not valid['proper_'..name] and uncurables[name] then
      return name..&quot; &lt;0,128,128&gt;uc&lt;r&gt;&quot;
    end
  end

  local function gethinttext(name)
    if not uncurables[name] then
      return &quot;Click to the the function to use for &quot;..name
    else
      return &quot;Click to the the function to use for &quot;..name..&quot;. Note also that this action has no in-game equivalent (UnCurable), so server-side priority can't be set for this&quot;
    end
  end

  for _, name in ipairs(t) do
    dechoLink(string.format(&quot;%-&quot;..getspacecount(name)..'s', gettext(name)),
        string.format([[svo.echof(&quot;Function to use for this aff:\nsvo.valid.%s()&quot;)]], not valid['proper_'..name] and 'simple'..name or 'proper_'..name), gethinttext(name), true)
    count = count + 1
    if count % 3 == 0 then echo &quot;\n  &quot; end
  end
  if count % 3 == 0 then echo &quot;\n  &quot; end
  echo'\n' svo.showprompt()
  _G.setUnderline = underline
end

function svo.adddefinition(tag, func)
  svo.assert(type(tag) == 'string' and type(func) == 'string', &quot;svo.adddefinition: need both tag and function to be strings&quot;)
  svo.cp.adddefinition(tag, func)
end

function svo.vaff(aff)
  if not svo.dict[aff] or not svo.dict[aff].aff then svo.echof(aff..&quot; isn't a known affliction to add.&quot;) return end

  if debug.traceback():find('Trigger', 1, true) then
    (svo.valid['proper_'..aff] or svo.valid['simple'..aff])()
  else
    if svo.dict[aff].aff and svo.dict[aff].aff.forced then
      svo.dict[aff].aff.forced()
    elseif svo.dict[aff].aff then
      svo.dict[aff].aff.oncompleted()
    else
      svo.addaffdict(svo.dict[aff])
    end

    if aff == 'aeon' then svo.rmaff('retardation') end
    signals.after_lifevision_processing:unblock(cnrl.checkwarning)
    sk.checkaeony()
    signals.aeony:emit()
    svo.make_gnomes_work()
  end
end

function svo.vrmaff(aff)
  if not svo.dict[aff] or not svo.dict[aff].aff then svo.echof(aff..&quot; isn't a known affliction to remove.&quot;) return end

  if lifevision.l[aff..'_aff'] then
    lifevision.l:set(aff..'_aff', nil)
  end

  if svo.dict[aff].gone then
    svo.dict[aff].gone.oncompleted()
  else
    svo.rmaff(aff)
  end
  signals.after_lifevision_processing:unblock(cnrl.checkwarning)
  sk.checkaeony()
  signals.aeony:emit()
  svo.make_gnomes_work()
end

if svo.haveskillset('kaido') then
  svo.transmute = function()
    -- custom check here, not using isadvisable because this should ignore prone
    if (not defc.dragonform and (stats.currenthealth &lt; sys.transmuteamount) and not svo.doingaction'healhealth' and not svo.doingaction'transmute' and svo.can_usemana()) then
        svo.doaction('transmute', 'physical')
    end
  end
else
  svo.transmute = function()
  end
end

</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Defences</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local conf, sk, me, defs, defc = svo.conf, svo.sk, svo.me, svo.defs, svo.defc
local defences, rift = svo.defences, svo.rift
local actions, lifevision = svo.actions, svo.lifevision

svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/defup+keepup&quot;)

--[[ a small dictionary to know which defences belong to which skillset ]]
defences.def_types = {}

-- the list from 'def'
defences.def_def_list = {}
defences.defup_timer = createStopWatch()

function defences.gettime(defence, max)
  if not defc[defence] then return &quot;&quot; end

  local time = max-math.ceil(getStopWatchTime(svo.dict[defence].stopwatch)/max)
  if time &lt; 0 then return &quot;&quot; else
    return time..'m'
  end
end

-- functions to handle the defc table events updates
function defences.got(def)
  if not defc[def] then defc[def] = true; raiseEvent(&quot;svo got def&quot;, def) end
end

function defences.lost(def)
  if defc[def] then defc[def] = false; raiseEvent(&quot;svo lost def&quot;, def) end
end

-- custom def types like channels
defences.custom_types = {}

defences.nodef_list = svo.phpTable()

-- set an initial mode to something, as it always needs to be a valid mode
svo.defs.mode = 'basic'

-- defc = current defs

-- specialskip: if this function returns true, that defence will be ignored for defup
svo.defs_data = svo.pl.OrderedMap {}
local defs_data = svo.defs_data
  defs_data:set('softfocus', { type = 'general',
    mana = 'lots',
    def = &quot;You have softened the focus of your eyes.&quot;,
    on = {&quot;You let your eyes go out of focus, causing you to miss some details.&quot;, &quot;Your eyes are already out of focus.&quot;},
    off = {&quot;You bring your eyes back into focus.&quot;, &quot;Your eyes are already in focus.&quot;}})
  defs_data:set('metawake', { type = 'general',
    def = &quot;You are concentrating on maintaining distance from the dreamworld.&quot;,
    mana = 'lots',
    on = {&quot;You order your mind to ensure you will not journey far into the dreamworld.&quot;, &quot;You already have metawake turned on.&quot;},
    off = {&quot;You cease concentrating on maintaining distance from the dreamworld.&quot;, &quot;You already have metawake turned off.&quot;}})
  defs_data:set('mass', { type = 'general',
    def = &quot;You are extremely heavy and difficult to move.&quot;,
    offr = {[[^You are pulled out of the room by \w+ and (?:his|her) whip\!$]],
            [[^A large handaxe comes flying into the room, arcs toward you, and carries you away with it to \w+!$]]},
    off = {&quot;You feel your density return to normal.&quot;, &quot;The savage winds pick you up and toss you through the air.&quot;}})
  defs_data:set('magicresist', { type = 'general',
    on_only = &quot;That resistance already suffuses your form.&quot;,
    def = &quot;You are enchanted against magic damage.&quot;})
  defs_data:set('fireresist', { type = 'general',
    on_only = &quot;That resistance already suffuses your form.&quot;,
    def = &quot;You are enchanted against fire damage.&quot;})
  defs_data:set('electricresist', { type = 'general',
    on_only = &quot;That resistance already suffuses your form.&quot;,
    def = &quot;You are enchanted against electric damage.&quot;})
  defs_data:set('coldresist', { type = 'general',
    on_only = &quot;That resistance already suffuses your form.&quot;,
    def = &quot;You are enchanted against cold damage.&quot;})
  defs_data:set('skywatch', { type = 'general',
    mana = 'little',
    def = &quot;You are aware of movement in the skies.&quot;,
    on = {&quot;You are now watching the skies.&quot;, &quot;You are already watching the skies.&quot;},
    off = &quot;You are no longer watching the skies.&quot;})
  defs_data:set('toughness', { nodef = true,
    def = &quot;Your skin is toughened.&quot; })
  defs_data:set(&quot;chivalry defended&quot;, { nodef = true,
    def = &quot;You are being defended by a stalwart ally.&quot; })
  defs_data:set('waterbubble', { type = 'general',
    def = &quot;You are surrounded by a pocket of air.&quot;})
  defs_data:set('resistance', { nodef = true,
    def = &quot;You are resisting magical damage.&quot;})
if not svo.haveskillset('alchemy') then
  defs_data:set('empower', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    on = &quot;You are already empowered by astronomical energies.&quot;,
    defr = [[^You are resonating with (?:the )?(?:Nebula )?(\w+)'s energy\.$]]})
end
if not svo.haveskillset('elementalism') then
  defs_data:set('reflection', { nodef = true,
    def = &quot;You are surrounded by one reflection of youself.&quot;,
    defr = [[^You are surrounded by \d+ reflections? of yourself\.$]]})
end
  defs_data:set('shipwarning', { nodef = true,
    def = &quot;You are aware of all nearby ship movements.&quot;})
  defs_data:set('constitution', { nodef = true,
    def = &quot;You are using your superior constitution to prevent nausea.&quot; })
  defs_data:set('preaching', { nodef = true,
    def = &quot;You have accepted a blessing for aid in times of need.&quot; })
  defs_data:set('frostblessing', { nodef = true,
    def = &quot;You are protected by the power of a Frost Spiritshield.&quot;})
  defs_data:set('willpowerblessing', { nodef = true,
    def = &quot;You are regenerating willpower at an increased rate.&quot;})
  defs_data:set('thermalblessing', { nodef = true,
    def = &quot;You are protected by the power of a Thermal Spiritshield.&quot;})
  defs_data:set('earthblessing', { nodef = true,
    def = &quot;You are protected by the power of an Earth Spiritshield.&quot;})
if not svo.haveskillset('groves') then
  defs_data:set('harmony', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = [[^You are under the blessing of the (\w+) environment\.$]]})
end
  defs_data:set('enduranceblessing', { nodef = true,
    def = &quot;You are regenerating endurance at an increased rate.&quot;,})
  defs_data:set('thirdeye', { type = 'general', def = &quot;You possess the sight of the third eye.&quot;,
    on = {&quot;You now possess the gift of the third eye.&quot;, &quot;You already possess the thirdeye.&quot;, &quot;You already possess the gift of the third eye.&quot;}})
  defs_data:set('treewatch', { type = 'general',
    mana = 'little',
    def = &quot;You are watching the trees or rigging above for signs of movement.&quot;,
    on = {&quot;You begin to keep a watchful eye on the treeline.&quot;, &quot;You begin to keep a watchful eye on the rigging.&quot;},
    off = &quot;You cease to watch the treeline.&quot;})
  defs_data:set('groundwatch', { type = 'general',
    mana = 'little',
    def = &quot;You are aware of movement on the ground.&quot;,
    on = {&quot;You begin to keep a watchful eye on the ground below.&quot;, &quot;You are already keeping a watchful eye on the ground.&quot;},
    off = &quot;You cease keeping a watchful eye on the ground below.&quot;})
  defs_data:set('alertness', { type = 'general',
    mana = 'little',
    def = &quot;Your senses are attuned to nearby movement.&quot;,
    on = {&quot;You prick up your ears.&quot;, &quot;Alertness is already on!&quot;, &quot;Your sense of hearing is already heightened.&quot;},
    off = {&quot;You cease your watchful alertness.&quot;, &quot;Alertness is already off!&quot;}})
  defs_data:set('curseward', { type = 'general',
    def = &quot;A curseward has been established about your person.&quot;,
    off = &quot;Your curseward has been breached!&quot;,
    on = {&quot;You bring a curseward into being to protect you from harm.&quot;, &quot;You already have curseward up.&quot;}})
  defs_data:set('bell', { type = 'general',
    on = {&quot;You will now attempt to detect attempts to spy on your person.&quot;, &quot;You touch the bell tattoo.&quot;},
    def = &quot;You are protected by the bell tattoo.&quot;})
  defs_data:set('cloak', { type = 'general',
    on = {&quot;You caress the tattoo and immediately you feel a cloak of protection surround you.&quot;, &quot;You are already protected by the cloak tattoo.&quot;},
    def = &quot;You are surrounded by a cloak of protection.&quot;})
  defs_data:set('favour', { nodef = true,
    ondef = function () return string.format(&quot;(%s by %s, %sh)&quot;,matches[2],matches[3], matches[4]) end,
    defr = [[^You are (\w+)favoured by (\w+) for over \d+ Achaean month \(which is about (\d+) hours?\)$]] })
  defs_data:set('telesense', { type = 'general',
    mana = 'little',
    def = &quot;You are attuned to local telepathic interference.&quot;,
    on = {&quot;You attune your mind to local telepathic interference.&quot;, &quot;Your mind is already attuned to local telepathic interference.&quot;},
    off = {&quot;Your mind is no longer concentrating on telepathic interference.&quot;, &quot;Your mind is already not attuned to local telepathic interference.&quot;}})
  defs_data:set('hypersight', { type = 'general',
    mana = 'little',
    def = &quot;You are utilising hypersight.&quot;,
    on = {&quot;You concentrate your mind and engage your ability of hypersight.&quot;, &quot;You are already concentrating on hypersight.&quot;},
    off = {&quot;You cease to concentrate on hypersight.&quot;, &quot;You are already not concentrating on hypersight.&quot;}})
  defs_data:set('parry', { nodef = true,
    ondef = function ()
      local t = svo.sps.parry_currently
      for limb, _ in pairs(t) do t[limb] = false end
      t[matches[2]] = true
      svo.check_sp_satisfied()

      return &quot;(&quot;..matches[2]..&quot;)&quot;
    end,
    tooltip = &quot;Completely blocks health and wound damage on a limb if you aren't hindered.&quot;,
    defr = [[^You will attempt to parry attacks to your (.+)\.$]]
  })

  defs_data:set('nightsight', { type = 'general',
    def = &quot;Your vision is heightened to see in the dark.&quot;,
    on = {&quot;Your vision sharpens with light as you gain night sight.&quot;, &quot;Your eyes already have the benefit of night sight.&quot;},
    off = {&quot;Your eyes lose the benefit of night sight.&quot;, &quot;Your eyes cannot lose the benefit of night sight, since they do not already have it!&quot;}})
  defs_data:set('block', { type = 'general',
    specialskip = function ()
      return (not sys.enabledgmcp) or not (gmcp.Room and gmcp.Room.Info.exits[conf.blockingdir])
    end,
    ondef = function ()
      svo.dict.block.physical.blockingdir = sk.anytoshort(matches[2])
      return &quot;(&quot;..svo.dict.block.physical.blockingdir..&quot;)&quot;
    end,
    defr = [[^You are blocking the exit (.+)\.$]],
    off = {&quot;You stop blocking.&quot;, &quot;You were not blocking.&quot;, &quot;You cease blocking the exit.&quot;, &quot;You begin to flap your wings powerfully, and rise quickly up into the firmament.&quot;},
    })
  defs_data:set('targetting', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    tooltip = &quot;Focuses hits on the targetted limb.&quot;,
    defr = [[^You are aiming your attacks to the (.+)\.$]]
  })
  defs_data:set('breath', { type = 'general',
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].meditate then
        svo['def'..whereto][mode].meditate = false
        if echoback then svo.echof(&quot;Removed meditate from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].dilation then
        svo['def'..whereto][mode].dilation = false
        if echoback then svo.echof(&quot;Removed dilation from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].flame then
        svo['def'..whereto][mode].flame = false
        if echoback then svo.echof(&quot;Removed flame from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].lyre then
        svo['def'..whereto][mode].lyre = false
        if echoback then svo.echof(&quot;Removed lyre from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end}) -- added in xml w/ conf.gagbreath
  defs_data:set('vigilance', { type = 'general',
    on = {&quot;You squint your eyes, more alert to potential danger.&quot;, &quot;You are already vigilant.&quot;},
    mana = 'little',
    def = &quot;You are vigilantly watching for potential danger.&quot;,
    off = {&quot;You relax your vigilance.&quot;, &quot;You are not maintaining vigilance.&quot;}})
  defs_data:set('satiation', { type = 'general',
    invisibledef = true,
    on = {&quot;You begin concentrating on efficient digestion.&quot;, &quot;You are already concentrating on efficient digestion.&quot;},
    off = &quot;Your digestive efficiency returns to normal.&quot;})
  defs_data:set('clinging', { type = 'general',
    on = {&quot;You begin to use your entire body to cleverly cling to the branches of the tree while still maintaining a great deal of freedom of action.&quot;,&quot;You are already clinging to the trees.&quot;, &quot;You must be in the trees to cling to branches, or in the rigging of a ship to cling to the ropes.&quot;},
    off = &quot;You cease your clinging behaviour and release the tree.&quot;,
    def = {&quot;You are clinging tightly to the trees.&quot;, &quot;You are clinging tightly to a ship's rigging.&quot;}})
  defs_data:set('selfishness', { type = 'general', def = &quot;You are feeling quite selfish.&quot;,
    onenable = function ()
      if conf.serverside and svo.serverignore.selfishness then
        svo.serverignore.selfishness = nil
        svo.echof(&quot;Setting Selfishness to be handled by Svof - serverside can't auto-generosity.&quot;)
      end

      return true
    end,
    on = {&quot;You rub your hands together greedily.&quot;, &quot;You already are a selfish bastard.&quot;},
    off = {&quot;A feeling of generosity spreads throughout you.&quot;, &quot;No worries. You're not a selfish bastard as is.&quot;}})
  defs_data:set('flying', { nodef = true,
    def = &quot;You are soaring high above the ground.&quot; })
  defs_data:set('starburst', { nodef = true,
    def = &quot;You are walking with the grace of the stars.&quot; })
  defs_data:set('chameleon', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = [[^You are assuming the identity of (\w+)\.$]]})
  defs_data:set('insomnia', { type = 'general',
    def = &quot;You have insomnia, and cannot easily go to sleep.&quot;,
    -- insomnia curing it is done in trigs as well
    -- &quot;Your insomnia has cleared up.&quot;: done in triggers for loki
  })
  defs_data:set('kola', { type = 'general',
    def = &quot;You are feeling extremely energetic.&quot; })
  defs_data:set(&quot;extra crits&quot;, { nodef = true,
    def = &quot;You are surrounded by a lucky green aura.&quot;})
  defs_data:set('rebounding', { type = 'general',
    def = &quot;You are protected from hand-held weapons with an aura of rebounding.&quot;,
    off = {&quot;Your defensive barriers disappear.&quot;, &quot;Your aura of weapons rebounding disappears.&quot;, &quot;A small brown lemming rips apart your aura of rebounding defence with its claws.&quot;, &quot;The vines rip apart the aura of rebounding surrounding you.&quot;},
    offr = {[[^\w+'s cantata shatters the defences surrounding you\.$]], [[^\w+ delivers a single, powerful blow to the aura of rebounding surrounding you, shattering it\.$]], [[^\w+ brings .+? down in a single diagonal stroke, carving cleanly through your aura of rebounding\.$]], [[^\w+ whirls .+? over (?:her|his) head, before bringing it down upon your aura of rebounding, shattering it instantly\.$]], [[^The point of .+? strikes your aura of rebounding, and rapid cracks begin to spread outward from the point of impact\. Moments later, the protection shatters\.$]]}})
  defs_data:set('blind', { type = 'general',
    def = &quot;You are blind.&quot; })
  defs_data:set('xpboost', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = [[^You are experiencing a (\d+) percent experience boost\.$]] })
  defs_data:set('xpbonus', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = {[[^You are benefitt?ing from a (\d+)% experience bonus\.$]], [[^You are benefitting from a (\d+)% bonus to experience gain\.$]] }})
  defs_data:set('deaf', { type = 'general',
    def = &quot;You are deaf.&quot;,
    off = &quot;The unnatural sound rips through your defences against auditory attacks.&quot; })
  defs_data:set(&quot;xp gain&quot;, { nodef = true,
    def = &quot;You are surrounded by a vibrant white aura.&quot; })
  defs_data:set('myrrh', { type = 'general',
    def = &quot;Your mind is racing with enhanced speed.&quot; })
  defs_data:set('deathsight', { type = 'general',
    def = &quot;Your mind has been attuned to the realm of Death.&quot;,
    on = {&quot;Your mind is already attuned to the realm of Death.&quot;, &quot;You shut your eyes and concentrate on the Soulrealms. A moment later, you feel inextricably linked with the realm of Death.&quot;},
    onr = &quot;^A miasma of darkness passes over your eyes and you feel a link to the realm of Death,? form in your mind\\.$&quot;,
    off = {&quot;You relax your link with the realm of Death.&quot;, &quot;You are not linked with the realm of Death.&quot;}})
  defs_data:set('mindseye', { type = 'general',
    on = {&quot;Touching the mindseye tattoo, your senses are suddenly heightened.&quot;, &quot;You already possess the mindseye defence.&quot;},
    def = &quot;Your senses are magically heightened.&quot;})
  defs_data:set('lyre', { type = 'general',
    specialskip = function() return not conf.lyre end,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].meditate then
        svo['def'..whereto][mode].meditate = false
        if echoback then svo.echof(&quot;Removed meditate from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].breath then
        svo['def'..whereto][mode].breath = false
        if echoback then svo.echof(&quot;Removed breath from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].dilation then
        svo['def'..whereto][mode].dilation = false
        if echoback then svo.echof(&quot;Removed dilation from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = &quot;You deftly shape the wall of light into a barrier surrounding yourself.&quot;,
    onr = [[^You strum .+, and a prismatic barrier forms around you\.$]],
    def = &quot;You are standing within a prismatic barrier.&quot;,
    off = {&quot;Your prismatic barrier dissolves into nothing.&quot;, &quot;The stream hits your prismatic barrier, shattering it.&quot;, &quot;The breath weapon rips apart your prismatic barrier.&quot;, &quot;The breath weapon rips through both your shield and prismatic barrier.&quot;, &quot;The spear shatters your prismatic barrier.&quot;}})
  defs_data:set('speed', { type = 'general',
    def = &quot;Your sense of time is heightened, and your reactions are speeded.&quot;})
  defs_data:set('frost', { type = 'general', def = &quot;You are tempered against fire damage.&quot;,
    on = &quot;A chill runs over your icy skin.&quot;,
    off = &quot;Forks of flame lick against your skin, melting away your protection against fire.&quot;})
  defs_data:set('venom', { type = 'general', def = &quot;Your resistance to damage by poison has been increased.&quot;,
    on = &quot;You feel a momentary dizziness as your resistance to damage by poison increases.&quot;})
  defs_data:set('levitation', { type = 'general', def = &quot;You are walking on a small cushion of air.&quot;,
    on = {&quot;Your body begins to feel lighter and you feel that you are floating slightly.&quot;, &quot;Your body grows light and buoyant as you touch the feather tattoo, and you begin hovering above the ground.&quot;}})
  defs_data:set('caloric', { type = 'general',
    def = &quot;You are coated in an insulating unguent.&quot;})
  defs_data:set('sileris', { type = 'general',
    def = &quot;You are protected from the fangs of serpents.&quot;})
  defs_data:set('chargeshield', { nodef = true,
    def = &quot;You are surrounded by a non-conducting chargeshield.&quot;})
  defs_data:set('meditate', { type = 'general',
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].breath then
        svo['def'..whereto][mode].breath = false
        if echoback then svo.echof(&quot;Removed breath from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].dilation then
        svo['def'..whereto][mode].dilation = false
        if echoback then svo.echof(&quot;Removed dilation from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].flame then
        svo['def'..whereto][mode].flame = false
        if echoback then svo.echof(&quot;Removed flame from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].lyre then
        svo['def'..whereto][mode].lyre = false
        if echoback then svo.echof(&quot;Removed lyre from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = &quot;You close your eyes, bow your head, and empty your mind of all thought.&quot;,
    off = {&quot;You snap your head up as you break your meditation.&quot;, &quot;You cease your meditation having achieved full will and mana.&quot;}})
  defs_data:set('shield', { type = 'general',
    on = {&quot;You touch the tattoo and a nearly invisible magical shield forms around you.&quot;, &quot;You bid your guardian angel to raise an aura to shield you.&quot;},
    onr = [[^(\w+)'s angel surrounds you with a protective shield\.$]],
    off = {&quot;Your movement causes your magical shield to dissipate.&quot;, &quot;The breath weapon rips through your shield.&quot;, &quot;The point of the weapon comes to a sudden stop as its tip impacts your magical shield. Originating at the point of impact, fractures spread across the barrier before it shatters.&quot;, &quot;Your action causes the nearly invisible magical shield around you to fade away.&quot;, &quot;The stream hits your magical shield, shattering it.&quot;, &quot;The spout of molten lava surges against your shield, which shatters under the intense force and heat.&quot;, &quot;Your defensive barriers disappear.&quot;, &quot;A glowing spear comes flying in towards you. The spear shatters your shield.&quot;, &quot;The breath weapon rips through both your shield and prismatic barrier.&quot;, &quot;With a mad cackle, a gremlin leaps at you and batters your shield with a flurry of blows, fracturing it in moments.&quot;, &quot;A dissonant tone shatters the magical shield surrounding you.&quot;},
    offr = {[[^\w+ razes your magical shield with ]],
        [[^A massive, translucent hammer rises out of .+'s tattoo and smashes your magical shield\.]],
        [[^\w+'s cantata shatters your magical shield\.$]],
        [[^The meteor, shot by \w+, slams into your shield, shattering it\.$]],
        [[^\w+ flays away your shield defence\.$]],
        [[^\w+ sends myriad russet streams towards you, shattering your shield\.$]],
        [[^\w+'s cantata shatters the defences surrounding you\.$]],
        [[^\w+'s many heads lash out around you, shattering your protective shield\.$]],
        [[^\w+ delivers a single, powerful blow to the magical shield surrounding you, shattering it\.$]],
        [[^\w+ continues (?:his|her) assault, coming around for a second blow that scythes straight through your magical shield\.$]],
        [[^\w+ brings .+? down in a single diagonal stroke, carving cleanly through your magical shield\.$]],
        [[^\w+ continues (?:his|his) attack, coming back around with a bone rattling blow with .+? that causes your magical shield to explode in a shower of twinkling shards\.$]],
        [[^\w+ whirls .+ over (?:her|his) head, before bringing it down upon your magical shield, shattering it instantly\.$]],
        [[^\w+ summons a blade of condensed air and shears cleanly through the magical shield surrounding you\.$]],
        [[^The shadow of \w+ suddenly comes alive, leaping forward to hammer at your shield in a silent frenzy of blows\. Your protection lasts mere moments before exploding in a shower of prismatic shards\.$]],
    },
    def = &quot;You are surrounded by a nearly invisible magical shield.&quot;})
  defs_data:set('riding', { type = 'general',
    specialskip = function() return defc.dragonform end,
    ondef = function ()
      if tostring(conf.ridingsteed) and tostring(conf.ridingsteed):match(&quot;([A-Za-z]+)&quot;) and string.find(matches[2], tostring(conf.ridingsteed):match(&quot;([A-Za-z]+)&quot;), nil, true) then
        return &quot;(&quot;..tostring(conf.ridingsteed):match(&quot;([A-Za-z]+)&quot;)..&quot;)&quot;
      else
        return &quot;(&quot;..matches[2]..&quot;)&quot;
      end
    end,
    defr = [[^You are riding (.+)\.$]],
    onr = {[[^You climb up on .+\.$]], [[^You easily vault onto the back of .+\.$]]},
    on = {&quot;You step aboard the chariot and firmly grasp the reins.&quot;},
    offr = {[[^You step down off of .+\.$]], [[^You lose purchase on .+\.$]], [[^\w+ waves (?:his|her) palm in your direction, and you can only watch as your surroundings dissolve and fade from existence\.$]], [[^You feel your blessed soul drawn toward \w+ as you are delivered out of harm's way\.$]], [[^\w+ steps into the attack, grabs your arm, and throws you violently to the ground\.$]], [[^You feel a strong tug in the pit of your stomach\. Your surroundings dissolve into the featureless swirl of the ether, resolving once more into a recognisable landscape as you land before \w+\.$]]},
    off = {&quot;You are not currently riding anything.&quot;, &quot;You are not currently riding that.&quot;, &quot;You must be mounted to trample.&quot;, &quot;You are thrown from the room by the sheer force of the fiery blast.&quot;, &quot;You're drawn screaming into its hellish maw.&quot;, &quot;The ring of shining metal carries you up into the skies.&quot;, &quot;You clamber off of your mount.&quot;,&quot;You need to be riding a proper mount to gallop.&quot;, &quot;You call upon your dark power, and instantly a black wind descends upon you. In seconds your body begins to dissipate, and you are one with the odious vapour.&quot;, &quot;You vaguely make out a large, square doorway of light and you step through it.&quot;}})

if not svo.haveskillset('groves') then
  defs_data:set(&quot;grove vigour&quot;, { nodef = true,
    def = &quot;You are bathed in an aura of radiant sunlight.&quot;})
end

-- Dragoncraft: everyone gets it
  defs_data:set('dragonform', { type = 'dragoncraft',
    offline_defence = true,
    invisibledef = true,
    stays_on_death = true,
    on = &quot;You already maintain the form of the Dragon.&quot;,
    off = &quot;Your draconic form melts away, leaving you suddenly weaker and more vulnerable.&quot; })
  defs_data:set('dragonarmour', { type = 'dragoncraft',
    specialskip = function() return not defc.dragonform end,
    def = &quot;You are surrounded by draconic armour.&quot;,
    off = &quot;You relax your draconic armour.&quot;,
    on = {&quot;With a low rumbling from deep within your belly, you beseech Ashaxei for protection. Your skin ripples as a web of crackling magical energy dances like fire across its surface, settling to solidify into a flexible, translucent shell.&quot;, &quot;You are already surrounded by draconic armour, Wyrm.&quot;}})
  defs_data:set('dragonbreath', { type = 'dragoncraft',
    specialskip = function() return not defc.dragonform end,
    def = &quot;You have summoned your draconic breath weapon.&quot;,
    off = {&quot;You have not summoned your breath weapon.&quot;, &quot;As the strain on your inflated lungs reaches extremity, you open your glistening, tooth-lined maw wide and rain a great tempest of venom down upon the ground below.&quot;},
    offr = {[[^As the strain on your inflated lungs reaches extremity, you open your glistening, tooth-lined maw wide and rain .+]], [[^Focusing your breath into a concentrated stream, you direct a blast of]], [[^Opening your great maw, you unleash an overpowering blast of flesh-searing lightning at .+, whose body goes rigid as s?he screams in agony\.$]], [[^Opening your dragon's mouth to its fullest, you blast .+ with your toxic wrath, damaging (?:her|his) very essence\.$]], [[^Opening your massive maw, you throw your head forward and blast wave after wave of deadly, all-consuming cold at .+\.$]], [[^Opening your maw, you force out a tremendous stream of acid, blasting the flesh from the very bones of .+\.$]], [[^Drawing a mighty breath to fill your lungs, you crane your neck backwards and send a screaming volley of \w+-infused vapour into the air\.$]], [[^You rear back your head, and with a keening roar unleash incandescent hell upon]], [[^With a roar of triumph, you unleash a cataclysm of crushing psi energy, laying waste to .+'s mind\.]], [[^Summoning a torpid cloud of \w+ deep within your belly, you expel your breath toward]] }})

if svo.haveskillset('necromancy') then
  defs_data:set('deathsight', { type = 'necromancy',
    staysindragon = true,
    availableindragon = true,
    def = &quot;Your mind has been attuned to the realm of Death.&quot;,
    on = {&quot;Your mind is already attuned to the realm of Death.&quot;, &quot;You shut your eyes and concentrate on the Soulrealms. A moment later, you feel inextricably linked with realm of Death.&quot;},
    onr = &quot;^A miasma of darkness passes over your eyes and you feel a link to the realm of Death,? form in your mind\\.$&quot;,
    off = {&quot;You relax your link with the realm of Death.&quot;, &quot;You are not linked with the realm of Death.&quot;}})
  defs_data:set('soulcage', { type = 'necromancy',
    staysindragon = true,
    offline_defence = true,
    on = {&quot;Your soul is already protected by the soulcage.&quot;, &quot;You lower the barrier between your spirit and the soulcage.&quot;, &quot;You begin to spin a web of necromantic power about your soul, drawing on your vast reserves of life essence. Moment by moment the bonds grow stronger, until your labours are complete. Your soul is entirely safe from harm, fortified in a cage of immortal power.&quot;},
    off = {&quot;You have not caged your soul in life essence.&quot;, &quot;You carefully raise a barrier between your spirit and the soulcage.&quot;, &quot;As you feel the last remnants of strength ebb from your tormented body, you close your eyes and let darkness embrace you. Suddenly, you feel your consciousness wrenched from its pitiful mortal frame and your soul is free. You feel your form shifting, warping and changing as you whirl and spiral outward, ever outward. A jolt of sensation awakens you, and you open your eyes tentatively to find yourself trapped within a physical body once more.&quot;},
    onr = [[^You may not use soulcage for another \d+ Achaean day\(s\)\.$]],
    def = &quot;Your being is protected by the soulcage.&quot;})
  defs_data:set('deathaura', { type = 'necromancy',
    on = {&quot;You let the blackness of your soul pour forth.&quot;, &quot;You already possess an aura of death.&quot;},
    def = &quot;You are emanating an aura of death.&quot;,
    off = &quot;Your aura of death has worn off.&quot;})
  defs_data:set('shroud', { type = 'necromancy',
    on = {&quot;Calling on your dark power, you draw a thick shroud of concealment about yourself to cover your every action.&quot;, &quot;You draw a Shadowcloak about you and blend into your surroundings.&quot;, &quot;You draw a cloak of the Blood Maiden about you and blend into your surroundings.&quot;},
    def = &quot;Your actions are cloaked in secrecy.&quot;,
    off = {&quot;Your shroud dissipates and you return to the realm of perception.&quot;, &quot;The flash of light illuminates you - you have been discovered!&quot;}})
  defs_data:set('lifevision', { type = 'necromancy',
    on = {&quot;You narrow your eyes and blink rapidly, enhancing your vision to seek out sources of lifeforce in others.&quot;, &quot;You already possess enhanced vision.&quot;},
    def = &quot;You have enhanced your vision to be able to see traces of lifeforce.&quot;})
  defs_data:set('putrefaction', { type = 'necromancy',
    on = {&quot;You concentrate for a moment and your flesh begins to dissolve away, becoming slimy and wet.&quot;, &quot;You have already melted your flesh. Why do it again?&quot;},
    def = &quot;You are bathed in the glorious protection of decaying flesh.&quot;,
    off = &quot;You concentrate briefly and your flesh is once again solid.&quot;})
  defs_data:set('vengeance', { type = 'necromancy',
    staysindragon = true,
    offline_defence = true,
    on = {&quot;You swear to yourself that you will wreak vengeance on your slayer.&quot;, &quot;Vengeance already burns within your heart, Necromancer.&quot;},
    def = &quot;You have sworn vengeance upon those who would slay you.&quot;,
    off = {&quot;You forswear your previous oath for vengeance, sudden forgiveness entering your heart.&quot;, &quot;You have sworn vengeance against none, Necromancer.&quot;}})
end

if svo.haveskillset('chivalry') then
  defs_data:set('weathering', { type = 'chivalry',
    on = &quot;A brief shiver runs through your body.&quot;,
    def = &quot;Your body is weathering the storm of life a little better.&quot;})
  defs_data:set('fury', { type = 'chivalry',
    on = {&quot;Your eyes rage with fury.&quot;, &quot;You're already raged with fury!&quot;, &quot;Too much fury in a day is unhealthy!&quot;},
    off = {&quot;You suddenly lose the fury in your eyes.&quot;, &quot;You are already calm and not feeling any fury.&quot;},
    def = &quot;Fury rages in your eyes.&quot;})
  defs_data:set('sturdiness', { type = 'chivalry',
    on = &quot;You cross your arms, standing firm and resolute.&quot;,
    def = &quot;You are standing firm against attempts to move you.&quot;,
    off = &quot;You cease to stand firm against attempts to move you.&quot;})
  defs_data:set('grip', { type = 'chivalry',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
  defs_data:set('mastery', { type = 'chivalry',
    on = {&quot;You have begun exercising true mastery of the blades through superior concentration.&quot;, &quot;You already have mastery on.&quot;},
    def = &quot;You are concentrating on mastery of bladecraft.&quot;,
    off = &quot;You relax your mastery of the blades a bit, finding it too taxing to maintain.&quot;})
  defs_data:set('resistance', { type = 'chivalry',
    on = &quot;You call aloud and feel an aura of resistance shroud itself silently about you.&quot;,
    def = &quot;You are resisting magical damage.&quot;})
end

if svo.haveskillset('evileye') then
  defs_data:set('truestare', { type = 'evileye',
    on = {&quot;A sharp pain spikes through your skull, before settling into a dull throbbing just behind your eyes.&quot;, &quot;You are already enhancing your ocular prowess. Lost: Your truestare defence erodes away.&quot;},
    def = &quot;You are enhancing your ocular prowess.&quot;})
end

if svo.haveskillset('weaponmastery') then
  defs_data:set('deflect', { type = 'weaponmastery',
    on = &quot;You will now attempt to deflect arrows toward less vital areas.&quot;,
    def = &quot;You are attempting to deflect arrows toward less vital areas.&quot;})
end

if svo.haveskillset('shindo') then
  defs_data:set('weathering', { type = 'shindo',
    on = &quot;A brief shiver runs through your body.&quot;,
    def = &quot;Your body is weathering the storm of life a little better.&quot;})
  defs_data:set('sturdiness', { type = 'shindo',
    on = &quot;You cross your arms, standing firm and resolute.&quot;,
    def = &quot;You are standing firm against attempts to move you.&quot;,
    off = &quot;You cease to stand firm against attempts to move you.&quot; })
  defs_data:set('toughness', { type = 'shindo',
    def = &quot;Your skin is toughened.&quot;,
    on = &quot;Flexing your muscles, you concentrate on forcing unnatural toughness over the surface of your skin.&quot;})
  defs_data:set('clarity', { type = 'shindo',
    on = {&quot;You are already concentrating on a clearer awareness of your environs.&quot;, &quot;As you focus upon your visual field, the shadows grow faint, details become pronounced, and the world seems somehow more real.&quot;},
    def = &quot;You are seeing the world around you with greater clarity of vision.&quot; })
  defs_data:set('mindnet', { type = 'shindo',
    on = {&quot;You cast an invisible mind net out into the distance, allowing it to settle about the surrounding land.&quot;, &quot;Extending your well-trained senses, you focus upon the movements of others nearby.&quot;, &quot;You already have mindnet active.&quot;},
    def = &quot;You have cast a mindnet over the local area.&quot;,
    off = &quot;You cease concentration and your mind net vanishes.&quot;})
  defs_data:set('constitution', { type = 'shindo',
    def = &quot;You are using your superior constitution to prevent nausea.&quot;,
    on = {&quot;You clench the muscles in your stomach, determined to svo.assert your superior constitution.&quot;, &quot;You are using your superior constitution to prevent nausea.&quot;}})
  defs_data:set('waterwalk', { type = 'shindo',
    def = &quot;You are poised to glide across the surface of water.&quot;,
    on = {&quot;You are already poised to glide across the surface of water.&quot;, &quot;Dancing lightly on your feet, you prepare to run across the surface of water.&quot;}})
  defs_data:set('shintrance', { type = 'shindo',
    on = {&quot;You are already focused upon gaining shindo energy.&quot;, &quot;You centre your focus inwards, slowly opening yourself up to the energy of Shindo.&quot;},
    off = &quot;You break out of the Shin Trance, sighing as you feel your accumulated Shin energy vanish.&quot;,
    def = &quot;You are deep within the Shin trance.&quot;})
  defs_data:set('consciousness', { type = 'shindo',
    def = &quot;You are maintaining consciousness at all times.&quot;,
    off = {&quot;You are not maintaining consciousness.&quot;, &quot;You will no longer concentrate on retaining full consciousness.&quot;},
    on = {&quot;You are already maintaining consciousness.&quot;, &quot;You will remain conscious at all times.&quot;}})
  defs_data:set('bind', { type = 'shindo',
    on = {&quot;You bind Shin energy to your form, willing your body to accept its restorative power.&quot;, &quot;You are already binding Shin energy.&quot;},
    def = &quot;You are diverting excess Shin energy into regeneration.&quot;,
    off = &quot;You cease binding excess Shin energy towards regeneration.&quot;})
  defs_data:set('projectiles', { type = 'shindo',
    def = &quot;You are alert to incoming projectiles.&quot;,
    off = {&quot;You cease your watch for projectiles.&quot;, &quot;You are not watching for projectiles.&quot;},
    on = &quot;You look about sharply, poised to avoid all incoming projectiles.&quot;})
  defs_data:set('dodging', { type = 'shindo',
    on = &quot;You resolve to keep an eye on the skies for danger.&quot;,
    def = &quot;You are watching the skies for danger.&quot;,
    off = {&quot;You are not using Shindo Dodging.&quot;, &quot;You cease watching the skies.&quot;}})
  defs_data:set('grip', { type = 'shindo',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
  defs_data:set('immunity', { type = 'shindo',
    on = &quot;You close your eyes and grit your teeth, feeling the heat of the blood pumping through your veins.&quot;,
    off = &quot;You cease concentrating on immunity.&quot;})
end

if svo.haveskillset('twoarts') then
  defs_data:set('retaliationstrike', { type = 'twoarts',
    def = &quot;You are performing retaliatory strikes against your attackers.&quot;,
    off = &quot;You will no longer strike in retaliation.&quot;,
    onr = [[Grasping the hilt of \w+ \w+, you prepare to counterattack when the opportunity arises\.$]]})
  defs_data:set('doya', { type = 'twoarts',
    off = {&quot;You adopt a neutral stance.&quot;, &quot;You are not in any stance, Warrior.&quot;},
    on = &quot;Lowering your centre of gravity, you drop into the Doya stance.&quot;,
    def = &quot;You are in the Doya stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      for _, stance in ipairs{'thyr', 'mir', 'arash', 'sanya', 'doya'} do
        if stance ~= newdef and svo['def'..whereto][mode][stance] then
          svo['def'..whereto][mode][stance] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, stance, whereto, newdef) end
        end
      end

      return true
    end,
    specialskip = function ()
      return (defc.thyr or defc.mir or defc.arash or defc.sanya)
    end })
  defs_data:set('thyr', { type = 'twoarts',
    off = {&quot;You adopt a neutral stance.&quot;, &quot;You are not in any stance, Warrior.&quot;},
    on = &quot;Readying yourself with a flourish, you flow into the Thyr stance.&quot;,
    def = &quot;You are in the Thyr stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      for _, stance in ipairs{'thyr', 'mir', 'arash', 'sanya', 'doya'} do
        if stance ~= newdef and svo['def'..whereto][mode][stance] then
          svo['def'..whereto][mode][stance] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, stance, whereto, newdef) end
        end
      end

      return true
    end,
    specialskip = function ()
      return (defc.doya or defc.mir or defc.arash or defc.sanya)
    end })
  defs_data:set('mir', { type = 'twoarts',
    off = {&quot;You adopt a neutral stance.&quot;, &quot;You are not in any stance, Warrior.&quot;},
    on = &quot;Resolving to move as water, you enter the Mir stance.&quot;,
    def = &quot;You are in the Mir stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      for _, stance in ipairs{'thyr', 'mir', 'arash', 'sanya', 'doya'} do
        if stance ~= newdef and svo['def'..whereto][mode][stance] then
          svo['def'..whereto][mode][stance] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, stance, whereto, newdef) end
        end
      end

      return true
    end,
    specialskip = function ()
      return (defc.thyr or defc.doya or defc.arash or defc.sanya)
    end })
  defs_data:set('arash', { type = 'twoarts',
    off = {&quot;You adopt a neutral stance.&quot;, &quot;You are not in any stance, Warrior.&quot;},
    on = &quot;Mind set on the dancing flame, you take up the Arash stance.&quot;,
    def = &quot;You are in the Arash stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      for _, stance in ipairs{'thyr', 'mir', 'arash', 'sanya', 'doya'} do
        if stance ~= newdef and svo['def'..whereto][mode][stance] then
          svo['def'..whereto][mode][stance] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, stance, whereto, newdef) end
        end
      end

      return true
    end,
    specialskip = function ()
      return (defc.thyr or defc.mir or defc.doya or defc.sanya)
    end })
  defs_data:set('sanya', { type = 'twoarts',
    off = {&quot;You adopt a neutral stance.&quot;, &quot;You are not in any stance, Warrior.&quot;},
    on = &quot;Clearing your mind, you sink into the Sanya stance.&quot;,
    def = &quot;You are in the Sanya stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      for _, stance in ipairs{'thyr', 'mir', 'arash', 'sanya', 'doya'} do
        if stance ~= newdef and svo['def'..whereto][mode][stance] then
          svo['def'..whereto][mode][stance] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, stance, whereto, newdef) end
        end
      end

      return true
    end,
    specialskip = function ()
      return (defc.thyr or defc.mir or defc.arash or defc.doya)
    end })
end

if svo.haveskillset('subterfuge') then
  defs_data:set('phase', { type = 'subterfuge',
    on = {&quot;A short burst of azure light fills your vision and when it is gone, you find yourself phased out of sync with the rest of reality.&quot; , &quot;You are already phased!&quot;},
    def = &quot;Phased slightly out of reality, you are effectively untouchable.&quot;,
    off = {&quot;There's a flash of light and you're pulled back into phase with reality.&quot; , &quot;Your surroundings shatter into a cloud of glowing stars which dissipate to leave you back where you began.&quot; , &quot;You are suddenly and unexpectedly pulled back into phase with reality.&quot;}})
  defs_data:set('hiding', { type = 'subterfuge',
    on = {&quot;You conceal yourself using all the guile you possess.&quot;, &quot;You are already hidden.&quot;, &quot;Too many prying eyes prevent you from finding a suitable hiding place.&quot;},
    def = &quot;You have used great guile to conceal yourself.&quot;,
    off = {&quot;You emerge from your hiding place.&quot;,&quot;You are discovered!&quot;,&quot;The flash of light illuminates you - you have been discovered!&quot;, &quot;From what do you wish to emerge?&quot;}})
  defs_data:set('scales', { type = 'subterfuge',
    on = {&quot;You concentrate and slowly your body is covered by protective, serpentine scales.&quot;,&quot;You are already covered in protective, serpentine scales.&quot;},
    def = &quot;Serpentine scales protect your body.&quot;,
    off = &quot;You ripple your muscles and as you watch, your skin turns white and peels off, taking your protective scaling with it.&quot;})
  defs_data:set('pacing', { type = 'subterfuge',
    on = {&quot;You begin to pace yourself and prepare for sudden bursts of exertion.&quot;,&quot;You are already pacing.&quot;},
    def = &quot;You are paced for bursts of exertion.&quot;,
    off = &quot;You are no longer pacing yourself.&quot;})
  defs_data:set('bask', { type = 'subterfuge',
    on = {&quot;You lie down and stretch yourself out, ready to bask beneath the blazing sun.&quot;, &quot;The stresses and strains of existence gradually fall from you.&quot;, &quot;The rays of sunlight spread a healing warmth through your body.&quot;},
    def = &quot;Your blood is being heated by the sun.&quot;,
    off = &quot;You rise to your feet.&quot;})
  defs_data:set('listen', { type = 'subterfuge',
    onr = [[^You listen intently to the (.+)\.$]],
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].eavesdrop then
        svo['def'..whereto][mode].eavesdrop = false
        if echoback then svo.echof(&quot;Removed eavesdrop from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    def = &quot;You are listening in on another conversation.&quot;,
    specialskip = function ()
      return (defc.eavesdrop)
    end
    })
  defs_data:set('eavesdrop', { type = 'subterfuge',
    onr = [[^You listen intently to the (.+)\.$]],
    def = &quot;You are listening in on another conversation.&quot;}) --this ability completely replaces listen
  defs_data:set('lipread', { type = 'subterfuge',
    on = {&quot;You will now lip read to overcome the effects of deafness.&quot;, &quot;You are already lipreading.&quot;},
    def = &quot;You are lipreading to overcome deafness.&quot;,
    specialskip = function()
      return ((not defc.deaf and not affs.deafaff) or defc.mindseye)
    end })
  defs_data:set('weaving', { type = 'subterfuge',
    mana = 'lots',
    on = {&quot;You picture a cobra in your mind, and slowly begin to weave back and forth agilely.&quot;, &quot;You are already imitating the cobra.&quot;},
    def = &quot;Cobra-like, you are weaving back and forth to dodge blows.&quot;,
    off = &quot;You cease your cobra-like weaving.&quot;,  --this vanishes when mana is 0 without a message, just like alertness
    })
  defs_data:set('cloaking', { type = 'subterfuge',
    on = &quot;You toss a sparkling cloud of dust over yourself and as it settles you shimmer into invisibility.&quot;,
    def = &quot;Your actions are cloaked in secrecy.&quot;,
    off = {&quot;You dispel all illusion magics that were woven about yourself.&quot;,&quot;Your shroud dissipates and you return to the realm of perception.&quot;},
    -- not compatible with ghost per Alyssea
    offr = [[^\w+ points a finger at you and you feel anti-magic sweep over you\.$]] })
  defs_data:set('ghost', { type = 'subterfuge',
    on = &quot;You project a net of light about yourself until your image becomes faded and ghostly.&quot;,
    def = &quot;You are shimmering with a ghostly light.&quot;,
    off = {&quot;You dispel all illusion magics that were woven about yourself.&quot;, &quot;Your ghostly image slowly intensifies until you appear flesh and blood again.&quot;},
    offr = [[^\w+ points a finger at you and you feel anti-magic sweep over you\.$]], })
  defs_data:set('secondsight', { type = 'subterfuge',
    on = {&quot;You narrow your eyes, allowing your vision to extend beyond the normal spectrum.&quot;, &quot;You already possess the second sight.&quot;},
    def = &quot;You are able to detect wormholes due to possessing the second sight.&quot;,})
end

if svo.haveskillset('swashbuckling') then
  defs_data:set('drunkensailor', { type = 'swashbuckling',
    on = {&quot;You start swaying to and fro seemingly unpredictably as you enter the stance of the Drunken Sailor.&quot;, &quot;You are already in the stance of the Drunken Sailor.&quot;},
    def = &quot;The Drunken Sailor stance protects you.&quot;,
    off = &quot;You relax into your normal fighting stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].heartsfury then
        svo['def'..whereto][mode].heartsfury = false
        if echoback then svo.echof(&quot;Removed heartsfury from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    specialskip = function ()
      return (defc.heartsfury)
    end})
  defs_data:set('arrowcatch', { type = 'swashbuckling',
    mana = 'lots',
    on = {&quot;You have begun to look for arrows to pluck from the air.&quot;, &quot;You already have arrowcatching on.&quot;},
    def = &quot;You are attempting to pluck arrows from the air.&quot;,
    off = &quot;You've turned off arrowcatching.&quot;})
  defs_data:set('balancing', { type = 'swashbuckling',
    mana = 'lots',
    on = {&quot;You move onto the balls of your feet and begin to concentrate on balance.&quot;, &quot;You're already balancing.&quot;},
    def = &quot;You are balancing on the balls of your feet.&quot;,
    off = &quot;You cease to balance on the balls of your feet.&quot;})
  defs_data:set('acrobatics', { type = 'swashbuckling',
    on = {&quot;You begin leaping and bouncing about, making it more difficult to hit you.&quot;, &quot;You are already bouncing around acrobatically.&quot;},
    def = &quot;You are bouncing around acrobatically.&quot;,
    off = &quot;You cease your acrobatic leaping and bouncing.&quot;})
  defs_data:set('dodging', { type = 'swashbuckling',
    on = {&quot;You resolve to keep an eye on the skies for danger.&quot;, &quot;You are already watching the skies.&quot;},
    def = &quot;You are watching the skies for danger.&quot;,
    off = &quot;You cease watching the skies.&quot;})
  defs_data:set('grip', { type = 'swashbuckling',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
  defs_data:set('heartsfury', { type = 'swashbuckling',
    on = {&quot;Taut with rage, you enter the Heart's Fury stance.&quot;, &quot;You are already in the Heart's Fury stance.&quot;},
    def = &quot;The Heart's Fury stance protects you.&quot;,
    off = &quot;You relax into your normal fighting stance.&quot;,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].drunkensailor then
        svo['def'..whereto][mode].drunkensailor = false
        if echoback then svo.echof(&quot;Removed drunkensailor from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    specialskip = function ()
      return (defc.drunkensailor)
    end})

  --[[trueparry = { type = 'swashbuckling',
    on = &quot;You will now attempt to parry attacks on your arms&quot;, --arms replaceable with legs/centre/right/left
    def = {&quot;You will attempt to parry attacks to your left arm.&quot;, &quot;You will attempt to parry attacks to your right arm.&quot;} --DEF shows both limbs being parried when trueparrying
    off = &quot;You cease your attempts at parrying.&quot;]]
end

if svo.haveskillset('voicecraft') then
  defs_data:set('lay', { type = 'voicecraft',
    on = {&quot;You sing a powerful Lay of distortion, protecting against the creation of physical images of yourself.&quot;, &quot;You sing a powerful Lay of distortion.&quot;},
    def = &quot;You are protected from the creation of physical images of yourself.&quot;,
    offr = [[^Your Lay of distortion is destroyed by \w+'s attempted fashion\.$]]})
  defs_data:set('tune', { type = 'voicecraft',
    on = &quot;Singing a powerful tune of safety and protection, you weave musical defences around yourself.&quot;,
    def = &quot;You are protected from damage by a tune of safety.&quot;})
  defs_data:set('songbird', { type = 'voicecraft',
    on = {&quot;Lifting your head, you whistle an intricate, lilting tune. You are soon answered by a blue-feathered songbird that wings swiftly in and perches upon your shoulder.&quot;, &quot;Your songbird twitters upon your shoulder, reminding you of its presence.&quot;},
    def = &quot;A songbird is perched upon your shoulder.&quot;,
    off = &quot;With a final chirp, the songbird upon your shoulder takes flight and wings swiftly away.&quot;})
  defs_data:set('aria', { type = 'voicecraft',
    on = {&quot;Your voice rises to the heavens with your instrument as you sing an Aria of healing to yourself.&quot;, &quot;Your voice rises to the heavens with your instrument, but without your audience, as you sing an Aria of healing to yourself.&quot;},
    def = &quot;Your health is enhanced by the beauties of an Aria.&quot;,
    off = &quot;The heavenly strains of the Aria slowly fall silent.&quot;})
end

if svo.haveskillset('harmonics') then
  defs_data:set('lament', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;Slowly you take up the dark and sombre tones of a Lament.&quot;,
    off = &quot;A burdensome sense of oppression lifts as the Lament arrives at its mournful conclusion.&quot;})
  defs_data:set('anthem', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;An Anthem fills the air with its mighty fortress of protective influences as you take up its stately music.&quot;,
    off = &quot;The structure of protection afforded by the Anthem decays with the final notes of the composition.&quot;})
  defs_data:set('harmonius', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;Blending several seemingly distinct musical ideas into one majestic whole, you begin the Harmonius.&quot;,
    off = &quot;The individual strands blended by the Harmonius slowly disintegrate into cacophony as the song ends.&quot;})
  defs_data:set('contradanse', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;An elaborate Contradanse melody begins to pervade the room.&quot;,
    off = &quot;Melody slows, simplifies, and comes to an end, terminating the elaborate Contradanse.&quot;})
  defs_data:set('paxmusicalis', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;You experience true rest and relief as you gently enter into the first soothing passage of the Pax Musicalis.&quot;,
    off = &quot;The peaceful strains of the Paxmusicalis slowly fade to silence.&quot;})
  defs_data:set('gigue', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;You dash off a few bars, launching into the detailed patterns of a Gigue.&quot;,
    off = &quot;Your thoughts return to their normal order as the Gigue's airs fade from the room.&quot;})
  defs_data:set('bagatelle', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;Through a series of musical twists and turns you begin the Bagatelle.&quot;,
    off = &quot;Twisting and turning no more, the Bagatelle ends suddenly.&quot;})
  defs_data:set('partita', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;Delicate and precise, you take up a Partita.&quot;,
    off = &quot;The Partita ends without fanfare, precisely as it began.&quot;})
  defs_data:set('berceuse', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;You begin a delicate Berceuse, playing with great tenderness.&quot;,
    off = &quot;The Berceuse drifts faintly away as its final notes float softly through the area.&quot;})
  defs_data:set('continuo', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;Your feelings rise with a Continuo's opening movement.&quot;,
    off = &quot;The Continuo falters and dies and, along with it, the thrilling feeling it had brought.&quot;})
  defs_data:set('wassail', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;The Wassail's first notes stir and strengthen you.&quot;,
    off = &quot;The Wassail trails slowly off, coming to a melancholy conclusion.&quot;})
  defs_data:set('canticle', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;You enter into the realms of the divine as you play the opening strains of a sacred Canticle.&quot;,
    off = &quot;The instabilities of the world again impinge upon you as the Canticle draws to a close.&quot;})
  defs_data:set('reel', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;With a hop you enter into the complex, up-tempo dance melody of a Reel.&quot;,
    off = &quot;The Reel comes around again, sounding as though ready to begin another step, and suddenly stops.&quot;})
  defs_data:set('hallelujah', {type = 'harmonics', custom_def_type = 'harmonic',
    on = &quot;With a powerful fanfare, you begin a resounding Hallelujah.&quot;,
    off = &quot;The Hallelujah's final amen fills you with awe at its power, and sorrow for the ending of this uplifting piece.&quot;})
end

if svo.haveskillset('devotion') then
  defs_data:set('inspiration', { type = 'devotion',
    on = {&quot;You bow your head and, praying to the gods for inspiration, you are soon rewarded as your body is suffused with strength.&quot;},
    def = &quot;Your limbs are suffused with divinely-inspired strength.&quot;,
    off = &quot;You slump slightly as the divinely-inspired strength leaves your body.&quot; })
  defs_data:set('bliss', { type = 'devotion',
    staysindragon = true,
    on = {&quot;You pour blessings of bliss over yourself, granting visions of the majesty of the divine.&quot;, &quot;The divine choir lingers on in your mind, and your spirit soars.&quot;, &quot;That person is already experiencing bliss.&quot;},
    onr = [[^(\w+) pours blessings over you, and divine choirs begin to sing joyously at the edge of your hearing\.]],
    invisibledef = true })
  defs_data:set('bloodsworn', { type = 'devotion',
    onr = [[^You are bloodsworn to \w+\.$]],
    on = &quot;The true power of the bloodsworn begins to rage in your veins.&quot;,
    invisibledef = true,
    off = &quot;The power of the bloodsworn leaves you.&quot; })
end

if svo.haveskillset('spirituality') then
  defs_data:set('mace', { type = 'spirituality',
    invisibledef = true})
  defs_data:set('heresy', { type = 'spirituality',
    def = &quot;You are hunting heretics.&quot;,
    off = &quot;Your rage to destroy heretics subsides.&quot;,
    on = {&quot;Rage fills you as the thought of heresy inspires you to greater efforts.&quot;, &quot;You are already hunting the heretics.&quot;}})
  defs_data:set('summon', { type = 'spirituality',
    def = &quot;You are regenerating endurance at an increased rate.&quot;,
    custom_def_type = 'angel',
    off = {&quot;The light of the guardian angel dims quietly out of existence.&quot;, &quot;Your guardian angel must be visible before you can communicate with her.&quot;, &quot;Your guardian angel shimmers silently away.&quot;},
    on = {&quot;A flower of white light blooms in the air beside you, and your guardian is by your side.&quot;, &quot;You feel confusion radiate from your guardian, who hovers already at your side.&quot;}})
  defs_data:set('empathy', { type = 'spirituality',
    specialskip = function() return not defc.summon end,
    off = {&quot;You stop using your guardian angel's empathic link.&quot;, &quot;You're not using your guardian angel's empathic link.&quot;, &quot;Your empathic link with your angel is severed.&quot;},
    custom_def_type = 'angel',
    on = {&quot;A feeling of deep peace fills you as your fate is bound with that of your guardian angel.&quot;, &quot;Your guardian informs you sadly that she lacks the power to obey your command.&quot;}})
  defs_data:set('care', { type = 'spirituality',
    specialskip = function() return not defc.summon end,
    off = {&quot;Your guardian angel ceases healing your afflictions.&quot;, &quot;Your guardian angel is not currently healing your afflictions.&quot;, &quot;Your guardian ceases to pass on her care.&quot;},
    custom_def_type = 'angel',
    on = {&quot;Your guardian angel begins to shimmer with a soft red light.&quot;, &quot;Your guardian informs you sadly that she lacks the power to obey your command.&quot;}})
  defs_data:set('watch', { type = 'spirituality',
    on = &quot;You bid your angel to watch over you.&quot;,
    off = {&quot;You order your angel to cease tracking the movements of your enemies.&quot;, &quot;Your guardian angel is not currently watching your enemies.&quot;, &quot;Your guardian ceases to watch.&quot;},
    custom_def_type = 'angel',
    })
end

if svo.haveskillset('metamorphosis') then
  defs_data:set('affinity', { type = 'metamorphosis',
    on = {&quot;You are already embracing the spirit that dwells within you.&quot;, &quot;You embrace the spirit that dwells within you and are overcome with the joy of true unity.&quot;},
    def = &quot;You have a great affinity with your spirit form.&quot; })
    --general meta ability,

  defs_data:set('bonding', { type = 'metamorphosis',
    on = {&quot;You are already bonding with the spirits, Metamorph.&quot;, &quot;Your soul draws inexorably closer to its spirit host as the spiritual bonding magic works about you.&quot;},
    def = &quot;You are bonded to your spirit totem.&quot;,
    off = {&quot;Your soul is not under the influence of a spiritual bond to its spirit host&quot;, &quot;You shiver briefly as the spiritual bonding of your soul to its spirit host ends.&quot;}})
    --general meta ability

  defs_data:set('elusiveness', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.elusiveness end,
    on = {&quot;You are already watching for pursuit.&quot;, &quot;Your eyes flicker this way and that as you watch for pursuers.&quot;},
    def = &quot;You are alert to those who would pursue you.&quot;,
    off = {&quot;You are not watching for pursuers, Metamorph.&quot;, &quot;You cease watching for pursuit.&quot;},
    })
    --Basilisk, Hyena, Wolverine, Jaguar

  defs_data:set('flame', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.flame end,
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'hydra'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    invisibledef = true,
    on = {&quot;You take a deep breath and realise your error - you sputter and engulf yourself in fire!&quot;, &quot;You take a deep breath and feel the heat begin to build within you.&quot;, &quot;You are ready to breathe yellow fire.&quot;, &quot;You are ready to breathe blue fire.&quot;,&quot;You are ready to breathe white fire.&quot;, &quot;With a roar you channel your reserves into your inner flame, instantly summoning forth a raging inferno.&quot;},
    offr = [[^You inhale deeply, allowing the raging flames to build up inside you. With an earth-shaking roar, you release a white-hot jet of fire directly at \w+\.$]],
    off = {&quot;A small gout of fire erupts harmlessly from your mouth.&quot;, &quot;You take a deep breath and realise your error - you sputter and engulf yourself in fire!&quot;, &quot;Unleashing white-hot flames in a reckless burst of fire, you create a roaring inferno about your person.&quot;, &quot;Your inner fire does not burn with sufficient intensity, Metamorph.&quot;, &quot;You take a deep breath and realise your error - you splutter and engulf yourself in fire!&quot;},
    })
    --Wyvern, Basilisk

  defs_data:set('lyre', { type = 'metamorphosis',
    specialskip = function() return not conf.lyre or not sk.morphsforskill.lyre end,
    availableindragon = true,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].meditate then
        svo['def'..whereto][mode].meditate = false
        if echoback then svo.echof(&quot;Removed meditate from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].breath then
        svo['def'..whereto][mode].breath = false
        if echoback then svo.echof(&quot;Removed breath from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].flame then
        svo['def'..whereto][mode].flame = false
        if echoback then svo.echof(&quot;Removed flame from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = {&quot;You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.&quot;, &quot;You strum a Lasallian lyre, and a prismatic barrier forms around you.&quot;, &quot;You deftly shape the wall of light into a barrier surrounding yourself.&quot;, &quot;You strum a darkly glowing mandolin, and a prismatic barrier forms around you.&quot;},
    def = &quot;You are standing within a prismatic barrier.&quot;,
    off = {&quot;Your prismatic barrier dissolves into nothing.&quot;, &quot;The stream hits your prismatic barrier, shattering it.&quot;, &quot;The breath weapon rips apart your prismatic barrier.&quot;, &quot;The breath weapon rips through both your shield and prismatic barrier.&quot;, &quot;The spear shatters your prismatic barrier.&quot;}})
    --Nightingale Only

  -- defs_data:set('nightsight', { type = 'metamorphosis',
  --   specialskip = function() return not sk.morphsforskill.nightsight end,
  --   on = &quot;Your vision sharpens with light as you gain night sight.&quot;,
  --   def = &quot;Your vision is heightened to see in the dark.&quot;,
  --   off = &quot;Your eyes lose the benefit of night sight.&quot;,
  --   })
    --Wildcat, Wolf, Cheetah, Owl, Hyena, Condor, Wolverine, Jaguar, Eagle, Icewyrm, Wyvern, Hydra

  defs_data:set('rest', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.rest end,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].flame then
        svo['def'..whereto][mode].flame = false
        if echoback then svo.echof(&quot;Removed flame from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = {&quot;You find a quiet corner, curl up and settle down to rest.&quot;,&quot;You feel the strains of the world falling away from your weary limbs.&quot;, &quot;But you're already resting, O sloth!&quot;},
    invisibledef = true,
    off = &quot;Your rest is interrupted.&quot;,&quot;You rise from your rest, refreshed and full of energy.&quot;})
    --Sloth only

  defs_data:set('resistance', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.resistance end,
    on = &quot;You call aloud and feel an aura of resistance shroud itself silently about you.&quot;,
    def = &quot;You are resisting magical damage.&quot;})
    --Basilisk, Jaguar, Hydra

  defs_data:set('stealth', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.stealth end,
    on = {&quot;You are already moving in total silence.&quot;, &quot;You will now move in total silence.&quot;},
    def = &quot;Your movements are incredibly stealthy.&quot;,
    off = {&quot;You are not currently moving silently, Metamorph.&quot;, &quot;You cease concentrating on stealth.&quot;},
    })
    --Basilisk, Hyena, Jaguar

  defs_data:set('temperance', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.temperance end,
    on = {&quot;Your skin is already chilled, Metamorph.&quot;, &quot;A chill runs over your icy skin.&quot;},
    def = &quot;You are tempered against fire damage.&quot;,
    })
    --Icewyrm, Wyvern, Hydra

  defs_data:set('vitality', { type = 'metamorphosis',
    specialskip = function() return not sk.morphsforskill.vitality end,
    on = {&quot;Your body is already aglow with vitality.&quot;, &quot;Your body positively glows with health and vitality.&quot;},
    def = &quot;You will call upon your fortitude in need.&quot;,
    off = {&quot;You cannot call upon your vitality again so soon.&quot;, &quot;A surge of rejuvenating energy floods your system, healing your wounds.&quot;}})
    --Bear, Elephant, Jaguar, Icewyrm, Wyvern, Hydra

  defs_data:set('squirrel', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A squirrel spirit co-habits your body.&quot; })
  defs_data:set('wildcat', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A wildcat spirit co-habits your body.&quot; })
  defs_data:set('wolf', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A wolf spirit co-habits your body.&quot; })
  defs_data:set('turtle', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A turtle spirit co-habits your body.&quot; })
  defs_data:set('jackdaw', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A jackdaw spirit co-habits your body.&quot; })
  defs_data:set('cheetah', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A cheetah spirit co-habits your body.&quot; })
  defs_data:set('owl', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;An owl spirit co-habits your body.&quot; })
  defs_data:set('hyena', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A hyena spirit co-habits your body.&quot; })
  defs_data:set('condor', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A condor spirit co-habits your body.&quot; })
  defs_data:set('gopher', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A gopher spirit co-habits your body.&quot; })
  defs_data:set('sloth', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A sloth spirit co-habits your body.&quot; })
if svo.me.class == 'Sentinel' then
  defs_data:set('basilisk', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A basilisk spirit co-habits your body.&quot; })
end
  defs_data:set('bear', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A bear spirit co-habits your body.&quot; })
  defs_data:set('nightingale', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A nightingale spirit co-habits your body.&quot; })
  defs_data:set('elephant', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;An elephant spirit co-habits your body.&quot; })
  defs_data:set('wolverine', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A wolverine spirit co-habits your body.&quot; })
if svo.me.class == 'Sentinel' then
  defs_data:set('jaguar', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A jaguar spirit co-habits your body.&quot; })
end
  defs_data:set('eagle', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;An eagle spirit co-habits your body.&quot; })
  defs_data:set('gorilla', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A gorilla spirit co-habits your body.&quot; })
  defs_data:set('icewyrm', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;An icewyrm spirit co-habits your body.&quot; })
if svo.me.class == 'Druid' then
  defs_data:set('wyvern', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A wyvern spirit co-habits your body.&quot; })

  defs_data:set('hydra', { type = 'metamorphosis',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'squirrel', 'wildcat', 'wolf', 'turtle', 'jackdaw', 'cheetah', 'owl', 'hyena', 'condor', 'gopher', 'sloth', 'basilisk', 'bear', 'nightingale', 'elephant', 'wolverine', 'jaguar', 'eagle', 'gorilla', 'icewyrm', 'wyvern', 'hydra', 'flame'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,
    def = &quot;A hydra spirit co-habits your body.&quot;})
end
end

if svo.haveskillset('occultism') then
  defs_data:set('shroud', { type = 'occultism',
    on = &quot;Calling on your dark power, you draw a thick shroud of concealment about yourself to cover your every action.&quot;,
    off = {&quot;Your shroud dissipates and you return to the realm of perception.&quot;, &quot;The flash of light illuminates you - you have been discovered!&quot;},
    offr = [[^\w+ points a finger at you and you feel anti-magic sweep over you\.$]],
    def = &quot;Your actions are cloaked in secrecy.&quot; })
  defs_data:set('astralvision', { type = 'occultism',
    on = {&quot;Gritting your teeth, you focus your will and expand your aura throughout the surroundings about you, seeking out the aura of others.&quot;, &quot;You already possess enhanced vision.&quot;},
    --astralvision gives both deathsight and lifevision at the same time, there is no way to manually lower lifevision
    def = &quot;You have enhanced your vision to be able to see traces of lifeforce.&quot; })
  defs_data:set('distortedaura', { type = 'occultism',
    on = {&quot;Clenching your fists, you focus your will on distorting your own aura. Your mind reels as your aura twists the very air around you.&quot;, &quot;Your aura is already distorted, Occultist.&quot;},
    off = {&quot;You concentrate on calming your distorted aura, breathing a sigh of relief as it subsides to its normal state.&quot;,&quot;Your aura is not distorted, Occultist.&quot;},
    def = &quot;You have distorted your own aura.&quot; })
  defs_data:set('tentacles', { type = 'occultism',
    on = {&quot;You raise your hands above your head, focusing your will to warp your own body. Ignoring the excruciating pain, tentacles spring out from the sides of your body and flail about of their own accord.&quot;,&quot;Tentacles are already flailing from your body.&quot;},
    off = &quot;You breathe a sigh of comfort as the flailing tentacles recede back into your body.&quot;,
    def = &quot;You have tentacles flailing from your body.&quot; })
  defs_data:set('devilmark', { type = 'occultism',
    on = {&quot;You lick your finger and then bend your will to the task of tracing the mark of the devil over your heart. There is a slight burning and a black mark forms where you've traced.&quot;,&quot;You already have the mark of the devil upon your heart.&quot;, [[The Devil in your service says, &quot;Your will demands I serve you again, and so it shall be.&quot;]]},
    off = {&quot;You do not bear the mark of the devil.&quot;, &quot;You draw your hand across your heart, releasing any devils in your service and erasing their mark from your skin.&quot;, &quot;You feel the devilmark fade from your heart.&quot;, &quot;You bend your will to the task of tracing the mark of the devil over your heart, but the presence of a devil waiting in service nullifies its effect.&quot;},
    specialskip = function() return defc.devil end,
    def = &quot;The devilmark is upon your breast.&quot; })
  defs_data:set('astralform', { type = 'occultism',
    on = {&quot;You summon all your will to focus your aura. In a flash of blazing light, your aura consumes your body and nothing is left except your disembodied presence.&quot;,&quot;You have taken the astralform and can not do that.&quot;},
    offr = {[[^You concentrate and are once again \w+\.$]],[[You are already in \w+ form\.$]]},
    def = &quot;As an insubstantial astral light, you are immune from many attacks.&quot; })
  defs_data:set('heartstone', { type = 'occultism',
    on = &quot;Cupping your hands before you, you tap into your stores of karma. Focusing your will on the image of your own heart, an unearthly crimson glow fills your cupped hands and solidifies into a heart-shaped ruby.&quot;,
    off = &quot;A heartstone cracks and crumbles to dust.&quot;,
    invisibledef = true })
  defs_data:set('simulacrum', { type = 'occultism',
    on = &quot;Cupping your hands before you, you tap into your stores of karma. Focusing your will on an image of yourself, an unearthly violet glow fills your cupped hands and solidifies into an amethyst resembling you.&quot;,
    offr = [[^A simulacrum shaped like &lt;fix me, insert character name here&gt; cracks and crumbles to dust\.$]],
    invisibledef = true })
  defs_data:set('transmogrify', { type = 'occultism',
      staysindragon = true,
      --Not useful to track it going up or down, since there's a random delay of 4-10 hours between.
      off = {&quot;You carefully raise a barrier between your soul and the Chaos Lord spirit within you.&quot;},
      on = {&quot;You lower the barrier separating your soul from the Chaos Lord spirit within you.&quot;},
      defr = [[The spirit of a Chaos (?:Lord|Lady) lies dormant in your soul\.$]] })
end

if svo.haveskillset('tarot') then
  defs_data:set('devil', { type = 'tarot',
      on = {[[You fling the card at the ground, and a red, horned Devil rises from the bowels of the earth to say, &quot;I will serve you but once...Master.&quot;]], &quot;You bend your will to the task of tracing the mark of the devil over your heart, but the presence of a devil waiting in service nullifies its effect.&quot;, [[The Devil in your service says, &quot;Your will demands I serve you again, and so it shall be.&quot;]]},
      off = {&quot;You feel the Devil leave you.&quot;, &quot;You lick your finger and then bend your will to the task of tracing the mark of the devil over your heart. There is a slight burning and a black mark forms where you've traced.&quot;, &quot;You draw your hand across your heart, releasing any devils in your service and erasing their mark from your skin.&quot;},
      invisibledef = true,
      offr = {[[^You quickly fling a Lust card at \w+ and (?:his|her) eyes light up\.$]], [[^You toss the Hanged Man tarot card at \d+ and as it reaches (?:him|her), a huge mass of rope bursts out of it to entrap and hinder (?:him|her)\.$]], [[^As you fling the Moon tarot at \w+, it turns an ominous, sickly red, before striking (?:him|her) in the head\.$]], [[^With a prayer to Miramar, the Just, you fling your tarot card at \w+\. A set of scales appears above (?:his|her) head and one side of the scale quickly descends\. Justice will be done\.$]], [[^You stand an Aeon tarot on your palm, and blow it lightly at \w+\.$]], [[^Standing the Aeon on your open palm, you blow it lightly at \w+ and watch as it seems to slow (?:his|her) movement through the time stream\.$]]},
    })
end

if svo.haveskillset('domination') then
  defs_data:set('arctar', { type = 'domination',
    on = {&quot;You command your chaos orb to grant you protection; it pulses once before detonating in a soundless conflagration.&quot;, &quot;You cannot summon Arctar, the Defender for you have no pact with that entity.&quot;},
    on_only = &quot;The Entity refuses to send another minion to aid you.&quot;,
    def = &quot;Surrounded by the power of Arctar.&quot;,
    off = &quot;Abruptly, the power rippling across your skin dissipates.&quot;,})
  defs_data:set('golgotha', { type = 'domination',
    on = {&quot;You cannot summon Jy'Barrak Golgotha, Emperor of Chaos for you have no pact with that entity.&quot;, &quot;Closing your eyes, you focus on your contract with Jy'Barrak Golgotha, Emperor of Chaos, beseeching Him for His aide. For the briefest instant the overpowering stench of sulphur fills your nostrils, then a flash of acknowledgement passes to you. Your skin comes alight with a furious burning, and a dire, inhuman sense of vicious amusement fills you as you are suffused with the power of the Emperor of Darkness. Your muscles lock and a scream claws at your throat, but you can do nothing until the pain leaves you except convulse in abject agony.&quot;},
    def = &quot;You are acknowledged by Jy'Barrak Golgotha, Emperor of Chaos.&quot;})
end

if svo.haveskillset('healing') then
  defs_data:set('simultaneity', {
    type = 'healing',
    custom_def_type = 'channel'
  })
  defs_data:set('bindall', {
    type = 'healing',
    custom_def_type = 'channel'
  })
  defs_data:set('fortifyall', {
    type = 'healing',
    custom_def_type = 'channel'
  })
  defs_data:set('air', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to air.&quot;, &quot;The power of air is harnessed to your will.&quot;}})
  defs_data:set('fire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to fire.&quot;, &quot;Elemental fire burns at your behest.&quot;}})
  defs_data:set('water', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to water.&quot;, &quot;Purest water soothes you into calm.&quot;}})
  defs_data:set('earth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to earth.&quot;, &quot;The strength of earth is at your command.&quot;}})
  defs_data:set('spirit', {
    off = {&quot;You sever the link to the realm of spirit.&quot;, &quot;The power of the knife sigil cuts your spirit channel.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to spirit.&quot;, &quot;You merge the four elemental channels and the formidable powers of the spirit realms are yours.&quot;}})

  defs_data:set('fortifiedair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Air channel.&quot;}})
  defs_data:set('fortifiedfire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;, &quot;Your magics around the fire channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Fire channel.&quot;}})
  defs_data:set('fortifiedwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Water channel.&quot;}})
  defs_data:set('fortifiedearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Earth channel.&quot;}})
  defs_data:set('fortifiedspirit', {
    off = {&quot;You sever the link to the realm of spirit.&quot;, &quot;The power of the knife sigil cuts your spirit channel.&quot;, &quot;Your magics around the spirit channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Spirit channel.&quot;}})

  defs_data:set('boundair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Air to your superior will.&quot;}})
  defs_data:set('boundfire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;, &quot;Your magics around the fire channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Fire to your superior will.&quot;}})
  defs_data:set('boundwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Water to your superior will.&quot;}})
  defs_data:set('boundearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Earth to your superior will.&quot;}})
  defs_data:set('boundspirit', {
    off = {&quot;You sever the link to the realm of spirit.&quot;, &quot;The power of the knife sigil cuts your spirit channel.&quot;, &quot;Your magics around the spirit channel have been destroyed by the knife sigil.&quot;},
    type = 'healing',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Spirit to your superior will.&quot;}})
  defs_data:set('frostblessing', { type = 'healing',
    on = &quot;You call upon the elements Air and Water and bestow the Frost Spiritshield blessing upon yourself.&quot;,
    def = &quot;You are protected by the power of a Frost Spiritshield.&quot;})
  defs_data:set('willpowerblessing', { type = 'healing',
    on = &quot;You call upon the elements Air, Water, and Fire and bestow the Willpower blessing upon yourself.&quot;,
    def = &quot;You are regenerating willpower at an increased rate.&quot;})
  defs_data:set('thermalblessing', { type = 'healing',
    on = &quot;You call upon the elements Fire and Spirit and bestow the Thermal Spiritshield blessing upon yourself.&quot;,
    def = &quot;You are protected by the power of a Thermal Spiritshield.&quot;})
  defs_data:set('earthblessing', { type = 'healing',
    on = &quot;You call upon the elements Earth and Spirit and bestow the Earth Spiritshield blessing upon yourself.&quot;,
    def = &quot;You are protected by the power of an Earth Spiritshield.&quot;})
  defs_data:set('enduranceblessing', { type = 'healing',
    def = &quot;You are regenerating endurance at an increased rate.&quot;,
    on = &quot;You call upon the elements Water, Earth, and Fire and bestow the Endurance blessing upon yourself.&quot;})
  defs_data:set('bedevil', { type = 'healing',
    on = {&quot;You manipulate the elements to lash at those who would do you harm.&quot;, &quot;You are already protected by the bedeviling aura.&quot;},
    def = &quot;An aura of bedevilment has been established about your person.&quot;,
    off = &quot;The elemental aura surrounding you sputters and dies.&quot;})
end

if svo.haveskillset('elementalism') then
  defs_data:set('stoneskin', {
    type = 'elementalism',
    specialskip = function () return not defc.earth end,
    def = &quot;Magically supple granite coats your body.&quot;,
    on = {&quot;Calling the powers of the elemental earth to you, you coat yourself in magically-supple granite.&quot;, &quot;Your skin is already covered in a protective, amazingly supple, granite coating.&quot;}})
  defs_data:set('diamondskin', {
    type = 'elementalism',
    specialskip = function() return not (defc.water and defc.fire and defc.earth) end,
    def = &quot;Diamond-hard skin protects you.&quot;,
    on = {&quot;Your skin is already covered in a protective, magically-flexible, diamond-hard coating.&quot;, &quot;Calling upon crystalline powers, you wrap your skin in a flexible, diamond-hard coating.&quot;}})

  defs_data:set('stonefist', {
    type = 'elementalism',
    on = {&quot;You already possess fists of stone.&quot;, &quot;You call upon the powers of the earth to coat your fists in dense granite.&quot;},
    off = &quot;The granite enveloping your fists cracks and falls off.&quot;,
    def = &quot;Your fists are covered with dense granite.&quot;})
  defs_data:set('efreeti', {
    type = 'elementalism',
    invisibledef = true,
    off = &quot;The efreeti begins to spin faster and faster, and suddenly disappears in a blaze of flame.&quot;,
    offr = [[^A fiery efreeti, your loyal companion, has been slain by]],
    on = {&quot;You are unable to summon more than one efreeti.&quot;, &quot;You rub your hands together briskly, heating them with friction, and with a word, throw them open. A fiery efreeti appears before you, swirling in a vortex of flame.&quot;}})
  defs_data:set('waterweird', {
    type = 'elementalism',
    on = {&quot;You do not have the power to summon more than one water weird.&quot;, &quot;You summon a water weird to assist you in water crossings.&quot;},
    def = &quot;Your water weird allows you to walk on water.&quot;})
  defs_data:set('chargeshield', {
    type = 'elementalism',
    on = {&quot;You already have a chargeshield active.&quot;, &quot;You call upon the powers of air and earth to weave a non-conducting energy shield around you.&quot;},
    def = &quot;You are surrounded by a non-conducting chargeshield.&quot;})
  defs_data:set('reflection', {
    type = 'elementalism',
    def = &quot;You are surrounded by one reflection of youself.&quot;,
    defr = [[^You are surrounded by \d+ reflections? of yourself\.$]],
    on = {&quot;You cast a spell of reflection over yourself.&quot;, &quot;This spell may only be used to cast one reflection on someone. If he or she already has one, it may not be used.&quot;},
    off = {&quot;One of your reflections has been destroyed! You have 0 left.&quot;, &quot;All your reflections wink out of existence!&quot;}})

  defs_data:set('simultaneity', {
    type = 'elementalism',
    custom_def_type = 'channel'
  })
  defs_data:set('bindall', {
    type = 'elementalism',
    custom_def_type = 'channel'
  })
  defs_data:set('fortifyall', {
    type = 'elementalism',
    custom_def_type = 'channel'
  })
  defs_data:set('air', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to air.&quot;, &quot;The power of air is harnessed to your will.&quot;}})
  defs_data:set('fire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to fire.&quot;, &quot;Elemental fire burns at your behest.&quot;}})
  defs_data:set('water', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to water.&quot;, &quot;Purest water soothes you into calm.&quot;}})
  defs_data:set('earth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to earth.&quot;, &quot;The strength of earth is at your command.&quot;}})

  defs_data:set('fortifiedair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Air channel.&quot;}})
  defs_data:set('fortifiedfire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;, &quot;Your magics around the fire channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Fire channel.&quot;}})
  defs_data:set('fortifiedwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Water channel.&quot;}})
  defs_data:set('fortifiedearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Earth channel.&quot;}})

  defs_data:set('boundair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Air to your superior will.&quot;}})
  defs_data:set('boundfire', {
    off = {&quot;You sever the link to the realm of fire.&quot;, &quot;The power of the knife sigil cuts your fire channel.&quot;, &quot;Your magics around the fire channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Fire to your superior will.&quot;}})
  defs_data:set('boundwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Water to your superior will.&quot;}})
  defs_data:set('boundearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'elementalism',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Earth to your superior will.&quot;}})
end

if svo.haveskillset('apostasy') then
  defs_data:set('armour', {
    type = 'apostasy',
    stays_on_death = true,
    on = {&quot;You already are surrounded by unholy armour.&quot;, &quot;You ask your Baalzadeen for its protection, and it summons a thin black protecting sheen over you.&quot;},
    def = &quot;Your person is surrounded by black demonic armour.&quot;})
  defs_data:set('syphon', {
    type = 'apostasy',
    invisibledef = true,
    on = {&quot;Your Baalzadeen begins to shimmer with a demonic red light.&quot;, &quot;Your Baalzadeen is already syphoning your diseases.&quot;}})
  defs_data:set('mask', {
    type = 'apostasy',
    invisibledef = true,
    stays_on_death = true,
    on = {&quot;You wrap your Baalzadeen in a mask of impenetrable obscurity.&quot;, &quot;Your Baalzadeen is already masked.&quot;}})
  defs_data:set('daegger', {
    type = 'apostasy',
    invisibledef = true,
    on = {&quot;You call upon the Lords of Hell to bestow the living weapon, the daegger, unto you.&quot;, &quot;Your daegger comes racing towards you, stopping unnaturally quickly to land in your grasp.&quot;}})
  defs_data:set('pentagram', {
    type = 'apostasy',
    on = {&quot;Using your daegger, you open a vein in your wrist, and let the blood drip to outline a pentagram, floating waist-high.&quot;, &quot;There is already a pentagram here.&quot;}
  })
  defs_data:set('baalzadeen', {
    type = 'apostasy',
    off = &quot;You must be leading your Baalzadeen.&quot;,
    on = {&quot;Imposing your will on Hell itself, you summon forth a Baalzadeen to serve your whim.&quot;, &quot;You call out, ordering your Baalzadeen to return to serve your whim.&quot;},
    invisibledef = true,
    stays_on_death = true,
  })
end

if svo.haveskillset('weatherweaving') then
  defs_data:set('simultaneity', {
    type = 'weatherweaving',
    custom_def_type = 'channel'
  })
  defs_data:set('bindall', {
    type = 'weatherweaving',
    custom_def_type = 'channel'
  })
  defs_data:set('fortifyall', {
    type = 'weatherweaving',
    custom_def_type = 'channel'
  })
  defs_data:set('air', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to air.&quot;, &quot;The power of air is harnessed to your will.&quot;}})
  defs_data:set('water', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to water.&quot;, &quot;Purest water soothes you into calm.&quot;}})
  defs_data:set('earth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You already have a channel opened to earth.&quot;, &quot;The strength of earth is at your command.&quot;}})
  defs_data:set('fortifiedair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Air channel.&quot;}})
  defs_data:set('fortifiedwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Water channel.&quot;}})
  defs_data:set('fortifiedearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You weave a layer of protective magic about your open elemental channels.&quot;, &quot;You weave a layer of protective magic about the Earth channel.&quot;}})
  defs_data:set('boundair', {
    off = {&quot;You sever the link to the realm of air.&quot;, &quot;The power of the knife sigil cuts your air channel.&quot;, &quot;Your magics around the air channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Air to your superior will.&quot;}})
  defs_data:set('boundwater', {
    off = {&quot;You sever the link to the realm of water.&quot;, &quot;The power of the knife sigil cuts your water channel.&quot;, &quot;Your magics around the water channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Water to your superior will.&quot;}})
  defs_data:set('boundearth', {
    off = {&quot;You sever the link to the realm of earth.&quot;, &quot;The power of the knife sigil cuts your earth channel.&quot;, &quot;Your magics around the earth channel have been destroyed by the knife sigil.&quot;},
    type = 'weatherweaving',
    custom_def_type = 'channel',
    on = {&quot;You bind all your open elemental channels to you.&quot;, &quot;You bind the element of Earth to your superior will.&quot;}})
  defs_data:set('circulate', { type = 'weatherweaving',
    on = {&quot;You begin circulating electricity throughout your body in a constant cycle.&quot;, &quot;You are already circulating electricity throughout your body.&quot;},
    def = &quot;You are circulating electricity throughout your body.&quot;})
  defs_data:set('reflection', {
    type = 'weatherweaving',
    def = &quot;You are surrounded by one reflection of youself.&quot;,
    defr = [[^You are surrounded by \d+ reflections? of yourself\.$]],
    on = {&quot;You cast a spell of reflection over yourself.&quot;, &quot;This spell may only be used to cast one reflection on someone. If he or she already has one, it may not be used.&quot;},
    off = {&quot;One of your reflections has been destroyed! You have 0 left.&quot;, &quot;All your reflections wink out of existence!&quot;}})
end

if svo.haveskillset('pranks') then
  defs_data:set('arrowcatch', { type = 'pranks',
    mana = 'lots',
    on = {&quot;You have begun to look for arrows to pluck from the air.&quot;, &quot;You already have arrowcatching on.&quot;},
    def = &quot;You are attempting to pluck arrows from the air.&quot;,
    off = &quot;You've turned off arrowcatching.&quot;})
  defs_data:set('balancing', { type = 'pranks',
    mana = 'lots',
    on = {&quot;You move onto the balls of your feet and begin to concentrate on balance.&quot;, &quot;You're already balancing.&quot;},
    def = &quot;You are balancing on the balls of your feet.&quot;,
    off = &quot;You cease to balance on the balls of your feet.&quot;})
  defs_data:set('acrobatics', { type = 'pranks',
    on = {&quot;You begin leaping and bouncing about, making it more difficult to hit you.&quot;, &quot;You are already bouncing around acrobatically.&quot;},
    def = &quot;You are bouncing around acrobatically.&quot;,
    off = &quot;You cease your acrobatic leaping and bouncing.&quot;})
  defs_data:set('slipperiness', { type = 'pranks',
    on = {&quot;You're quite the slippery little fellow aren't you?&quot;, &quot;You're already quite slippery.&quot;, &quot;You're quite the slippery little gal aren't you?&quot;},
    def = &quot;You are looking a little shady today.&quot;,
    })
end

if svo.haveskillset('puppetry') then
  defs_data:set('grip', { type = 'puppetry',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
end


if svo.haveskillset('vodun') then
  defs_data:set('grip', { type = 'vodun',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
end

if svo.haveskillset('curses') then
  defs_data:set('swiftcurse', { type = 'curses',
    on = &quot;You weave your fingers together, calling upon the swiftcurse to aid you.&quot;,
    def = &quot;The swiftcurse is upon you.&quot;,
    off = &quot;The swiftcurse leaves you.&quot;})
end

if svo.haveskillset('kaido') then
  defs_data:set('weathering', { type = 'kaido',
    on = &quot;A brief shiver runs through your body.&quot;,
    def = &quot;Your body is weathering the storm of life a little better.&quot;})
  defs_data:set('resistance', { type = 'kaido',
    on = &quot;You call aloud and feel an aura of resistance shroud itself silently about you.&quot;,
    def = &quot;You are resisting magical damage.&quot;})
  defs_data:set('numb', { type = 'kaido',
    on = &quot;You grit your teeth and will your pain out of existence.&quot;,
    off = &quot;You cry out in agony as the effects of your numbness fade away and you feel your wounds once more.&quot;,
    def = &quot;You are temporarily numbed to damage.&quot; })
  defs_data:set('regeneration', { type = 'kaido',
    on = {&quot;You begin to concentrate on regeneration of your wounds.&quot;, &quot;Regeneration is already on.&quot;},
    def = &quot;You are regenerating lost health through the power of Kaido.&quot;,
    off = {&quot;You have no regenerative ability to boost.&quot;, &quot;You call a halt to the regenerative process.&quot;}})
  defs_data:set('boosting', { type = 'kaido',
    onenable = function (mode, newdef, whereto, echoback)
      if not svo['def'..whereto][mode].regeneration then
        svo['def'..whereto][mode].heartsfury = true
        if echoback then svo.echof(&quot;Added regeneration to %s, it's necessary for %s.&quot;, whereto, newdef) end
      end

      return true
    end,
    specialskip = function() return not defc.regeneration end,
    on = {&quot;You call upon your Kai power to boost your health regeneration.&quot;, &quot;Your regeneration is already boosted.&quot;},
    def = &quot;Your regeneration is boosted.&quot;,
    off = {&quot;You call a halt to the regenerative process.&quot;}})
  defs_data:set('kaiboost', { type = 'kaido',
    off = &quot;You are no longer boosting your Kai gain.&quot;,
    def = &quot;You have boosted the power of your Kai Trance.&quot;,
    on = &quot;You gather up and expend your Kai energy to enhance your sensitivity to its energies.&quot;})
  defs_data:set('toughness', { type = 'kaido',
    on = &quot;Flexing your muscles, you concentrate on forcing unnatural toughness over the surface of your skin.&quot;,
    def = &quot;Your skin is toughened.&quot;})
  -- disabled, better be general for dragons to work
  -- defs_data:set('nightsight', { type = 'kaido',
  --   def = &quot;Your vision is heightened to see in the dark.&quot;,
  --   on = {&quot;Your vision sharpens with light as you gain night sight.&quot;, &quot;Your eyes already have the benefit of night sight.&quot;},
  --   off = {&quot;Your eyes lose the benefit of night sight.&quot;, &quot;Your eyes cannot lose the benefit of night sight, since they do not already have it!&quot;}})
  defs_data:set('projectiles', { type = 'kaido',
    mana = 'lots',
    def = &quot;You are alert to incoming projectiles.&quot;,
    off = {&quot;You cease your watch for projectiles.&quot;, &quot;You are not watching for projectiles.&quot;},
    on = &quot;You look about sharply, poised to avoid all incoming projectiles.&quot;})
  defs_data:set('trance', { type = 'kaido',
    mana = 'lots',
    on = {&quot;You begin to chant an ancient mantra, preparing your body to become a channel for Kai energy.&quot;, &quot;Your mantra is complete - the Kai Trance is upon you.&quot;},
    off = &quot;You break out of the Kai Trance, sighing as you feel your accumulated Kai energy vanish.&quot;,
    def = &quot;You are utilising the trance to store Kai energy.&quot;})
  defs_data:set('dodging', { type = 'kaido',
    mana = 'lots',
    on = &quot;You resolve to keep an eye on the skies for danger.&quot;,
    def = &quot;You are watching the skies for danger.&quot;,
    off = {&quot;You are not using Shindo Dodging.&quot;, &quot;You cease watching the skies.&quot;}})
  defs_data:set('constitution', { type = 'kaido',
    def = &quot;You are using your superior constitution to prevent nausea.&quot;,
    on = {&quot;You clench the muscles in your stomach, determined to svo.assert your superior constitution.&quot;, &quot;You are using your superior constitution to prevent nausea.&quot;}})
  defs_data:set('splitmind', { type = 'kaido',
    on = {&quot;You begin to devote a portion of your Kaido-trained mind to constant, unconscious meditation.&quot;, &quot;Your mind is already split.&quot;},
    def = &quot;Your mind is split, allowing constant meditation.&quot;,
    off = {&quot;You cease the process of Kai meditation, joining the split segments of your mind once more.&quot;, &quot;Your mind is already whole.&quot;}})
  defs_data:set('consciousness', { type = 'kaido',
    def = &quot;You are maintaining consciousness at all times.&quot;,
    off = {&quot;You are not maintaining consciousness.&quot;, &quot;You will no longer concentrate on retaining full consciousness.&quot;},
    on = {&quot;You are already maintaining consciousness.&quot;, &quot;You will remain conscious at all times.&quot;}})
  defs_data:set('sturdiness', { type = 'kaido',
    on = &quot;You cross your arms, standing firm and resolute.&quot;,
    def = &quot;You are standing firm against attempts to move you.&quot;,
    off = &quot;You cease to stand firm against attempts to move you.&quot;})
  defs_data:set('vitality', { type = 'kaido',
    on = {&quot;Your body is already aglow with vitality.&quot;, &quot;Your body positively glows with health and vitality.&quot;},
    def = &quot;You will call upon your fortitude in need.&quot;,
    off = {&quot;A surge of rejuvenating energy floods your system, healing your wounds.&quot;, &quot;You cannot call upon your vitality again so soon.&quot;}})
  defs_data:set('immunity', { type = 'kaido',
    on = &quot;You close your eyes and grit your teeth, feeling the heat of the blood pumping through your veins.&quot;,
    off = &quot;You cease concentrating on immunity.&quot;})
end

if svo.haveskillset('shikudo') then
  local onenable_shikudo = function (mode, newdef, whereto, echoback)
    local shikudo_forms = {
      'tykonos',
      'willow',
      'rain',
      'oak',
      'gaital',
      'maelstrom'
    }

    local fail_string =
      &quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;

    for _, shikudo_form in ipairs(shikudo_forms) do
      if shikudo_form ~= newdef and svo['def'..whereto][mode][shikudo_form] then
        svo['def'..whereto][mode][shikudo_form] = false
        if echoback then svo.echof(fail_string, shikudo_form, whereto, newdef) end
      end
    end

    return true
  end

  defs_data:set('tykonos', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the Tykonos form.&quot;,
    on = &quot;You spin your staff in the opening sequence of the form of Tykonos, snapping into a ready stance.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('willow', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the Willows shaken by the Wind form.&quot;,
    on = &quot;Twirling your staff, you sink into the calm required for the form of Willows Shaken by the Wind.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('rain', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the Willows in Rain Storm form.&quot;,
    on = &quot;Dropping into a lower stance, you snap your weapon into an offensive position, tensing your muscles in preparation for the form of Willows in Rain Storm.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('oak', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the the Live Oak form.&quot;,
    on = &quot;Rising onto the balls of your feet, you prepare to begin the deadly form of the Live Oak.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('gaital', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the Gaital form.&quot;,
    on = &quot;You let your eyes fall closed and instinct guide you as you flow into the form of Gaital.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('maelstrom', {
    type = 'shikudo',
    onenable = onenable_shikudo,
    def = &quot;You are enacting the the Unrelenting Storm form.&quot;,
    on = &quot;You allow your kai to flow through you, circulating throughout your limbs and down your weapon in preparation to begin the form of the Unrelenting Storm.&quot;,
    off = [[^You clumsily transition from the form of \w+ into the form of]]
  })
  defs_data:set('grip', {
    type = 'shikudo',
    on = {&quot;You concentrate on gripping tightly with your hands.&quot;, &quot;You are already tightly gripping with your hands.&quot;},
    def = &quot;Your hands are gripping your wielded items tightly.&quot;,
    off = &quot;You relax your grip.&quot;})
end

if svo.haveskillset('tekura') then
  defs_data:set('guarding', { nodef = true,
    ondef = function ()
      local t = svo.sps.parry_currently
      for limb, _ in pairs(t) do t[limb] = false end
      t[matches[2]] = true
      svo.check_sp_satisfied()

      return &quot;(&quot;..matches[2]..&quot;)&quot;
    end,
    tooltip = &quot;Completely blocks health and wound damage on a limb if you aren't hindered.&quot;,
    defr = [[^You will attempt to throw those who attack your (.+)\.$]]
  })
  defs_data:set('bodyblock', { type = 'tekura',
    mana = 'lots',
    def = &quot;You are trying to absorb blows to your body.&quot;,
    on = &quot;You ready yourself to block as best you can.&quot;,
    off = {&quot;You drop all your blocks.&quot;, &quot;You lower your body block.&quot;}})
  defs_data:set('pinchblock', { type = 'tekura',
    mana = 'lots',
    def = &quot;You will try to pinch block a weakened foe.&quot;,
    on = &quot;You ready yourself to pinch block to the best of your ability.&quot;,
    off = {&quot;You drop all your blocks.&quot;, &quot;You lower your pinch block.&quot;}})
  defs_data:set('evadeblock', { type = 'tekura',
    mana = 'lots',
    def = &quot;You are using Tekura to evade incoming attacks.&quot;,
    on = &quot;You ready yourself to evade incoming blows.&quot;,
    off = {&quot;You drop all your blocks.&quot;, &quot;You lower your evade block.&quot;}})

  defs_data:set('horse', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You drop your legs into a sturdy Horse stance.&quot;,
    def = &quot;You are in the Horse stance.&quot;,
    off = &quot;You ease yourself out of the Horse stance.&quot;})
  defs_data:set('eagle', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You draw back and balance into the Eagle stance.&quot;,
    def = &quot;You are in the Eagle stance.&quot;,
    off = &quot;You ease yourself out of the Eagle stance.&quot;})
  defs_data:set('cat', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You tense your muscles and look about sharply as you take the stance of the Cat.&quot;,
    def = &quot;You are in the Cat stance.&quot;,
    off = &quot;You ease yourself out of the Cat stance.&quot;})
  defs_data:set('bear', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You draw yourself up to full height and roar aloud, adopting the Bear stance.&quot;,
    def = &quot;You are in the Bear stance.&quot;,
    off = &quot;You ease yourself out of the Bear stance.&quot;})
  defs_data:set('rat', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You take the Rat stance.&quot;,
    def = &quot;You are in the Rat stance.&quot;,
    off = &quot;You ease yourself out of the Rat stance.&quot;})
  defs_data:set('scorpion', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You sink back into the menacing stance of the Scorpion.&quot;,
    def = &quot;You are in the Scorpion stance.&quot;,
    off = &quot;You ease yourself out of the Scorpion stance.&quot;})
  defs_data:set('dragon', { type = 'tekura',
    onenable = function (mode, newdef, whereto, echoback)
      for _, morph in ipairs{'horse', 'eagle', 'cat', 'bear', 'rat', 'scorpion', 'dragon'} do
        if morph ~= newdef and svo['def'..whereto][mode][morph] then
          svo['def'..whereto][mode][morph] = false
          if echoback then svo.echof(&quot;Removed %s from %s, it's incompatible with %s to have simultaneously up.&quot;, morph, whereto, newdef) end
        end
      end

      return true
    end,

    on = &quot;You allow the form of the Dragon to fill your mind and govern your actions.&quot;,
    def = &quot;You are in the Dragon stance.&quot;,
    off = &quot;You ease yourself out of the Dragon stance.&quot;})
end

if svo.haveskillset('telepathy') then
  defs_data:set('mindtelesense', { type = 'telepathy',
    mana = 'lots',
    on = &quot;You attune your mind to tampering from telepathy.&quot;,
    off = &quot;You cease to concentrate your mind on mindlock attempts.&quot;,
    def = &quot;You are using your telesense.&quot;})
  defs_data:set('mindcloak', { type = 'telepathy',
    on = {&quot;You will now begin to concentrate on cloaking your telepathy.&quot;, &quot;You are already cloaking your attempts at mindlocking.&quot;},
    off = &quot;You allow the mindcloak to drop.&quot;,
    def = &quot;You are cloaking your attempts at establishing a mindlock.&quot;})
  defs_data:set('mindnet', { type = 'telepathy',
    on = {&quot;You cast an invisible mind net out into the distance, allowing it to settle about the surrounding land.&quot;, &quot;You already have mindnet active.&quot;},
    off = &quot;You cease concentration and your mind net vanishes.&quot;,
    mana = 'little',
    def = &quot;You have cast a mindnet over the local area.&quot;})
  defs_data:set('hypersense', { type = 'telepathy',
    mana = 'lots',
    on = &quot;You begin detecting mindlock attempts in your local area.&quot;,
    off = &quot;You turn hypersense off.&quot;,
    def = &quot;You are using your hypersense.&quot;})
end

if svo.haveskillset('woodlore') then
  defs_data:set('barkskin', { type = 'woodlore',
    on = {&quot;You concentrate for a moment, and your skin becomes rough and thick like tree bark.&quot;, &quot;Your skin is already covered in protective bark.&quot;, &quot;Your skin is already as tough as bark.&quot;},
    def = &quot;Your skin is hard and tough like the bark of an oak tree.&quot;})
  defs_data:set('hiding', { type = 'woodlore',
    on = {&quot;You conceal yourself using all the guile you possess.&quot;, &quot;You are already hidden.&quot;},
    def = &quot;You have used great guile to conceal yourself.&quot;,
    off = {&quot;You emerge from your hiding place.&quot;,&quot;You are discovered!&quot;,&quot;The flash of light illuminates you - you have been discovered!&quot;, &quot;From what do you wish to emerge?&quot;}})
  defs_data:set('spinning', { type = 'woodlore',
    onr = [[^You begin to rapidly spin .+ in a defensive pattern\.$]],
    off = [[^You cease spinning .+\.$]]})
  defs_data:set('impaling', { type = 'woodlore',
    onr = [[^You plant the butt end of .+ firmly on the ground and ready yourself to impale any charging enemies\.$]],
    def = &quot;You are preparing to impale onrushing attackers.&quot;,
    off = &quot;You cease your preparations to impale any charging enemies.&quot;})
  defs_data:set('evasion', { type = 'woodlore',
    on = {&quot;You must be in the air before you can begin evasive flying.&quot;, &quot;You begin soaring erratically and frantically, attempting to avoid the eyes gazing up from below.&quot;, &quot;You are already attempting to elude the prying eyes below.&quot;},
    def = &quot;You are flying evasively.&quot;,
    off = {&quot;You cease your aerial acrobatics.&quot;, &quot;You are already not attempting to elude the prying eyes below.&quot;}})
  defs_data:set('firstaid', { type = 'woodlore',
    on = {&quot;You begin to concentrate on clotting your wounds.&quot;, &quot;You have already turned on first aid.&quot; },
    off = {&quot;You cease to concentrate on the clotting of your wounds.&quot;,&quot;You've already turned off first aid.&quot;},
    def = &quot;You are concentrating on clotting your wounds.&quot;})
  defs_data:set('fleetness', { type = 'woodlore',
    on = &quot;You will seek out the best paths through the forest.&quot;,
    def = &quot;You are able to navigate forests more easily.&quot;})
end

if svo.haveskillset('propagation') then
  defs_data:set('barkskin', { type = 'propagation',
    on = {&quot;You concentrate for a moment, and your skin becomes rough and thick like tree bark.&quot;, &quot;Your skin is already covered in protective bark.&quot;, &quot;Your skin is already as tough as bark.&quot;},
    def = &quot;Your skin is hard and tough like the bark of an oak tree.&quot;})
  defs_data:set('viridian', { type = 'propagation',
    def = &quot;You have taken the form of the Viridian.&quot;,
    off = &quot;You will the vines to retreat, and you shed the form of the Viridian.&quot;})
end

if svo.haveskillset('groves') then
  defs_data:set('panacea', { type = 'groves',
    on = {&quot;You call on the curative powers of Nature. A spiralling helix of wildflowers and lush leaves races up the length of your quarterstaff, before sublimating into a cool mist that drifts about your body.&quot;, &quot;A healing mist already surrounds you, Forestwalker.&quot;},
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    off = &quot;The tendrils of delicate mist surrounding you disperse.&quot;,
    def = &quot;You are surrounded by a healing mist.&quot;})
  defs_data:set('vigour', { type = 'groves',
    on = {&quot;You are bathed in radiant sunlight, its warm glow seeping into your skin.&quot;, &quot;You are bathed in an aura of radiant sunlight.&quot;, &quot;An aura of sunlight already radiates around that person.&quot;},
    off = &quot;The radiant sunlight warming your body fades away.&quot;,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    def = &quot;You are bathed in an aura of radiant sunlight.&quot;})
  defs_data:set('flail', { type = 'groves',
    on = {&quot;You flail the quarterstaff smoothly around in the air about you to summon up a defensive sphere.&quot;, &quot;Your quarterstaff has already been flailed.&quot;},
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    def = &quot;You are flailing a wielded quarterstaff.&quot;})
  defs_data:set('wildgrowth', { type = 'groves',
    def = &quot;Your movements are trailed by profusions of wild growth.&quot;,
    on = {&quot;You quietly recite an incantation calling on all that is wild and green. As you speak the final syllables, you slowly raise your quarterstaff skywards, drawing vibrant new growth from the earth.&quot;, &quot;Wild vines already circle your feet.&quot;},
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    off = &quot;Curling in on itself, the tangle of wild green growth surrounding you retreats into the earth.&quot;})
  defs_data:set('dampening', { type = 'groves',
    invisibledef = true,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    on = &quot;You whirl your quarterstaff in a grand arc, and a distant rustling reaches your ears. Moments later, a flurry of leaves blankets the area with copper tones.&quot;})
  defs_data:set('snowstorm', { type = 'groves',
    invisibledef = true,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    on = &quot;You grip your quarterstaff tightly and with a whisper invoke winter's icy chill, the vapour of your breath growing visible as you speak. First scattered flakes and then great gusts of snow respond, as the area is overwhelmed by a glacial shroud of white.&quot;})
  defs_data:set('roots', { type = 'groves',
    invisibledef = true,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    off = &quot;The roots that secured you to the ground fall away and retreat back into the earth.&quot;,
    on = &quot;Roots spring up from the rich earth beneath your feet and wreath themselves gently about your form.&quot;})
  defs_data:set('concealment', { type = 'groves',
    invisibledef = true,
    off = &quot;The undergrowth parts slightly, and banishes the gloom that seemed to hang here.&quot;,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    on = {&quot;Your grove fills with gloom as the leaves huddle closer in secrecy.&quot;, &quot;This grove is already concealed from prying eyes.&quot;}})
  defs_data:set('screen', { type = 'groves',
    invisibledef = true,
    off = &quot;A low fizzle can be heard as the tension in the grove decreases.&quot;,
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    on = {&quot;You call a telepathic screen into being around your grove.&quot;, &quot;There is already a mind screen in existence here.&quot;}})
  defs_data:set('lyre', { type = 'groves',
    on_only = &quot;You find your sunlight reserves too low to attempt that.&quot;,
    specialskip = function() return not conf.lyre end,
    availableindragon = true,
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].meditate then
        svo['def'..whereto][mode].meditate = false
        if echoback then svo.echof(&quot;Removed meditate from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].breath then
        svo['def'..whereto][mode].breath = false
        if echoback then svo.echof(&quot;Removed breath from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].flame then
        svo['def'..whereto][mode].flame = false
        if echoback then svo.echof(&quot;Removed flame from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = {&quot;You begin to weave a melody of magical, heart-rending beauty and a beautiful barrier of prismatic light surrounds you.&quot;, &quot;You strum a Lasallian lyre, and a prismatic barrier forms around you.&quot;, &quot;You deftly shape the wall of light into a barrier surrounding yourself.&quot;, &quot;You strum a darkly glowing mandolin, and a prismatic barrier forms around you.&quot;},
    def = &quot;You are standing within a prismatic barrier.&quot;,
    off = {&quot;Your prismatic barrier dissolves into nothing.&quot;, &quot;The stream hits your prismatic barrier, shattering it.&quot;, &quot;The breath weapon rips apart your prismatic barrier.&quot;, &quot;The breath weapon rips through both your shield and prismatic barrier.&quot;, &quot;The spear shatters your prismatic barrier.&quot;}})
  defs_data:set('swarm', { type = 'groves',
    invisibledef = true,
    on = {&quot;You already have a swarm in the lands.&quot;, &quot;Barely within the range of normal hearing, you utter a buzz-like hum from deep within your throat.&quot;}})
  defs_data:set('harmony', { nodef = true,
    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = [[^You are under the blessing of the (\w+) environment\.$]]})
end

if svo.haveskillset('alchemy') then
  defs_data:set('lead', { type = 'alchemy',
    on = &quot;Directing the energy of lead, you increase your mass and weigh yourself down.&quot;,
    off = &quot;You feel your density return to normal.&quot;,
    def = &quot;You are extremely heavy and difficult to move.&quot;})
  defs_data:set('tin', { type = 'alchemy',
    on = {&quot;Directing the energy of tin, you erect a reflective barrier about yourself.&quot;, &quot;You are already surrounded by a protective barrier.&quot;},
    offr = [[^As \w+'s attack falls, your reflective barrier shatters and reflects the attack\.$]],
    def = &quot;You are protected by a reflective barrier.&quot;})
  defs_data:set('sulphur', { type = 'alchemy',
    on = {&quot;Directing the energy of sulphur, you surround yourself with an aura of primal energies, bolstering your healing capacity.&quot;, &quot;You are already drawing upon the power of sulphur.&quot;},
    off = &quot;The symbol of sulphur inscribed about you fades away.&quot;,
    tooltip = &quot;Boosts the effect of the vitality tonic.&quot;,
    def = &quot;You are bolstered by the energy of sulphur.&quot;})
  defs_data:set('mercury', { type = 'alchemy',
    on = {&quot;Directing the energy of mercury, you surround yourself with an aura of primal energies, boosting your mental regeneration.&quot;, &quot;You are already drawing upon the power of mercury.&quot;},
    off = &quot;The symbol of mercury inscribed about you fades away.&quot;,
    tooltip = &quot;Boosts the effect of the mentality tonic.&quot;,
    def = &quot;You are bolstered by the energy of mercury.&quot;})
  defs_data:set('extispicy', { type = 'alchemy',
    on = {&quot;As you poke through the entrails, a pink and shiny intestine foretells good fortune.&quot;, &quot;You've already divined the future, Alchemist.&quot;, &quot;As you poke through the entrails, a bleeding ulcer predicts great victories.&quot;},
    def = &quot;You have divined the future.&quot;})
  defs_data:set('empower', { type = 'alchemy',
    on = {
      &quot;You close your eyes and, calling upon latent alchemical energies, sketch the symbol of the sun in the air. A warm thrill shivers throughout your body, and a halo of pale flames flickers momentarily about your body.&quot;,
      &quot;You close your eyes and, calling upon latent alchemical energies, sketch the symbol of the moon in the air. A warm thrill shivers throughout your body, and a halo of pale flames flickers momentarily about your body.&quot;,
      &quot;You close your eyes and, calling upon latent alchemical energies, sketch the symbol of Nebula in the air. A warm thrill shivers throughout your body, and a halo of pale flames flickers momentarily about your body.&quot;,
      &quot;You close your eyes and, calling upon latent alchemical energies, sketch the symbol of Ethian in the air. A warm thrill shivers throughout your body, and a halo of pale flames flickers momentarily about your body.&quot;,
      &quot;&lt;fix me, insert character name here&gt; is already empowered by astronomical energies.&quot;,
      &quot;You are already empowered by astronomical energies.&quot;,
    },

    ondef = function () return &quot;(&quot;..matches[2]..&quot;)&quot; end,
    defr = [[^You are resonating with (?:the )?(?:Nebula )?(\w+)'s energy\.$]]})
end

if svo.haveskillset('skirmishing') then
  defs_data:set('scout', { type = 'skirmishing',
    on = &quot;You begin scouting ahead for danger.&quot;,
    def = {&quot;You are able to scout passed obstructions.&quot;, &quot;You are able to scout past obstructions.&quot;}})
end

if svo.haveskillset('shadowmancy') then
  defs_data:set('shadowcloak', {
    type = 'shadowmancy',
    custom_def_type = 'shadowcloak',
    offline_defence = true,
    invisibledef = true,
    stays_on_death = true,
    staysindragon = true,
    on = {
      &quot;You are now wearing a grim cloak.&quot;,
    },
    off = {
      &quot;You remove a grim cloak.&quot;,
      &quot;You must be wearing your cloak of darkness in order to perform this ability.&quot;
    }
   })
  defs_data:set('disperse', {
    type = 'shadowmancy',
    custom_def_type = 'shadowcloak',
    on = {
      &quot;The shadows swirl about you, masking you from view.&quot;,
      &quot;You have already shrouded yourself in beguiling shadow.&quot;
    },
    def = &quot;You are masking your egress.&quot;
   })
--shadowveil gives both shadowveil and hiding
  defs_data:set('shadowveil', {
    type = 'shadowmancy',
    custom_def_type = 'shadowcloak',
    on = {
      &quot;Summoning the shadows to coalesce about your person, you vanish into their stygian embrace.&quot;,
      &quot;You are already veiled within the shadows embrace.&quot;,
    },
    def = &quot;Concealed by a shifting veil of shadow.&quot;,
   })
  defs_data:set('hiding', {
    type = 'shadowmancy',
    custom_def_type = 'shadowcloak',
    on = {
      &quot;Summoning the shadows to coalesce about your person, you vanish into their stygian embrace.&quot;,
      &quot;You are already veiled within the shadows embrace.&quot;,
    },
    def = &quot;You have used great guile to conceal yourself.&quot;,
    off = {
      &quot;You emerge from your hiding place.&quot;,
      &quot;You are discovered!&quot;,
      &quot;The flash of light illuminates you - you have been discovered!&quot;,
      &quot;From what do you wish to emerge?&quot;
    }
   })

-- signals for shadowcloak tracking
  signals.gmcpcharitemslist:connect(function()
    if gmcp.Char.Items.List.location ~= 'inv' then
      return
    end
    for _, item in ipairs(gmcp.Char.Items.List.items) do
      if item.name == &quot;a grim cloak&quot; then
        if item.attrib and item.attrib:find('w') then
           defences.got('shadowcloak')
         else
           defences.lost('shadowcloak')
         end
         return
      end
    end
  end, 'add/remove shadowcloak on gmcp items list')
  signals.gmcpcharitemsadd:connect(function()
    if gmcp.Char.Items.Add.location ~= 'inv' then
      return
    end
    for _, item in ipairs(gmcp.Char.Items.Add.item) do
      if item.name == &quot;a grim cloak&quot; then
        if item.attrib and item.attrib:find('w') then
          defences.got('shadowcloak')
        end
      end
    end
  end, 'add shadowcloak on gmcp items add')
  signals.gmcpcharitemsremove:connect(function()
    if gmcp.Char.Items.Remove.location ~= 'inv' then
      return
    end
    for _, item in ipairs(gmcp.Char.Items.Remove.item) do
      if item.name == &quot;a grim cloak&quot; then
        defences.lost('shadowcloak')
      end
    end
  end, 'remove shadowcloak on gmcp items remove')
  signals.gmcpcharitemsupdate:connect(function()
    if gmcp.Char.Items.Update.location ~= 'inv' then
      return
    end
    for _, item in ipairs(gmcp.Char.Items.Update.item) do
      if item.name == &quot;a grim cloak&quot; then
        if item.attrib and item.attrib:find('w') then
          defences.got('shadowcloak')
        end
      end
    end
  end, 'add shadowcloak on gmcp items update')
end


if svo.haveskillset('aeonics') then
  defs_data:set('blur', { type = 'aeonics',
    def = &quot;Travelling the world more quickly due to time dilation.&quot;
  })
  defs_data:set('dilation', { type = 'aeonics',
    onenable = function (mode, newdef, whereto, echoback)
      if svo['def'..whereto][mode].breath then
        svo['def'..whereto][mode].breath = false
        if echoback then svo.echof(&quot;Removed breath from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].meditate then
        svo['def'..whereto][mode].meditate = false
        if echoback then svo.echof(&quot;Removed meditate from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end
      if svo['def'..whereto][mode].lyre then
        svo['def'..whereto][mode].lyre = false
        if echoback then svo.echof(&quot;Removed lyre from %s, it's incompatible with %s to have simultaneously up.&quot;, whereto, newdef) end
      end

      return true
    end,
    on = &quot;Growing very still, you begin to manipulate the flow of time around you, drastically speeding up your rate of regression.&quot;,
    off = {&quot;Your concentration broken, you cease dilating time.&quot;, &quot;Having fully regressed to your normal age, you cease dilating time.&quot;}})
end

if svo.haveskillset('terminus') then
  defs_data:set('trusad', { type = 'terminus',
    def = &quot;You are enhancing your precision through the power of Terminus.&quot;
  })
  defs_data:set('tsuura', { type = 'terminus',
    def = &quot;You are enhancing your durability against denizens.&quot;
  })
  defs_data:set('ukhia', { type = 'terminus',
    defr = &quot;^You are focus?sing on quelling your bleeding more efficiently\\.$&quot;
  })
  defs_data:set('qamad', { type = 'terminus',
    def = &quot;You have a will of iron.&quot;
  })
  defs_data:set('mainaas', { type = 'terminus',
    def = &quot;You have augmented your own body for enhanced defence.&quot;
  })
  defs_data:set('gaiartha', {
    type = 'terminus',
    staysindragon = true,
    def = &quot;You are concentrating on maintaining control over your faculties.&quot;
  })
else
  defs_data:set('gaiartha', { nodef = true,
    def = &quot;You are concentrating on maintaining control over your faculties.&quot;
  })
end

do
  function defences.enablelifevision()
    if svo.dict.lifevision then return end

    defs_data:set('lifevision', { type = 'general',
      on = {&quot;You narrow your eyes and blink rapidly, enhancing your vision to seek out sources of lifeforce in others.&quot;, &quot;You already possess enhanced vision.&quot;},
      def = &quot;You have enhanced your vision to be able to see traces of lifeforce.&quot;})

    svo.dict.lifevision = {
      physical = {
        name = 'lifevision_physical',
        balance = 'physical',
        action_name = 'lifevision',
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,

        isadvisable = function ()
          return (not defc.lifevision and ((sys.deffing and defdefup[defs.mode].lifevision) or (conf.keepup and defkeepup[defs.mode].lifevision)) and not svo.codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got('lifevision')
        end,

        action = 'lifevision',
        onstart = function ()
          send('lifevision', conf.commandecho)
        end
      }
    }

    for mode, _ in pairs(defdefup) do
      defdefup[mode].lifevision = defdefup[mode].lifevision or false
      defkeepup[mode].lifevision = defkeepup[mode].lifevision or false
    end

    sk.ignored_defences.general.t.lifevision = sk.ignored_defences.general.t.lifevision or false
    sk.ignored_defences_map['lifevision'] = 'general'

    defences.def_types['general'][#defences.def_types['general']+1] = 'lifevision'

    local v = defs_data.lifevision;
    local k = 'lifevision';
    if v.on and type(v.on) == 'table' then
      for _,pattern in ipairs(v.on) do
        (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
      end
    elseif v.on then
      (tempExactMatchTrigger or tempTrigger)(v.on, 'svo.defs.got_' .. sk.sanitize(k) .. '()')
    end

    (tempExactMatchTrigger or tempTrigger)(v.def, 'svo.defs.def_' .. sk.sanitize(k) .. '()');

    defs['def_'..sk.sanitize(k)] = function ()
      if not v.ondef then
        defences.def_def_list[k] = true
      else
        defences.def_def_list[k] = v.ondef()
      end
      deleteLine()
    end
    defs['got_' .. k] = function ()
      defences.got(k)
    end
    defs['lost_' .. k] = function ()
      defences.lost(k)
    end

    -- create a snapshot of the before state for all balances, since svo.dict_setup might mess with any
    local beforestate = sk.getbeforestateprios()

    svo.dict_setup()
    svo.dict_validate()

    -- notify any prio diffs
    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    signals.dragonform:emit()

    svo.echof(&quot;Have lifevision mask - enabled it for defup/keepup.&quot;)
  end

  function defences.checklifevision()
    local t = _G.gmcp.Char.Items.List
    if not t.location == 'inv' then return end

    -- feh! Easier to hardcode it for such a miniscule amount of items.
    -- If list enlarges, fix appopriately.
    for _, it in pairs(t.items) do
      -- if it.name == &quot;a Veil of the Sphinx&quot; then
      if it.name == &quot;a mask of lifevision&quot; or it.name == &quot;a painted basilisk mask&quot; or it.name == &quot;a silver mask with gold reliefs&quot; then
        defences.enablelifevision()
        conf.havelifevision = true
        raiseEvent(&quot;svo config changed&quot;, 'havelifevision')
        signals.gmcpcharitemslist:disconnect(defences.checklifevision)
      end
    end

  end
  signals.systemstart:connect(function()
    tempTimer(0, function()
      if conf.havelifevision then
        defences.enablelifevision()
        signals.gmcpcharitemslist:disconnect(defences.checklifevision)
      end
    end)
  end, 'enable lifevision when system loaded')
  signals.gmcpcharitemslist:connect(defences.checklifevision, 'check lifevision on gmcpcharitemslist')
end

do
  function defences.enableshroud()
    if svo.dict.shroud then return end

    defs_data:set('shroud', { type = 'general',
      on = {&quot;You draw your Shadowcloak about you and blend into your surroundings.&quot;, &quot;You draw a Shadowcloak about you and blend into your surroundings.&quot;, &quot;You draw a cloak of the Blood Maiden about you and blend into your surroundings.&quot;},
      def = &quot;Your actions are cloaked in secrecy.&quot;,
      off = {&quot;Your shroud dissipates and you return to the realm of perception.&quot;, &quot;The flash of light illuminates you - you have been discovered!&quot;}})

    svo.dict.shroud = {
      physical = {
        name = 'shroud_physical',
        balance = 'physical',
        action_name = 'shroud',
        balanceful_act = true,
        aspriority = 0,
        spriority = 0,
        def = true,

        isadvisable = function ()
          return (not defc.shroud and ((sys.deffing and defdefup[defs.mode].shroud) or (conf.keepup and defkeepup[defs.mode].shroud)) and not svo.codepaste.balanceful_defs_codepaste() and sys.canoutr and not affs.prone) or false
        end,

        oncompleted = function ()
          defences.got('shroud')
        end,

        action = 'shroud',
        onstart = function ()
          send('shroud', conf.commandecho)
        end
      }
    }

    for mode,_ in pairs(defdefup) do
      defdefup[mode].shroud = defdefup[mode].shroud or false
      defkeepup[mode].shroud = defkeepup[mode].shroud or false
    end

    sk.ignored_defences.general.t.shroud = sk.ignored_defences.general.t.shroud or false
    sk.ignored_defences_map['shroud'] = 'general'

    defences.def_types['general'][#defences.def_types['general']+1] = 'shroud'

    local v = defs_data.shroud;
    local k = 'shroud';
    -- FIXME not to be such a hack!
    (tempExactMatchTrigger or tempTrigger)(v.on[1], 'svo.defs.got_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.on[2], 'svo.defs.got_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.def, 'svo.defs.def_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.off[1], 'svo.defs.lost_' .. sk.sanitize(k) .. '()');
    (tempExactMatchTrigger or tempTrigger)(v.off[2], 'svo.defs.lost_' .. sk.sanitize(k) .. '()');

    defs['def_'..sk.sanitize(k)] = function ()
      if not v.ondef then
        defences.def_def_list[k] = true
      else
        defences.def_def_list[k] = v.ondef()
      end
      deleteLine()
    end
    defs['got_' .. k] = function ()
      defences.got(k)
    end
    defs['lost_' .. k] = function ()
      defences.lost(k)
    end

    -- create a snapshot of the before state for all balances, since svo.dict_setup might mess with any
    local beforestate = sk.getbeforestateprios()

    svo.dict_setup()
    svo.dict_validate()

    -- notify any prio diffs
    local afterstate = sk.getafterstateprios()
    sk.notifypriodiffs(beforestate, afterstate)

    signals.dragonform:emit()

    svo.echofn(&quot;Have Shadowcloak - enabled it for defup/keepup (&quot;)
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink('disable', [[svo.conf.haveshroud = nil; svo.echof(&quot;Alright - won't add shroud to defup/keepup next time.&quot;) raiseEvent(&quot;svo config changed&quot;, 'haveshroud')]], 'Click to disable shroud from getting added to defup/keepup next time', true)
    setUnderline(false)
    echo(&quot;)\n&quot;)
  end

  function defences.checkshroud()
    local t = _G.gmcp.Char.Items.List
    if not t.location == 'inv' then return end

    for _, it in pairs(t.items) do
      if it.name:find('Shadowcloak', 1, true) then
        defences.enableshroud()
        conf.haveshroud = true
        raiseEvent(&quot;svo config changed&quot;, 'haveshroud')
        signals.gmcpcharitemslist:disconnect(defences.checkshroud)
      end
    end

  end
  signals.systemstart:connect(function()
    tempTimer(0, function()
      if conf.haveshroud then
        defences.enableshroud()
        signals.gmcpcharitemslist:disconnect(defences.checkshroud)
      end
    end)
  end, 'enable shroud on login')
  signals.gmcpcharitemslist:connect(defences.checkshroud, 'check shroud on defs list')
end

-- check for both shadowcloak and mask of lifevision
function svo.detect_lifevision()
  sendGMCP(&quot;Char.Items.Inv&quot;)
  send(&quot;&quot;)
end

-- TODO: add a validator to make sure all defs have a type

-- quick debug validation
--~ for def, deft in defs_data:iter() do
  --~ if not deft.on and not deft.onr and not deft.nodef then
    --~ echo(def..&quot;, &quot;)
  --~ end
--~ end

defences.urlify = function (self)
  local t = string.split(self, &quot; &quot;)
  for i = 1, #t do
    t[i] = string.title(t[i])
  end

  return table.concat(t, '_')
end


defences.complete_def = function(tbl)
  local name, def, defr, tooltip = tbl.name, tbl.def, tbl.defr, tbl.tooltip
  name = name:lower()

  if not defs_data[name] then return end

  defs_data[name].def = def or defs_data[name].def
  defs_data[name].defr = defr or defs_data[name].defr
  defs_data[name].tooltip = tooltip
end

sk.showwaitingdefup = function()
  return svo.concatand(select(2, sk.have_defup_defs()))
end

-- def setup &amp; def-related controllers

-- used in 'vshow' to get the list of available defences
defences.print_def_list = function ()
  local t = {}; for defmode, _ in pairs(defdefup) do t[#t+1] = defmode end
  table.sort(t)

  -- echo each def mode: defence (-),
  for i = 1, #t do
    local defmode = t[i]

    if defmode ~= defs.mode then
      setFgColor(unpack(svo.getDefaultColorNums))
      setUnderline(true) echoLink(defmode, 'svo.defs.switch(&quot;'..defmode..'&quot;, true)', 'Switch to '..defmode..' defences mode', true) setUnderline(false)
    else
      fg'a_darkgreen'
      setUnderline(true) echoLink(defmode, 'svo.defs.switch(&quot;'..defmode..'&quot;, true)', 'Currently in this defence mode. Click to redo defup', true) setUnderline(false)
    end

    if sys.deffing and defmode == defs.mode then
      echo(&quot; (currently deffing)&quot;)
    end

    echo&quot; (&quot;
    fg'orange_red'setUnderline(true) echoLink('-', 'svo.delete_defmode(&quot;'..defmode..'&quot;, true)', 'Delete '..defmode.. ' defences mode', true) setUnderline(false) setFgColor(unpack(svo.getDefaultColorNums))
    echo&quot;, &quot;
    fg'a_darkgreen' setUnderline(true) echoLink('c', 'printCmdLine(&quot;vcopy defmode '..defmode..' TO &quot;)', &quot;Copy &quot;..defmode..&quot; into a new or existing defence mode&quot;, true) setUnderline(false) setFgColor(unpack(svo.getDefaultColorNums))
    echo&quot;)&quot;

    if i == #t then echo &quot; &quot; else
      echo&quot;, &quot;
    end
  end

  -- then an add the (+ add new), if we can
  if printCmdLine then
    echo(&quot;(&quot;)
    fg'a_darkgreen' setUnderline(true) echoLink(&quot;+ add new&quot;, 'printCmdLine(&quot;vcreate defmode &quot;)', &quot;Create a new defences mode&quot;, true) setUnderline(false) setFgColor(unpack(svo.getDefaultColorNums))
    echo(&quot;)&quot;)
  end

  echo&quot;\n&quot;
end

defences.get_def_list = function ()
  local s = svo.oneconcat(defdefup)

  if sys.deffing then
    s = string.gsub(s, &quot;(&quot;..defs.mode..&quot;)&quot;, &quot;(currently deffing) &lt;0,250,0&gt;%1&quot; .. svo.getDefaultColor())
  else
    s = string.gsub(s, &quot;(&quot;..defs.mode..&quot;)&quot;, &quot;&lt;0,250,0&gt;%1&quot; .. svo.getDefaultColor())
  end
  return s
end

-- nodefup is useful for relogging in, where you don't do defup, but you want keepup to be active
function defs.switch(which, echoback, nodefup)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not which then
    sendf(&quot;To which mode do you want to switch to?&quot;) return
  end

  if not defdefup[which] then
    sendf(&quot;%s defence mode doesn't exist - the list is: %s&quot;, which, svo.oneconcat(defdefup)) return
  end

  defs.mode = which

  if not nodefup and echoback then
    svo.echof(&quot;Deffing up in %s defence mode.&quot;, defs.mode)
  end

  rift.precache = rift.precachedata[defs.mode]
  if not nodefup then sys.deffing = true end
  sk.fix_affs_and_defs()
  startStopWatch(defences.defup_timer)

  raiseEvent(&quot;svo switched defence mode&quot;, defs.mode)
  if not nodefup then raiseEvent(&quot;svo started defup&quot;, defs.mode) end

  svo.make_gnomes_work()
  if not nodefup then svo.defupfinish() end
end

function defs.quietswitch(which, echoback)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not which then
    sendf(&quot;To which mode do you want to switch to?&quot;) return
  end

  if not defdefup[which] then
    sendf(&quot;%s defence mode doesn't exist - the list is: %s&quot;, which, svo.oneconcat(defdefup)) return
  end

  defs.mode = which

  if echoback then
    svo.echof(&quot;Deffing up in %s defence mode.&quot;, defs.mode)
  end

  rift.precache = rift.precachedata[defs.mode]
  sk.fix_affs_and_defs()
end

svo.defupfinish = function ()
  if not sys.deffing then return end

  -- serverside doesn't support defup and Svof doesn't emulate it at the moment
  if sk.have_defup_defs() then
    sys.deffing = false
    local time = stopStopWatch(defences.defup_timer)
    local timestring

    if time &gt; 60 then
      timestring = string.format(&quot;%dm, %.1fs&quot;, math.floor(time/60), time%60)
    else
      timestring = string.format(&quot;%.1fs&quot;, time)
    end

    echo&quot;\n&quot;
    svo.echof(&quot;Ready for combat! (%s defences mode, took %s)&quot;, defs.mode, (timestring == &quot;0.0s&quot; and &quot;no time&quot; or timestring))
    raiseEvent(&quot;svo done defup&quot;, defs.mode)
    signals.donedefup:emit()
    svo.showprompt()
  end
end

svo.defupcancel = function(echoback)
  if sys.deffing then
    sys.deffing = false
    if echoback then svo.echof(&quot;Cancelled defup.&quot;) end
  else
    if echoback then svo.echof(&quot;Weren't doing defup already.&quot;) end
  end

  stopStopWatch(defences.defup_timer)
end

function defs.keepup(which, status, mode, echoback, reshow)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not mode then mode = defs.mode end

  if not mode then
    sendf(&quot;We aren't in any defence mode yet - switch to one first.&quot;)
    return
  end

  if defkeepup[mode][which] == nil then
    sendf(&quot;Don't know about a %s defence.&quot;, which)
    return
  end

  -- if we were given an explicit option...
  if type(status) == 'string' then
    status = svo.convert_string(status)
  end

  -- if it's invalid or wasn't given to us, toggle
  if status == nil then
    if defkeepup[mode][which] then status = false
    else status = true end
  end

  if status == true and defs_data[which].onenable then
    local s,m = defs_data[which].onenable(mode, which, 'keepup', echoback)
    if not s then svo.echof(m) return end
  end

  defkeepup[mode][which] = status
  raiseEvent(&quot;svo keepup changed&quot;, mode, which, status)

  if echoback then
    if defkeepup[mode][which] then
      svo.echof(&quot;Will keep %s up%s.&quot;, which, (svo.ignore[which] and ' (however it\'s on ignore right now)' or ''))
    else
      svo.echof(&quot;Won't keep %s up anymore.&quot;, which)
    end

    if sys.deffing then
      svo.echof(&quot;You're still in defup however, and keepup is after defup. Still waiting on: %s to be put up.&quot;, sk.showwaitingdefup())
    elseif not conf.keepup and status == true then
      svo.echof(&quot;Keepup needs to be on, though.&quot;)
    end
  end

  sk.fix_affs_and_defs()
  svo.make_gnomes_work()

  if reshow then svo.show_keepup() echo&quot;\n&quot; end
end

function defs.defup(which, status, mode, echoback, reshow)
  local sendf; if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not mode then mode = defs.mode end

  if not mode then
    sendf(&quot;We aren't in any defence mode yet - switch to one first.&quot;)
    return
  end

  if defdefup[mode][which] == nil then
    sendf(&quot;Don't know about a %s defence.&quot;, which)
    return
  end

  -- if we were given an explicit option...
  if type(status) == 'string' then
    status = svo.convert_string(status)
  end

  -- if it's invalid or wasn't given to us, toggle
  if status == nil then
    if defdefup[mode][which] then status = false
    else status = true end
  end

  if status == true and defs_data[which].onenable then
    local s,m = defs_data[which].onenable(mode, which, 'defup', echoback)
    if not s then svo.echof(m) return end
  end

  defdefup[mode][which] = status
  raiseEvent(&quot;svo defup changed&quot;, mode, which, status)

  if echoback then
    if defdefup[mode][which] then
      svo.echof(&quot;Will put %s up in %s mode.&quot;, which, mode)
    else
      svo.echof(&quot;Won't put %s up anymore in %s mode.&quot;, which, mode)
    end
  end

  if reshow then svo.show_defup() echo&quot;\n&quot; end

  sk.fix_affs_and_defs()
  svo.make_gnomes_work()
end

function svo.create_defmode(which, echoback)
  local sendf; if echoback then sendf = svo.echof end

  svo.assert(which, &quot;Which defences mode do you want to create?&quot;, sendf)
  svo.assert(not (defdefup[which] and defkeepup[which]), which .. &quot; defences mode already exists.&quot;, sendf)

  defdefup[which] = {}
  defkeepup[which] = {}

  for k,_ in defs_data:iter() do
    defdefup[which][k] = false
    defkeepup[which][k] = false
  end

  rift.precachedata[which] = {}
  for _,herb in pairs(rift.herbsminerals) do
    rift.precachedata[which][herb] = 0
  end

  if echoback then
    sendf(&quot;Defences mode created. You may now do vdefs %s!&quot;, which)
    printCmdLine(&quot;vdefs &quot;..which)
  end
end

function svo.copy_defmode(which, newname, echoback)
  local sendf; if echoback then sendf = svo.echof end

  svo.assert(which, &quot;Which defences mode do you want to copy?&quot;, sendf)
  svo.assert(defdefup[which] and defkeepup[which], which .. &quot; defences mode doesn't exist.&quot;, sendf)
  svo.assert(newname, &quot;To which name do you want to rename &quot; .. which .. &quot; to?&quot;, sendf)

  defdefup[newname] = svo.deepcopy(defdefup[which])
  defkeepup[newname] = svo.deepcopy(defkeepup[which])
  rift.precachedata[newname] = svo.deepcopy(rift.precachedata[which])
  if echoback then svo.echof(&quot;Copied %s to %s.&quot;, which, newname) end
end

function svo.rename_defmode(which, newmode, echoback)
  local sendf; if echoback then sendf = svo.echof end

  svo.assert(which, &quot;Which defences mode do you want to rename?&quot;, sendf)
  svo.assert(defdefup[which] and defkeepup[which], which .. &quot; defences mode doesn't exist.&quot;, sendf)
  svo.assert(newmode, &quot;To which name do you want to rename &quot; .. which .. &quot; to?&quot;, sendf)

  if defs.mode == which then
    defs.mode = newmode
    if echoback then
      svo.echof(&quot;Changed your current defence mode to %s&quot;, defs.mode)
    end
  end

  defdefup[newmode], defdefup[which] = defdefup[which], defdefup[newmode]
  defkeepup[newmode], defkeepup[which] = defkeepup[which], defkeepup[newmode]
  rift.precachedata[which], rift.precachedata[newmode] = rift.precachedata[newmode], rift.precachedata[which]
  if echoback then svo.echof(&quot;Renamed %s to %s.&quot;, which, newmode) end
end

function svo.delete_defmode(which, echoback)
  local sendf; if echoback then sendf = svo.echof end

  svo.assert(which, &quot;Which defences mode do you want to delete?&quot;, sendf)
  svo.assert(defdefup[which] and defkeepup[which], which .. &quot; defences mode doesn't exist.&quot;, sendf)
  svo.assert(which ~= defs.mode, &quot;You're currently in &quot; .. which .. &quot; defmode already - switch to another one first, and then delete this one.&quot;, sendf)

  defdefup[which], defkeepup[which], rift.precachedata[which] = nil, nil, nil

  if math.random(1, 10) == 1 then
    svo.echof(&quot;Deleted '%s' defences mode.&quot;, which)
  else
    svo.echof(&quot;Deleted '%s' defences mode. Forever!&quot;, which) end
end

function svo.defload()
  local defdefup_t, defkeepup_t = {}, {}
  local defup_path, keepup_path = getMudletHomeDir() .. &quot;/svo/defup+keepup/defup&quot;, getMudletHomeDir() .. &quot;/svo/defup+keepup/keepup&quot;

  if lfs.attributes(defup_path) then table.load(defup_path, defdefup_t) end
  if lfs.attributes(keepup_path) then table.load(keepup_path, defkeepup_t) end
  if lfs.attributes(getMudletHomeDir() ..&quot;/svo/defup+keepup/ignored_defences&quot;) then
    table.load(getMudletHomeDir() ..&quot;/svo/defup+keepup/ignored_defences&quot;, sk.ignored_defences)
  end

  if lfs.attributes(getMudletHomeDir() ..&quot;/svo/defup+keepup/offline_defences&quot;) then
    local t = {}
    table.load(getMudletHomeDir() ..&quot;/svo/defup+keepup/offline_defences&quot;, t)

    for i = 1, #t do
      defences.got(t[i])
    end

    signals.dragonform:emit()
  end

  return defdefup_t, defkeepup_t
end

signals.relogin:connect(function()
  -- reset defs at login
  local t = {}
  for def in pairs(defc) do
    if def ~= 'dragonform' then
      t[#t+1] = defc
    end
  end

  for i = 1, #t do
    defences.lost(t[i])
  end
end, 'remove defs at login')

-- re-set defences mode to basic upon qqing and relogging in without closing Mudlet
function sk.loginonbasic()
  -- defs.mode = &quot;&quot; -- small hack to have the defup start event be raised when logging in for the first time, can't have the value on &quot;&quot; to begin with because the mode is always expected to be valid
  defs.switch('basic', true, true)

  -- disable initial connect and only use relogin after the first time
  signals.charname:disconnect(sk.loginonbasic)
  signals.gmcpcharname:disconnect(sk.loginonbasic)
end
signals.relogin:connect(sk.loginonbasic, 'change to basic mode at re/login')
signals.charname:connect(sk.loginonbasic, 'change to basic mode at re/login')
signals.gmcpcharname:connect(sk.loginonbasic, 'change to basic mode at re/login')

signals.saveconfig:connect(function ()
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/defup+keepup/defup&quot;, defdefup)
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/defup+keepup/keepup&quot;, defkeepup)
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/defup+keepup/ignored_defences&quot;, sk.ignored_defences)

  local t = {}
  for k,v in defs_data:iter() do if v.offline_defence and defc[k] then t[#t+1] = k end end
  svo.tablesave(getMudletHomeDir() .. &quot;/svo/defup+keepup/offline_defences&quot;, t)
end, 'save defs config')

function sk.sanitize(self)
  return string.gsub(self, &quot; &quot;, '_')
end

function sk.desanitize(self)
  return string.gsub(self, '_', &quot; &quot;)
end

signals.systemstart:connect(function ()
  local defdefup_t, defkeepup_t = svo.defload()

  -- create blank defup modes
  for k,_ in pairs(defdefup_t) do
    defdefup[k] = defdefup[k] or {}
    defkeepup[k] = defkeepup[k] or {}
  end


  for defname, defdata in defs_data:iter() do
    -- sort into def types if applicable
    if defdata.custom_def_type then
      defences.custom_types[defdata.custom_def_type] = defences.custom_types[defdata.custom_def_type] or {}
      defences.custom_types[defdata.custom_def_type][defname] = true
    end

    if defdata.onr and type(defdata.onr) == 'table' then
      for _, pattern in ipairs(defdata.onr) do
        tempRegexTrigger(pattern, 'svo.defs.got_' .. sk.sanitize(defname) .. '()')
      end
    elseif defdata.onr then
      tempRegexTrigger(defdata.onr, 'svo.defs.got_' .. sk.sanitize(defname) .. '()')
    end

    if defdata.on and type(defdata.on) == 'table' then
      for _, pattern in ipairs(defdata.on) do
        (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.defs.got_' .. sk.sanitize(defname) .. '()')
      end
    elseif defdata.on then
      (tempExactMatchTrigger or tempTrigger)(defdata.on, 'svo.defs.got_' .. sk.sanitize(defname) .. '()')
    end

    if defdata.on_only and type(defdata.on_only) == 'table' then
      for _,pattern in ipairs(defdata.on_only) do
        (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.defs.gotonly_' .. sk.sanitize(defname) .. '()')
      end
    elseif defdata.on_only then
      (tempExactMatchTrigger or tempTrigger)(defdata.on_only, 'svo.defs.gotonly_' .. sk.sanitize(defname) .. '()')
    end

    if defdata.on_free then (tempExactMatchTrigger or tempTrigger)(defdata.on_free, 'svo.defs.got_' .. sk.sanitize(defname) .. '()') end

    if defdata.offr and type(defdata.offr) == 'string' then
        tempRegexTrigger(defdata.offr, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
    elseif defdata.offr then
      for _,pattern in ipairs(defdata.offr) do
        tempRegexTrigger(pattern, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
      end
    end

    if defdata.off and type(defdata.off) == 'string' then
        (tempExactMatchTrigger or tempTrigger)(defdata.off, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
    elseif defdata.off then
      for _,pattern in ipairs(defdata.off) do
        (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
      end
    end

    -- this is EXACTLY for substring
    if defdata.offs and type(defdata.offs) == 'string' then
        tempTrigger(defdata.offs, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
    elseif defdata.offs then
      for _,pattern in ipairs(defdata.offs) do
        tempTrigger(pattern, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()')
      end
    end

    if defdata.off_free then (tempExactMatchTrigger or tempTrigger)(defdata.off_free, 'svo.defs.lost_' .. sk.sanitize(defname) .. '()') end

    if defdata.def and type(defdata.def) == 'table' then
      for _,pattern in ipairs(defdata.def) do
        (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.defs.def_' .. sk.sanitize(defname) .. '()')
      end
    elseif defdata.def then
      (tempExactMatchTrigger or tempTrigger)(defdata.def, 'svo.defs.def_' .. sk.sanitize(defname) .. '()')
    end

    if defdata.defr and type(defdata.defr) == 'table' then
      for _,pattern in ipairs(defdata.defr) do
        tempRegexTrigger(pattern, 'svo.defs.def_' .. sk.sanitize(defname) .. '()')
      end
    elseif defdata.defr then
      tempRegexTrigger(defdata.defr, 'svo.defs.def_' .. sk.sanitize(defname) .. '()')
    end

    if not defs['got_' .. defname] then
      if svo.dict[defname] then
        -- rely on the fact that defs only have 1 item in them
        local bal
        for kk,vv in pairs(svo.dict[defname]) do if type(vv) == 'table' and kk ~= 'gone' then bal = kk break end end
        if bal then
          defs['got_' .. defname] = function (force)
            if svo.haveskillset('metamorphosis') then
              if defdata.custom_def_type or svo.usingbal(bal) then svo.checkaction(svo.dict[defname][bal], true)
              else svo.checkaction(svo.dict[defname][bal], force) end
            else
              if not defdata.custom_def_type then svo.checkaction(svo.dict[defname][bal], force) else svo.checkaction(svo.dict[defname][bal], true) end
            end
            if actions[defname .. '_' .. bal] then
              if force then --bypass lifevision for gmcp/other 'force' situations
                svo.actionfinished(actions[defname .. '_' .. bal].p)
              else
                lifevision.add(actions[defname .. '_' .. bal].p)
              end
            end
          end
        end
      end

      if not defs['got_' .. defname] then
        defs['got_' .. defname] = function ()
          defences.got(defname)
        end
      end
    end

    if defdata.on_only and not defs['gotonly_' .. defname] then
      if svo.dict[defname] then
        -- rely on the fact that defs only have 1 item in them
        local bal
        for kk,vv in pairs(svo.dict[defname]) do
          if type(vv) == 'table' and kk ~= 'gone' then bal = kk break end
        end
        defs['gotonly_' .. defname] = function ()
          svo.checkaction(svo.dict[defname][bal], false)
          if actions[defname .. '_' .. bal] then
            lifevision.add(actions[defname .. '_' .. bal].p)
          end
        end
      else
        defs['gotonly_' .. defname] = function ()
          defences.got(defname)
        end
      end
    end

    if not defs['lost_' .. sk.sanitize(defname)] then
      if svo.dict[defname] and svo.dict[defname].gone then
        defs['lost_' .. defname] = function ()
          svo.checkaction(svo.dict[defname].gone, true)
          if actions[defname .. '_gone'] then
            lifevision.add(actions[defname .. '_gone'].p)
          end
        end
      else
        defs['lost_' .. defname] = function ()
          defences.lost(defname)
        end
      end
    end

    if not defdata.nodef and not defdata.custom_def_type then
      defs['def_'..sk.sanitize(defname)] = function ()

        -- if we're in dragonform and this isn't a general or a dragoncraft def, then remember it as an additional def - not a class skill one, since those are not shown in Dragon
        if defc.dragonform and defdata.type ~= 'general' and defdata.type ~= 'dragoncraft' then
          if not defdata.ondef then
            defences.nodef_list[defname] = true
          else
            defences.nodef_list[defname] = defdata.ondef()
          end
        else
          if not defdata.ondef then
            defences.def_def_list[defname] = true
          else
            defences.def_def_list[defname] = defdata.ondef()
          end
        end
        deleteLine()
      end
    elseif not defdata.nodef and defdata.custom_def_type then
      defs['def_'..sk.sanitize(defname)] = function ()
        defences.got(defname)
        deleteLine()
      end

    -- additional defence (nodef)
    else
      defs['def_'..sk.sanitize(defname)] = function ()
      -- only accept the def line if we know that we're parsing the def list currently, so lines similar to ones on the DEFENCES list that show up elsewhere don't mess things up
        if not actions.defcheck_physical then return end

        deleteLine()
        if not defdata.ondef then
          defences.nodef_list[defname] = true
        else
          defences.nodef_list[defname] = defdata.ondef()
        end
      end
    end

    -- fill up our defences.def_types
    if defdata.type then
      defences.def_types[defdata.type] = defences.def_types[defdata.type] or {}
      defences.def_types[defdata.type][#defences.def_types[defdata.type]+1] = defname
    end

    -- create blanks for defup and keepup
    if not defdata.nodef then
      for mode, _ in pairs(defdefup) do
        defdefup[mode][defname] = false
        defkeepup[mode][defname] = false
      end
    end

    if defdata.type then
      sk.ignored_defences[defdata.type] = sk.ignored_defences[defdata.type] or {status = false, t = {}}
      sk.ignored_defences[defdata.type].t[defname] = sk.ignored_defences[defdata.type].t[defname] or false
      sk.ignored_defences_map[defname] = defdata.type
    end
  end -- end of the whole defences svo.dict iteration

  svo.update(defdefup, defdefup_t)
  svo.update(defkeepup, defkeepup_t)

  -- remove skillsets from ignorelist that we don't have, for people that change
  for skillset, _ in pairs(sk.ignored_defences) do
    if skillset ~= 'general' and skillset ~= 'enchantment' and skillset ~= 'dragoncraft' and not me.skills[skillset] then
      sk.ignored_defences[skillset] = nil
    end
  end


  -- simple way of removing all and adding per line
  for name, _ in pairs(defences.custom_types) do
    defs['def'..name..'start'] = function()
      for def, _ in pairs(defences.custom_types[name]) do
        defences.lost(def)
      end
    end
  end
end, 'setup def triggers on system start')

-- customize for gag
defs['lost_shield'] = function ()
  svo.checkaction(svo.dict.shield.gone, true)
  if actions['shield_gone'] then
    lifevision.add(actions['shield_gone'].p)
  end

  -- local line = getCurrentLine()
  -- selectCurrentLine() replace''
  -- cecho(string.format(&quot;&lt;DarkOrange&gt;&gt;&lt;red&gt;&gt; &lt;white:sienna&gt;%s&lt;:black&gt; &lt;red&gt;&lt;&lt;DarkOrange&gt;&lt;&quot;, line))
  if selectString(line, 1) ~= -1 then
    replace(&quot;&quot;)
    cecho(string.format(&quot;&lt;DarkOrange&gt;&gt;&lt;red&gt;&gt; &lt;white:sienna&gt;%s&lt;:black&gt; &lt;red&gt;&lt;&lt;DarkOrange&gt;&lt;&quot;, line))
  end
end

-- customize for riding_physical
defs['lost_riding'] = function()
  -- force it so unwilling dismount is counted
  svo.checkaction(svo.dict.riding.physical, true)
  if actions['riding_physical'] then
    lifevision.add(actions['riding_physical'].p, 'dismount')
  end
end

defs['block_failed'] = function()
  svo.checkaction(svo.dict.block.physical, true)
  if actions['block_physical'] then
    lifevision.add(actions['block_physical'].p, 'failed')
  end
end

function defs.defprompt()
  svo.show_current_defs()

  -- see if we need to show any additional defences
  local function check_additionals()
    for def, _ in defences.nodef_list:pairs() do
      if defs_data[def] and (defs_data[def].nodef or (defc.dragonform and defs_data[def].type ~= 'dragoncraft' and defs_data[def].type ~= 'general')) then return true end
    end
  end

  if check_additionals() then
    svo.echof(&quot;Additional defences:&quot;)
    local count = 1
    for def, value in defences.nodef_list:pairs() do
      if defs_data[def] and (defs_data[def].nodef or (defc.dragonform and defs_data[def].type ~= 'dragoncraft' and defs_data[def].type ~= 'general')) then
        if value == true then
          decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, sk.desanitize(def)))
        else
          decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, sk.desanitize(def) .. &quot; &quot; .. tostring(value)))
        end

        if count % 3 == 0 then echo(&quot;\n&quot;) end
        count = count + 1
      end
    end
    echo(&quot;\n&quot;)

  end
  defences.nodef_list = svo.phpTable()
  defences.def_def_list = {}
  svo.showprompt()
end

function defs.defstart()
  svo.checkaction(svo.dict.defcheck.physical)
  if actions.defcheck_physical then
    deleteLine()

    -- reset parry, as no parry won't show a line
    local t = svo.sps.parry_currently
    for limb, _ in pairs(t) do t[limb] = false end
    svo.check_sp_satisfied()
  end
end

-- last line of 'def' that shows your count
function defs.defline()
  svo.checkaction(svo.dict.defcheck.physical)
  if actions.defcheck_physical then
    deleteLine()
    tempLineTrigger(1, 1, 'selectString(line, 1) replace&quot;&quot;')
    lifevision.add(actions.defcheck_physical.p)
  end
end

svo.process_defs = function ()
  local addback = {}

  for defname, _ in pairs(defc) do
    -- clear ones we don't have
    if defc[defname] and not defences.def_def_list[defname] and not (defs_data[defname] and (defs_data[defname].invisibledef or defs_data[defname].custom_def_type)) then
      if svo.dict[defname] and svo.dict[defname].gone then
        svo.checkaction(svo.dict[defname].gone, true)
        lifevision.add(actions[defname..'_gone'].p)
      else
        defences.lost(defname)
      end
    elseif defc[defname] and defences.def_def_list[defname] and not (defs_data[defname] and defs_data[defname].custom_def_type) then -- if we do have it, remove from def list
      addback[defname] = defences.def_def_list[defname]
      defences.def_def_list[defname] = nil
    end
  end

  -- add left over ones
  for defname,_ in pairs(defences.def_def_list) do
    local bal
    for kk,vv in pairs(svo.dict[defname] or {}) do if type(vv) == 'table' and kk ~= 'gone' then bal = kk break end end
    if bal and svo.dict[defname][bal].oncompleted then
        svo.dict[defname][bal].oncompleted(true)
    else
      defences.got(defname)
    end
  end

  for k,v in pairs(addback) do defences.def_def_list[k] = v end


  tempTimer(0, defs.defprompt)
end

-- prints out a def table
local function show_defs(tbl, linkcommand, cmdname)
  local count = 1

  local olddechoLink = dechoLink
  local function dechoLink(text, command, hint)
    olddechoLink(text, command, hint, true)
  end

  local function show_em(skillset, what)
    if skillset and not sk.ignored_defences[skillset] then
      if not skillset then svo.echof(&quot;no fucking skillset! %s&quot;, debug.traceback()) end
      svo.echof(&quot;what, %s is not in ignored_defences: %s&quot;, skillset, svo.pl.pretty.write(sk.ignored_defences))
    end
    if skillset and not sk.ignored_defences[skillset].status then svo.echof(&quot;%s defences:&quot;, skillset:title()) end
    for _,def in ipairs(what) do
      local disabled = ((sk.ignored_defences[skillset] and sk.ignored_defences[skillset].status) and true or (sk.ignored_defences[sk.ignored_defences_map[def]].t[def]))

      if not disabled and not tbl[def] and not defences.nodef_list[def] then
        if (count % 3) ~= 0 then
          if not linkcommand or not dechoLink then
            decho(string.format(&quot;&lt;153,204,204&gt;[ ] %-23s&quot;, def))
          else
            dechoLink(string.format(&quot;&lt;153,204,204&gt;[ ] %-23s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Add %s to %s&quot;, def, cmdname))
          end
        else
          if not linkcommand or not dechoLink then
            decho(string.format(&quot;&lt;153,204,204&gt;[ ] %s&quot;, def))
          else
            dechoLink(string.format(&quot;&lt;153,204,204&gt;[ ] %s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Add %s to %s&quot;, def, cmdname))
          end
        end
      elseif not disabled then
        if (count % 3) ~= 0 then
          if not defs_data[def].mana then
            if type(defences.nodef_list[def]) == 'string' then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; (&quot;..defences.nodef_list[def]..&quot;)&quot;))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; (&quot;..defences.nodef_list[def]..&quot;)&quot;), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif type(defences.def_def_list[def]) == 'string' then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; &quot;..defences.def_def_list[def]))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; &quot;..defences.def_def_list[def]), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif defs_data[def].onshow then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; (&quot;..defs_data[def].onshow()..&quot;)&quot;))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def..&quot; (&quot;..defs_data[def].onshow()..&quot;)&quot;), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
            else
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %-23s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
            end
          elseif defs_data[def].mana == 'little' then
            if not linkcommand or not dechoLink then
              decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,140&gt;m&lt;153,204,204&gt;] %-23s&quot;, def))
            else
              dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,140&gt;m&lt;153,204,204&gt;] %-23s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
            end
          else
            if not linkcommand or not dechoLink then
              decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,204&gt;M&lt;153,204,204&gt;] %-23s&quot;, def))
            else
              dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,204&gt;M&lt;153,204,204&gt;] %-23s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
            end
          end
        else
          if not defs_data[def].mana then
            if type(defences.nodef_list[def]) == 'string' then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def..&quot; (&quot;..defences.nodef_list[def]..&quot;)&quot;))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def..&quot; (&quot;..defences.nodef_list[def]..&quot;)&quot;), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif type(defences.def_def_list[def]) == 'string' then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] % s&quot;, def..&quot; &quot;..defences.def_def_list[def]))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] % s&quot;, def..&quot; &quot;..defences.def_def_list[def]), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
              defences.nodef_list[def] = nil
            elseif defs_data[def].onshow then
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def..&quot; (&quot;..defs_data[def].onshow()..&quot;)&quot;))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def..&quot; (&quot;..defs_data[def].onshow()..&quot;)&quot;), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
            else
              if not linkcommand or not dechoLink then
                decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def))
              else
                dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,204,0&gt;X&lt;153,204,204&gt;] %s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
              end
            end
          elseif defs_data[def].mana == 'little' then
            if not linkcommand or not dechoLink then
              decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,140&gt;m&lt;153,204,204&gt;] %s&quot;, def))
            else
              dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,140&gt;m&lt;153,204,204&gt;] %s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
            end
          else
            if not linkcommand or not dechoLink then
              decho(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,204&gt;M&lt;153,204,204&gt;] %s&quot;, def))
            else
              dechoLink(string.format(&quot;&lt;153,204,204&gt;[&lt;0,0,204&gt;M&lt;153,204,204&gt;] %s&quot;, def), string.format(&quot;%s('%s', nil, nil, false, true)&quot;, linkcommand, def), string.format(&quot;Remove %s from %s&quot;, def, cmdname))
            end
          end
        end
      end

      if not disabled and count % 3 == 0 then echo(&quot;\n&quot;) end
      if not disabled then count = count + 1 end
    end

    if count %3 ~= 1 then echo(&quot;\n&quot;) end; count = 1
  end

  setFgColor(153,204,204)
  local underline = setUnderline; _G.setUnderline = function () end

  show_em(nil, defences.def_types.general)

  if defc.dragonform then
    show_em('dragoncraft', defences.def_types.dragoncraft)
  else

    for skillset,s in pairs(defences.def_types) do
      if skillset ~= 'general' and skillset ~= 'dragoncraft' then show_em (skillset, s) end
    end
  end

  _G.setUnderline = underline
end

function svo.show_current_defs(window)
  svo.echof(window or 'main', &quot;Your current defences (%d):&quot;, (function ()
    local count = 0
    for _,v in pairs(defc) do if v then count = count + 1 end end
    for _,v in defences.nodef_list:pairs() do
      if v then count = count + 1 end end
    return count
  end)())

  if not window then
    show_defs(defc)
  else
    sk.echofwindow = window
    local olddecho, oldecho = decho, echo
    _G.decho, _G.echo = svo.ofs.windowdecho, svo.ofs.windowecho

    show_defs(defc)

    _G.decho, _G.echo = olddecho, oldecho
  end
end

function svo.show_defup()
  svo.echof(&quot;%s defup defences (click to toggle):&quot;, defs.mode:title())
  show_defs(defdefup[defs.mode], &quot;svo.defs.defup&quot;, 'defup')
  svo.showprompt()
end

function svo.show_keepup()
  if not conf.serverside then
    svo.echof(&quot;%s keepup defences (click to toggle):&quot;, defs.mode:title())
  else
    svo.echofn(&quot;%s keepup defences (click to toggle) (&quot;, defs.mode:title())

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink(&quot;view serverside keepup&quot;, [[send'CURING PRIORITY DEFENCE LIST']], &quot;Click to view serverside's keepup list - which'll be the same as Svof's&quot;, true)
    setUnderline(false)
    echo(&quot;)\n&quot;)
  end
  show_defs(defkeepup[defs.mode], &quot;svo.defs.keepup&quot;, 'keepup')
  svo.showprompt()
end

-- can't just check if we need and don't have, because some might have conflicts.
-- hence, just check isadvisable; this checks it for us and skips conflicts.
-- check have defup on prompt so it's not called many times.
function sk.have_defup_defs()
  local waitingon = {}
  for def,deft in defs_data:iter() do
    if defdefup[defs.mode][def] and not defc[def]
     -- if we have to skip it
    and not ((deft.specialskip and deft.specialskip())
     -- or if it's ignored
    or svo.ignore[def]
      -- or it's not a general or dragon defence and we're in dragon
    or (defc.dragonform and not (deft.type == 'general' or deft.type == 'dragoncraft'))) and not deft.nodef then
      if svo.dict[def] then
        if svo.dict[def].physical and not svo.dict_balanceful_def[def] and not svo.dict_balanceless_def[def] then
          waitingon[#waitingon+1] = string.format(&quot;%s (?)&quot;, def)
        else
          waitingon[#waitingon+1] = def
        end
      else
        waitingon[#waitingon+1] = string.format(&quot;%s (?)&quot;, def)
      end
    end
  end

  -- sort them according to aspriority
  table.sort(waitingon,
    function(a,b)
      if svo.dict[a] and svo.dict[b] and svo.dict[a].physical and svo.dict[b].physical then
        return svo.dict[a].physical.aspriority &gt; svo.dict[b].physical.aspriority
      end
    end)

  if #waitingon &gt; 0 then return false, waitingon
  else return true end
end;

function svo.ignoreskill(skill, newstatus)
  skill = skill:lower()

  -- first, check if this is a group we're disabling as a whole
  if sk.ignored_defences[skill] then
    sk.ignored_defences[skill].status = newstatus
    svo.showhidelist() return
  end

  -- otherwise, loop through all skillsets, looking for the skill
  for _, group in pairs(sk.ignored_defences) do
    for skills, _ in pairs(group.t) do
      if skills == skill then
        group.t[skill] = newstatus
        svo.showhidelist() return
      end
    end
  end
end

function svo.showhidelist()
  local enabled_c, disabled_c = &quot;&lt;242,218,218&gt;&quot;, &quot;&lt;156,140,140&gt;&quot;

  -- adds in the link with a proper tooltip
  local function makelink(skill, sign, groupstatus)
    if sign == &quot;+&quot; then
      echoLink(sign, [[svo.ignoreskill(&quot;]]..skill..[[&quot;, false, true)]],
        string.format(&quot;Click to start showing &quot; .. skill..&quot;%s&quot;, groupstatus and &quot; (won't do anything since the group is disabled, though)&quot; or &quot;&quot;), true)
    elseif sign == &quot;-&quot; then
      echoLink(sign, [[svo.ignoreskill(&quot;]]..skill..[[&quot;, true, true)]],
        string.format(&quot;Click to hide &quot; .. skill..&quot;%s&quot;, groupstatus and &quot; (won't do anything since the group is disabled, though)&quot; or &quot;&quot;), true)
    else
      echo &quot; &quot;
    end

    return &quot;&quot;
  end

  local count = 1
  -- shows a specific defences group
  local function show_em(name, what)
    decho(string.format(&quot;%s%s %s defences:\n&quot;,
      (what.status and disabled_c or enabled_c),
      makelink(name, (what.status and &quot;+&quot; or &quot;-&quot;)),
      name:title()))

    -- loops through all defences within the group
    for def,disabled in pairs(what.t) do
      -- if the whole group is disabled, then all things inside it should be as well
      local skill_color = (what.status and true or disabled)

      if count % 3 == 1 then echo&quot;  &quot; end
      if (count % 3) ~= 0 then
        decho(string.format(&quot;%s%s %-23s&quot;,
          (skill_color and disabled_c or enabled_c),
          makelink(def, (disabled and &quot;+&quot; or &quot;-&quot;), what.status),
          def))
      else
        decho(string.format(&quot;%s%s %s&quot;,
          (skill_color and disabled_c or enabled_c),
          makelink(def, (disabled and &quot;+&quot; or &quot;-&quot;), what.status),
          def))
      end

      if count % 3 == 0 then echo(&quot;\n&quot;) end
      --~ if count % 3 ~= 1 then echo(&quot;  &quot;) end
      count = count + 1
    end

    if count %3 ~= 1 then echo(&quot;\n&quot;) end
    count = 1
  end

  svo.echof(&quot;Select which skillsets or skills to show in defence display lists:&quot;)
  show_em('general', sk.ignored_defences.general)

  local function f()
    for j,k in pairs(sk.ignored_defences) do
      if j ~= 'general' then show_em (j, k) end
    end
  end

  local s,_ = pcall(f)
  if not s then svo.echof(&quot;Your Mudlet version doesn't seem to be new enough to display this; please update to latest (http://forums.mudlet.org/viewtopic.php?f=5&amp;t=1874)&quot;) end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Priorities</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

--[[ Logic: keep the prios embedded in the svo.dict.*.*.spriority/svo.dict.*.*.aspriority, don't keep a table
      of it's own. When exporting/importing, create such tables.]]

local sys, signals, sk, prio = svo.sys, svo.signals, svo.sk, svo.prio

svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/prios&quot;)

function prio.export (name, options, echoback)
  local sendf; if echoback then sendf = svo.echof end
  svo.assert(name, &quot;what name do you want to save this list as?&quot;, sendf)

  -- kv table of what to export
  local to_export = {
    herb = {
      prewrite = &quot;Herb cures: &quot;,
    },
    smoke = {
      prewrite = &quot;Smoke cures: &quot;,
    },
    salve = {
      prewrite = &quot;Salve cures: &quot;,
    },
    sip = {
      prewrite = &quot;Sipping balance: &quot;,
    },
    purgative = {
      prewrite = &quot;Purgative cures: &quot;,
    },
    physical = {
      prewrite = &quot;Balance or equilibrium actions: &quot;,
    },
    focus = {
      prewrite = &quot;Focus cures: &quot;,
    },
    moss = {
      prewrite = &quot;Moss balances (these don't really make sense to order): &quot;,
    },
    misc = {
      prewrite = &quot;Miscallaneous actions: &quot;,
    },
    slowcuring = {
      prewrite = &quot;Slow curing mode priorities: &quot;
    }
  }

  if not options or options == &quot;&quot; or options == &quot; &quot; then
    for _, v in pairs(to_export) do
      v.o = true
    end
  elseif type(options) == 'string' then
    for w in string.gmatch(options, &quot;%a+&quot;) do
      if to_export[w] then to_export[w].o = true end
    end
  elseif type(options) == 'table' then
    for _, w in ipairs(options) do
      if to_export[w] then to_export[w].o = true end
    end
  end

  --[[ generate a single table like so:
  {
    herb = {
      'relapsing',
      'paranoia',
      'vapors',
      ...
    },

    salve = {
    ....
    }

  }

  Writing out though, skip the initial whole table itself.
  ]]

  local data
  local s = {
    &quot;-- Priorities list '&quot;.. name .. &quot;' by &quot;.. sys.charname .. &quot;, exported @ &quot; .. os.date()..&quot;\n&quot;,
    &quot;-- Note: The lower the priority in the list without a number, or the lower number - the more important the thing is. ie, things at the bottom of the list will get done before those on the top!&quot;
  }


  for priority, priotbl in pairs(to_export) do
    if priotbl.o then
      if priority == 'slowcuring' then
        data = svo.make_sync_prio_table(&quot;%s_%s&quot;)
      else
        data = svo.make_prio_table(priority)
      end

      s[#s+1] = &quot;\n-- &quot; .. priotbl.prewrite
      s[#s+1] = priority .. &quot; = &quot; .. svo.pl.pretty.write(data)
    end
  end

  s = table.concat(s, &quot;\n&quot;)

  svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/prios&quot;)
  io.output(getMudletHomeDir() .. &quot;/svo/prios/&quot;..name, 'w')
  io.write(s)
  io.close()

  if echoback then svo.echof(&quot;exported %s prio to %s&quot;, name, getMudletHomeDir() .. &quot;/svo/prios/&quot;..name) end
  svo.debugf(&quot;exported %s prio to %s&quot;, name, getMudletHomeDir() .. &quot;/svo/prios/&quot;..name)
end

function prio.list(echoback)
  local dir = getMudletHomeDir() .. &quot;/svo/prios&quot;
  local list = {}

  for file in lfs.dir(dir) do
    if file ~= &quot;.&quot; and file ~= &quot;..&quot; then
      list[#list+1] = file
    end
  end

  if echoback then
    svo.echof(&quot;Priorities that we've got stored in '%s':\n  %s&quot;, dir, svo.concatand(list))
  else
    return list
  end
end

-- returns the table of actions in a balance
function prio.getlist(balance)
  return svo.make_prio_table(balance)
end

-- returns a table of actions in a balance, sorted most important first, without gaps
function prio.getsortedlist(balance)
  -- get into table...
  local data
  if balance ~= 'slowcuring' then
    data = svo.make_prio_table(balance)
  else
    data = svo.make_sync_prio_table(&quot;%s_%s&quot;)
  end
  local orderly = {}

  -- create an indexed list of just the priorities only
  for i,_ in pairs(data) do
    orderly[#orderly+1] = i
  end

  -- invert the list, so actions are ordered most important first
  table.sort(orderly, function(a,b) return a&gt;b end)

  -- sort original keys usin the new sorting
  local sortedprios = {}
  for _, sortedprio in ipairs(orderly) do
    sortedprios[#sortedprios+1] = data[sortedprio]
  end

  return sortedprios
end

-- returns the highest number used, and what uses it, in a balance
function prio.gethighest(balance)
  local t = svo.make_prio_table(balance)

  -- there could be holes - can't use #
  local maxprio, maxaction = 0
  for prioname, action in pairs(t) do
    if prioname &gt; maxprio then
      maxprio = prioname
      maxaction = action
    end
  end

  return maxprio, maxaction
end

-- returns a sorted list of actions in a balance by priority
function prio.sortlist(actions, balance)
  svo.assert(type(actions) == 'table', &quot;svo.prio.sortlist: actions must be an indexed table (a list)&quot;)
  svo.assert(balance, &quot;svo.prio.sortlist: in which balance do you want to check these actions in?&quot;)

  table.sort(actions, function(a,b)
    return svo.dict[a] and svo.dict[a][balance] and svo.dict[b] and svo.dict[b][balance] and
      svo.dict[a][balance].aspriority &gt; svo.dict[b][balance].aspriority
  end)

  return actions
end

function prio.getaction(num, balance)
  svo.assert(num and balance, &quot;What number and balance to use?&quot;)
  local data = svo.make_prio_table(balance)
  return data[num]
end

function prio.getslowaction(num)
  svo.assert(num, &quot;What number to use?&quot;)
  local data = svo.make_sync_prio_table(&quot;%s_%s&quot;)
  if data[num] then
    return data[num]:match(&quot;(%w+)_(%w+)&quot;)
  end
end

-- inserts an action at balance and bumps all current actions down if necessary
-- string, string, number -&gt; boolean
-- inserts an action at balance and bumps all current actions down if necessary.
-- because we're really only swapping items in the priority list and not inserting, we don't need to worry
-- about items underflowing past 0 priority yet
function prio.insert(action, balance, number, echoback)
  number = tonumber(number)

  if balance == 'balance' then balance = 'physical' end

  if balance == 'slowcuring' then
    local validaction, plainaction = svo.valid_sync_action(action)

    if not validaction then return false, plainaction end
  end

  local function getpriotable(balancename)
    if balancename ~= 'slowcuring' then
      return svo.make_prio_table(balancename)
    else
      return svo.make_sync_prio_table(&quot;%s_%s&quot;)
    end
  end

  local function insertat(actionname, balancename, newprio)
    if balancename ~= 'slowcuring' then
      svo.dict[actionname][balancename].aspriority = newprio
    else
      svo.dict[actionname][balancename].spriority = newprio
    end
    if echoback then svo.echof(&quot;Set %s's priority in %s balance to %d.&quot;, actionname, balancename, newprio) end
    raiseEvent(&quot;svo prio changed&quot;, actionname, balancename, newprio, (balancename == 'slowcuring' and 'slowcuring'))
  end

  local t = getpriotable(balance)
  local originalt = svo.deepcopy(t)

  if balance ~= 'slowcuring' and not t then return nil, &quot;no such balance: &quot;..balance end

  -- if nothing is in the desired index, then just insert. If something is, shuffle down first.
  if not t[number] then
    insertat(action, balance, number)
  else
    local function index_of(table, element)
      for k,v in pairs(table) do
        if v == element then return k end
      end
    end

    -- remove from its current position
    local oldnum = index_of(t, action)
    t[oldnum] = nil

    -- move everything below the old index (oldnum) one up
    local newt = {}
    for k,v in pairs(t) do
      if k &lt;= oldnum then
        newt[k+1] = v
      else
        newt[k] = v
      end
    end

    -- copy items into a new table, one lower if they're at or below new index (number)
    local l = {}
    for k,v in pairs(newt) do
      if k &lt;= number then -- if at or below - shuffle 1 down, unless it's at the previous position or below - then keep it
        l[k-1] = v
      else  -- if above: keep where it was
        l[k] = v
      end
    end

    l[number] = action -- insert our action back in
    local action_prio = {} -- create an action-value list of the new priorities
    for k,v in pairs(l) do action_prio[v] = k end

    -- then read off our diff of new list and store away new prios.
    local diff = svo.basictableindexdiff(originalt, l) -- obtain an indexed list of all the different positions
    for _, a in pairs(diff) do
      if balance ~= 'slowcuring' then
        svo.dict[a][balance].aspriority = action_prio[a]
        raiseEvent(&quot;svo prio changed&quot;, a, balance, action_prio[a])
      else
        local _, syncaction, syncbalance = svo.valid_sync_action(a)
        svo.dict[syncaction][syncbalance].spriority = action_prio[a]
        raiseEvent(&quot;svo prio changed&quot;, syncaction, syncbalance, action_prio[a], 'slowcuring')
      end
    end

    if echoback then svo.echof(&quot;Set %s's priority in %s balance to %d.&quot;, action, balance, number) end
  end

  return true
end

function prio.getnumber(aff, balance)
  svo.assert(aff and balance and svo.dict[aff] and svo.dict[aff][balance], &quot;Such affliction/defence or balance doesn't exist&quot;)
  return svo.dict[aff][balance].aspriority
end

function prio.cleargaps(balance, echoback)
  -- sync mode
  if balance == 'slowcuring' then
    local data = svo.make_sync_prio_table(&quot;%s_%s&quot;)

    local max=0
    for k,_ in pairs(data) do
      if k&gt;max then max=k end
    end

    local t, n = {}, 0

    for i=1,max do
      if data[i] then n=n+1 t[n]=data[i] end
    end

    -- create an action - prio table for retrieval of location using diffs
    local action_prio = {}
    for i = 1, #t do action_prio[t[i]] = i end

    -- create a diff, using the old table first as it has no holes
    local diff = svo.basictableindexdiff(t, data)

    -- now only change &amp; notify for the delta differences
    for _, a in pairs(diff) do
      local _, syncaction, syncbalance = svo.valid_sync_action(a)
      svo.dict[syncaction][syncbalance].spriority = action_prio[a]
      raiseEvent(&quot;svo prio changed&quot;, syncaction, syncbalance, action_prio[a], 'slowcuring')
    end

    if echoback then svo.echof(&quot;Cleared all gaps for the slow curing prio.&quot;) end
  -- normal modes
  else
    local data = svo.make_prio_table(balance)

    local max=0
    for k,_ in pairs(data) do
      if k&gt;max then max=k end
    end

    local t, n = {}, 0

    for i=1,max do
      if data[i] then n=n+1 t[n]=data[i] end
    end

    -- create an action - prio table for retrieval of location using diffs
    local action_prio = {}
    for i = 1, #t do action_prio[t[i]] = i end

    local diff = svo.basictableindexdiff(t, data)

    for _, a in pairs(diff) do
      svo.dict[a][balance].aspriority = action_prio[a]
      raiseEvent(&quot;svo prio changed&quot;, a, balance, action_prio[a])
    end

    if echoback then svo.echof(&quot;Cleared all gaps for the %s prio.&quot;, balance) end
  end
  svo.showprompt()
end

function prio.usedefault(echoback)
  local sendf; if echoback then sendf = svo.echof else sendf = function() end end

  -- um. this fails for some reason on Windows.
--[[  local s,m = os.remove(getMudletHomeDir() .. &quot;/svo/prios/current&quot;)
  if not s then svo.echof(&quot;Couldn't update because of: &quot;..tostring(m)) return end]]

  if prio.import('current', false, false, true) then
    sendf(&quot;Updated to default priorities.&quot;)
  else
    sendf(&quot;Couldn't update to default priorities :|&quot;) end
end

function prio.import(name, echoback, report_errors, use_default)
  local sendf; if echoback then sendf = svo.echof else sendf = function() end end

  local filename
  if not name then
    filename = invokeFileDialog(true, &quot;Select the priority list you'd like to import&quot;)
    if filename == &quot;&quot; then
      sendf(&quot;Cancelled; don't have anything to import.&quot;)
      return
    end
  end

  local path = filename or getMudletHomeDir() .. &quot;/svo/prios/&quot;.. name

  local importables = {
    'herb',
    'smoke',
    'salve',
    'sip',
    'purgative',
    'physical',
    'focus',
    'moss',
    'misc',
    'slowcuring',
  }

  local s
  if name == 'current' and (use_default or not lfs.attributes(path)) then
    s = &quot;&quot;
    -- adds in the default prios here at compile-time
    -- s = $(
    --     io.input(&quot;bin/default_prios&quot;)
    --     local prios = io.read(&quot;*a&quot;)
    --     _put(string.format(&quot;%q&quot;, prios))
    --     )
  else
    svo.assert(lfs.attributes(path), name .. &quot; prio doesn't exist.&quot;, sendf)

    io.input(path)
    s = io.read(&quot;*all&quot;)
  end

  -- load file into our sandbox; credit to http://lua-users.org/wiki/SandBoxes
  local i = {}
  -- run code under environment
  local function run(untrusted_code)
    local untrusted_function, message = loadstring(untrusted_code)
    if not untrusted_function then return nil, message end
    setfenv(untrusted_function, i)
    return pcall(untrusted_function)
  end

  local ok, m = run(s)
  if not ok then sendf(&quot;There's a syntax problem in the prios file, we couldn't load it:\n  %s&quot;, m) return end

  local function set(num, action, balance, priority)
    if not (svo.dict[action] and svo.dict[action][balance]) then
      if report_errors then
        if not svo.dict[action] then sendf(&quot;Skipping %s, don't know such thing.&quot;, action) else
          sendf(&quot;Skipping %s, it doesn't use %s balance.&quot;, action, balance) end
      end
    else
      svo.dict[action][balance][priority] = num
    end
  end

  -- create a snapshot of the before state for all balances, since dict_setup might mess with any
  local beforestate = sk.getbeforestateprios()

  local contains, sfind = table.contains, string.find
  -- table i now contains subtables with all of our stuff
  for balance,balancet in pairs(i) do
    if contains(importables, balance) then
      if balance == 'slowcuring' then
        -- reset all current ones to zero
        svo.clear_sync_prios()

        for num, action in pairs(balancet) do
          -- have to weed out action name _ balance name first
          local _,_, actionname, balancename = sfind(action, '(%w+)_(%w+)')
          set(num, actionname, balancename, 'spriority')
        end
      else
        -- reset all current ones to zero
        svo.clear_balance_prios(balance)
        for num, action in pairs(balancet) do
          set(num, action, balance, 'aspriority')
        end
      end
    end
  end
  svo.dict_setup()
  svo.dict_validate()

  local afterstate = sk.getafterstateprios()
  sk.notifypriodiffs(beforestate, afterstate)

  if echoback then svo.echof(&quot;Imported %s prio list.&quot;, name) end
  svo.debugf(&quot;imported %s prio.&quot;, name)
  return true
end

signals.saveconfig:connect(function ()
  prio.export('current')
end, 'save prios on quit')

signals.systemstart:connect(function ()
  prio.import('current')
end, 'load prios on start')
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Parry</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, signals = svo.sys, svo.affs, svo.signals
local me, sps, sp_config = svo.me, svo.sps, svo.sp_config
local sp = svo.sp

svo.pl.dir.makepath(getMudletHomeDir() .. &quot;/svo/config&quot;)

-- check if we need to adjust parrying on any limbs or not
function svo.check_sp_satisfied()
  if sps.something_to_parry() then -- have we asked for any limbs to be parried?
    for name, limb in pairs(sp_config.parry_shouldbe) do
      if limb ~= sps.parry_currently[name] then
       sys.sp_satisfied = false; return
      end
    end
  elseif type(sp_config.parry) == 'string' and sp_config.parry == 'manual' then
    -- check if we need to unparry in manual
    for limb, status in pairs(sps.parry_currently) do
      if status ~= sp_config.parry_shouldbe[limb] then
       sys.sp_satisfied = false; return
      end
    end
  elseif sp_config.priority[1] and not sps.parry_currently[sp_config.priority[1]] then
    sp_config.parry_shouldbe[sp_config.priority[1]] = true
    sys.sp_satisfied = false; return
  end
  sys.sp_satisfied = true
end

svo.sp_limbs = {
  head = true,
  torso = true,
  [&quot;right arm&quot;] = true,
  [&quot;left arm&quot;] = true,
  [&quot;right leg&quot;] = true,
  [&quot;left leg&quot;] = true
}
local sp_limbs = svo.sp_limbs

sps.sp_fillup = function ()
  local t = {}
  for limb, _ in pairs(sp_limbs) do
    t[limb] = false
  end
  return t
end

sp_config = { parry = &quot;&quot;, priority = {}, parry_actionlevel = {}, parry_shouldbe = sps.sp_fillup() }
sps.parry_currently = sps.sp_fillup()
me.parry_currently = sps.parry_currently

sps.parry_options = {
  full = &quot;Parry the currently damaged limb (one that's mangled/mutilated).&quot;,
  lasthit = &quot;Parry the last hit limb (ie got hit left leg - will parry left leg).&quot;,
  [&quot;lasthit opposite limb&quot;] = &quot;Parry the opposite of the last hit limb, by limbs (ie got hit left leg - will parry right  leg).&quot;,
  [&quot;lasthit opposite side&quot;] = &quot;Parry the opposite of the last hit limb, by sides (ie got hit left leg - will parry left arm).&quot;,
  manual = &quot;Allows you to manually control parry with the p* aliases.&quot;
}

-- ask users to click on limbs for priority first, then ask for each limb in order to select action level,
-- then ask what to do with stancing when the action level happens, and what to do with parrying
sps.install = {
  {
    check = function () return #sp_config.priority == table.size(sp_limbs) end,
    act = function (step)
      svo.echof(&quot;Step %d - assign priorities to the limbs. Click on the following in the order of most important, or use the %s command:&quot;, step, svo.green(&quot;vp nextprio &lt;limb&gt;&quot;))
      echo(&quot;  &quot; .. svo.oneconcat(sp_limbs))
          resetFormat()
          deselect()
      for name, _ in pairs(sp_limbs) do
        moveCursor('main',  1, getLineNumber()+2)
        if selectString(name, 1) ~= -1 then
          setLink('svo.sp.nextprio (&quot;' .. name .. '&quot;, true)', 'Set ' .. name .. ' as the next limb in importance.')
          resetFormat()
          deselect()
        end
      end
      echo&quot;\n&quot;
    end},
  --[[{
    check = function ()
        for limb,_ in pairs(sp_limbs) do
          if sp_config.parry_actionlevel[limb] == nil then return false end
        end
        return true
      end,
    act = function (step)
      local function makecodestrings(name)
        local t = {}
        t[#t+1] = 'svo.sp.setparrylevel(&quot;'..name..'&quot;, false, true)'
        for amount = 275, 2000, 275 do
          t[#t+1] = 'svo.sp.setparrylevel(&quot;'..name..'&quot;, '..amount..', true)'
        end
        return t
      end
      local function maketooltipstrings(name)
        local t = {}
        t[#t+1] = 'Set ' .. name .. ' to ' .. 'none'
        for amount = 275, 2000, 275 do
          t[#t+1] = 'Set ' .. name .. ' to ' .. amount
        end
        return t
      end


      svo.echof(&quot;Step %d - assign a level above which parry should act for for each limb by right-clicking, or use the %s command:&quot;, step, svo.green(&quot;vp parrylevel &lt;limb&gt; &lt;amount, or 'none'&gt;&quot;))
      echo &quot;  &quot;
      for name, _ in pairs(sp_limbs) do
        echoPopup(name, makecodestrings(name), maketooltipstrings(name))
        echo(&quot; &quot;)
      end
      echo&quot;\n&quot;
    end},
]]
  {
    check = function () return sp_config.parry ~= &quot;&quot; end,
    act = function (step)
      svo.echof(&quot;Step %d - decide what parry strategy to use when a limb is over the limit by clicking on it, or using the %s command:&quot;, step, svo.green(&quot;vp parrystrat &lt;strategy&gt;&quot;))
      echo &quot;  &quot;
      for name, tooltip in pairs(sps.parry_options) do
        echoLink(name, 'svo.sp.setparry (&quot;' .. name .. '&quot;, true)', tooltip)
        echo &quot; &quot;
      end
      echo&quot;\n&quot;
    end},

}

sps.installnext = function()
  if not sps.settingup then return end
  for i, c in ipairs(sps.install) do
    if not c.check() then
      echo&quot;\n&quot;
      c.act(i)
      return
    end
  end

  sps.settingup = nil
  svo.echof(&quot;Parry setup done :)&quot;)
end


function sp.setup()
  sp_config = { parry = &quot;&quot;, priority = {}, parry_actionlevel = {}, parry_shouldbe = sps.sp_fillup() }
  sps.settingup = true

  sps.installnext()
end

function sp.nextprio(limb, echoback)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end
  local prios = sp_config.priority

  if not sp_limbs[limb] then
    sendf(&quot;Sorry, %s isn't a proper limb name. They are:\n  %s&quot;, limb, svo.oneconcat(sp_limbs))
    return; end

  if svo.contains(prios, limb) then
    sendf(&quot;%s is already in the list.&quot;, limb); return; end

  prios[#prios+1] = limb
  if echoback then
    svo.echof(&quot;%s added; current list: %s&quot;, limb, table.concat(prios, &quot;, &quot;))
  end

  if #prios == table.size(sp_limbs) then sps.installnext() end
end

function sp.setparry(option, echoback)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not option then
    sendf(&quot;Possible options are:&quot;)
    echo&quot;  &quot;
    for name, tooltip in pairs(sps.parry_options) do
      echoLink(name, 'svo.sp.setparry (&quot;' .. name .. '&quot;, true)', tooltip)
      echo &quot;   &quot;
    end
    echo'\n'
    svo.showprompt()
    return
  elseif not sps.parry_options[option] then
    sendf(&quot;Sorry, %s isn't a valid option for parry. They are:&quot;)
    echo&quot;  &quot;
    for name, tooltip in pairs(sps.parry_options) do
      echoLink(name, 'svo.sp.setparry (&quot;' .. name .. '&quot;, true)', tooltip)
      echo &quot;   &quot;
    end
    echo'\n'
    svo.showprompt()
    return
  end

  sp_config.parry = option
  if echoback then
    svo.echof(&quot;Will use the %s strategy for parry.&quot;, sp_config.parry)
    svo.showprompt()
  end

  svo.sp_checksp()
  sps.installnext()
end

function sp.setparrylevel(limb, amount, echoback)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end

  if not sp_limbs[limb] then
    sendf(&quot;Sorry, %s isn't a proper limb name. They are:\n  %s&quot;, limb, svo.oneconcat(sp_limbs))
    return; end

  if not tonumber(amount) and amount ~= false then
    sendf(&quot;To what amount do you want to set %s to?&quot;, limb)
    return; end

  sp_config.parry_actionlevel[limb] = tonumber(amount)

  if echoback then
    svo.echof(&quot;Set the %s parry action level to %s&quot;, limb, amount and tostring(amount) or 'none')
  end

  for limbname,_ in pairs(sp_limbs) do
    if sp_config.parry_actionlevel[limbname] == nil then return end
  end
  sps.installnext()
end

function svo.sp_setparry(what, echoback)
  local sendf
  if echoback then sendf = svo.echof else sendf = svo.errorf end

  local t = {
    h = 'head',
    tt = 'torso',
    rl = &quot;right leg&quot;,
    ll = &quot;left leg&quot;,
    ra = &quot;right arm&quot;,
    la = &quot;left arm&quot;,
    n = 'nothing'
  }

  svo.assert(t[what], &quot;invalid short letter for svo.sp_setparry&quot;, sendf)

  for limb, _ in pairs(sp_limbs) do
    if limb == t[what] then sp_config.parry_shouldbe[limb] = true
      else sp_config.parry_shouldbe[limb] = false end
  end

  svo.sp_checksp()
  svo.make_gnomes_work()
end

sp.show = function ()
  svo.echof(&quot;Parry report:&quot;)

  --[[svo.echof(&quot;Action levels:&quot;)
  for limb, level in pairs(sp_config.parry_actionlevel) do
    echo&quot;  &quot; svo.echof(&quot;%s: parry %s&quot;, limb, tostring(level))
  end]]

  svo.echof(&quot;Limb priorities: %s&quot;, table.concat(sp_config.priority, &quot;, &quot;))
  svo.echof(&quot;Parry strategy: %s (currently parrying: %s)&quot;, type(sp_config.parry) == 'string' and sp_config.parry or &quot;custom function&quot;,

  (function ()
    local parrying_list = {}
    for limb, parrying in pairs(sp_config.parry_shouldbe) do
      if parrying then parrying_list[#parrying_list+1] = limb end
    end

    return table.concat(parrying_list, &quot;, &quot;) end)())
end

svo.sp_checksp = function ()
  -- check parry
  -- see if any priories have been set for strategies that require them
  local prios, priosset = sp_config.priority, true
  if type(prios) ~= 'table' then
    priosset = false
  end

  if priosset and sp_config.parry == 'full' then
    local alreadyset
    for i = 1, #prios do
      local limb = prios[i]
      if not alreadyset and type(sp_config.parry_actionlevel[limb]) == 'number' and (affs['mangled'..limb] or (limb == 'head' and (affs.serioustrauma or affs.mildtrauma)) or (limb == 'torso' and (affs.mildconcussion or affs.seriousconcussion))) then
        sp_config.parry_shouldbe[limb] = true
        alreadyset = true
      else
        sp_config.parry_shouldbe[limb] = false
      end
    end

  elseif sp_config.parry == 'lasthit' then
    for limb, _ in pairs(sp_config.parry_shouldbe) do
      if limb == me.lasthitlimb then
        sp_config.parry_shouldbe[limb] = true
      else
        sp_config.parry_shouldbe[limb] = false
      end
    end

  elseif sp_config.parry == &quot;lasthit opposite limb&quot; then
    local t = {
      head = 'torso',
      torso = 'head',
      [&quot;right arm&quot;] = &quot;left arm&quot;,
      [&quot;left arm&quot;] = &quot;right arm&quot;,
      [&quot;right leg&quot;] = &quot;left leg&quot;,
      [&quot;left leg&quot;] = &quot;right leg&quot;
    }

    local wanted = t[me.lasthitlimb]

    if wanted then
      for limb, _ in pairs(sp_config.parry_shouldbe) do
        if limb == wanted then
          sp_config.parry_shouldbe[limb] = true
        else
          sp_config.parry_shouldbe[limb] = false
        end
      end
    end

  elseif sp_config.parry == &quot;lasthit opposite side&quot; then
    local t = {
      head = 'torso',
      torso = 'head',
      [&quot;right arm&quot;] = &quot;right leg&quot;,
      [&quot;left arm&quot;] = &quot;left leg&quot;,
      [&quot;right leg&quot;] = &quot;right arm&quot;,
      [&quot;left leg&quot;] = &quot;left arm&quot;
    }

    local wanted = t[me.lasthitlimb]

    if wanted then
      for limb, _ in pairs(sp_config.parry_shouldbe) do
        if limb == wanted then
          sp_config.parry_shouldbe[limb] = true
        else
          sp_config.parry_shouldbe[limb] = false
        end
      end
    end

  elseif type(sp_config.parry) == 'function' then
    local s,m = pcall(sp_config.parry)
    if not s then svo.echof(&quot;Your custom parry function had a problem:\n  %s&quot;, m) end
  end

  -- check if we need to adjust our parry
  svo.check_sp_satisfied()

  signals.after_lifevision_processing:block(svo.sp_checksp)
end

-- check custom parry functions whenever we gain or lose an aff
-- implemented in another function and not svo.sp_checksp, because of https://github.com/katcipis/luanotify/issues/24
sps.checkcustomparry = function()
  if type(sp_config.parry) == 'function' then
    sp_config.parry()

    -- check if we need to adjust our parry
    svo.check_sp_satisfied()
  end
end
signals.svogotaff:connect(sps.checkcustomparry, 'check parry when afflicted')
signals.svolostaff:connect(sps.checkcustomparry, 'check parry when cured')
-- public API
svo.checkcustomparry = sps.checkcustomparry

signals.after_lifevision_processing:connect(svo.sp_checksp, 'check if we need to change parry on prompt')
signals.after_lifevision_processing:block(svo.sp_checksp)

sps.something_to_parry = function ()
  for _, shouldparry in pairs(sp_config.parry_shouldbe) do
    if shouldparry then return true end
  end

  return false -- don't unparry if we have all zero's as shouldparry
end

signals.saveconfig:connect(function () svo.tablesave(getMudletHomeDir() .. &quot;/svo/config/sp_config&quot;, sp_config) end, 'save parry config')

local sp_config_path = getMudletHomeDir() .. &quot;/svo/config/sp_config&quot;

if lfs.attributes(sp_config_path) then
  local ok, msg = pcall(table.load,sp_config_path, sp_config)
  if not ok then
    os.remove(sp_config_path)
    tempTimer(10, function()
      svo.echof(&quot;Your parry config file was corrupted - I've deleted it so the system can load other stuff OK. You'll need to set the parry options again with vconfig sp. (%q)&quot;, msg)
    end)
  end
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Funnies</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local life = svo.life
life.hellotrigs = {}

life.hellodata = {
  [&quot;Dusk has overtaken the light in Achaea.&quot;] = function ()
    local t = {&quot;Good evening.&quot;, &quot;Good evening, &quot; .. svo.sys.charname..&quot;.&quot;, &quot;Hello!&quot;}
    svo.echof(t[math.random(1, #t)])
  end,
  [&quot;It is dusk in Achaea.&quot;] = function ()
    local t = {&quot;Good evening.&quot;, &quot;Good evening, &quot; .. svo.sys.charname..&quot;.&quot;, &quot;Hello!&quot;}
    svo.echof(t[math.random(1, #t)])
  end,

  [&quot;It is deep night in Achaea, before midnight.&quot;] = function ()
    local t = {&quot;*yawn*. Hi.&quot;, &quot;Ello. It's a lovely night tonight.&quot;, &quot;What a night. Look at the stars!&quot;}
    svo.echof(t[math.random(1, #t)])
  end,
  [&quot;It is early morning in Achaea.&quot;] = function ()
    local t = {&quot;*yawn*. Morning!&quot;, &quot;Gooood morning, &quot; .. svo.sys.charname .. &quot;!&quot;, &quot;Hello!&quot;, &quot;Morning!&quot;}
    svo.echof(t[math.random(1, #t)])
  end,
  [&quot;It is early afternoon in Achaea.&quot;] = function ()
    local t = {&quot;Good afternoon.&quot;, &quot;Good afternoon, &quot; .. svo.sys.charname .. &quot;.&quot;, &quot;Hello!&quot;, &quot;hi!&quot;}
    svo.echof(t[math.random(1, #t)])
  end,
}

life.hellodata[&quot;It is the middle of the night in Achaea.&quot;] = life.hellodata[&quot;It is deep night in Achaea, before midnight.&quot;]
life.hellodata[&quot;You think that it is currently night-time up above.&quot;] = life.hellodata[&quot;It is deep night in Achaea, before midnight.&quot;]
life.hellodata[&quot;Darkness rules the land. It is deepest midnight.&quot;] = life.hellodata[&quot;It is deep night in Achaea, before midnight.&quot;]
life.hellodata[&quot;It is late night, approaching dawn.&quot;] = life.hellodata[&quot;It is deep night in Achaea, before midnight.&quot;]
life.hellodata[&quot;The shadows have lengthened. It is late afternoon in Achaea.&quot;] = life.hellodata[&quot;It is early afternoon in Achaea.&quot;]
life.hellodata[&quot;It's mid-morning in Achaea.&quot;] = life.hellodata[&quot;It is early morning in Achaea.&quot;]
life.hellodata[&quot;The sun has awakened from its long slumber. It is dawn.&quot;] = life.hellodata[&quot;It is early morning in Achaea.&quot;]
life.hellodata[&quot;The sun sits at its apex. It is exactly noon.&quot;] = life.hellodata[&quot;It is early afternoon in Achaea.&quot;]
life.hellodata[&quot;You think that it is currently day-time up above.&quot;] = life.hellodata[&quot;It is early afternoon in Achaea.&quot;]

svo.protips = {
  &quot;You can do 'vconfig warningtype right' to have the instakill warnings be less spammy&quot;,
  &quot;You can toggle sbites and stabs to ignore bites or doublestabs with only one venom from Serpents&quot;,
  &quot;You can toggle 'tsc' to toggle command overriding or denying in aeon or retardation. The autotsc will also automatically toggle this for you&quot;,
  &quot;'lp' will relight all pipes manually&quot;,
  &quot;'inra' will store away all riftables in the rift&quot;,
  &quot;You can customize when the system uses the tree tattoo with your own custom scenarios&quot;,
  &quot;You can customize when the system uses the restore skill with your own custom scenarios&quot;,
  &quot;You can use 'vdefs cancel' to cancel defup&quot;,
  &quot;You can use 'fl' to get to full stats, and chain it with commands to do after you're good - ie 'fl write journal', 'fl board ship, 'fl challenge person'&quot;,
  &quot;You can use 'pva' to toggle quickly between paralysis and asthma priority&quot;,
  &quot;You can use 'pvd' to toggle quickly between paralysis and darkshade priority&quot;,
  &quot;You can use 'avs' to toggle quickly between impatience and slickness priority (apostate vs serpent)&quot;,
  &quot;You can use svo.prompttrigger() to trigger actions to be done on the next prompt. Can come in very handy in scripting&quot;,
  &quot;Basic keepup is done at login for you, so you might want to be conservative about what you put on basic keepup - and instead put most of the defs on defup, or in another mode&quot;,
  &quot;You can create your own priority lists, and swap them in depending on your fighting conditions&quot;,
  &quot;You can add names not to be autorejected with vconfig lustlist &lt;name&gt;&quot;,
  &quot;You can add names not to writhe against with vconfig hoistlist &lt;name&gt;&quot;,
  &quot;No illusions will be checked with anti-illusion off. If you're worried, it's best to leave it on&quot;,
  &quot;If you attach flame sigils to your pipes, you can't be forced to put them in your container&quot;,
  &quot;Be extra careful in blackout. People use it, obviously enough, to hide things from you&quot;,
  &quot;Review your fight logs. There's always room for improvement&quot;,
  &quot;This is a game, and it should be entertaining. If it's not - consider something else&quot;,
  &quot;Pay attention in raids! Group cohesiveness demands attention and quick action&quot;,
  &quot;When your group leader is spamming into your block to move, take that as a hint to unblock quickly&quot;,
  &quot;You can use vconfig showbaltimes to see how long your balance &amp; equilibrium actions took&quot;,
  &quot;With vconfig gagpipes on, the system will light all 3 pipes whenever one goes out for better assurance&quot;,
  &quot;It might be a good idea to clear your target if they raise deliverance - can save you from accidentally hitting them. Search for Svof's \&quot;Deliverance\&quot; trigger for the pattern on that&quot;,
  &quot;Svof can plot people on the mapper for you! With the peopletracker addon you have, open the Mudlet map and make sure you have the latest mapper script&quot;,
  &quot;You can do 'qwho' with the peopletracker addon to plot people on the map&quot;,
  &quot;You can do 'qwhom' to see a nicer list of where everyone is located, along with 'qwhom &lt;area&gt;'&quot;,
  &quot;You can do 'ppin &lt;area&gt;' after doing qwho to report on your ccto what people are in an area&quot;,
  &quot;You can do 'ppwith &lt;person&gt;' after doing qwho to report the people grouped with someone to your ccto&quot;,
  &quot;You can do vconfig ccto pt, vconfig ccto tell &lt;person&gt;, vconfig ccto ot, vconfig ccto echo and vconfig ccto &lt;short clan name&gt; to configure where ccto messages go&quot;,
  &quot;You can use gotop or gotop &lt;person&gt; with the peopletracker addon after locating them to go to them&quot;,
  &quot;If a name is on the map, you can gotop &lt;name&gt; to get to it&quot;,
  &quot;With the peopletracker addon, you can just use 'gotop' to go to the last known location of the person in the 'target' variable&quot;,
  &quot;hh quickly toggles between health and mana priority&quot;,
  &quot;Some limbcounters (not Svof's) reset when you apply a salve to a limb after an attack - if you know that's the case, you could trigger to randomly apply mending to a limb they just hit!&quot;,
  &quot;You can make colour logs by selecting text, right-clicking and selecting 'copy to HTML'. Then paste it into pastehtml.com and share the link&quot;,
  &quot;Find out which of your abilities are completely hidden in blackout - you can cause blackout by obtaining dust bombs and throwing them at the ground&quot;,
  &quot;You can make your own echos colour schemes and select them with 'vshow colors'. See docs on how!&quot;,
  &quot;You can customize which defences, or even skillsets, show up in def lists with vshow hidelist&quot;,
  &quot;Svof comes with a built-in logger: you can do 'startlog' to log, and 'stoplog' to stop logging&quot;,
  &quot;You might want to turn focus use off against experienced Priests to save on mana&quot;,
  &quot;It'd be good to adjust your vconfig manause amount to something above 50 against Apostates, Alchemists or Priests - this'll sure the system doesn't use mana for curing when you're getting close to instakill levels&quot;,
  &quot;cll (and cll on, cll off) is a shortcut for vconfig clot - toggles clotting on/off&quot;,
  &quot;va (and va on, va off) is a shortcut for vkeep riding - toggles auto-mounting or auto-dismounting. If you'd like to disable this, you can do vignore riding&quot;,
  &quot;Disabling clotting against an Apostate might be a good idea - this'll save you precious mana. Just keep tabs on how much you're bleeding for&quot;,
  &quot;Noticed an opponent stopped hitting certain limbs of yours? They're likely prepped now. You could break them yourself by bouncing off their rebounding aura on that limb&quot;,
  &quot;You can use svo.boxDisplay(\&quot;message here\&quot;, \&quot;foreground color:background color\&quot;) to make giant echoes&quot;,
  &quot;The system is your tool; it's in your interest to master it&quot;,
  &quot;You can use vconfig manause # to mod the % of mana below which the system won't be using mana skills and will be trying for alternatives. You want to be upping this against Apostates, Alchemists, Priests&quot;,
  &quot;Svof doesn't make you edit text files for any settings - everything is accessible from vconfig options, or clickable menus of vshow, vconfig, vconfig2&quot;,
  &quot;To lock areas in the mapper, type 'arealock' or 'arealock area' and click on the Lock! buttons&quot;,
  &quot;Mudlet's errors view is in Scripts -&gt; Errors, the button is bottom-left&quot;,
  &quot;You can use Svof's echos by doing svo.echof(\&quot;stuff\&quot;)&quot;,
  &quot;Need to catch a breather in retardation and cure up? Tumble out - Svof will send all curing commands right when you get out of the room. Good chance you'll get braziered back in though&quot;,
  &quot;You can use svo.concatand(mytable) to bring all the items together in a list, with a proper 'and' at the end&quot;,
  &quot;You can use svo.deleteLineP() to completely gag the line and the prompt coming after it&quot;,
  &quot;'vshow herbstat' shows what Svof thinks of your herb inventory and updates real-time!&quot;,
  &quot;You can do \&quot;vlua svo.protips\&quot; to see all of the svo.protips&quot;,
  &quot;The extra Svof's in the Package Manager are OK - those are the addons&quot;,
  [[When you're scripting, you can make Svof do an action for you in the proper way via the svo.doaction(&quot;&lt;action&gt;&quot;, &quot;&lt;balance&gt;&quot;) function - for example svo.doaction('healmana', 'sip') will properly sip mana or mentality, depending on the users settings and what they actually have]],
  [[vconfig lag 4 - for those times when you're on a hawaiian mountainside catching DSL wifi through a rain catchment tank during a heavy jungle rain]],
  &quot;You can look at vshow curelist for a forestal &lt;-&gt; alchemist equivalents table, and configure prefercustom curemethod from right there&quot;,
  &quot;vlua can work as a calculator - try it, do vlua 2+2&quot;,
  &quot;If bleeding a ton, switch your sipping priority to mana as long as you can afford it to clot away quicker&quot;,
  &quot;Use qwho &lt;area&gt; to see if any ungemmed people are bashing in an area before walking there&quot;,
  &quot;Svof is designed to be a platform for your system - there's loads of things you can build on top of it. Check out the docs for anything you'd like to do!&quot;,
  &quot;Attach flame sigils to your pipes so you can't be forced to put them away in your pack. You can still be forced to drop them, though&quot;,
  &quot;You can pre-block a direction with b &lt;direction&gt; before moving, to help combat beckon triggered on alertness (you can also spam manual block to help with that too)&quot;,
  &quot;You can use dop to toggle the do queue - useful in bashing, when you don't want to dor off/dor &lt;bashing alias&gt; again&quot;,
  &quot;Svof is not an acronym! Just a short name...&quot;,
  &quot;'ndb' shows you a cheatsheet for NameDB! You can hover over or click on aliases to see an explanation.&quot;,
  &quot;'ndb long' shows you a cheatsheet for NameDB!&quot;,
  &quot;Svof has a very thorough Lyre mode built-in - check the manual on how to make use of it&quot;,
  &quot;You can make use of the 'svo system loaded' event to stop having to shuffle your scripts down after upgrading&quot;,
  &quot;Proning your hoister is the quickest way to get down - if you're setup for that, you can do 'vignore hoisted' to have the system not autowrithe for you&quot;,
  &quot;You can sit and sleep without needing to pause the system&quot;,
  &quot;You can use 'shh' to toggle sipping health before all prios in retardation curing mode&quot;,
  &quot;You can use vp &lt;balance&gt; to view &amp; change priorities for a balance&quot;,
  &quot;The (a) that pops up on aeon/retardation is clickable - clicking on it will show what actions was the system considering/doing&quot;,
  &quot;You can use vset &lt;aff name&gt; &lt;balance&gt; &lt;priority number&gt; to move a prio to a position and shift the rest down, ie vset wristfractures sip 5&quot;,
  &quot;'tn raid' will switch into combat defs mode for you and ensure that a few essential defs are on keepup&quot;,
  &quot;'vconfig repeatcmd #' will have Svof repeat all curing commands # amount of times&quot;,
  &quot;'ppof &lt;city&gt;' will report the citizens online of that city&quot;,
  &quot;'qwc' will sort qw by citizenry&quot;,
  &quot;'qwm' shows ungemmed marks on qw&quot;,
  &quot;'qwic' shows ungemmed Infamous on qw. 'qwi' re-checks all people and then shows the ungemmed Infamous&quot;,
  &quot;You can toggle vconfig gagservercuring to show/hide [CURING] messages from serverside&quot;,
  &quot;You can use 'ndb delete unranked' to wipe unranked (dormant / newbies) players from NameDB&quot;,
  &quot;You can export all priorities in a file and edit them there, see 'vshow'&quot;,
  &quot;Svof comes with some scripting examples of the API built-in - take a look at Svof's scripts folder&quot;,
}
if svo.haveskillset('spirituality') then
  svo.protips[#svo.protips+1] = &quot;You can do 'fx' or 'fxx' to fix up your angel (if you have Angels in Vision)&quot;
end
if svo.haveskillset('elementalism') then
  svo.protips[#svo.protips+1] = &quot;'rfl' toggles self-reflect mode&quot;
end
if svo.haveskillset('devotion') then
  svo.protips[#svo.protips+1] = &quot;The vconfig bloodswornoff &lt;health %&gt; feature of Svof will automatically unlink you from Bloodswon if you call below that health amount&quot;
end

svo.lifep.sayhello = function()
  for _, id in ipairs(life.hellotrigs) do
    killTrigger(tostring(id))
  end
  life.hellotrigs = nil
  svo.deleteAllP()

  for pattern, func in pairs(life.hellodata) do
    if line:find(pattern) then
      tempTimer(.1, function () func() svo.showprompt() end)

      tempTimer(math.random(2,5), function () math.randomseed(os.time()) svo.echof(&quot;protip: &quot;.. svo.protips[math.random(1, #svo.protips)]..&quot;.&quot;) svo.showprompt() end)
      break
    end
  end
end

life.sayhello = function ()

  tempTimer(math.random(2, 7), function ()
    if svo.conf.paused then svo.echof(&quot;Hey!&quot;) return end

    life.hellotrigs = {}
    for pattern, _ in pairs(life.hellodata) do
      life.hellotrigs[#life.hellotrigs+1] = (tempExactMatchTrigger or tempTrigger)(pattern, 'svo.lifep.sayhello()')
    end
    send(&quot;time raw&quot;, false)
  end)
end
svo.signals.charname:connect(life.sayhello, 'say hi at login')
svo.signals.gmcpcharname:connect(life.sayhello, 'say hi at login')
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Dor</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sk, me, sys = svo.sk, svo.me, svo.sys
local bals = svo.bals

function sk.getactiondo(i)
  local action = me.doqueue[i]
  if not action then return '' end

  if type(action) == 'table' then
    return tostring(action.what)
  else
    return tostring(action)
  end
end

sk.dometatable = {
  __tostring = function (self)
    return self.what
  end
}

function svo.dofirst(what, echoback, show)
  if type(show) == 'nil' then
    table.insert(me.doqueue, 1, what)
  else
    local t = {what = what, show = show}
    setmetatable(t, sk.dometatable)
    table.insert(me.doqueue, 1, t)
  end

  if echoback then svo.echof(&quot;Will do \&quot;%s\&quot; first.&quot;, tostring(what)) end
  -- spur the queue into doing work right away, unless this came from a trigger - in which case the prompt will make the stuff work anyhow
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
  raiseEvent(&quot;svo do changed&quot;)
end
function svo.dofreefirst(what, echoback)
  table.insert(me.dofreequeue, 1, what)
  if echoback then svo.echof(&quot;Will do \&quot;%s\&quot; first in dofree.&quot;, tostring(what)) end
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
  raiseEvent(&quot;svo dofree changed&quot;)
end

function svo.doadd(what, echoback, show)
  if type(show) == 'nil' then
    me.doqueue[#me.doqueue+1] = what
  else
    local t = {what = what, show = show}
    setmetatable(t, sk.dometatable)
    me.doqueue[#me.doqueue+1] = t
  end

  if echoback then svo.echof(&quot;Added '%s' to the do queue.&quot;, tostring(what)) end
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
  raiseEvent(&quot;svo do changed&quot;)
end

function svo.doaddfree(what, echoback)
  me.dofreequeue[#me.dofreequeue+1] = what
  if echoback then svo.echof(&quot;Added '%s' to the dofree queue.&quot;, tostring(me.dofreequeue[#me.dofreequeue])) end
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
  raiseEvent(&quot;svo dofree changed&quot;)
end

function svo.donext()
  sys.balancetick = sys.balancetick + 1
  if sys.actiontimeoutid then
    killTimer(sys.actiontimeoutid)
    sys.actiontimeoutid = false
  end
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
end

function svo.dor (what, echoback, show)
  if not what or what == 'off' then
    if me.doqueue.repeating or what == 'off' then
      me.doqueue = {repeating = false}
      if echoback then svo.echof(&quot;Do-Repeat %s.&quot;, svo.red('disabled')) end
    else
      me.doqueue.repeating = true
      if echoback and #me.doqueue &gt; 0 then
        svo.echof(&quot;Do-Repeat %s; will repeat the first command (%s) in the queue%s.&quot;, svo.green('enabled'), sk.getactiondo(1), (me.dopaused and &quot;, but the do queue is currently paused&quot; or &quot;&quot;))
      elseif echoback then
        svo.echof(&quot;Do-Repeat %s; will repeat the first command (which is nothing right now) in the queue%s.&quot;, svo.green('enabled'), (me.dopaused and &quot;, but the do queue is currently paused&quot; or &quot;&quot;))
      end
    end
  else
    me.doqueue.repeating = true
    if type(show) == 'nil' then
      me.doqueue[1] = what
    else
      me.doqueue[1] = {what = what, show = show}
    end

    if echoback then svo.echof(&quot;Do-Repeat %s; will repeat %s forever%s.&quot;, svo.green('enabled'), sk.getactiondo(1), (me.dopaused and &quot;, but the do queue is currently paused&quot; or &quot;&quot;)) end
  end
  if not debug.traceback():find('Trigger', 1, true) then svo.make_gnomes_work() end
  raiseEvent(&quot;svo do changed&quot;)
end

function sk.check_do()
  if not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or svo.doworking or me.dopaused then return end

  if #me.doqueue == 0 then return end

  svo.doworking = true

  local action = me.doqueue[1]
  local show
  if type(action) == 'table' then
    show = action.show
    action = action.what
  end

  if type(action) == 'string' then
    for _,w in ipairs(string.split(action, &quot;%$&quot;)) do
      if type(show) == 'nil' then
        pcall(expandAlias, w)
      else
        pcall(expandAlias, w, show)
      end
    end
  else
    local s,m = pcall(action)
    if not s then svo.echof(&quot;Your do queue %s had a problem:\n  %s&quot;, tostring(action), m) end
  end

  if not me.doqueue.repeating then
    table.remove(me.doqueue, 1)
    raiseEvent(&quot;svo do changed&quot;)
  end

  svo.doworking = false

  return true
end

svo.signals.systemstart:connect(function () svo.addbalanceful(&quot;svo check do&quot;, sk.check_do) end, 'add balanceful do check at start')

function svo.check_dofree()
  if not bals.balance or not bals.equilibrium or not bals.rightarm or not bals.leftarm or svo.dofreeworking then return end

  if #me.dofreequeue == 0 then return end

  svo.dofreeworking = true

  for _, action in ipairs(me.dofreequeue) do
    if type(action) == 'string' then
      for _,w in ipairs(string.split(action, &quot;%$&quot;)) do
        expandAlias(w, false)
      end
    else
      local s,m = pcall(action)
      if not s then svo.echof(&quot;Your dofree queue %s had a problem:\n  %s&quot;, tostring(action), m) end
    end
  end

  me.dofreequeue = {}
  raiseEvent(&quot;svo dofree changed&quot;)

  svo.dofreeworking = false
end

svo.signals.systemstart:connect(function () svo.addbalanceless(&quot;svo check dofree&quot;, svo.check_dofree) end, 'add balanceless dofree check at start')

function svo.undo(what, echoback)
  if what == 'all' then return end

  if #me.doqueue == 0 then
    if echoback then svo.echof(&quot;The do queue is empty.&quot;) end
  return end

  if what then
    for i in ipairs(me.doqueue) do
      local action = sk.getactiondo(i)
      if type(action) == 'table' then
        action = action.what
      end

      if action == what then
        table.remove(me.doqueue, i)
        if echoback then svo.echof(&quot;Removed \&quot;%s\&quot; from the do queue.&quot;, action) return end
      end
    end

    if echoback then svo.echof(&quot;Don't have \&quot;%s\&quot; in the do queue.&quot;, what) end
  else
    local action = sk.getactiondo(1)
    if type(action) == 'table' then
      action = action.what
    end

    if echoback then svo.echof(&quot;Removed \&quot;%s\&quot; from the do queue.&quot;, action) end
  end
  raiseEvent(&quot;svo do changed&quot;)
end

function svo.undofree(echoback, what)
  if #me.dofreequeue == 0 then
    if echoback then svo.echof(&quot;The dofree queue is empty.&quot;) end
  return end

  if what then
    for i,v in ipairs(me.dofreequeue) do
      if v == what then
        table.remove(me.dofreequeue, i)
        if echoback then svo.echof(&quot;Removed \&quot;%s\&quot; from the dofree queue.&quot;, v) return end
      end
    end

    if echoback then svo.echof(&quot;Don't have \&quot;%s\&quot; in the dofree queue.&quot;, what) end
  else
    what = table.remove(me.dofreequeue, 1)
    if echoback then svo.echof(&quot;Removed \&quot;%s\&quot; from the dofree queue.&quot;, what) end
  end
  raiseEvent(&quot;svo dofree changed&quot;)
end

function svo.undoall(echoback)
  me.doqueue = {}
  if echoback then svo.echof(&quot;Do queue completely cleared.&quot;) end
  raiseEvent(&quot;svo do changed&quot;)
end

function svo.undoallfree(echoback)
  me.dofreequeue = {}
  if echoback then svo.echof(&quot;Dofree queue completely cleared.&quot;) end
  raiseEvent(&quot;svo dofree changed&quot;)
end

function svo.doshow()
  svo.echof(&quot;Actions left in the dofree queue (%d): %s&quot;, #me.dofreequeue, svo.safeconcat(me.dofreequeue, &quot;, &quot;))
  svo.echof(&quot;Actions left in the do queue (%d): %s&quot;, #me.doqueue, svo.safeconcat(me.doqueue, &quot;, &quot;))
  if me.dorepeat then svo.echof(&quot;Do-Repeat is enabled.&quot;) end
end

</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Custom prompt</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, signals = svo.sys, svo.affs, svo.signals
local conf, sk, me, defc = svo.conf, svo.sk, svo.me, svo.defc
local stats = svo.stats
local bals, cp, cpp = svo.bals, svo.cp, svo.cpp

for _, stat in ipairs {'health', 'mana', 'endurance', 'willpower'} do
  cpp['compute_'..stat..'_percent'] = function()
    return math.floor((stats['current'..stat]/stats['max'..stat])*100)
  end
end

for _, stat in ipairs {'health', 'mana', 'endurance', 'willpower'} do
  cpp['compute_'..stat..'_colour'] = function()
    if stats['current'..stat] &gt;= (stats['max'..stat] * .75) then
      return &quot;&lt;a_darkgreen&gt;&quot;
    elseif stats['current'..stat] &gt;= (stats['max'..stat] * .25) then
      return &quot;&lt;a_yellow&gt;&quot;
    else
      return &quot;&lt;a_red&gt;&quot; end
  end
end

cpp.compute_reverse_xp = function()
  return 100 - stats.nextlevel
end

cpp.compute_pause = function()
  return conf.paused and '&lt;a_red&gt;(&lt;a_darkgrey&gt;p&lt;a_red&gt;)&lt;black&gt; ' or ''
end

cpp.compute_slowcuring = function()
  if not sys.sync then return '' end

  local s = {}
  s[#s+1] = &quot;&lt;red&gt;(&quot;

  if svo.sacid then
    s[#s+1] = &quot;&lt;green&gt;a&quot;
  elseif sk.doingstuff_inslowmode() then
    s[#s+1] = &quot;&lt;red&gt;a&quot;
  else
    s[#s+1] = &quot;&lt;blue&gt;a&quot;
  end

  s[#s+1] = &quot;&lt;red&gt;) &quot;

  return table.concat(s)
end

cpp.unknown_stats = function()
  if not affs.recklessness and not affs.blackout then return '' else
  return &quot;&lt;blaze_orange&gt;?: &quot; end
end

cpp.compute_defs = function()
  local t = {}

  if defc.cloak then
    t[#t+1] = 'c'
  end

  if affs.deafaff or defc.deaf then
    t[#t+1] = 'd'
  end

  if affs.blindaff or defc.blind then
    t[#t+1] = 'b'
  end

  if defc.kola then
    t[#t+1] = 'k'
  end

  if defc.rebounding then
    t[#t+1] = 'r'
  end

  if defc.breath then
    t[#t+1] = 'h'
  end

  return table.concat(t)
end

cpp.compute_eqbal = function()
  local t = {}

  if bals.equilibrium then t[#t+1] = 'e' end
  if bals.balance then t[#t+1] = 'x' end

  return table.concat(t)
end

cpp.compute_armbal = function()
  local t = {}

  if bals.leftarm == true then
    t[#t+1] = 'l'
  elseif bals.leftarm ~= false then
    t[#t+1] = &quot;?&quot; end

  if bals.rightarm == true then
    t[#t+1] = 'r'
  elseif bals.rightarm ~= false then
    t[#t+1] = &quot;?&quot; end

  return table.concat(t)
end

cpp.compute_prone = function ()
  return (affs.prone and 'p' or &quot;&quot;)
end

cpp.compute_Prone = function ()
  return (affs.prone and 'P' or &quot;&quot;)
end

if svo.haveskillset('kaido') then
cpp.compute_kai = function ()
  if stats.kai ~= 0 then
    return stats.kai
  end

  return &quot;&quot;
end

cpp.compute_kai_colour = function ()
  if not stats.kai or stats.kai == 0 then
    return &quot;&quot;
  elseif stats.kai &lt;= 11 then
    return &quot;&lt;a_onelevel&gt;&quot;
  elseif stats.kai &lt;= 21 then
    return &quot;&lt;a_twolevel&gt;&quot;
  elseif stats.kai &lt;= 41 then
    return &quot;&lt;a_threelevel&gt;&quot;
  elseif stats.kai &lt;= 61 then
    return &quot;&lt;a_fourlevel&gt;&quot;
  elseif stats.kai &lt;= 81 then
    return &quot;&lt;a_fivelevel&gt;&quot;
  elseif stats.kai == 100 then
    return &quot;&lt;a_sixlevel&gt;&quot;
  else
    return &quot;&quot;
  end

end
end


if svo.haveskillset('shindo') then
cpp.compute_shin = function ()
  if stats.shin ~= 0 then
    return stats.shin
  end

  return &quot;&quot;
end

cpp.compute_shin_colour = function ()
  if not stats.shin or stats.shin == 0 then
    return &quot;&quot;
  elseif stats.shin &lt;= 5 then
    return &quot;&lt;a_onelevel&gt;&quot;
  elseif stats.shin &lt;= 15 then
    return &quot;&lt;a_twolevel&gt;&quot;
  elseif stats.shin &lt;= 30 then
    return &quot;&lt;a_threelevel&gt;&quot;
  elseif stats.shin &lt;= 40 then
    return &quot;&lt;a_fourlevel&gt;&quot;
  elseif stats.shin &lt;= 90 then
    return &quot;&lt;a_fivelevel&gt;&quot;
  elseif stats.shin == 100 then
    return &quot;&lt;a_sixlevel&gt;&quot;
  else
    return &quot;&quot;
  end

end
end

cpp.compute_gametarget_colour = function()
  local colour = 'blanched_almond'

  local hp = me.gametargethp or 0
  if hp == 0 then
        colour = 'blanched_almond'
  elseif hp &lt; 5 then
        colour = 'red' -- nearly dead
  elseif hp &lt; 25 then
        colour = 'orange_red' -- grievously wounded
  elseif hp &lt; 50 then
        colour = 'dark_orange' -- injured
  elseif hp &lt; 75 then
        colour = 'orange' -- slightly injured
  end

  return '&lt;'..colour..&quot;&gt;&quot;
end


if svo.haveskillset('voicecraft') then
cpp.compute_voicebal = function()
  return (bals.voice and 'v' or &quot;&quot;)
end
end

-- add me to default prompt
if svo.haveskillset('domination') then
cpp.compute_entitiesbal = function()
  return (bals.entities and 'e' or &quot;&quot;)
end
end

if svo.haveskillset('healing') then
cpp.compute_healingbal = function()
  return (bals.healing and 'E' or &quot;&quot;)
end
end

if svo.haveskillset('physiology') then
cpp.compute_humourbal = function()
  return (bals.humour and 'h' or &quot;&quot;)
end

cpp.compute_homunculusbal = function()
  return (bals.homunculus and 'H' or &quot;&quot;)
end
end

if svo.haveskillset('venom') then
cpp.compute_shruggingbal = function()
  return (bals.shrugging and 's' or &quot;&quot;)
end
end

cpp.compute_dragonhealbal = function()
  return (bals.dragonheal and 'd' or &quot;&quot;)
end

if svo.haveskillset('terminus') then
cpp.compute_wordbal = function()
  return (bals.word and 'w' or &quot;&quot;)
end
end

if svo.haveskillset('aeonics') then
cpp.compute_age = function()
  return ((stats.age and stats.age &gt; 0) and tostring(stats.age) or &quot;&quot;)
end
end

cpp.compute_timestamp = function()
  return getTime(true, 'hh:mm:ss.zzz')
end

cpp.compute_servertimestamp = function()
  return me.servertime or ''
end

cpp.compute_at = function()
  return (defc.blackwind or defc.astralform or defc.phase) and &quot;@&quot; or &quot;&quot;
end

cpp.compute_gametarget = function()
  return me.gametarget and me.gametarget or &quot;&quot;
end

cpp.compute_gametargethp = function()
  return me.gametargethp and me.gametargethp..&quot;%&quot; or &quot;&quot;
end

cpp.compute_weaponmastery = function()
  return stats.weaponmastery or 0
end

cpp.compute_power = function()
  local power = stats.shin or stats.kai
  if not power or power == 0 then
   power = &quot;&quot;
  else
   power = power .. &quot;&lt;grey&gt;-&quot;
  end
  return power
end

cpp.compute_power_color = function()
  local powerColor
  local power = stats.shin or stats.kai
  if not power or power == 0 then
   powerColor = &quot;&quot;
  else
   powerColor = &quot;&lt;&quot; .. (power &lt; 25 and 'red' or power &lt; 60 and
  'yellow' or power &lt; 75 and
       'green_yellow' or power &lt; 100 and 'a_darkgreen' or 'a_green') ..&quot;&gt;&quot;
  end
  return powerColor
end

if svo.haveskillset('metamorphosis') then
cpp.compute_morph = function()
  return me.morph or &quot;&quot;

end
end

if svo.haveskillset('groves') then
cpp.compute_sunlight = function()
  return stats.sunlight &gt; 0 and tostring(stats.sunlight) or &quot;&quot;
end
end

if svo.haveskillset('tekura') then
cpp.compute_monkpath = function()
  return me.path or &quot;&quot;
end

cpp.compute_stanceform = function()
  return me.stance or me.form or &quot;&quot;
end

cpp.compute_stanceform_verbose = function()
  return string.format(
    &quot;%s: %s&quot;,
    cpp.compute_monkpath(),
    cpp.compute_stanceform()
  )
end
end

cpp.compute_promptstring = function()
  local text = (&quot;&lt;LightSlateGrey&gt;&quot;)..
        (defc.cloak and 'c' or &quot;&quot;) ..
        (bals.equilibrium and &quot;&lt;white&gt;e&lt;LightSlateGrey&gt;&quot; or &quot;&quot;)..
        (bals.balance and &quot;&lt;white&gt;x&lt;LightSlateGrey&gt;&quot; or &quot;&quot;)..
        (defc.kola and 'k' or &quot;&quot;)..
        ((defc.deaf or affs.deafaff) and 'd' or &quot;&quot;)..
        ((defc.blind or affs.blindaff) and 'b' or &quot;&quot;)..
        (defc.astralform and &quot;@&quot; or &quot;&quot;)..
        (defc.phase and &quot;@&quot; or &quot;&quot;)..
        (defc.blackwind and &quot;@&quot; or &quot;&quot;)..
        (defc.breath and &quot;&lt;blue&gt;|&lt;LightSlateGrey&gt;b&quot; or &quot;&quot;)
  local composition = {text}
if bals.entities then
  composition[#composition+1] = 'e'
end
if bals.healing then
  composition[#composition+1] = 'E'
end
if svo.haveskillset('physiology') then
  if bals.humour then
    composition[#composition+1] = 'h'
  end
  if bals.homunculus then
    composition[#composition+1] = 'H'
  end
end
if bals.shrugging then
  composition[#composition+1] = 's'
end
if bals.voice then
  composition[#composition+1] =  'v'
end
if bals.word then
  composition[#composition+1] = 'w'
end
  composition[#composition+1] = '-&lt;grey&gt;'
  return table.concat(composition)
end

cpp.compute_promptstringorig = function()
 return (&quot;&lt;grey&gt;&quot;)..
        (defc.cloak and 'c' or &quot;&quot;) ..
        (bals.equilibrium and 'e' or &quot;&quot;)..
        (bals.balance and 'x' or &quot;&quot;)..
        (defc.kola and 'k' or &quot;&quot;)..
        ((defc.deaf or affs.deafaff) and 'd' or &quot;&quot;)..
        ((defc.blind or affs.blindaff) and 'b' or &quot;&quot;)..
        ((defc.phase or defc.blackwind or defc.astralform) and &quot;@&quot; or &quot;&quot;)
end

cpp.compute_diffmana = function()
  return (me.manachange &gt; 0 and &quot;+&quot;..me.manachange or (me.manachange &lt; 0 and me.manachange or ''))
end
cpp.compute_diffhealth = function()
  return (me.healthchange &gt; 0 and &quot;+&quot;..me.healthchange or (me.healthchange &lt; 0 and me.healthchange or ''))
end

cpp.compute_diffmana_paren = function()
  return (me.manachange &gt; 0 and &quot;(+&quot;..me.manachange..&quot;)&quot; or (me.manachange &lt; 0 and &quot;(&quot;..me.manachange..&quot;)&quot; or ''))
end
cpp.compute_diffhealth_paren = function()
  return (me.healthchange &gt; 0 and &quot;(+&quot;..me.healthchange..&quot;)&quot; or (me.healthchange &lt; 0 and &quot;(&quot;..me.healthchange..&quot;)&quot; or ''))
end

cpp.compute_diffmana_bracket = function()
  return (me.manachange &gt; 0 and &quot;[+&quot;..me.manachange..&quot;]&quot; or (me.manachange &lt; 0 and &quot;[&quot;..me.manachange..&quot;]&quot; or ''))
end
cpp.compute_diffhealth_bracket = function()
  return (me.healthchange &gt; 0 and &quot;[+&quot;..me.healthchange..&quot;]&quot; or (me.healthchange &lt; 0 and &quot;[&quot;..me.healthchange..&quot;]&quot; or ''))
end

cpp.compute_day = function()
  return me.gametime and me.gametime.day or &quot;&quot;
end

cpp.compute_month = function()
  return me.gametime and me.gametime.month or &quot;&quot;
end

cpp.compute_year = function()
  return me.gametime and me.gametime.year or &quot;&quot;
end

cpp.compute_battlerage = function()
  return stats.battlerage &gt; 0 and tostring(stats.battlerage) or &quot;&quot;
end

cp.definitions                      = cp.definitions or {}
cp.definitions[&quot;@health&quot;]           = &quot;svo.stats.currenthealth&quot;
cp.definitions[&quot;@mana&quot;]             = &quot;svo.stats.currentmana&quot;
cp.definitions[&quot;@willpower&quot;]        = &quot;svo.stats.currentwillpower&quot;
cp.definitions[&quot;@endurance&quot;]        = &quot;svo.stats.currentendurance&quot;
cp.definitions[&quot;@maxhealth&quot;]        = &quot;svo.stats.maxhealth&quot;
cp.definitions[&quot;@maxmana&quot;]          = &quot;svo.stats.maxmana&quot;
cp.definitions[&quot;@maxwillpower&quot;]     = &quot;svo.stats.maxwillpower&quot;
cp.definitions[&quot;@maxendurance&quot;]     = &quot;svo.stats.maxendurance&quot;
cp.definitions[&quot;@%health&quot;]          = &quot;svo.cpp.compute_health_percent()&quot;
cp.definitions[&quot;@%mana&quot;]            = &quot;svo.cpp.compute_mana_percent()&quot;
cp.definitions[&quot;@%willpower&quot;]       = &quot;svo.cpp.compute_willpower_percent()&quot;
cp.definitions[&quot;@%endurance&quot;]       = &quot;svo.cpp.compute_endurance_percent()&quot;
cp.definitions[&quot;@%xp&quot;]              = &quot;svo.stats.nextlevel&quot;
cp.definitions[&quot;@-%xp&quot;]             = &quot;svo.cpp.compute_reverse_xp()&quot;
cp.definitions[&quot;@xprank&quot;]           = &quot;svo.stats.xprank&quot;
cp.definitions[&quot;@defs&quot;]             = &quot;svo.cpp.compute_defs()&quot;
cp.definitions[&quot;@eqbal&quot;]            = &quot;svo.cpp.compute_eqbal()&quot;
cp.definitions[&quot;@armbal&quot;]           = &quot;svo.cpp.compute_armbal()&quot;
cp.definitions[&quot;@prone&quot;]            = &quot;svo.cpp.compute_prone()&quot;
cp.definitions[&quot;@Prone&quot;]            = &quot;svo.cpp.compute_Prone()&quot;
cp.definitions[&quot;@@&quot;]                = &quot;svo.cpp.compute_at()&quot;
cp.definitions[&quot;@power&quot;]            = &quot;svo.cpp.compute_power()&quot;
cp.definitions[&quot;@promptstring&quot;]     = &quot;svo.cpp.compute_promptstring()&quot;
cp.definitions[&quot;@promptstringorig&quot;] = &quot;svo.cpp.compute_promptstringorig()&quot;
cp.definitions[&quot;@diffmana&quot;]         = &quot;svo.cpp.compute_diffmana()&quot;
cp.definitions[&quot;@diffhealth&quot;]       = &quot;svo.cpp.compute_diffhealth()&quot;
cp.definitions[&quot;@(diffmana)&quot;]       = &quot;svo.cpp.compute_diffmana_paren()&quot;
cp.definitions[&quot;@(diffhealth)&quot;]     = &quot;svo.cpp.compute_diffhealth_paren()&quot;
cp.definitions[&quot;@[diffmana]&quot;]       = &quot;svo.cpp.compute_diffmana_bracket()&quot;
cp.definitions[&quot;@[diffhealth]&quot;]     = &quot;svo.cpp.compute_diffhealth_bracket()&quot;
cp.definitions[&quot;@day&quot;]              = &quot;svo.cpp.compute_day()&quot;
cp.definitions[&quot;@month&quot;]            = &quot;svo.cpp.compute_month()&quot;
cp.definitions[&quot;@year&quot;]             = &quot;svo.cpp.compute_year()&quot;
cp.definitions[&quot;@p&quot;]                = &quot;svo.cpp.compute_pause()&quot;
cp.definitions[&quot;@slowcuring&quot;]       = &quot;svo.cpp.compute_slowcuring()&quot;
cp.definitions[&quot;@?:&quot;]               = &quot;svo.cpp.unknown_stats()&quot;
cp.definitions[&quot;@gametarget&quot;]       = &quot;svo.cpp.compute_gametarget()&quot;
cp.definitions[&quot;@gametargethp&quot;]     = &quot;svo.cpp.compute_gametargethp()&quot;
cp.definitions[&quot;@dragonhealbal&quot;]    = &quot;svo.cpp.compute_dragonhealbal()&quot;
cp.definitions[&quot;@battlerage&quot;]       = &quot;svo.cpp.compute_battlerage()&quot;
cp.definitions[&quot;^7&quot;]                = &quot;svo.cpp.compute_power_color()&quot;
cp.definitions[&quot;^r&quot;]                = &quot;'&lt;a_red&gt;'&quot;
cp.definitions[&quot;^R&quot;]                = &quot;'&lt;a_darkred&gt;'&quot;
cp.definitions[&quot;^g&quot;]                = &quot;'&lt;a_green&gt;'&quot;
cp.definitions[&quot;^G&quot;]                = &quot;'&lt;a_darkgreen&gt;'&quot;
cp.definitions[&quot;^y&quot;]                = &quot;'&lt;a_yellow&gt;'&quot;
cp.definitions[&quot;^Y&quot;]                = &quot;'&lt;a_darkyellow&gt;'&quot;
cp.definitions[&quot;^b&quot;]                = &quot;'&lt;a_blue&gt;'&quot;
cp.definitions[&quot;^B&quot;]                = &quot;'&lt;a_darkblue&gt;'&quot;
cp.definitions[&quot;^m&quot;]                = &quot;'&lt;a_magenta&gt;'&quot;
cp.definitions[&quot;^M&quot;]                = &quot;'&lt;a_darkmagenta&gt;'&quot;
cp.definitions[&quot;^c&quot;]                = &quot;'&lt;a_cyan&gt;'&quot;
cp.definitions[&quot;^C&quot;]                = &quot;'&lt;a_darkcyan&gt;'&quot;
cp.definitions[&quot;^w&quot;]                = &quot;'&lt;a_white&gt;'&quot;
cp.definitions[&quot;^W&quot;]                = &quot;'&lt;a_darkwhite&gt;'&quot;
cp.definitions[&quot;^gametarget&quot;]       = &quot;svo.cpp.compute_gametarget_colour()&quot;

if svo.haveskillset('voicecraft') then
  cp.definitions[&quot;@voicebal&quot;]      = &quot;svo.cpp.compute_voicebal()&quot;
end
if svo.haveskillset('domination') then
  cp.definitions[&quot;@entitiesbal&quot;]   = &quot;svo.cpp.compute_entitiesbal()&quot;
end
if svo.haveskillset('healing') then
  cp.definitions[&quot;@healingbal&quot;]    = &quot;svo.cpp.compute_healingbal()&quot;
end
if svo.haveskillset('physiology') then
  cp.definitions[&quot;@humourbal&quot;]     = &quot;svo.cpp.compute_humourbal()&quot;
  cp.definitions[&quot;@homunculusbal&quot;] = &quot;svo.cpp.compute_homunculusbal()&quot;
end
if svo.haveskillset('venom') then
  cp.definitions[&quot;@shrugging&quot;]     = &quot;svo.cpp.compute_shruggingbal()&quot;
end
if svo.haveskillset('tekura') or svo.haveskillset('shikudo') then
  cp.definitions[&quot;@monkpath&quot;]      = &quot;svo.cpp.compute_monkpath()&quot;
  cp.definitions[&quot;@monkstance&quot;]        = &quot;svo.cpp.compute_stanceform()&quot;
  cp.definitions[&quot;@monkfull&quot;]      = &quot;svo.cpp.compute_stanceform_verbose()&quot;
end
if svo.haveskillset('kaido') then
  cp.definitions[&quot;@kai&quot;]           = &quot;svo.cpp.compute_kai()&quot;
end
if svo.haveskillset('shindo') then
  cp.definitions[&quot;@shin&quot;]          = &quot;svo.cpp.compute_shin()&quot;
end
  cp.definitions[&quot;@timestamp&quot;]     = &quot;svo.cpp.compute_timestamp()&quot;
  cp.definitions[&quot;@servertimestamp&quot;] = &quot;svo.cpp.compute_servertimestamp()&quot;
if svo.haveskillset('weaponmastery') then
  cp.definitions[&quot;@weaponmastery&quot;] = &quot;svo.cpp.compute_weaponmastery()&quot;
end
if svo.haveskillset('metamorphosis') then
  cp.definitions[&quot;@morph&quot;]         = &quot;svo.cpp.compute_morph()&quot;
end
if svo.haveskillset('groves') then
  cp.definitions[&quot;@sunlight&quot;]      = &quot;svo.cpp.compute_sunlight()&quot;
end
if svo.haveskillset('terminus') then
  cp.definitions[&quot;@wordbal&quot;]       = &quot;svo.cpp.compute_wordbal()&quot;
end
if svo.haveskillset('aeonics') then
  cp.definitions[&quot;@age&quot;]           = &quot;svo.cpp.compute_age()&quot;
end
  cp.definitions[&quot;^1&quot;]             = &quot;svo.cpp.compute_health_colour()&quot;
  cp.definitions[&quot;^2&quot;]             = &quot;svo.cpp.compute_mana_colour()&quot;
  cp.definitions[&quot;^4&quot;]             = &quot;svo.cpp.compute_willpower_colour()&quot;
  cp.definitions[&quot;^5&quot;]             = &quot;svo.cpp.compute_endurance_colour()&quot;
if svo.haveskillset('kaido') then
  cp.definitions[&quot;^6&quot;]             = &quot;svo.cpp.compute_kai_colour()&quot;
end
if svo.haveskillset('shindo') then
  cp.definitions[&quot;^6&quot;]             = &quot;svo.cpp.compute_shin_colour()&quot;
end

function cp.adddefinition(tag, func)
  func = string.format(&quot;tostring(%s)&quot;, func)

  cp.definitions[tag] = func
  cp.makefunction()
end

function cp.makefunction()
  if not conf.customprompt or not sk.logged_in then return end

  local t = cp.generatetable(conf.customprompt)

  local display, error = loadstring(&quot;return table.concat({&quot;..table.concat(t, &quot;, &quot;)..&quot;})&quot;)
  if display then cp.display = display else
    cp.display = function() return '' end
    svo.debugf(&quot;Couldn't compile the custom prompt: %s&quot;, error)
  end

  -- set the prompt we require within the game for these tags to work
  if conf.customprompt:find(&quot;@gametarget&quot;) or conf.customprompt:find(&quot;@gametargethp&quot;) or conf.customprompt:find(&quot;@weaponmastery&quot;) or conf.customprompt:find(&quot;@servertimestamp&quot;) then
    send(sys.ingamecustomprompt, false)

    svo.ingameprompt = tempExactMatchTrigger(&quot;Your custom prompt is now:&quot;, [[
      svo.deleteAllP()
      if svo.ingameprompt then
        killTrigger(svo.ingameprompt)
        svo.ingameprompt = nil
      end
    ]])
  end
end
-- use the login event, and not systemstart, so we get can set the right prompt in the game
signals.gmcpcharname:connect(cp.makefunction, 'create the prompt function at start')
-- meanwhile, return nothing
cp.display = function() return '' end

-- but also regenerate the function if we're already logged in and this script is saved
if svo.systemloaded then
  cp.makefunction()
end

signals.systemstart:connect(function ()
  if not conf.oldcustomprompt or conf.oldcustomprompt == 'off' then
    conf.oldcustomprompt = conf.customprompt
  end
end, 'remember the oldcustomprompt')

function cp.generatetable(customprompt)
  local t = {}
  local ssub = string.sub

  local tags_array = {}
  for def, defv in pairs(cp.definitions) do
    tags_array[#tags_array+1] = {def = def, defv = defv}
  end

  table.sort(tags_array, function(a,b) return #a.def &gt; #b.def end)

  local buffer = &quot;&quot;

  local function add_character(c)
      buffer = buffer .. c
  end

  local function add_buffer()
    if buffer ~= &quot;&quot; then
      t[#t+1] = &quot;'&quot; .. buffer .. &quot;'&quot;
      buffer = &quot;&quot;
    end
  end

  local function add_code(c)
      add_buffer()
      t[#t+1] = c
  end

  while customprompt ~= &quot;&quot; do
    local matched = false

    for i = 1, #tags_array do
      local def = tags_array[i].def

      if ssub(customprompt, 1, #def) == def then
        add_code(tags_array[i].defv)
        customprompt = ssub(customprompt, #def + 1)
        matched = true
        break
      end
    end

    if not matched then
      add_character(ssub(customprompt, 1, 1))
      customprompt = ssub(customprompt, 2)
    end

  end

  add_buffer()

  return t
end

-- import color_table
for color in pairs(color_table) do
  cp.definitions[&quot;^&quot;..color] = &quot;'&lt;&quot;..color..&quot;&gt;'&quot;
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Serverside</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

local sys, affs, defdefup, defkeepup, signals = svo.sys, svo.affs, svo.defdefup, svo.defkeepup, svo.signals
local conf, sk, me, defs = svo.conf, svo.sk, svo.me, svo.defs
local stats, serverignore = svo.stats, svo.serverignore

-- update serverside prios in general
signals[&quot;svo prio changed&quot;]:connect(function()
  if not conf.serverside then return end

  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end, 'update serverside prios on svo prio change')

-- update serverside prios with custom svo.dict overrides, ie for health which is not on serverside prios
signals[&quot;svo prio changed&quot;]:connect(function(action, balance, newprio, slowcuring)
  if not (conf.serverside and svo.dict[action][balance].onprioswitch) then return end

  svo.dict[action][balance].onprioswitch(newprio, slowcuring)
end, 'run onprioswitch dict functions')

-- start out with blank prios, so a diff on switch to basic has the right stuff
signals[&quot;svo system loaded&quot;]:connect(function()
  sk.priosbeforechange = sk.getblankbeforestateprios()
end, 'get initial state of prios')


function sk.sendpriorityswitch(action, balance, raffs, rdefs, cache)
  local isdefence, priority, gamename

  if svo.dict[action][balance].def then
    isdefence = &quot;defence &quot;
    priority = rdefs[action]
  elseif svo.dict[action].aff then
    isdefence = &quot;&quot;
    priority = raffs[action]
  else -- an action that's not an aff or a def - ignore
    svo.debugf(&quot;(e!) sk.sendpriorityswitch: quitting, not an aff or a def&quot;)
    return
  end

  -- caps at 25, so pool everything after on 25
  if priority &gt; 25 then priority = 25 end

  -- if already in cache at same priority, don't send
  if cache[action] == priority then
    svo.debugf(&quot;%s is already on %s, ignoring&quot;, action, cache[action])
    return
  else
    cache[action] = priority
  end

  gamename = svo.dict[action].gamename and svo.dict[action].gamename or action

  local command = string.format(&quot;priority %s%s %s&quot;, isdefence, gamename, priority)

  svo.sendcuring(command)
end

function sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, cache)
  local isdefence, priority, gamename

  if svo.dict[action][balance].def then
    isdefence = &quot;defence &quot;
    priority = 'reset'
  elseif svo.dict[action].aff then
    isdefence = &quot;&quot;
    priority = 26
  else -- an action that's not an aff or a def - ignore
    svo.debugf(&quot;(e!) sk.sendpriorityignore: quitting, not an aff or a def&quot;)
    return
  end

  -- if already in cache at same priority, don't send
  if cache[action] == 'ignore' then
    svo.debugf(&quot;%s is already on %s, ignoring&quot;, action, cache[action])
    return
  else
    cache[action] = 'ignore'
  end

  gamename = svo.dict[action].gamename and svo.dict[action].gamename or action

  local command = string.format(&quot;priority %s%s %s&quot;, isdefence, gamename, priority)

  svo.sendcuring(command)
end

function sk.updateserversideprios()
  if not sk.priochangetimer then return end
  sk.updateserverwatch = sk.updateserverwatch or createStopWatch()
  startStopWatch(sk.updateserverwatch)

  -- don't notify of prio changes until the system is loaded, as they can get shuffled around a bit
  if not svo.systemloaded then return end

  local afterstate = sk.getafterstateprios()
  svo.debugf(&quot;sk.updateserverwatch sk.getafterstateprios: %s&quot;, getStopWatchTime(sk.updateserverwatch))

  local basictableindexdiff = svo.basictableindexdiff

  for balance, data in pairs(sk.priosbeforechange) do
    if balance == 'slowcuring' then
      sk.priochangecache[balance] = sk.priochangecache[balance] or {}
      local priochangecache = sk.priochangecache[balance]

      -- make the diff of snapshots
      local diffslow = basictableindexdiff(data.data, afterstate[balance].newdata)
      -- split the action_balance actions into separate balances
      local diff = sk.splitbals(diffslow)

      -- get the new list of prios, sorted in importance
      local neworderslow = svo.prio.getsortedlist(balance)
      -- split the action_balance actions into separate balances
      local neworderbals = sk.splitbals(neworderslow)

      -- if not in slowcuring mode, switch to slowcuring prios first
      local needtoswitch, needtoswitchback = false, false
      if not sys.sync then
        needtoswitch = true
      end

      for balance, neworder in pairs(neworderbals) do
        if diff[balance] then
          priochangecache[balance] = priochangecache[balance] or {}
          local affs, defs, ignoreaffs, ignoredefs = sk.splitdefs(balance, neworder)
          local raffs, rdefs, rignoreaffs, rignoredefs = {}, {}, {}, {}
          for index, aff in pairs(affs) do raffs[aff] = index end
          for index, def in pairs(defs) do rdefs[def] = index end
          for index, aff in pairs(ignoreaffs) do rignoreaffs[aff] = index end
          for index, def in pairs(ignoredefs) do rignoredefs[def] = index end

          -- update for the changes
          for _, action in pairs(diff[balance]) do
            -- check if this is something actually on prios. an aff could be ignored, a def not on keepup
            if raffs[action] or rdefs[action] then
              if needtoswitch then svo.sendc(&quot;curingset switch slowcuring&quot;); needtoswitch = false; needtoswitchback = true end

              sk.sendpriorityswitch(action, balance, raffs, rdefs, priochangecache[balance])
            elseif rignoreaffs[action] or rignoredefs[action] then
              if needtoswitch then svo.sendc(&quot;curingset switch slowcuring&quot;); needtoswitch = false; needtoswitchback = true end

              sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, priochangecache[balance])
            end
          end
        end
      end

      if needtoswitchback then
        svo.sendc(&quot;curingset switch normal&quot;)
      end
    else
      sk.priochangecache[balance] = sk.priochangecache[balance] or {}

      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)
      -- if next(diff) then svo.debugf(&quot;%s diff: %s&quot;, balance, pl.pretty.write(diff)) end
      -- get the new list of prios, sorted in importance
      local neworder = svo.prio.getsortedlist(balance)
      local affs, defs, ignoreaffs, ignoredefs = sk.splitdefs(balance, neworder)
      local raffs, rdefs, rignoreaffs, rignoredefs = {}, {}, {}, {}
      for index, aff in pairs(affs) do raffs[aff] = index end
      for index, def in pairs(defs) do rdefs[def] = index end
      for index, aff in pairs(ignoreaffs) do rignoreaffs[aff] = index end
      for index, def in pairs(ignoredefs) do rignoredefs[def] = index end

      -- if not in slowcuring mode, switch to slowcuring prios first
      local needtoswitch, needtoswitchback = false, false
      if sys.sync then
        needtoswitch = true
      end

      -- update for the changes
      for _, action in pairs(diff) do
        -- check if this is something actually on prios. an aff could be ignored, a def not on keepup
        if raffs[action] or rdefs[action] then
          if needtoswitch then svo.sendc(&quot;curingset switch normal&quot;); needtoswitch = false; needtoswitchback = true end

          sk.sendpriorityswitch(action, balance, raffs, rdefs, sk.priochangecache[balance])
        elseif rignoreaffs[action] or rignoredefs[action] then
          if needtoswitch then svo.sendc(&quot;curingset switch normal&quot;); needtoswitch = false; needtoswitchback = true end

          sk.sendpriorityignore(action, balance, rignoreaffs, rignoredefs, sk.priochangecache[balance])
        end
      end

      if needtoswitchback then
        svo.sendc(&quot;curingset switch slowcuring&quot;)
      end
    end
  end

  sk.priochangetimer = nil

  -- save new state for next change
  svo.debugf(&quot;sk.updateserverwatch sk.getbeforestateprios: %s&quot;, getStopWatchTime(sk.updateserverwatch))
  sk.priosbeforechange = sk.getbeforestateprios()

  svo.debugf(&quot;sk.updateserverwatch: %s&quot;, stopStopWatch(sk.updateserverwatch))
end

-- splits slowcuring prios by balance
function sk.splitbals(list)
  local balances, valid_sync_action = {}, svo.valid_sync_action

  for i = 1, #list do
    local action_balance = list[i]

    local _, action, balance = valid_sync_action(action_balance)
    balances[balance] = balances[balance] or {}
    local balancet = balances[balance]
    balancet[#balancet+1] = action
  end

  return balances
end

-- returns true if the given action should be ignored on serverside, which it should be if:
-- it's ignored in system in general
-- it's handled by Svof instead of serverside
-- it's not on keepup
-- if we're in defup and it's not on defup
-- its custom onservereignore function returns true
function sk.shouldignoreserverside(action)
  return conf.serverside and (
    svo.ignore[action] or
    not serverignore[action] or
    (not sys.deffing and defkeepup[defs.mode][action] == false) or
    (sys.deffing and defdefup[defs.mode][action] == false) or
    (svo.dict[action].onservereignore and svo.dict[action].onservereignore())
  ) -- false so afflictions are okay, which are a nil
end
svo.shouldignoreserverside = sk.shouldignoreserverside

function sk.handleserversideswitch()
  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end

function sk.handleserversideswitch_keepup(defmode, action)
  if not svo.dict[action] then return end

  -- don't do anything for the current defences mode
  if defmode ~= defs.mode then return end

  if not sk.priochangetimer then
    sk.priochangetimer = tempTimer(0, function() sk.updateserversideprios() end)
  end
end

-- splits defs up into another list and removes them from the affs one
-- also remove uncurable actions that aren't affs, and defs that
-- aren't on defup or keepup
function sk.splitdefs(balance, list)
  local defslist, disableddefs, disabledaffs, dict, defmode = {}, {}, {}, svo.dict, svo.defs.mode

  -- prune list to only be a list of affs, save defs and disable defs into another list
  -- iterate backwards, so we can remove items from the list safely
  for i = #list, 1, -1 do
    local action = list[i]

    -- take care of defs
    if dict[action][balance].def then
      -- check that it's not undeffable in-game and on keepup
      if not dict[action][balance].undeffable and ((sys.deffing and defdefup[defmode][action]) or (not sys.deffing and defkeepup[defmode][action])) and not sk.shouldignoreserverside(action) then
        defslist[i] = list[i]
        list[i] = nil
      -- if it's off keepup, send to another list so those defs get ignored
      elseif not dict[action][balance].undeffable and sk.shouldignoreserverside(action) then
        disableddefs[#disableddefs+1] = list[i]
        list[i] = nil
      else
        -- make sure to remove a def either way
        list[i] = nil
      end
    else
      -- remove if not priotisable
      if dict[action][balance].uncurable or dict[action][balance].irregular then
        list[i] = nil
      -- if handled by svo, or handled by serverside and on normal ignore, ignore
      elseif dict[action].aff and sk.shouldignoreserverside(action) then
        disabledaffs[#disabledaffs+1] = list[i]
        list[i] = nil
      end
    end
  end

  return list, defslist, disabledaffs, disableddefs
end


-- gets a snapshot of priorities, skipping actions that should be ignored
function sk.getbeforestateprios()
  local beforestate = {}
  local importables = {
    'herb',
    'smoke',
    'salve',
    'sip',
    'purgative',
    'physical',
    'moss',
    'misc',
    'slowcuring',
  }

  local make_prio_tablef = svo.make_prio_tablef

  for _, balance in ipairs(importables) do
    beforestate[balance] = {}

    if balance == 'slowcuring' then
      -- get the before state for diffing
      local data = svo.make_sync_prio_tablef(&quot;%s_%s&quot;, function(action)
        return not sk.shouldignoreserverside(action)
      end, { focus = true })
      beforestate[balance] = {data = data}
    else
      -- get the before state for diffing
      local data = make_prio_tablef(balance, function(action)
        return not sk.shouldignoreserverside(action)
      end)
      beforestate[balance] = {data = data}
    end
  end

  return beforestate
end

-- gets a blanked out state of before prios - useful if all of them need to be reset serverside
function sk.getblankbeforestateprios()
  local beforestate = {}
  local importables = {
    'herb',
    'smoke',
    'salve',
    'sip',
    'purgative',
    'physical',
    'moss',
    'misc',
    'slowcuring',
  }
  local make_prio_tablef = svo.make_prio_tablef

  for _, balance in ipairs(importables) do
    beforestate[balance] = {}

    if balance == 'slowcuring' then
      -- get the before state for diffing
      local data = svo.make_sync_prio_tablef(&quot;%s_%s&quot;, nil, { focus = true })
      -- set all prios to negative, so things get set or ignored serverside properly
      local nullify, c = {}, -1
      for _,v in pairs(data) do nullify[c] = v; c = c - 1 end
      beforestate[balance] = {data = nullify}
    else
      -- get the before state for diffing
      local data = make_prio_tablef(balance)
      -- set all prios to negative, so things get set or ignored serverside properly
      local nullify, c = {}, -1
      for _,v in pairs(data) do nullify[c] = v; c = c - 1 end
      beforestate[balance] = {data = nullify}
    end
  end

  return beforestate
end

function sk.getafterstateprios()
  local afterstate = {}
  local importables = {
    'herb',
    'smoke',
    'salve',
    'sip',
    'purgative',
    'physical',
    'moss',
    'misc',
    'slowcuring',
  }

  local make_prio_tablef = svo.make_prio_tablef

  for _, balance in ipairs(importables) do
    afterstate[balance] = {}

    if balance == 'slowcuring' then
      -- get the new state
      local newdata = svo.make_sync_prio_tablef(&quot;%s_%s&quot;, function(action)
        return not sk.shouldignoreserverside(action)
      end, { focus = true })
      -- create an action - prio table for retrieval of location using diffs
      local action_prio = {}
      for k,v in pairs(newdata) do action_prio[v] = k end
      afterstate[balance] = {newdata = newdata, action_prio = action_prio}
    else
      -- get the new state
      local newdata = make_prio_tablef(balance, function(action)
        return not sk.shouldignoreserverside(action)
      end)
      -- create an action - prio table for retrieval of location using diffs
      local action_prio = {}
      for k,v in pairs(newdata) do action_prio[v] = k end
      afterstate[balance] = {newdata = newdata, action_prio = action_prio}
    end
  end

  return afterstate
end

function sk.notifypriodiffs(beforestate, afterstate)
  local basictableindexdiff = svo.basictableindexdiff

  -- don't notify of prio changes until the system is loaded, as they can get shuffled around a bit
  if not svo.systemloaded then return end

  for balance, data in pairs(beforestate) do
    if balance == 'slowcuring' then
      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)
      local valid_sync_action = svo.valid_sync_action

      -- now only notify for the differences
      for _, a in pairs(diff) do
        local _, action, balance = valid_sync_action(a)
        raiseEvent(&quot;svo prio changed&quot;, action, balance, afterstate[balance].action_prio[a], 'slowcuring')
      end
    else
      -- make the diff of snapshots
      local diff = basictableindexdiff(data.data, afterstate[balance].newdata)

      -- notify only for the changes
      for _, a in pairs(diff) do
        raiseEvent(&quot;svo prio changed&quot;, a, balance, afterstate[balance].action_prio[a])
      end
    end
  end
end


-- returns an alphabetically sorted indexed list of all actions serverside can do
function sk.getallserversideactions()
  local type = type

  local actions = {}
  for action, balances in pairs(svo.dict) do
    for balance, data in pairs(balances) do
      if type(data) == 'table' and balance ~= 'waitingfor' and balance ~= 'aff' and balance ~= 'gone' and balance ~= 'happened' and not data.uncurable and not data.undeffable then
        actions[action] = true
      end
    end
  end

  local actionslist = {}
  for k,_ in pairs(actions) do
    actionslist[#actionslist+1] = k
  end

  table.sort(actionslist)

  return actionslist
end

--[[ register all signals needed for this to work ]]

signals.sync:connect(function ()
  if not conf.serverside then return end

  if sys.sync then
    svo.sendc(&quot;curingset switch slowcuring&quot;)
  else
    svo.sendc(&quot;curingset switch normal&quot;)
  end
end, 'update curingset on aeon/retardation')

-- vconfig serverside
signals[&quot;svo config changed&quot;]:connect(function(config)
  if config ~= 'serverside' then return end

  if conf.serverside then
    sk.priochangecache = {
      special = {
        focustoggle = conf.focus
      }
    }
    -- sync everything
    sk.priosbeforechange = sk.getblankbeforestateprios()
    svo.sendcuring(&quot;PRIORITY RESET&quot;)
    sk.priochangetimer = true
    sk.updateserversideprios()
    -- sync all special things like health
    for _, actiont in pairs(svo.dict) do
      for _, balancet in pairs(actiont) do
        if type(balancet) == 'table' and balancet.onprioswitch then
          balancet.onprioswitch()
        end
      end
    end

    -- initial sync of some config options.
    local option
    for _, optionname in ipairs({'healthaffsabove', 'mosshealth', 'mossmana'}) do
      if conf[optionname] == true then option = 'on'
      elseif conf[optionname] == false then option = 'off'
      else
        option = conf[optionname]
      end

      svo.sendcuring(optionname.. &quot; &quot;..option)
    end

    if conf.keepup then
      svo.sendcuring(&quot;defences on&quot;)
    else
      svo.sendcuring(&quot;defences off&quot;)
    end

    sk.togglefocusserver()
    sk.toggleclotserver()
    sk.toggleinsomniaserver()

    if sk.canclot() and conf.clot then svo.sendcuring(&quot;clot on&quot;) else svo.sendcuring(&quot;clot off&quot;) end
    svo.sendcuring(&quot;clotat &quot;..conf.bleedamount)

    if not serverignore.healhealth then
      svo.sendcuring(&quot;siphealth 0&quot;)
      sk.priochangecache.special.healhealth = 0
    elseif serverignore.healhealth then
      svo.sendcuring(&quot;siphealth &quot;..conf.siphealth)
      sk.priochangecache.special.healhealth = conf.siphealth
    end

    if not serverignore.healmana then
      svo.sendcuring(&quot;sipmana 0&quot;)
      sk.priochangecache.special.healmana = 0
    elseif serverignore.healmana then
      svo.sendcuring(&quot;sipmana &quot;..conf.sipmana)
      sk.priochangecache.special.healmana = conf.sipmana
    end

    if conf.curemethod == 'transonly' then
      svo.sendcuring(&quot;transmutation on&quot;)
    elseif conf.curemethod == 'conconly' then
      svo.sendcuring(&quot;transmutation off&quot;)
    elseif conf.curemethod == 'prefertrans' then
      svo.sendcuring(&quot;transmutation on&quot;)
      svo.echof(&quot;Setting in-game curemethod to 'transmutation cures only', as serverside doesn't support mixed cures.&quot;)
    elseif conf.curemethod == 'preferconc' then
       svo.sendcuring(&quot;transmutation off&quot;)
       svo.echof(&quot;Setting in-game curemethod to 'concoctions cures only', as serverside doesn't support mixed cures.&quot;)
    end

    svo.sendcuring(&quot;manathreshold &quot;..conf.manause)
  end
end, 'update serverside prios on config change')
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'healthaffsabove') then return end

  local option
  if conf.healthaffsabove == true then option = 'on'
  elseif conf.healthaffsabove == false then option = 'off'
  else
    option = conf.healthaffsabove
  end

  svo.sendcuring(&quot;healthaffsabove &quot;..option)
end, 'update healthaffsabove')

for _, optionname in ipairs({'mosshealth', 'mossmana'}) do
  signals[&quot;svo config changed&quot;]:connect(function(config)
    if not (conf.serverside and config == optionname) then return end

    local option
    if conf.moss then
      option = conf[optionname]
    else
      option = '0'
    end

    svo.sendcuring(optionname ..&quot; &quot;..option)
  end, 'update serverside moss')
end

-- vconfig moss
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'moss') then return end

  if conf.moss then
    svo.sendcuring(&quot;mosshealth &quot;..conf.mosshealth)
    svo.sendcuring(&quot;mossmana &quot;..conf.mossmana)
  else
    svo.sendcuring(&quot;mosshealth 0&quot;)
    svo.sendcuring(&quot;mossmana 0&quot;)
  end

end, 'update serverside moss use amount')

signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'clot') then return end

  if sk.canclot() and conf.clot and not sk.clotting_on_serverside then
    svo.sendcuring(&quot;clot on&quot;)
    sk.clotting_on_serverside = true
  elseif not (sk.canclot() and conf.clot) and sk.clotting_on_serverside then
    svo.sendcuring(&quot;clot off&quot;)
    sk.clotting_on_serverside = false
  end
end, 'update serverside clot')

-- healhealth / siphealth
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'siphealth') then return end

  if not serverignore.healhealth and sk.priochangecache.special.healhealth ~= 0 then
    svo.sendcuring(&quot;siphealth 0&quot;)
    sk.priochangecache.special.healhealth = 0
  elseif serverignore.healhealth and sk.priochangecache.special.healhealth ~= conf.siphealth then
    svo.sendcuring(&quot;siphealth &quot;..conf.siphealth)
    sk.priochangecache.special.healhealth = conf.siphealth
  end
end, 'update serverside siphealth')
signals[&quot;svo serverignore changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'healhealth') then return end

  if not serverignore.healhealth and sk.priochangecache.special.healhealth ~= 0 then
    svo.sendcuring(&quot;siphealth 0&quot;)
    sk.priochangecache.special.healhealth = 0
  elseif serverignore.healhealth and sk.priochangecache.special.healhealth ~= conf.siphealth then
    svo.sendcuring(&quot;siphealth &quot;..conf.siphealth)
    sk.priochangecache.special.healhealth = conf.siphealth
  end
end, 'update serverside healhealth')

-- healmana / sipmana
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'sipmana') then return end

  if not serverignore.healmana and sk.priochangecache.special.healmana ~= 0 then
    svo.sendcuring(&quot;sipmana 0&quot;)
    sk.priochangecache.special.healmana = 0
  elseif serverignore.healmana and sk.priochangecache.special.healmana ~= conf.sipmana then
    svo.sendcuring(&quot;sipmana &quot;..conf.sipmana)
    sk.priochangecache.special.healmana = conf.sipmana
  end
end, 'update serverside sipmana')
signals[&quot;svo serverignore changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'healmana') then return end

  if not serverignore.healmana and sk.priochangecache.special.healmana ~= 0 then
    svo.sendcuring(&quot;sipmana 0&quot;)
    sk.priochangecache.special.healmana = 0
  elseif serverignore.healmana and sk.priochangecache.special.healmana ~= conf.sipmana then
    svo.sendcuring(&quot;sipmana &quot;..conf.sipmana)
    sk.priochangecache.special.healmana = conf.sipmana
  end
end, 'update serverside sipmana')

-- bleedamount
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'bleedamount') then return end

  svo.sendcuring(&quot;clotat &quot;..conf.bleedamount)
end, 'update serverside clot amount')

-- manause
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'manause') then return end

  svo.sendcuring(&quot;manathreshold &quot;..conf.manause)
end, 'update serverside manathreshold')

-- curemethod
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'curemethod' and not svo.logging_in) then return end

  if conf.curemethod == 'transonly' then
    svo.sendcuring(&quot;transmutation on&quot;)
  elseif conf.curemethod == 'conconly' then
    svo.sendcuring(&quot;transmutation off&quot;)
  elseif conf.curemethod == 'prefertrans' then
    svo.sendcuring(&quot;transmutation on&quot;)
    svo.echof(&quot;Setting in-game curemethod to 'transmutation cures only', as serverside doesn't support mixed cures.&quot;)
  elseif conf.curemethod == 'preferconc' then
     svo.sendcuring(&quot;transmutation off&quot;)
     svo.echof(&quot;Setting in-game curemethod to 'concoctions cures only', as serverside doesn't support mixed cures.&quot;)
  end
end, 'update serverside curemethod')

-- pause
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'paused' and not svo.logging_in) then return end

  -- send right away, so chained commands are done in proper order
  if conf.paused then
    svo.force_send(&quot;curing off&quot;)
  else
    svo.force_send(&quot;curing on&quot;)
  end
end, 'update serverside curing pause')

-- keepup
signals[&quot;svo config changed&quot;]:connect(function(config)
  if not (conf.serverside and config == 'keepup' and not svo.logging_in) then return end

  if conf.keepup then
    svo.sendcuring(&quot;defences on&quot;)
  else
    svo.sendcuring(&quot;defences off&quot;)
  end
end, 'update serverside keepup')

signals[&quot;svo ignore changed&quot;]:connect(sk.handleserversideswitch, &quot;sk.handleserversideswitch&quot;)
signals[&quot;svo ignore changed&quot;]:connect(sk.handleserversideswitch_keepup, &quot;sk.handleserversideswitch_keepup&quot;)
signals[&quot;svo keepup changed&quot;]:connect(sk.handleserversideswitch, &quot;sk.handleserversideswitch&quot;)
signals[&quot;svo keepup changed&quot;]:connect(sk.handleserversideswitch_keepup, &quot;sk.handleserversideswitch_keepup&quot;)
signals[&quot;svo serverignore changed&quot;]:connect(sk.handleserversideswitch, &quot;sk.handleserversideswitch&quot;)
signals[&quot;svo serverignore changed&quot;]:connect(sk.handleserversideswitch_keepup, &quot;sk.handleserversideswitch_keepup&quot;)
signals[&quot;svo switched defence mode&quot;]:connect(sk.handleserversideswitch, &quot;sk.handleserversideswitch&quot;)
signals[&quot;svo done defup&quot;]:connect(sk.handleserversideswitch, &quot;sk.handleserversideswitch&quot;)

-- setup the block if serverside isn't on at load
signals[&quot;svo system loaded&quot;]:connect(function()
  if not conf.serverside then
    signals[&quot;svo ignore changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo ignore changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo keepup changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo keepup changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo serverignore changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo serverignore changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo switched defence mode&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo done defup&quot;]:block(sk.handleserversideswitch)
  end
end, 'disable serverside functions when not using serverside')

-- toggle appropriately upon vconfig changed
signals[&quot;svo config changed&quot;]:connect(function(config)
  if config ~= 'serverside' then return end

  if conf.serverside then
    signals[&quot;svo ignore changed&quot;]:unblock(sk.handleserversideswitch)
    signals[&quot;svo ignore changed&quot;]:unblock(sk.handleserversideswitch_keepup)
    signals[&quot;svo keepup changed&quot;]:unblock(sk.handleserversideswitch)
    signals[&quot;svo keepup changed&quot;]:unblock(sk.handleserversideswitch_keepup)
    signals[&quot;svo serverignore changed&quot;]:unblock(sk.handleserversideswitch)
    signals[&quot;svo serverignore changed&quot;]:unblock(sk.handleserversideswitch_keepup)
    signals[&quot;svo switched defence mode&quot;]:unblock(sk.handleserversideswitch)
    signals[&quot;svo done defup&quot;]:unblock(sk.handleserversideswitch)
  else
    signals[&quot;svo ignore changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo ignore changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo keepup changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo keepup changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo serverignore changed&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo serverignore changed&quot;]:block(sk.handleserversideswitch_keepup)
    signals[&quot;svo switched defence mode&quot;]:block(sk.handleserversideswitch)
    signals[&quot;svo done defup&quot;]:block(sk.handleserversideswitch)
  end
end, 'toggle serverside functions')


-- if we've got cadmus, and have one of the me.cadmusaffs afflictions, then we should focus
function sk.canfocus()
  -- check if we haven't got cadmus
  if not affs.cadmus then return true end

  -- if we do, and focus with cadmus is on, check if any of the affs we've got allow us to focus
  if conf.focuswithcadmus then
    -- iterate aff list, as that'll be smaller most of the time than cadmusaffs
    for aff in pairs(affs) do
      if me.cadmusaffs[aff] == true then return true end
    end
  end

  return false
end

function sk.togglefocusserver()
  if not (conf.serverside and sk.logged_in) then return end

  if sk.canfocus() and conf.focus and not sk.priochangecache.special.focustoggle then
    svo.sendcuring(&quot;focus on&quot;)
    sk.priochangecache.special.focustoggle = true
  elseif (not conf.focus or (conf.focus and not sk.canfocus())) and sk.priochangecache.special.focustoggle then
    svo.sendcuring(&quot;focus off&quot;)
    sk.priochangecache.special.focustoggle = false
  end
end
signals.svogotaff:connect(sk.togglefocusserver, &quot;sk.togglefocusserver&quot;)
-- use after prompt processing, not lost aff, so afflictions getting removed don't spam-toggle
signals.after_prompt_processing:connect(sk.togglefocusserver, &quot;sk.togglefocusserver&quot;)
signals[&quot;svo config changed&quot;]:connect(sk.togglefocusserver, &quot;sk.togglefocusserver&quot;)

function sk.canclot()
  if (affs.corrupted and stats.currenthealth &lt; sys.corruptedhealthmin) then
    return false
  else
    return true
  end
end

function sk.toggleclotserver()
  if not conf.serverside then return end

  if sk.canclot() and conf.clot and not sk.clotting_on_serverside then
    svo.sendcuring(&quot;clot on&quot;)
    sk.clotting_on_serverside = true
  elseif not (sk.canclot() and conf.clot) and sk.clotting_on_serverside then
    svo.sendcuring(&quot;clot off&quot;)
    sk.clotting_on_serverside = false
  end
end
-- use after prompt processing, not lost aff, so afflictions getting removed don't spam-toggle
signals.svogotaff:connect(sk.toggleclotserver, &quot;sk.toggleclotserver&quot;)
signals.after_prompt_processing:connect(sk.toggleclotserver, &quot;sk.toggleclotserver&quot;)


function sk.toggleinsomniaserver()
  if not (conf.serverside and sk.logged_in) then return end

  if conf.insomnia and not sk.priochangecache.special.insomniatoggle then
    svo.sendcuring(&quot;insomnia on&quot;)
    sk.priochangecache.special.insomniatoggle = true
  elseif not conf.insomnia and sk.priochangecache.special.insomniatoggle then
    svo.sendcuring(&quot;insomnia off&quot;)
    sk.priochangecache.special.insomniatoggle = false
  end
end
signals[&quot;svo config changed&quot;]:connect(sk.toggleinsomniaserver, &quot;sk.toggleinsomniaserver&quot;)

--


function svo.setupserverside()
  if not conf.serverside then return end

  svo.sendc(&quot;curingset new normal&quot;)
  svo.sendc(&quot;curingset new slowcuring&quot;)

  if svo.serversidesetup then killTimer(svo.serversidesetup) end
  svo.serversidesetup = tempTimer(5+svo.getping(), function()
    svo.serversidesetup = nil
  end)
end
signals.charname:connect(svo.setupserverside, &quot;svo.setupserverside&quot;)
signals.gmcpcharname:connect(svo.setupserverside, &quot;svo.setupserverside&quot;)

function svo.hitcuringsetlimit()
  if not svo.serversidesetup then return end

  if not svo.conf.serverside then return end

  echo(&quot;\n&quot;)
  svo.echofn(&quot;You don't have enough curingset slots to enable serverside use - Svof requires two. View your curingsets with &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(&quot;CURINGSET LIST&quot;, 'send&quot;curingset list&quot;', &quot;CURINGSET LIST&quot;, true)
  setUnderline(false)
  echo(&quot; and delete some with &quot;)
  setUnderline(true)
  echoLink(&quot;CURINGSET DELETE&quot;, 'printCmdLine&quot;curingset delete &quot;', &quot;CURINGSET DELETE&quot;, true)
  setUnderline(false)
  echo(&quot;.\n&quot;)

  svo.tntf_set('serverside', 'off', true)
end

function svo.hitaliaslimit()
  if not svo.serversidesetup then return end

  if not svo.conf.serverside then return end

  echo(&quot;\n&quot;)
  svo.echofn(&quot;You haven't got enough space for Svof's two serverside aliases - view list with &quot;)
  setFgColor(unpack(svo.getDefaultColorNums))
  setUnderline(true)
  echoLink(&quot;ALIAS LIST&quot;, 'send&quot;alias list&quot;', &quot;ALIAS LIST&quot;, true)
  setUnderline(false)
  echo(&quot; and delete some with &quot;)
  setUnderline(true)
  echoLink('CLEARALIAS', 'printCmdLine&quot;clearalias &quot;', 'CLEARALIAS', true)
  setUnderline(false)
  echo(&quot;.\n&quot;)

  svo.tntf_set('serverside', 'off', true)
end
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Peopletracker</name>
                    <packageName></packageName>
                    <script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.


--[[
things to optimize: only do label updates on prompt
handling multiple rooms ideas:
 * draw a far-away label saying &quot;also in area at '%s': blah, blah&quot;
   -&gt; can't work yet, because calculating a possible location would be a pain
 * put names in every room
   -&gt; looks ugly in this combination: http://img7.imagebanana.com/img/oshg8lw5/Selection_037.png
 * label by single letters for groups, with only the rightmost room having the full list of names with letter) prepended
]]

local sys, signals = svo.sys, svo.signals
local conf, sk = svo.conf, svo.sk

-- area = {labels}
local labels = {}

-- default to numerals when we run out
-- while defining this as a function would be nicer, it's easier for most people to mod if it's in this format
local multiplegroups = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}

conf.peopletracker = type(conf.peopletracker) == 'nil' and true or conf.peopletracker
svo.config.setoption('peopletracker', {
  type = 'boolean',
  onenabled = function ()
    if not deleteMapLabel or not createMapLabel then
      svo.echof(&quot;I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!&quot;)
      conf.peopletracker = false
      raiseEvent(&quot;svo config changed&quot;, 'peopletracker')
      return
    end

    svo.echof(&quot;People tracker &lt;0,250,0&gt;enabled%s.&quot;, svo.getDefaultColor())
  end,
  ondisabled = function () sys.clean_old_labels() svo.echof(&quot;People tracker &lt;250,0,0&gt;disabled%s.&quot;, svo.getDefaultColor()) end,
  installstart = function () conf.peopletracker = true end,
})

conf.clearlabels = type(conf.clearlabels) == 'nil' and true or conf.clearlabels
svo.config.setoption('clearlabels', {
  type = 'boolean',
  onenabled = function ()
    signals.newarea:connect(sys.clear_labels, 'clear labels on new area')
    svo.echof(&quot;&lt;0,250,0&gt;Will%s automatically clear map labels that are surrounded by ().&quot;, svo.getDefaultColor())
  end,
  ondisabled = function ()
    signals.newarea:disconnect(sys.clear_labels)
    svo.echof(&quot;&lt;250,0,0&gt;Won't%s automatically clear map labels that are surrounded by ().&quot;, svo.getDefaultColor())
  end,
  installstart = function () conf.clearlabels = true end,
})

conf.labelsfont = type(conf.labelsfont) == 'nil' and 10 or conf.labelsfont
svo.config.setoption('labelsfont', {
  type = 'number',
  onset = function () sys.update_people_labels() svo.echof(&quot;Labels set to draw at %dpt.&quot;, conf.labelsfont) end,
  installstart = function () conf.labelsfont = 10 end,
})

conf.labelcolor = conf.labelcolor or 'white'
conf.maxdupes = conf.maxdupes or 20
svo.config.setoption('labelcolor', {
  type = 'string',
  vconfig2string = true,
  check = function (what)
    if color_table[what] then return true end
  end,
  onshow = function (defaultcolour)
    fg('gold')
    echoLink(&quot;ppl: &quot;, &quot;&quot;, &quot;svo People Tracker&quot;, true)
    fg(defaultcolour) echo(&quot;People tracker &quot;)
    fg('a_cyan') echoLink((conf.peopletracker and 'on' or 'off'), &quot;svo.config.set('peopletracker', &quot;..(conf.peopletracker and 'false' or 'true')..&quot;, true)&quot;, &quot;Click to &quot;..(conf.peopletracker and 'disable' or 'enable')..&quot; people tracking on the map&quot;, true)
    fg(defaultcolour) echo(&quot;; using&quot;)
    fg(conf.labelcolor or 'a_cyan') echoLink(&quot; &quot;..(conf.labelcolor or '?'), &quot;printCmdLine'vconfig labelcolor '&quot;, &quot;Click to change the color&quot;, true)
    fg(defaultcolour) echo(&quot; map labels (&quot;)
    fg('a_cyan') echoLink(&quot;view all&quot;, &quot;showColors()&quot;, &quot;Click to view possible color names that you can use for customizing the label colors&quot;, true)
    fg(defaultcolour)
    echo(&quot;); font size is &quot;)
    fg('a_cyan') echoLink(tostring(conf.labelsfont), &quot;printCmdLine'vconfig labelsfont '&quot;, &quot;Click to set the font size for peopletracker labels&quot;, true)
    echo(&quot;.\n&quot;)
  end,
  onset = function ()
    local r,g,b = unpack(color_table[conf.labelcolor])
    sys.update_people_labels()
    svo.echof(&quot;Okay, will color the map labels in &lt;%s,%s,%s&gt;%s%s now.&quot;, r,g,b, conf.labelcolor, svo.getDefaultColor())
  end,
  installstart = function ()
    conf.labelcolor = 'blue'
  end
})

-- check for old Mudlet versions
if not deleteMapLabel or not createMapLabel then
  svo.echof(&quot;I'm sorry, but your Mudlet is too old and can't make labels on the map yet - update it!&quot;)
  return
end

sys.clean_old_labels = function()
  for areanum, arealabels in pairs(labels) do
    for _, label in pairs(arealabels) do
      deleteMapLabel(areanum, label)
    end
  end
  labels = {}
end
signals.sysexitevent:connect(sys.clean_old_labels, 'cleanup old labels on Mudlet quit')

sys.clear_labels = function()
  if not mmp then return end
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= 'table' then return end

    local starts, ends = string.starts, string.ends
    for labelid, text in pairs(t) do
      if starts(text, '(') and ends(text, ')') then
        deleteMapLabel(areaid, labelid)
      end
    end
  end

  for areaid in pairs(mmp.areatabler or {}) do
    clearlabels(areaid)
  end
end

if conf.clearlabels then
  signals.newarea:connect(sys.clear_labels, 'clear labels on new area')
end

sys.update_people_labels = function ()
  -- drawwatch = drawwatch or createStopWatch()
  -- startStopWatch(drawwatch)

  local s,m = pcall(function()
    if not mmp then return end
    -- build a 'location = people' reverse map
    local r = {}
    -- keeps track at which index of multiplegroups are we at
    local multiplescount = 1

    local fr,fg,fb = unpack(color_table[conf.labelcolor or 'white'])
    local br,bg,bb = unpack(color_table.black)

    for k,v in pairs(mmp.pdb) do
      if mmp.pdb_lastupdate[k] then
        r[v] = r[v] or {}; r[v][#r[v]+1] = k
      end
    end

    sys.clean_old_labels()
    if not conf.peopletracker or not mmp.pdb_lastupdate or not mmp.roomexists(mmp.currentroom) then return end

    local getRoomArea, createMapLabel, getRoomCoordinates, concat, sort = getRoomArea, createMapLabel, getRoomCoordinates, table.concat, table.sort

    -- if we have a unique location, draw fancy labels in all rooms on 60% opacity
    for room, persons in pairs(r) do
      sort(persons)
      local ids = mmp.getnums(room, true)

      -- multiples? special case then. Current method implemented is #3
      if ids and #ids &gt;1 and #ids &lt;= conf.maxdupes then
        -- make a table of roomid = {x,y,z}
        -- in a separate variable, track the right-most room ID and x coordinate per-Z level
        local coords, rightmost = {}, {}
        for _, exactroomid in pairs(ids) do
          coords[exactroomid] = {getRoomCoordinates(exactroomid)}
          coords[exactroomid][4] = getRoomArea(exactroomid)

          if not rightmost[coords[exactroomid][3]] or
            coords[exactroomid][1] &gt;= rightmost[coords[exactroomid][3]][1] then -- &gt;= so rightmostroom is set at least once

            rightmost[coords[exactroomid][3]] =
              {coords[exactroomid][1], exactroomid} -- we don't account for the Y coordinate if the X's are the same atm, though
          end
        end

        -- now, draw!
        for roomid, l in pairs(coords) do
          local area = l[4]
          labels[area] = labels[area] or {}

          if rightmost[l[3]] and roomid == rightmost[l[3]][2] then
            -- doesn't account for multiplescount overflowing atm
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount]..&quot; &quot;..concat(persons, &quot;, &quot;)..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          else
            labels[area][#labels[area]+1] = createMapLabel(area, '('..multiplegroups[multiplescount]..')', l[1],l[2],l[3], fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
          end
        end
        multiplescount = multiplescount +1

      elseif ids and #ids == 1 then
        local x,y,z = getRoomCoordinates(ids[1])
        local area = getRoomArea(ids[1])

        if area then -- somehow area can still be returned as nil
          labels[area] = labels[area] or {}

          labels[area][#labels[area]+1] = createMapLabel(area, '('..concat(persons, &quot;, &quot;)..')', x,y,z, fr, fg, fb, br, bg, bb, 0,conf.labelsfont)
        end
      end
    end
  end)

  if not s then
    echoLink(&quot;(e!)&quot;, string.format(&quot;echo([=[The problem was: %q]=])&quot;, m), 'Oy - there was a problem with the peopletracker. Click on this link and submit a bug report with what it says.')
  end

  -- svo.echof(&quot;update took %s&quot;, stopStopWatch(drawwatch))
end

signals[&quot;mmapper updated pdb&quot;]:connect(function()
  if isPrompt() then
    sys.update_people_labels()
  else
    sk.onprompt_beforeaction_add('update_labels', sys.update_people_labels)
  end
end, 'update labels on new pdb update')

signals.quit:connect(sys.clean_old_labels, 'cleanup old labels on system start')
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>System loaded</name>
                    <packageName></packageName>
                    <script>if svo.systemloaded then return end

svo.signals.systemstart:emit()
svo.systemloaded = true
raiseEvent(&quot;svo system loaded&quot;)

svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.pathurs.com/homepage.php&quot;', &quot;Svof homepage&quot;)
decho(svo.getDefaultColor()..&quot;)\n&quot;)</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Event handlers</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>svo_events</name>
                    <packageName></packageName>
                    <script>function svo_events(...)
	local s,m = pcall(svo.events, ...)
	if not s then display(m) end
end</script>
                    <eventHandlerList>
                        <string>CharVitals</string>
                        <string>CharName</string>
                        <string>RoomNum</string>
                        <string>RoomBrief</string>
                        <string>sysDataSendRequest</string>
                        <string>sysExitEvent</string>
                        <string>mmapper updated pdb</string>
                        <string>svo lost balance</string>
                        <string>svo got balance</string>
                        <string>svo prio changed</string>
                        <string>svo system loaded</string>
                        <string>svo config changed</string>
                        <string>svo serverignore changed</string>
                        <string>svo ignore changed</string>
                        <string>svo defup changed</string>
                        <string>svo keepup changed</string>
                        <string>svo switched defence mode</string>
                        <string>svo done defup</string>
                        <string>NameDB finished honors</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo_gevents</name>
                    <packageName></packageName>
                    <script>function svo_gevents(...)
	local s,m = pcall(svo.gevents, ...)
	if not s then display(m) end
end</script>
                    <eventHandlerList>
                        <string>gmcp.Char</string>
                        <string>gmcp.Room</string>
                        <string>gmcp.Char.Status</string>
                        <string>gmcp.IRE.Time</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo_savesettings</name>
                    <packageName></packageName>
                    <script>svo_savesettings = svo.savesettings</script>
                    <eventHandlerList>
                        <string>sysExitEvent</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo Utilities</name>
                <packageName></packageName>
                <script>function svo.inslowcuringmode()
	return (svo.affl.retardation or svo.affl.aeon) and true or false
end

-- originally from Sidd, improved by Lynara
function svo.boxDisplay(msg, color)
    deselect()
    local colTbl = {}
    if color then
       colTbl = string.split(color, &quot;:&quot;)
       for k = 1,2 do
          if colTbl[k] == &quot;&quot; then
             colTbl[k] = nil
          end
       end
       if colTbl[2] then
          bg(colTbl[2])
       end
    end
    colTbl[1] = colTbl[1] or &quot;red&quot;
    fg(colTbl[1])
	local leng = ((2*string.len(msg)) + 11)
	local mes = string.upper(msg)
	echo(&quot;\n &quot;)
    echo( string.rep(&quot;-&quot;, leng+2) )
    echo(&quot; \n|     &quot; .. mes .. &quot; | &quot; .. mes .. &quot;     |\n &quot;)
    echo( string.rep(&quot;-&quot;, leng+2) )
    echo(&quot; \n&quot;)
    resetFormat()
end

function svo.preattack()
  if svo.inslowcuringmode() then return end

  if svo.affl.prone then send'stand' end
end

function mapper_can_move()
  return (svo.bals.balance and svo.bals.equilibrium and svo.bals.rightarm and svo.bals.leftarm) and true or false
end

function svo.echotime(s, sameline)
  if not sameline then moveCursor(0, getLineNumber()-1) end
  moveCursor(#getCurrentLine(), getLineNumber())

  fg(&quot;dark_slate_gray&quot;)
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

function svo.echoafftime(s, aff)
  if aff == &quot;bleeding&quot; and svo.conf.gagclot then return end

  if isPrompt() then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
  end

  deselect()
  fg(&quot;DarkGoldenrod&quot;)
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

local function docc(...)
  local sendto, method
  if not svo.conf.ccto or svo.conf.ccto == 'pt' then sendto = &quot;pt &quot;
  elseif svo.conf.ccto == 'clt' then sendto = &quot;clt &quot;
  elseif svo.conf.ccto:find(&quot;^tell %w+&quot;) then sendto = &quot;tell &quot;..svo.conf.ccto:match(&quot;^tell (%w+)&quot;)..&quot; &quot;
  elseif svo.conf.ccto == 'ot' then sendto = &quot;ot &quot;
  elseif svo.conf.ccto == 'army' then sendto = &quot;art &quot;
  elseif svo.conf.ccto == 'team' then sendto = &quot;team &quot;
  elseif svo.conf.ccto == 'echo' then method = svo.echof; sendto = &quot;&quot;
  else sendto = &quot;clan &quot;..svo.conf.ccto..&quot; tell &quot; end

  if not method then
    send(sendto .. string.format(...), false)
  else
    (method)(sendto .. string.format(...))
  end
end

function svo.ccnop(...)
  if svo.inslowcuringmode() then return end

  docc(...)
end

function svo.cc(...)
  if svo.conf.paused or svo.inslowcuringmode() then return end

  docc(...)
end

-- credit to: http://hci.iastate.edu/~rpavlik/downloads/vrjugglua/snapshot/share/vrjugglua/lua/string_ext.lua
function string.ordinalSuffix(n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return &quot;st&quot;
  elseif d == 2 and n ~= 12 then
    return &quot;nd&quot;
  elseif d == 3 and n ~= 13 then
    return &quot;rd&quot;
  else
    return &quot;th&quot;
  end
end

function svo.shipprompt()
--  selectCurrentLine() fg(&quot;chartreuse&quot;) deselect() resetFormat()

  svo.me.shippromptn = getLineCount()
end

-- shows memory use by Lua objects only
svo.adddefinition(&quot;@mem&quot;, &quot;string.format('%0.2f', collectgarbage('count')/1024)&quot;)

function svo.doubleRunToSend(...)
  local doubleClick = .4
  if not DoubleRunTimer then
    DoubleRunTimer = tempTimer(doubleClick,[[killTimer(DoubleRunTimer)
      DoubleRunTimer = nil
      DoubleRunCounter = nil
    ]])
  end
  if DoubleRunCounter then
    DoubleRunCounter = DoubleRunCounter + 1
  else
    DoubleRunCounter = 0
  end
  if DoubleRunCounter == 1 then
    sendAll({...})
  end
end

-- returns a list of affs that focus can get
function svo.getfocusableaffs()
  return table.n_intersection(svo.keystolist(svo.affl), svo.focuscurables)
end

-- starts the stopwatch which measures how long a balance was missing for
function svo.startbalancewatch(balance)
  svo.watch[&quot;bal_&quot;..balance] = svo.watch[&quot;bal_&quot;..balance] or createStopWatch()
  startStopWatch(svo.watch[&quot;bal_&quot;..balance])
end

function svo.endbalancewatch(balance, sameline)
  if svo.watch[&quot;bal_&quot;..balance] then
    local s = stopStopWatch(svo.watch[&quot;bal_&quot;..balance])
    svo.stats[&quot;last&quot;..balance] = s
    if svo.conf.showbaltimes then svo.echotime(s, sameline) end
  end
end

function svo.countbrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm then c = c + 1 end
  if affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm then c = c + 1 end
  if affs.crippledleftleg or affs.mangledleftleg or affs.mutilatedleftleg then c = c + 1 end
  if affs.crippledrightleg or affs.mangledrightleg or affs.mutilatedrightleg then c = c + 1 end

  return c
end

function svo.countonlybrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm then c = c + 1 end
  if affs.crippledrightarm then c = c + 1 end
  if affs.crippledleftleg then c = c + 1 end
  if affs.crippledrightleg then c = c + 1 end
  return c
end

function svo.havefractures()
  local affs = svo.affl

  return affs.crackedribs or affs.skullfractures or affs.torntendons or affs.wristfractures
end</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Tree curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.tree.blackout = {
  desc = &quot;Use tree to cure blackout&quot;,

  function () return svo.affl.blackout and not svo.ignore.blackout end
}

svo.tree.aeon = {
  desc = &quot;Use tree to cure aeon when we have asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.tree.hardlock = {
  desc = &quot;Use tree to cure hard locks (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()

    return svo.me.locks.hard
  end
}

-- touch tree if we have 3+ limbs damaged and at least one of them is curable with tree
svo.tree.maybevivi = {
  desc = &quot;Use tree in a situation when you might get vivisected&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}

svo.tree.crippledandprone = {
  desc = &quot;Use tree if prone and both legs are crippled&quot;,

  function ()
    local affs = svo.affl

    return (affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      and (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg)) and (affs.prone or not svo.bals.salve)
  end
}

svo.tree.getupfaster = {
  desc = &quot;Use tree if prone, off salve balance, and a leg is crippled&quot;,

  function ()
    local affs = svo.affl

    return ((affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      or (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg))) and affs.prone and not svo.bals.salve
  end
}

svo.tree.curearmsfaster = {
  desc = &quot;Use tree if both arms are crippled and you're off salve balance&quot;,

  function ()
    local affs = svo.affl

    return ((affs.crippledleftarm and not (affs.mangledleftarm or affs.mutilatedleftarm)) or (affs.crippledrightarm and not (affs.mangledrightarm or affs.mutilatedrightarm))) and not svo.bals.salve
  end
}

svo.tree.novoyriacure = {
  desc = &quot;Use tree when you have voyria and no immunity/antigen for it&quot;,

  function ()
    return (svo.affl.voyria and ((svo.es_potions.elixir and svo.es_potions.elixir[&quot;an elixir of immunity&quot;] and svo.es_potions.elixir[&quot;an elixir of immunity&quot;].sips &lt;= 1)
      and (svo.es_potions.tonic and svo.es_potions.tonic[&quot;a tonic of antigen&quot;] and svo.es_potions.tonic[&quot;a tonic of antigen&quot;].sips &lt;= 1))
    )
  end
}

svo.tree.any2affs = {
  desc = &quot;Use tree when we've got at least two tree-curable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.tree.any3affs = {
  desc = &quot;Use tree when we've got at least three tree-curable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

svo.tree.fractures = {
  desc = &quot;Use tree you're got a fracture and are off sip balance&quot;,

  function ()
    return not svo.bals.sip and svo.havefractures()
  end
}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Restore curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

--[[svo.restore.anylimb = {
  desc = &quot;Use restore if any limb is crippled (useful for bashing without mending, for example)&quot;,
  function () return svo.affl.crippledleftleg or svo.affl.crippledrightleg
    or svo.affl.crippledrightarm or svo.affl.crippledleftarm
  end
}]]

svo.restore.anyoneortwolimbs = {
  desc = &quot;Use restore if one or two limbs are crippled (and no more), and you're off salve/tree balance&quot;,

  function ()
    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}


svo.restore.anyoneortwolimbsprone = {
  desc = &quot;Use restore if one or two limbs are crippled (and no more), prone, and you're off salve/tree balance&quot;,

  function ()
    if not svo.affl.prone then return false end

    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}

svo.restore.riftlock = {
  desc = &quot;Use restore on riftlocks&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}


svo.restore.stainlock = {
  desc = &quot;Use restore to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()
    return svo.me.locks.stain and (affs.crippledleftarm or affs.crippledrightarm) -- don't restore if we can't restore anything useful.
  end
}

-- restore if we have 3+ limbs damaged and at least one of them is curable with restore
svo.restore.maybevivi = {
  desc = &quot;Use restore if you have 3+ limbs damaged and at least one of them is curable with restore&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}
</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Dragonheal curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.dragonheal.riftlock = {
  desc = &quot;Use dragonheal on riftlocks&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.dragonheal.aeon = {
  desc = &quot;Use dragonheal to cure aeon when we have asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.dragonheal.hardlock = {
  desc = &quot;Use dragonheal to cure hard locks (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()

    return svo.me.locks.hard
  end
}

svo.dragonheal.stainlock = {
  desc = &quot;Use dragonheal to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()

    return svo.me.locks.stain
  end
}

-- dragonheal if we have 3+ limbs damaged and at least one of them is curable with dragonheal
svo.dragonheal.maybevivi = {
  desc = &quot;Use dragonheal in a situation when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with dragonheal&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Shrugging curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

-- desc should should assume it starts with 'Scenarios to use shrugging in:'
svo.shrugging.riftlock = {
  desc = &quot;when you're riftlocked&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.shrugging.aeon = {
  desc = &quot;when we have aeon with asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.shrugging.hardlock = {
  desc = &quot;when we have a hard lock (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()
    return svo.me.locks.hard
  end
}

svo.shrugging.stainlock = {
  desc = &quot;when we have a stain lock (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()
    return svo.me.locks.stain
  end
}

svo.shrugging.any2affs = {
  desc = &quot;when we've got at least two shruggable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.shrugging.any3affs = {
  desc = &quot;when we've got at least three shruggable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

-- shrugging if we have 3+ limbs damaged and at least one of them is curable with shrugging
svo.shrugging.maybevivi = {
  desc = &quot;when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with shrugging&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Rage curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.rage.any2affs = {
  desc = &quot;Use rage when we've got at least two afflictions and one of them is rage-curable&quot;,

  function ()
    return table.size(svo.affl) &gt;= 2
  end
}

svo.rage.any3affs = {
  desc = &quot;Use rage when we've got at least three afflictions and one of them is rage-curable&quot;,

  function ()
    return table.size(svo.affl) &gt;= 3
  end
}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Fitness curing strats</name>
                    <packageName></packageName>
                    <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.fitness.anylock = {
  desc = &quot;Use fitness if we've got any locks we can use fitness to cure out of&quot;,

  function ()
    return (svo.me.locks.soft and not svo.doing&quot;focus&quot;) or svo.me.locks.venom or svo.me.locks.hard or
            svo.me.locks.rift or svo.me.locks[&quot;rift 2&quot;] or svo.me.locks.slow or svo.me.locks[&quot;true&quot;]
  end
}

svo.fitness.asthmainaeon = {
  desc = &quot;Use fitness if we've got asthma in aeon&quot;,

  function ()
    return svo.affl.asthma and svo.affl.aeon
  end
}

svo.fitness.hellsightconc = {
  desc = &quot;Use fitness if we've got hellsight and a concussion&quot;,

  function ()
    return svo.affl.hellsight and (svo.affl.mildconcussion or svo.affl.seriousconcussion)
  end
}</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo.isenemy</name>
                    <packageName></packageName>
                    <script>function svo.isenemy(name)
  return (target and target:lower():starts(name:lower())) or ndb.isenemy(name)
end</script>
                    <eventHandlerList/>
                </Script>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>Custom prompt tags</name>
                    <packageName></packageName>
                    <script></script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>@affs</name>
                        <packageName></packageName>
                        <script>--[[ Iocuns prompt aff thingy from http://forums.achaea.com/index.php?showtopic=39543&amp;view=findpost&amp;p=1283964, taken with permission ]]
--[[ to use in a custom prompt, use the @paracelsus_affs_customtag tag ]]
--[[ this is now used by default in Svo ]]
local aff_abbrev = {
  ablaze              = &quot;abl&quot;,
  addiction           = &quot;add&quot;,
  aeon                = &quot;ae&quot;,
  agoraphobia         = &quot;agor&quot;,
  airdisrupt          = &quot;adsr&quot;,
  anorexia            = &quot;ano&quot;,
  asleep              = &quot;asl&quot;,
  asthma              = &quot;ast&quot;,
  blackout            = &quot;&quot;,
  bleeding            = &quot;bld&quot;,
  blindaff            = &quot;blind&quot;,
  bound               = &quot;bound&quot;,
  burning             = &quot;burn&quot;,
  charredburn         = &quot;4burn&quot;,
  cholerichumour      = &quot;choH&quot;,
  claustrophobia      = &quot;clau&quot;,
  clumsiness          = &quot;cl&quot;,
  confusion           = &quot;con&quot;,
  corrupted           = &quot;corr&quot;,
  crackedribs         = &quot;cr&quot;,
  crippledleftarm     = &quot;la1&quot;,
  crippledleftleg     = &quot;ll1&quot;,
  crippledrightarm    = &quot;ra1&quot;,
  crippledrightleg    = &quot;rl1&quot;,
  darkshade           = &quot;dark&quot;,
  deadening           = &quot;dea&quot;,
  deafaff             = &quot;deaf&quot;,
  degenerate          = &quot;deg&quot;,
  dehydrated          = &quot;deh&quot;,
  dementia            = &quot;dem&quot;,
  depression          = &quot;dep&quot;,
  deteriorate         = &quot;det&quot;,
  disloyalty          = &quot;disl&quot;,
  disrupt             = &quot;disr&quot;,
  dissonance          = &quot;disso&quot;,
  dizziness           = &quot;diz&quot;,
  earthdisrupt        = &quot;edsr&quot;,
  epilepsy            = &quot;epi&quot;,
  extremeburn         = &quot;3burn&quot;,
  fear                = &quot;fear&quot;,
  firedisrupt         = &quot;fdsr&quot;,
  frozen              = &quot;frz&quot;,
  generosity          = &quot;gen&quot;,
  haemophilia         = &quot;haem&quot;,
  hallucinations      = &quot;hall&quot;,
  hamstring           = &quot;hms&quot;,
  hatred              = &quot;htr&quot;,
  healthleech         = &quot;hthl&quot;,
  heartseed           = &quot;heart&quot;,
  hellsight           = &quot;hell&quot;,
  hypersomnia         = &quot;hypers&quot;,
  hypochondria        = &quot;hypoch&quot;,
  icing               = &quot;ice&quot;,
  illness             = &quot;ill&quot;,
  impaled             = &quot;impale&quot;,
  impatience          = &quot;impat&quot;,
  justice             = &quot;just&quot;,
  laceratedthroat     = &quot;lac2&quot;,
  lethargy            = &quot;let&quot;,
  loneliness          = &quot;lon&quot;,
  lovers              = &quot;lust&quot;,
  madness             = &quot;mad&quot;,
  mangledleftarm      = &quot;la2&quot;,
  mangledleftleg      = &quot;ll2&quot;,
  mangledrightarm     = &quot;ra2&quot;,
  mangledrightleg     = &quot;rl2&quot;,
  masochism           = &quot;maso&quot;,
  melancholichumour   = &quot;melaH&quot;,
  meltingburn         = &quot;5burn&quot;,
  mildconcussion      = &quot;h1&quot;,
  mildtrauma          = &quot;t1&quot;,
  mutilatedleftarm    = &quot;la3&quot;,
  mutilatedleftleg    = &quot;ll3&quot;,
  mutilatedrightarm   = &quot;ra3&quot;,
  mutilatedrightleg   = &quot;rl3&quot;,
  nausea              = &quot;nau&quot;,
  ninkharsag          = &quot;nkh&quot;,
  numbedleftarm       = &quot;nbla&quot;,
  numbedrightarm      = &quot;nbra&quot;,
  pacifism            = &quot;pac&quot;,
  paradox             = &quot;para&quot;,
  paralysis           = &quot;par&quot;,
  paranoia            = &quot;prn&quot;,
  parasite            = &quot;prs&quot;,
  peace               = &quot;pea&quot;,
  phlegmatichumour    = &quot;phleH&quot;,
  phlogistication     = &quot;phlog&quot;,
  pinshot             = &quot;psh&quot;,
  prone               = &quot;pr&quot;,
  recklessness        = &quot;reck&quot;,
  relapsing           = &quot;scy&quot;,
  retardation         = &quot;ret&quot;,
  retribution         = &quot;reb&quot;,
  roped               = &quot;rop&quot;,
  sanguinehumour      = &quot;sanH&quot;,
  selarnia            = &quot;sel&quot;,
  sensitivity         = &quot;sen&quot;,
  seriousconcussion   = &quot;h2&quot;,
  serioustrauma       = &quot;t2&quot;,
  severeburn          = &quot;2burn&quot;,
  shadowmadness       = &quot;sham&quot;,
  shivering           = &quot;shiv&quot;,
  shyness             = &quot;shy&quot;,
  skullfractures      = &quot;sf&quot;,
  slashedthroat       = &quot;lac1&quot;,
  slickness           = &quot;sli&quot;,
  spiritdisrupt       = &quot;sdsr&quot;,
  stain               = &quot;sta&quot;,
  stupidity           = &quot;st&quot;,
  stuttering          = &quot;stut&quot;,
  swellskin           = &quot;swsk&quot;,
  timeflux            = &quot;tfx&quot;,
  timeloop            = &quot;tlp&quot;,
  torntendons         = &quot;tt&quot;,
  transfixed          = &quot;transf&quot;,
  unconsciousness     = &quot;unconc&quot;,
  unknownany          = &quot;?&quot;,
  unknowncrippledarm  = &quot;uwna&quot;,
  unknowncrippledleg  = &quot;uwnl&quot;,
  unknowncrippledlimb = &quot;uwcrip&quot;,
  unknowncure         = &quot;uc&quot;,
  unknownmental       = &quot;?&quot;,
  vertigo             = &quot;vert&quot;,
  vitrification       = &quot;vitri&quot;,
  voided              = &quot;void&quot;,
  voyria              = &quot;voy&quot;,
  waterdisrupt        = &quot;wdsr&quot;,
  weakness            = &quot;wea&quot;,
  webbed              = &quot;web&quot;,
  wristfractures      = &quot;wf&quot;,
}

-- recoded, it's quicker by a third
function paracelsus_affs_customtag2()
  if next(svo.affl) then
    local s, type = {}, type
    for k,v in pairs(svo.affl) do
        if (k == &quot;unknownany&quot; or k == &quot;unknownmental&quot;) and (type(v) == 'table') then
          s[#s+1] = (&quot;?&quot;):rep(v.count)
        elseif k == &quot;bleeding&quot; and type(v) == 'table' then
          if v.count &gt;= svo.conf.bleedamount then
            s[#s+1] = string.format(&quot;bld(%d)&quot;, v.count)
          end
       elseif k == &quot;lovers&quot; and type(v) == 'table' then
          s[#s+1] = string.format(&quot;lust(%s)&quot;, svo.oneconcat(svo.affl.lovers.names))
        elseif type(v) == 'table' and v.count then
          s[#s+1] = (aff_abbrev[k] or k)..'('..v.count..')'
        else
          s[#s+1] = (aff_abbrev[k] or k)
        end
    end
    return #s &gt; 0 and (&quot;&lt;IndianRed&gt;[&quot;..table.concat(s, &quot; &quot;)..&quot;]&quot;) or &quot;&quot; -- don't display just [] b/c of bleeding
  else
    return &quot;&quot;
  end
end

svo.adddefinition(&quot;@paracelsus_affs_customtag&quot;, &quot;paracelsus_affs_customtag2()&quot;)
svo.adddefinition(&quot;@affs&quot;, &quot;paracelsus_affs_customtag2()&quot;)

svo.adddefinition(&quot;@target&quot;, &quot;target&quot;)</script>
                        <eventHandlerList/>
                    </Script>
                    <Script isActive="yes" isFolder="no">
                        <name>@exits</name>
                        <packageName></packageName>
                        <script>function svo.cpp.show_exits()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return &quot;&quot; end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, &quot;|&quot;)
end

svo.adddefinition(&quot;@exits&quot;, &quot;svo.cpp.show_exits()&quot;)

function svo.cpp.show_exits_caps()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return &quot;&quot; end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, &quot;|&quot;):upper()
end

svo.adddefinition(&quot;@EXITS&quot;, &quot;svo.cpp.show_exits_caps()&quot;)</script>
                        <eventHandlerList/>
                    </Script>
                </ScriptGroup>
                <Script isActive="yes" isFolder="no">
                    <name>svo_autoslickprio</name>
                    <packageName></packageName>
                    <script>function svo_autoslickprio(_, balance)
  if not svo.conf.autoslick then return end
  if balance ~= 'herb' then return end
  if not (svo.affl.slickness and svo.affl.asthma) and not svo.swapped_asthma then return end

  -- see if we need to swap it back
  if svo.swapped_asthma then
    if not svo.affl.slickness or not svo.affl.asthma then
      -- all good now? undo change
      svo.prio_swap(&quot;asthma&quot;, &quot;herb&quot;, svo.swapped_asthma)
      svo.swapped_asthma = nil
      echo'\n' svo.echof(&quot;Swapped asthma priority back down.&quot;)
      return
    end
  end

  -- don't have any more affs than this? Then asthma will get cured, so we're fine
  if table.size(svo.affl) &lt;= 2 then return end

  local asthma_prio = svo.prio.getnumber(&quot;asthma&quot;, &quot;herb&quot;)
  local paralysis_prio = svo.prio.getnumber(&quot;paralysis&quot;, &quot;herb&quot;)
  local impatience_prio = svo.prio.getnumber(&quot;impatience&quot;, &quot;herb&quot;)

  -- see if it's not highest
  if asthma_prio &gt; paralysis_prio and asthma_prio &gt; impatience_prio then return end

  local currentmax = svo.prio.gethighest(&quot;herb&quot;)

  svo.prio_swap(&quot;asthma&quot;, &quot;herb&quot;, currentmax+1)
  svo.swapped_asthma = asthma_prio
  echo'\n' svo.echof(&quot;emergency - have asthma+slickness and paralysis/impatience prio is before asthma: swapping asthma to be cured first.&quot;)
end</script>
                    <eventHandlerList>
                        <string>svo got balance</string>
                        <string>svo lost aff</string>
                        <string>svo got aff</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo_onimportant_aff</name>
                    <packageName></packageName>
                    <script>local bigboxaffs = {&quot;serioustrauma&quot;, &quot;mildtrauma&quot;, &quot;mildconcussion&quot;, &quot;seriousconcussion&quot;, &quot;mutilatedleftarm&quot;, &quot;mutilatedleftleg&quot;, &quot;mutilatedrightarm&quot;, &quot;mutilatedrightleg&quot;, &quot;mangledleftarm&quot;, &quot;mangledleftleg&quot;, &quot;mangledrightarm&quot;, &quot;mangledrightleg&quot;}
local bigboxaffs_t = {}; for i = 1, #bigboxaffs do bigboxaffs_t[bigboxaffs[i]] = true end

function svo_onimportant_aff(_, which)
  if bigboxaffs_t[which] then
    svo.boxDisplay(&quot;afflicted w/ &quot;..which, &quot;black:DarkOrange&quot;)
  end
end</script>
                    <eventHandlerList>
                        <string>svo got aff</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo.autopause_on_def</name>
                    <packageName></packageName>
                    <script>function svo.autopause_on_def(event, def)
  if (def == &quot;blackwind&quot; or def == &quot;astralform&quot;) and event == &quot;svo got def&quot; then
    if svo.conf.paused then svo.dont_unpause_for_bw = true
    else svo.app(&quot;on&quot;) end
  elseif (def == &quot;blackwind&quot; or def == &quot;astralform&quot;) and event == &quot;svo lost def&quot; then
    if not svo.dont_unpause_for_bw then svo.app(&quot;off&quot;) end
    svo.dont_unpause_for_bw = nil
  end
end</script>
                    <eventHandlerList>
                        <string>svo got def</string>
                        <string>svo lost def</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo.sitting</name>
                    <packageName></packageName>
                    <script>-- handles getting up after a manual sit
function svo.sitting(_, aff)
  if aff ~= &quot;prone&quot; then return end

  if svo.ignore.prone and svo.ignore.prone.because and svo.ignore.prone.because == &quot;you sat down&quot; then
    svo.ignore.prone = nil
    raiseEvent(&quot;svo ignore changed&quot;, &quot;prone&quot;)
  end
end</script>
                    <eventHandlerList>
                        <string>svo lost aff</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo.sleeping</name>
                    <packageName></packageName>
                    <script>-- handles unignoring sleeping after waking up
function svo.sleeping(_, aff)
  if aff ~= &quot;sleep&quot; then return end

  if svo.ignore.sleep and svo.ignore.sleep.because and svo.ignore.sleep.because == &quot;you wanted to sleep&quot; then
    svo.ignore.sleep = nil
  end
end</script>
                    <eventHandlerList>
                        <string>svo lost aff</string>
                    </eventHandlerList>
                </Script>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>svo Meteor Compress</name>
                    <packageName></packageName>
                    <script>function svo.updatemeteors()
  deleteLine()
  svo.prompttrigger(&quot;compress meteors&quot;, svo.showmeteors)
end

local function concatmap(tbl)
  local t = {}
  for k,v in pairs(tbl) do
    t[#t+1] = v..&quot; on &quot;..k
  end
  return svo.concatand(t)
end

function svo.showmeteors()
  local t = {}
  if svo.meteors.justlaunched then
    t[#t+1] = string.format(&quot;%d launched&quot;, svo.meteors.justlaunched)
  end
  if svo.meteors.justlaunchedmine then
    t[#t+1] = &quot;plus your meteor&quot;
  end
  if svo.meteors.headingin then
    t[#t+1] = string.format(&quot;%d heading to you&quot;, svo.meteors.headingin)
  end
  if svo.meteors.headingout then
    t[#t+1] = string.format(&quot;%d going elsewhere&quot;, svo.meteors.headingout)
  end
  if svo.meteors.brokeshield then
    t[#t+1] = svo.meteors.brokeshield.. &quot; broke your shield&quot;
  end
  if svo.meteors.hityou then
    t[#t+1] = string.format(&quot;%s hit you&quot;, svo.concatand(svo.meteors.hityou))
  end
  if svo.meteors.brokeshieldother then
    t[#t+1] = string.format(&quot;shield broke on: %s&quot;, concatmap(svo.meteors.brokeshieldother))
  end
  if svo.meteors.hitanother then
    t[#t+1] = string.format(&quot;meteors hit: %s&quot;, concatmap(svo.meteors.hitanother))
  end
  if svo.meteors.fellelsewhere then
    t[#t+1] = string.format(&quot;%d hit no-one&quot;, svo.meteors.fellelsewhere)
  end

  svo.echof(&quot;&lt;255,0,0&gt;meteors%s: %s&quot;, svo.getDefaultColor(), svo.concatand(t))
  svo.meteors = nil
end</script>
                    <eventHandlerList/>
                </ScriptGroup>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>commandTracker</name>
                    <packageName></packageName>
                    <script>lastCommands = lastCommands or {}

function commandTracker(_,what)
   local howMany = 5
   what = what:lower():gsub(&quot;^%s+&quot;,&quot;&quot;)
   table.insert(lastCommands, 1, what)
   table.remove(lastCommands, howMany+1)
end

function commandCheck(what)
   local found = false
   for k,v in ipairs(lastCommands) do
      if v:find(stupidityCheckTable[what]) then
         found = true
      end
   end
   return found
end

stupidityCheckTable = {
	[&quot;You waggle your eyebrows comically.&quot;]                                                                             = &quot;^waggle&quot;,
	[&quot;You blink.&quot;]                                                                                                      = &quot;^blink&quot;,
	[&quot;You twitch spasmodically.&quot;]                                                                                       = &quot;^twitch&quot;,
	[&quot;As horrible thoughts fill your mind, you begin to sob uncontrollably.&quot;]                                           = &quot;^sob&quot;,
	[&quot;You hug yourself compassionately.&quot;]                                                                               = &quot;^hug&quot;,
	[&quot;My friend, clearly you know little of the sultry tango, if you think that you can perform it without a partner.&quot;] = &quot;^tango&quot;,
	[&quot;Your mind is whirling with thoughts - you cannot settle down to sleep.&quot;]                                          = &quot;^sleep&quot;,
	[&quot;You get down on one knee and serenade the world.&quot;]                                                                = &quot;^serenade&quot;,
	[&quot;You make a strangled meowing noise and quickly shut up in embarrassment.&quot;]                                        = &quot;^meow&quot;,
	[&quot;You burp obscenely.&quot;]                                                                                             = &quot;^burp&quot;,
	[&quot;You flap your arms madly.&quot;]                                                                                       = &quot;^flap&quot;,
	[&quot;You wouldn't want to drink a salve. It would not be tasty at all.&quot;]                                               = &quot;^sip&quot;,
	[&quot;Tears fill your eyes and begin to slowly run down your face.&quot;]                                                    = &quot;^cry&quot;,
	[&quot;You drop to one knee, demonstrating your humility and respect.&quot;]                                                  = &quot;^kneel&quot;,
	[&quot;You pick your nose absently.&quot;]                                                                                    = &quot;^picknose&quot;,
	[&quot;You wail like an old woman.&quot;]                                                                                     = &quot;^wail&quot;,
	[ [[You grunt a bit and then let out a loud &quot;OINK!&quot;]] ]                                                             = &quot;^oink&quot;,
	[ [[You let out a loud, long &quot;MOOOOOOOOOOO!&quot;]] ]                                                                    = &quot;^moo&quot;,
	[ [[&quot;The voices! The voices! Get them out of my head!!&quot; you moan, holding your head in pain.]] ]                    = &quot;^voices&quot;,
	[&quot;You stumble and poke yourself in the eye.&quot;]                                                                       = &quot;^poke&quot;,
	[&quot;Your mind is whirling with thoughts - you cannot settle down to sleep.&quot;]                                          = &quot;^sleep&quot;,
}</script>
                    <eventHandlerList>
                        <string>sysDataSendRequest</string>
                    </eventHandlerList>
                </ScriptGroup>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Check for system updates</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>svo_downloaded_file</name>
                    <packageName></packageName>
                    <script>function svo_downloaded_file(_, filename)
  -- is the file that downloaded our oursystem?

  if filename == tostring(svo.versionfile) then
    svo.checkingupdates = false

    local s = io.open(filename):read(&quot;*a&quot;)
    if svo.version == s:trim() then
      if svo.announceupdates == &quot;checking&quot; then
        svo.announceupdates = nil
        svo.echof(&quot;You're all good! Latest version is %s and you're on it.&quot;, svo.version)
      end
      return
    end

    -- new version? See if we've already downloaded it, if not, do so
    local f = io.open(getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;)

    local writtenversion

    -- new version file can not exist if we didn't download a system previously
    if f then
      writtenversion = f:read(&quot;*a&quot;)
    end

    if not writtenversion or writtenversion:trim() ~= s:trim() or not lfs.attributes(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)) then
      if svo.announceupdates == &quot;checking&quot; then svo.echof(&quot;A new Svo is available! You're on %s, latest is %s. I'll download it for you.&quot;, svo.version, s:trim()) end
      svo.downloadnewsystem(s:trim())
    else
      if svo.announceupdates == &quot;checking&quot; then svo.echof(&quot;A new Svo is available and has been downloaded for you! You're on %s, latest is %s.&quot;, svo.version, s:trim()) end
      svo.showupdatereminder(writtenversion)
    end

  elseif filename == tostring(svo.downloadedsystem) then
    svo.checkingupdates = false

    -- got new zip? make sure it's valid, Dropbox likes to mess with us.
    local f = io.open(filename)
    if not f or f:read(&quot;*a&quot;):find(&quot;302 Found&quot;) then
      -- don't loop downloading forever
      if not svo.downloadretries or svo.downloadretries &lt;= (svo.maxdownloadretries or 5) then
        svo.downloadnewsystem(svo.newdownloadedversion)
        svo.downloadretries = (svo.downloadretries or 0) + 1
        svo.echof(&quot;Bah. I downloaded the new system, but Dropbox wigged out and didn't actually send us a new zip but an error message. Going to try downloading it again%s.&quot;,
          (svo.downloadretries == 1 and &quot;&quot; or &quot; (attempt &quot;..svo.downloadretries..&quot; out of &quot;..(svo.maxdownloadretries or 5)..&quot;)&quot;))
      else
        svo.echof(&quot;Giving up. Dropbox keeps refusing to give us a working zip. Try downloading and upgrading manually; uninstall Svo in the Package Manager and install the new zip from there.&quot;)
      end

      if f then f:close() end
      return
    end

    -- cleanup
    if f then f:close() end
    if svo.downloadretries then
      svo.downloadretries = nil
      svo.echof(&quot;OK, got a working zip now that we can install!&quot;)
    end

    -- downloaded a new system zip? Save its version in a file, so on restart if the person hasn't updated, we can poke them about it
    local f,err = io.open(getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;, &quot;w&quot;)
    if not f then return svo.echof(&quot;Couldn't write to the new version file, because: &quot;..err) end
    f:write(svo.newdownloadedversion)
    f:close()

    svo.showupdatereminder(svo.newdownloadedversion)
  end
end</script>
                    <eventHandlerList>
                        <string>sysDownloadDone</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Check for updates</name>
                    <packageName></packageName>
                    <script>local downloadfolder = getMudletHomeDir()..&quot;/svo/downloads/&quot;
local baseUrl = string.format(&quot;http://svof.github.io/svof/%s/&quot;, svo.conf.releasechannel)

-- this should get called at start and every hour after that
function svo.checkforupdate(type)
  if svo.checkingupdates then return end
  svo.versionfile = downloadfolder..&quot;svo_version&quot;

  if not downloadFile then
    svo.echof(&quot;Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+&quot;)
  else
    if not lfs.attributes(downloadfolder) then
      if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(downloadfolder)
         if not t and s ~= &quot;File exists&quot; then svo.echof(&quot;Couldn't make the '&quot;..downloadfolder..&quot;' folder; &quot;..s) return end
      else
        svo.echof(&quot;Sorry, but you need LuaFileSystem (lfs) installed, or have the '&quot;..downloadfolder..&quot;' folder exist.&quot;)
        return
      end
    end

    svo.checkingupdates = true
    downloadFile(svo.versionfile, baseUrl .. &quot;current_version.txt&quot;)

    if type == &quot;checking&quot; then
      svo.echof(&quot;Checking for updates...&quot;)
      svo.announceupdates = &quot;checking&quot;
    elseif type == &quot;force&quot; then
      svo.echof(&quot;(re)downloading latest system...&quot;)
      svo.announceupdates = &quot;force&quot;
      svo.version = 0


      local location = getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;
      if io.exists(location) then
        local s,m = os.remove(location)
        if not s then svo.echof(&quot;Couldn't remove the %s file (error was: %s) - this might be a problem.&quot;, location, m) end
      end

      location = downloadfolder..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)
      if io.exists(location) then
        local s,m = os.remove(location)
        if not s then svo.echof(&quot;Couldn't delete the old svo zip (located at %s), because of: %s. This might be a problem.&quot;, location, m) end
      end
    else
      svo.announceupdates = nil
    end
  end
end

-- downloads the system &amp; updates the system version saved
function svo.downloadnewsystem(newversion)
  svo.downloadedsystem = downloadfolder..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)
  local downloadurl = baseUrl..svo.me.class..[[.Svof.v]]..newversion..[[.zip]]

  downloadFile(svo.downloadedsystem, downloadurl)
  svo.newdownloadedversion = newversion
end</script>
                    <eventHandlerList/>
                    <Script isActive="yes" isFolder="no">
                        <name>svo_checkupdatestart</name>
                        <packageName></packageName>
                        <script>function svo_checkupdatestart()
  svo.checkforupdate()
end</script>
                        <eventHandlerList>
                            <string>svo system loaded</string>
                        </eventHandlerList>
                    </Script>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Update UI</name>
                    <packageName></packageName>
                    <script>function svo.showupdatereminder(newversion)
  svo.announceupdates = nil

  svo.updatelabel = svo.updatelabel or Geyser.Label:new({
    name = &quot;svo.updatelabel&quot;,
    x = &quot;-340px&quot;, y = &quot;-115px&quot;,
    width = &quot;320px&quot;, height = &quot;110px&quot;,
  })

  svo.doupdatelabel = svo.doupdatelabel or Geyser.Label:new({
    name = &quot;svo.doupdatelabel&quot;,
    x = &quot;25%&quot;, y = &quot;-30px&quot;,
    width = &quot;20%&quot;, height = &quot;20px&quot;,
  }, svo.updatelabel)

  svo.dontupdatelabel = svo.dontupdatelabel or Geyser.Label:new({
    name = &quot;svo.dontupdatelabel&quot;,
    x = &quot;55%&quot;, y = &quot;-30px&quot;,
    width = &quot;20%&quot;, height = &quot;20px&quot;,
  }, svo.updatelabel)

  -- grey to black shade, top to bottom
  svo.updatelabel:setStyleSheet([[
      margin: 0px;
      padding: 2px;

      /* Vertical gradient */
      background: qlineargradient(
          x1: 0, y1: 0, x2: 0, y2: 1,
          stop: 0 #3c3c3c, stop: 1 #232323
      );

      border: none;
      border-radius: 4px;

      color: #ffffff;

    qproperty-alignment: 'AlignTop | AlignHCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  svo.doupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: green;
    font-family: monospace;
  ]])

  svo.dontupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: grey;
    font-family: monospace;
  ]])

  svo.updatelabel:echo(string.format([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Hey, a new Svo (%s) has been downloaded and is available for install.&lt;br&gt;&lt;br&gt;Install and restart now, or install later?&lt;p&gt;]], newversion))

  svo.doupdatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Restart&lt;/p]])

  svo.dontupdatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Later&lt;/p]])

  svo.updatelabel:show()
  svo.doupdatelabel:show()
  svo.dontupdatelabel:show()

  svo.doupdatelabel:setClickCallback(&quot;svo_doupdate_click&quot;)
  svo.dontupdatelabel:setClickCallback(&quot;svo_dontupdate_click&quot;)
end

function svo_dontupdate_click()
  svo.updatelabel:hide()
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()
end

function svo_doupdate_click()
  svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Updating Svo...&lt;p&gt;]])
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()

  local class = svo.me.class

  if not (uninstallPackage and installPackage) then
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Can't update your Svo. You didn't update to Mudlet 2.1, and your current Mudlet lacks the features necessary. Go update first please.&lt;p&gt;]])
    return
  end

  if not io.exists(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class)) then
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Hm, can't update Svo - seems the new system we downloaded dissapeared. Do 'vupdate force' to download it again.&lt;p&gt;]])
    return
  end

  function svo_update_system()
    svo_updating_system = &quot;uninstalling&quot;
    uninstallPackage(class..&quot; svo&quot;)

    svo_updating_system = &quot;installing&quot;
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Uninstalled the old Svo, installing the new one now...&lt;p&gt;]])
    installPackage(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class))

    svo_updating_system = nil
    svo.echof(&quot;Svo updated! Restart Mudlet, and you'll be all done. You can find the changelog on svof.pathurs.com/changelog.php&quot;)

    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Svo updated!&lt;br&gt;&lt;br&gt;Restart Mudlet, and you'll be all done.&lt;p&gt;]])
    svo.updatelabel:setStyleSheet([[
        margin: 0px;
        padding: 2px;

        /* Vertical gradient */
        background: qlineargradient(
            x1: 0, y1: 0, x2: 0, y2: 1,
            stop: 0 #3c3c3c, stop: 1 #232323
        );

        border: none;
        border-radius: 4px;

        color: #ffffff;

      qproperty-alignment: 'AlignVCenter | AlignHCenter';
      qproperty-wordWrap: true;
      font-family: 'Ubuntu','Calibri',serif;
    ]])
  end

  svo_updating_system = &quot;started&quot;
  tempTimer(10, function()
    if not svo_updating_system then return end

    if svo_updating_system == &quot;uninstalling&quot; then
      svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Hm, seems the update got stuck on the uninstallPackage() function. Try uninstalling Svo from the Package Manager and then installing it from the zip (found in ]].. getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class) ..[[) to upgrade now.&lt;p&gt;]])
    elseif svo_updating_system == &quot;installing&quot; then
      svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Hm, seems the update got stuck on the installPackage() function. Old Svo is uninstalled, but it the new one didn't get installed - install your Svo zip (found in ]].. getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class) ..[[ via the Package Manager.&lt;p&gt;]])
    end
  end)
  svo_update_system()
end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Examples</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>Use of got/lost aff/def events</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="no" isFolder="no">
                        <name>svo_example_affs</name>
                        <packageName></packageName>
                        <script>-- Act on lost/gained affs
-- can be used, for example, to stop an instakill if you've gotten hindered - unpause system, unpause offense, etc.
-- must have vconfig eventaffs on
function svo_example_affs(eventname, data)
	svo.echof(&quot;Event: %s, data: %s&quot;, eventname, data)
--	tempTimer(0, function() svo.echof(&quot;Event: %s, data: %s&quot;, eventname, data) end)
end</script>
                        <eventHandlerList>
                            <string>svo got aff</string>
                            <string>svo lost aff</string>
                            <string>svo got def</string>
                            <string>svo lost def</string>
                        </eventHandlerList>
                    </Script>
                </ScriptGroup>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>affs display window</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="no" isFolder="no">
                        <name>svo_update_window</name>
                        <packageName></packageName>
                        <script>-- delete the line below and enable vconfig eventaffs plus this script for this demo to work!
if true or not Geyser then return end

local affslabel

local main = Geyser.Container:new({x=0,y=0,width=&quot;100%&quot;,height=&quot;100%&quot;,name=&quot;affslabelcontainer&quot;})

affslabel = Geyser.Label:new({  name = &quot;affslabel&quot;,
                               x = &quot;87%&quot;, y = &quot;80%&quot;,
                               width = &quot;11%&quot;, height = &quot;17%&quot;},
                               main)
-- this sets the colour of the whole label to greenish
affslabel:setColor(100,155,0,127)

local function highlight(name)
	if not svo.ignore[name] then return name else
	return string.format([[&lt;span style=&quot;color:yellowgreen&quot;&gt;%s&lt;/span&gt;]], name) end
end

function svo_update_window()
local s = {}
	if not affslabel then return end

	for name, namet in pairs(svo.affl) do
		if name ~= &quot;deaf&quot; and name ~= &quot;blind&quot; then
			if type(namet) == &quot;table&quot; and namet.count then
				s[#s+1] = string.format(&quot;%s (%d)&quot;, highlight(name), namet.count)
			else
				s[#s+1] = highlight(name)
			end
		end
	end
	affslabel:echo([[&lt;span style=&quot;color:white&quot;&gt;]].. table.concat(s, &quot;&lt;br&gt;&quot;) ..&quot;&lt;/span&gt;&quot;)
end</script>
                        <eventHandlerList>
                            <string>svo got aff</string>
                            <string>svo lost aff</string>
                        </eventHandlerList>
                    </Script>
                </ScriptGroup>
                <Script isActive="no" isFolder="no">
                    <name>Customize_systems_echos</name>
                    <packageName></packageName>
                    <script>-- sample custom echo! Feel free to change the 'demo' name, so you can do 'vconfig echotype &lt;name&gt;'.

-- to edit this, mode this script outside of Svo - doesn't matter if it's before or after Svo scripts
-- then do 'vshow colors' to select your new colour scheme

-- this does take #'s for colours, not words - http://colorschemedesigner.com might help you in
-- selecting the hex colour code and then use http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
-- to convert it to the 3 RGB colours
function Customize_systems_echos()
if not svo then return end

-- this does the (svo): blah-style echoes
function svo.echos.demo(newline, what)
  decho(&quot;&lt;80,66,80&gt;(&lt;107,79,125&gt;svo&lt;80,66,80&gt;)&lt;87,85,89&gt;: &lt;159,128,180&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

-- this is the default color of the text in (svo): &lt;this colour here&gt;, so keep it consistent
-- with the last colour used above
function svo.echosd.demo()
  return &quot;&lt;159,128,180&gt;&quot;
end

end

-- this is so editing the scheme after loading works
Customize_systems_echos()</script>
                    <eventHandlerList>
                        <string>svo system loaded</string>
                    </eventHandlerList>
                </Script>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>Display afflictions on prompt demo</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="no" isFolder="no">
                        <name>mm_display_affs</name>
                        <packageName></packageName>
                        <script>-- just shows how to suffix affs to the prompt so you know

function mm_display_affs()
	-- put two dashes before the line below so this function will work!
	if true then return end

	-- this if/elseif chain will append one aff at a time only
	if svo.affl.prone then
		echo(&quot;[[PRONE]] &quot;)
	elseif svo.affl.paralysis then
		echo(&quot;[[PARALYSIS]] &quot;)
	elseif svo.affl.crippledleftleg then
		echo(&quot;[[CRIPPLED LEFTLEG]] &quot;)
	end

	-- these stand-alone ifs will allow for several affs to be suffixed
	if svo.affl.crippledrightleg then
		echo(&quot;[[CRIPPLED RIGHT LEG]] &quot;)
	end

	if svo.affl.tangled then
		echo(&quot;[[TANGLED]] &quot;)
	end
end</script>
                        <eventHandlerList>
                            <string>svo done with prompt</string>
                        </eventHandlerList>
                    </Script>
                </ScriptGroup>
                <ScriptGroup isActive="yes" isFolder="yes">
                    <name>Show which affs you got/lost w/ times and count (by Lynara)</name>
                    <packageName></packageName>
                    <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                    <eventHandlerList/>
                    <Script isActive="no" isFolder="no">
                        <name>MyAffs</name>
                        <packageName></packageName>
                        <script>-- made by Lynara

svo.stopWatches = svo.stopWatches or {}
function MyAffs(eventname, data)
   local default = svo.getDefaultColor()
   if eventname == &quot;svo got aff&quot; then
      svo.stopWatches[data] = svo.affl[data] and svo.affl[data].sw or 0
      svo.echof(&quot;Got aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;170,0,0&gt;%s%s affs&lt;210,210,210&gt;)&quot;, data, table.size(svo.affl), default )
   else
      svo.echof([[Lost aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;0,210,0&gt;%s%ssec&lt;210,210,210&gt;) (&lt;170,0,0&gt;%s%s left&lt;210,210,210&gt;)]],
 data, getStopWatchTime(svo.stopWatches[data]), default, table.size(svo.affl), default)
   end
end</script>
                        <eventHandlerList>
                            <string>svo got aff</string>
                            <string>svo lost aff</string>
                        </eventHandlerList>
                    </Script>
                </ScriptGroup>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo Time Tracking</name>
                <packageName></packageName>
                <script>svo.me.time = svo.me.time or {
  h = 0, m = 0,
  tictimer = false,
  min2s = 2.5
}

function svo.sync_time(hour)
  svo.me.time.h, svo.me.time.m = hour, 0
  if svo.me.time.tictimer then killTimer(svo.me.time.tictimer) end

  svo.me.time.tictimer = tempTimer(svo.me.time.min2s - getNetworkLatency(), svo.tic_time)
end

function svo.tic_time()
  svo.me.time.m = svo.me.time.m + 1
  if svo.me.time.m &gt;= 60 then
    svo.me.time.h = svo.me.time.h + 1
    if svo.me.time.h &gt;= 24 then svo.me.time.h = 0 end

    svo.me.time.m = 0
  end

  svo.echof(&quot;It is now %.0d:%1d&quot;, svo.me.time.h, svo.me.time.m)
  svo.me.time.tictimer = tempTimer(svo.me.time.min2s, svo.tic_time)
end</script>
                <eventHandlerList/>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo Class Management</name>
                <packageName></packageName>
                <script>--[[ start of a class management (tn class/tn classonly) + class-specifics tricks ]]

svo.classes = {
  alchemist    = {fighting = false, skills = {&quot;transmutation&quot;, &quot;physiology&quot;, &quot;alchemy&quot;}},
  apostate     = {fighting = false, skills = {&quot;evileye&quot;, &quot;necromancy&quot;, &quot;apostasy&quot;}},
  bard         = {fighting = false, skills = {&quot;voicecraft&quot;, &quot;swashbuckling&quot;, &quot;harmonics&quot;}},
  blademaster  = {fighting = false, skills = {&quot;twoarts&quot;, &quot;striking&quot;, &quot;shindo&quot;}},
  depthswalker = {fighting = false, skills = {&quot;shadowmancy&quot;, &quot;aeonics&quot;, &quot;terminus&quot;}},
  dragon       = {fighting = false, skills = {&quot;dragoncraft&quot;}},
  druid        = {fighting = false, skills = {&quot;groves&quot;, &quot;metamorphosis&quot;, &quot;concoctions&quot;}},
  infernal     = {fighting = false, skills = {&quot;necromancy&quot;, &quot;chivalry&quot;, &quot;forging&quot;}},
  jester       = {fighting = false, skills = {&quot;tarot&quot;, &quot;pranks&quot;, &quot;puppetry&quot;}},
  magi         = {fighting = false, skills = {&quot;elementalism&quot;, &quot;crystalism&quot;, &quot;enchantment&quot;}},
  monk         = {fighting = false, skills = {&quot;tekura&quot;, &quot;kaido&quot;, &quot;telepathy&quot;}},
  occultist    = {fighting = false, skills = {&quot;occultism&quot;, &quot;tarot&quot;, &quot;domination&quot;}},
  paladin      = {fighting = false, skills = {&quot;chivalry&quot;, &quot;devotion&quot;, &quot;forging&quot;}},
  priest       = {fighting = false, skills = {&quot;spirituality&quot;, &quot;devotion&quot;, &quot;healing&quot;}},
  runewarden   = {fighting = false, skills = {&quot;runelore&quot;, &quot;chivalry&quot;, &quot;forging&quot;}},
  sentinel     = {fighting = false, skills = {&quot;metamorphosis&quot;, &quot;woodlore&quot;, &quot;concoctions&quot;}},
  serpent      = {fighting = false, skills = {&quot;subterfuge&quot;, &quot;venom&quot;, &quot;hypnosis&quot;}},
  shaman       = {fighting = false, skills = {&quot;spiritlore&quot;, &quot;curses&quot;, &quot;vodun&quot;}},
  sylvan       = {fighting = false, skills = {&quot;elementalism&quot;, &quot;groves&quot;, &quot;concoctions&quot;}},
}
-- keeps track of what skills are actually enabled
svo.enabledskills, svo.enabledclasses = svo.enabledskills or {}, svo.enabledclasses or {}

-- this is used before we're actually sure that we're fighting a class and not illusions
svo.maybefighting = svo.maybefighting or {}

function svo.enableclass(class)
  if not svo.classes[class] or svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) + 1
  end

  svo.enabledclasses[class] = true
  raiseEvent(&quot;svo enabled class&quot;, class)
end

function svo.disableclass(class)
  if not svo.classes[class] or not svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) - 1
    if svo.enabledskills[skill] &lt;= 0 then svo.enabledskills[skill] = nil end
  end

  svo.enabledclasses[class] = nil
  raiseEvent(&quot;svo disabled class&quot;, class)
end

function svo.enableallclasses()
  for class in pairs(svo.classes) do
    svo.enableclass(class)
  end
end

function svo.disableallclasses()
  for class in pairs(svo.classes) do
    svo.disableclass(class)
  end
end

-- once a class is enabled, maybefighting shouldn't be added, but the timer renewed
function svo.startedfighting(class, name)
  svo.valid.gothit(class, name) -- check for **ILLUSION**s
end</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>svo_show_classes</name>
                    <packageName></packageName>
                    <script>function svo_show_classes()
  if not next(svo.enabledclasses) then svo.echof(&quot;No class tricks are enabled.&quot;) return end

  local l = svo.keystolist(svo.enabledclasses)
  table.sort(l)
  svo.echof(&quot;Enabled tricks for: %s&quot;, svo.concatand(l))
end</script>
                    <eventHandlerList>
                        <string>svo onshow</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo.registerhit</name>
                    <packageName></packageName>
                    <script>function svo.registerhit(_, class, name)
  if not svo.classes[class] or not svo.conf.autoclasses then return end

  if not svo.enabledclasses[class] then
    svo.maybefighting[class] = (svo.maybefighting[class] or 0) + 1

    tempTimer(svo.conf.classattackswithin, function()
      if svo.maybefighting[class] then
        svo.maybefighting[class] = svo.maybefighting[class] - 1
        if svo.maybefighting[class] &lt;= 0 then
          svo.maybefighting[class] = nil
        end
      end
    end)
  end

  -- enable if we got attacked enough
  if svo.maybefighting[class] and svo.maybefighting[class] &gt;= svo.conf.classattacksamount and not svo.enabledclasses[class] then
    svo.enableclass(class)
    svo.prompttrigger(&quot;enabled &quot;..class, function() svo.echof(&quot;Seems that we're fighting with %s - enabled class tricks.&quot;, string.title(class)) end)
  end

  -- start/renew timer
  if svo.classes[class].fighting then killTimer(svo.classes[class].fighting) end
  svo.classes[class].fighting = tempTimer(60*svo.conf.enableclassesfor, function()
    svo.classes[class].fighting = nil
    if not svo.enabledclasses[class] then return end

    svo.disableclass(class)
    if svo.stats.currenthealth ~= 0 then echo'\n' svo.echof(&quot;Don't think we're fighting with class %s anymore, disabled tricks.&quot;, string.title(class)) end
    svo.showprompt()
  end)
end</script>
                    <eventHandlerList>
                        <string>svo got hit by</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo UI Experiments</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>Enable Comm</name>
                    <packageName></packageName>
                    <script>function svo_enableCommChannel()
	-- register after GMCP is enabled. gmod doesn't re-register atm on restart
    sendGMCP([[Core.Supports.Add [&quot;Comm.Channel 1&quot;] ]])
end</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>svo_captureChats</name>
                    <packageName></packageName>
                    <script>-- magical chat capture that doesn't require any triggers!
-- made for Svo
svo.ui = svo.ui or {}

function svo_captureChats()
    if not svo.ui.chat then return end

    tempLineTrigger(0,1,[[
        if isPrompt() then return end
		selectCurrentLine()
		copy()

		if string.starts(line, &quot;(Party)&quot;) then svo.ui.chat:Append(&quot;Party&quot;)
		else svo.ui.chat:Append(&quot;All&quot;) end
]])
end</script>
                    <eventHandlerList>
                        <string>gmcp.Comm.Channel.Start</string>
                    </eventHandlerList>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>Rift label dimensions</name>
                    <packageName></packageName>
                    <script>-- after editing this, do vshow herbstat to make it appear. To adjust the font size used, use vconfig herbstatsize #

-- if you'd like your changes to stay between Svo updates, move this script out of Svo's folder,
-- and make sure it is *after* Svo's folder after an update


svo.riftlabel = Geyser.Label:new({  name = &quot;svo.riftlabel&quot;,
                               x = -360, y = -166,
                               width = 355, height = 166})

if not svo.conf.riftlabel then svo.riftlabel:hide() end</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <Script isActive="yes" isFolder="no">
                <name>Load externals</name>
                <packageName></packageName>
                <script>--[[ svo system loader, made by Vadi ]]

      svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
      echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.pathurs.com/homepage.php&quot;', &quot;Svof homepage&quot;)
      decho(svo.getDefaultColor()..&quot;)\n&quot;)

if true then return end

local _sep
if string.char(getMudletHomeDir():byte()) == &quot;/&quot; then _sep = &quot;/&quot; else  _sep = &quot;\\&quot; end
require &quot;lfs&quot;

function svo_load()
  svo_load = function () end
  if package.loaded[&quot;svo&quot;] then return end

  -- loader for packages
  local foldername
  for item in lfs.dir(getMudletHomeDir()) do
    foldername = item:match(&quot;(%w+) svo&quot;)
    if foldername and lfs.attributes(getMudletHomeDir()..&quot;/&quot;..foldername..&quot; svo/svo&quot;) then
      local oldpath = package.path
      local system_path = getMudletHomeDir()..&quot;/&quot;..foldername..&quot; svo/&quot;
      package.path = system_path .. &quot;?;&quot; .. system_path .. &quot;?.lua;&quot; .. system_path .. &quot;?.dll;&quot; .. system_path .. &quot;?.so;&quot;

      local s,m = pcall(require, &quot;svo&quot;)
      package.path = oldpath

      if not s then display(m) return end

      svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
      echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.pathurs.com/homepage.php&quot;', &quot;Svof homepage&quot;)
      decho(svo.getDefaultColor()..&quot;)\n&quot;)
      return
    end
  end

--[[  tempTimer(5, function()
    cecho(&quot;\n\n&lt;red&gt;Warning: &lt;cyan&gt;Svof couldn't be located. Please only install 'Character svo.zip', not anything renamed!\n\n&quot;)
  end)]]

  -- or a non-package... [depreciated]

  local svo_location = getMudletHomeDir() .. _sep .. &quot;svo_location&quot;
  local system_path -- location of the system's folder with a trailing slash
  local f,msg

  if not lfs.attributes(svo_location) then
    system_path = svo_whereisit()
    if not system_path then return end
  else
    f,msg = io.open(svo_location, &quot;r+&quot;)
    assert(f, msg)

    -- this should give us the folder it's in
    system_path = f:read(&quot;*l&quot;)

    if string.sub(system_path, -1) == &quot;/&quot; or string.sub(system_path, -1) == [[\]] then
      system_path = string.sub(system_path, 1, -2)
    end

    -- if we had an invalid path stored
    if not lfs.attributes(system_path) then
      system_path = svo_whereisit()
      if not system_path then return end
    end
  end

  -- re-add the suffix that we might have had to strip earlier for lfs.attributes to work on Windows
  if not (string.sub(system_path, -1) == &quot;/&quot; or string.sub(system_path, -1) == [[\]]) then
    system_path = system_path .. &quot;/&quot;
  end

  local oldpath = package.path
  package.path = system_path .. &quot;?;&quot; .. system_path .. &quot;?.lua;&quot; .. system_path .. &quot;?.dll;&quot; .. system_path .. &quot;?.so;&quot;

  local s,m = pcall(require, &quot;svo&quot;)
  package.path = oldpath

  if not s then display(m) return end

  svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
  echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.pathurs.com/homepage.php&quot;', &quot;Svof homepage&quot;)
  decho(svo.getDefaultColor()..&quot;)\n&quot;)

  -- update file
  if not f then
    f,msg = io.open(svo_location, &quot;w&quot;)
    if not f then display(msg) return end
  else
    f:seek(&quot;set&quot;,0)
  end

  f:write(system_path)
  f:close()
end

-- find the folder
function svo_whereisit()
  local path = invokeFileDialog(false, &quot;Where is the svo folder? Select it and click Open&quot;)

  if path == &quot;&quot; then return nil else return path .. _sep end
end

--load system
svo_load()</script>
                <eventHandlerList/>
            </Script>
        </ScriptGroup>
    </ScriptPackage>
    <KeyPackage/>
    <HelpPackage>
        <helpURL/>
    </HelpPackage>
</MudletPackage>
