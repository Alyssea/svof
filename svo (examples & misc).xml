<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
    <TriggerPackage/>
    <TimerPackage/>
    <AliasPackage/>
    <ActionPackage/>
    <ScriptPackage>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>3rdparty</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>double_queue</name>
                <packageName></packageName>
                <script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;

-- This file is part of LuaNotify.

-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.

-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name ordered_set
-- @description DoubleQueue Class.
-- @author &lt;a href=&quot;mailto:tiagokatcipis@gmail.com&quot;&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href=&quot;mailto:paulo.pizarro@gmail.com&quot;&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local setmetatable = setmetatable
local pairs = pairs
local display = display

module(&quot;notify.double_queue&quot;)

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local DoubleQueue = {}

------------------------------------
-- Metamethods goes on this table --
------------------------------------
local DoubleQueue_mt = { __index = DoubleQueue }


--------------------------
-- Constructor function --
--------------------------

function new ()
    local object = {}
    -- set the metatable of the new object as the DoubleQueue_mt table (inherits DoubleQueue).
    setmetatable(object, DoubleQueue_mt)

    -- create all the instance state data.
    object.data          = {}
    object.data_position = {}
    object.first         = 1 
    object.last          = 0
    return object
end

---------------------------
-- Class private methods --
---------------------------
local function refresh_first(self)
    while(self.first &lt;= self.last) do
        if(self.data[self.first]) then
            return true
        end
        self.first = self.first + 1
    end
end


--------------------------
-- Class public methods --
--------------------------
function DoubleQueue:is_empty()
    return self.first &gt; self.last
end

function DoubleQueue:push_front(data)
    if(self.data_position[data]) then
        return
    end
    self.first = self.first - 1
    self.data[self.first]    = data
    self.data_position[data] = self.first
end

function DoubleQueue:push_back(data)
    if(self.data_position[data]) then
        return
    end
    self.last = self.last + 1
    self.data[self.last]     = data
    self.data_position[data] = self.last
end

function DoubleQueue:get_iterator()
    local first = self.first
    local function iterator()
        while(first &lt;= self.last) do
            local data = self.data[first]
            first = first + 1
            if(data) then
                return data
            end
        end    
    end 
    return iterator
end

function DoubleQueue:contains(data)
	return self.data_position[data] and true or false
end

function DoubleQueue:remove(data)
    if(not self.data_position[data]) then
        return 
    end
    self.data[self.data_position[data]] = nil
    self.data_position[data]            = nil
    refresh_first(self)
end

local function removeByValue(tbl, valueToRemove)
	for key, value in pairs(tbl) do
			if value == valueToRemove then
			  tbl[key] = nil
				return tbl
			end
	end
	
	return tbl
end

function DoubleQueue:removeIndex(position)
		if not self.data[position] then
			return
		end
		
    self.data[position] = nil		
    self.data_position  = removeByValue(self.data_position, position)
    refresh_first(self)
end

function DoubleQueue:position(data)
	return self.data_position[data]
end
</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>signal</name>
                <packageName></packageName>
                <script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
 
-- This file is part of LuaNotify.
 
-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
 
-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
 
-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name signal
-- @description Signal Class.
-- @author &lt;a href=&quot;mailto:tiagokatcipis@gmail.com&quot;&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href=&quot;mailto:paulo.pizarro@gmail.com&quot;&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local require = require
local setmetatable = setmetatable
local display = display

module(&quot;notify.signal&quot;)

local queue = require &quot;notify.double_queue&quot;

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local Signal = {} 


------------------------------------
-- Metamethods goes on this table --
------------------------------------
local Signal_mt = { __index = Signal }


--------------------------
-- Constructor function --
--------------------------
function new ()
    local object = {}      
    -- set the metatable of the new object as the Signal_mt table (inherits Signal).
    setmetatable(object, Signal_mt)

    -- create all the instance state data.
    object.handlers_block  = {}
    object.handlers        = queue.new()
    object.handler_names   = queue.new()
    object.pre_emit_funcs  = queue.new()
    object.post_emit_funcs = queue.new()
    object.signal_stopped = false
    return object
end


----------------------------------
-- Class definition and methods --
----------------------------------


---
-- Disconnects a handler function from this signal, the function will no longer be called.
-- @param handler_function – The function that will be disconnected.
function Signal:disconnect(handler_function)
    self.handlers:remove(handler_function)
    self.handlers_block[handler_function] = nil
end


---
-- Connects a handler function on this signal, all handlers connected will be called 
-- when the signal is emitted with a FIFO  behaviour (The first connected will be the first called).
-- @param handler_function – The function that will be called when this signal is emitted.
function Signal:connect(handler_function, handler_name)
    if(not self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = 0
				
				local position = self.handler_names:position(handler_name)
    		if position then
					self.handlers:removeIndex(position)
					self.handler_names:remove(handler_name)
					-- handlers_block table will keep growing as there's no way to find out what key to
					-- remove, but that is OK and should not affect anything
				end
		
        self.handlers:push_back(handler_function)
        self.handler_names:push_back(handler_name or &quot;&quot;)
    end
end


---
-- Does not execute the given handler function when the signal is emitted until it is unblocked. 
-- It can be called several times for the same handler function.
-- @param handler_function – The handler function that will be blocked.
function Signal:block(handler_function)
    if(self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = self.handlers_block[handler_function] + 1
    end
end


---
-- Unblocks the given handler function, this handler function will be executed on 
-- the order it was previously connected, and it will only be unblocked when 
-- the calls to unblock are equal to the calls to block.
-- @param handler_function – The handler function that will be unblocked.
function Signal:unblock(handler_function)
    if(self.handlers_block[handler_function]) then
        if(self.handlers_block[handler_function] &gt; 0) then
            self.handlers_block[handler_function] = self.handlers_block[handler_function] - 1
        end
    end
end


---
-- Emits a signal calling the handler functions connected to this signal passing the given args.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit(...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            handler(...)
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Typical signal emission discards handler return values completely. 
-- This is most often what you need: just inform the world about something. 
-- However, sometimes you need a way to get feedback. For instance, 
-- you may want to ask: “is this value acceptable, eh?”
-- This is what accumulators are for. Accumulators are specified to signals at emission time. 
-- They can combine, alter or discard handler return values, post-process them or even stop emission. 
-- Since a handler can return multiple values, accumulators can receive multiple args too, following 
-- Lua flexible style we give the user the freedom to do whatever he wants with accumulators.
-- @param accumulator – Function that will accumulate handlers results.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit_with_accumulator(accumulator, ...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            accumulator(handler(...))
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Adds a pre_emit func, pre_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, will not receive any data passed 
-- on the emission and they are always called before ANY handler is called. 
-- This is useful when you want to perform some global task before handling an event, 
-- like opening a socket that the handlers might need to use or a database, pre_emit functions 
-- can make sure everything is ok before handling an event, reducing the need to do this check_ups 
-- inside the handler function. They are called on a queue (FIFO) policy based on the order they added.
-- @param pre_emit_func – The pre_emit function.
function Signal:add_pre_emit(pre_emit_func)
    self.pre_emit_funcs:push_back(pre_emit_func)
end


---
-- Removes the pre_emit function
-- @param pre_emit_func – The pre_emit function.
function Signal:remove_pre_emit(pre_emit_func)
    self.pre_emit_funcs:remove(pre_emit_func)
end


---
-- Adds a post_emit function, post_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, they will not receive any data 
-- passed on the emission and they are always called after ALL handlers where called. 
-- This is useful when you want to perform some global task after handling an event, 
-- like closing a socket that the handlers might need to use or a database or do some cleanup. 
-- post_emit functions can make sure everything is released after handling an event, 
-- reducing the need to do this check_ups inside some handler function, since some resources 
-- can be shared by multiple handlers. They are called on a stack (LIFO) policy based on the order they added.
-- @param post_emit_func – The post_emit function.
function Signal:add_post_emit(post_emit_func)
    self.post_emit_funcs:push_front(post_emit_func)
end

---
-- Removes the post_emit function
-- @param post_emit_func – The post_emit function.
function Signal:remove_post_emit(post_emit_func)
    self.post_emit_funcs:remove(post_emit_func)
end


---
-- Stops the current emission, if there is any handler left to be called by the signal it wont be called.
function Signal:stop()
    self.signal_stopped = true
end

</script>
                <eventHandlerList/>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Event handlers</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>svo_events</name>
                <packageName></packageName>
                <script>function svo_events(...)
	local s,m = pcall(svo.events, ...)
	if not s then display(m) end
end</script>
                <eventHandlerList>
                    <string>CharVitals</string>
                    <string>CharName</string>
                    <string>RoomNum</string>
                    <string>RoomBrief</string>
                    <string>sysDataSendRequest</string>
                    <string>sysExitEvent</string>
                    <string>mmapper updated pdb</string>
                    <string>svo lost balance</string>
                    <string>svo got balance</string>
                    <string>svo prio changed</string>
                    <string>svo system loaded</string>
                    <string>svo config changed</string>
                    <string>svo serverignore changed</string>
                    <string>svo ignore changed</string>
                    <string>svo defup changed</string>
                    <string>svo keepup changed</string>
                    <string>svo switched defence mode</string>
                    <string>svo done defup</string>
                    <string>NameDB finished honors</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo_gevents</name>
                <packageName></packageName>
                <script>function svo_gevents(...)
	local s,m = pcall(svo.gevents, ...)
	if not s then display(m) end
end</script>
                <eventHandlerList>
                    <string>gmcp.Char</string>
                    <string>gmcp.Room</string>
                    <string>gmcp.Char.Status</string>
                    <string>gmcp.IRE.Time</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo_savesettings</name>
                <packageName></packageName>
                <script>svo_savesettings = svo.savesettings</script>
                <eventHandlerList>
                    <string>sysExitEvent</string>
                </eventHandlerList>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>svo Utilities</name>
            <packageName></packageName>
            <script>function svo.inslowcuringmode()
	return (svo.affl.retardation or svo.affl.aeon) and true or false
end

-- originally from Sidd, improved by Lynara
function svo.boxDisplay(msg, color)
    deselect()
    local colTbl = {}
    if color then
       colTbl = string.split(color, &quot;:&quot;)
       for k = 1,2 do
          if colTbl[k] == &quot;&quot; then
             colTbl[k] = nil
          end
       end
       if colTbl[2] then
          bg(colTbl[2])
       end
    end
    colTbl[1] = colTbl[1] or &quot;red&quot;
    fg(colTbl[1])
	local leng = ((2*string.len(msg)) + 11)
	local mes = string.upper(msg)
	echo(&quot;\n &quot;)
    echo( string.rep(&quot;-&quot;, leng+2) )
    echo(&quot; \n|     &quot; .. mes .. &quot; | &quot; .. mes .. &quot;     |\n &quot;)
    echo( string.rep(&quot;-&quot;, leng+2) )
    echo(&quot; \n&quot;)
    resetFormat()
end

function svo.preattack()
  if svo.inslowcuringmode() then return end

  if svo.affl.prone then send'stand' end
end

function mapper_can_move()
  return (svo.bals.balance and svo.bals.equilibrium and svo.bals.rightarm and svo.bals.leftarm) and true or false
end

function svo.echotime(s, sameline)
  if not sameline then moveCursor(0, getLineNumber()-1) end
  moveCursor(#getCurrentLine(), getLineNumber())

  fg(&quot;dark_slate_gray&quot;)
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

function svo.echoafftime(s, aff)
  if aff == &quot;bleeding&quot; and svo.conf.gagclot then return end

  if isPrompt() then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
  end

  deselect()
  fg(&quot;DarkGoldenrod&quot;)
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

local function docc(...)
  local sendto, method
  if not svo.conf.ccto or svo.conf.ccto == 'pt' then sendto = &quot;pt &quot;
  elseif svo.conf.ccto == 'clt' then sendto = &quot;clt &quot;
  elseif svo.conf.ccto:find(&quot;^tell %w+&quot;) then sendto = &quot;tell &quot;..svo.conf.ccto:match(&quot;^tell (%w+)&quot;)..&quot; &quot;
  elseif svo.conf.ccto == 'ot' then sendto = &quot;ot &quot;
  elseif svo.conf.ccto == 'army' then sendto = &quot;art &quot;
  elseif svo.conf.ccto == 'team' then sendto = &quot;team &quot;
  elseif svo.conf.ccto == 'echo' then method = svo.echof; sendto = &quot;&quot;
  else sendto = &quot;clan &quot;..svo.conf.ccto..&quot; tell &quot; end

  if not method then
    send(sendto .. string.format(...), false)
  else
    (method)(sendto .. string.format(...))
  end
end

function svo.ccnop(...)
  if svo.inslowcuringmode() then return end

  docc(...)
end

function svo.cc(...)
  if svo.conf.paused or svo.inslowcuringmode() then return end

  docc(...)
end

-- credit to: http://hci.iastate.edu/~rpavlik/downloads/vrjugglua/snapshot/share/vrjugglua/lua/string_ext.lua
function string.ordinalSuffix(n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return &quot;st&quot;
  elseif d == 2 and n ~= 12 then
    return &quot;nd&quot;
  elseif d == 3 and n ~= 13 then
    return &quot;rd&quot;
  else
    return &quot;th&quot;
  end
end

function svo.shipprompt()
--  selectCurrentLine() fg(&quot;chartreuse&quot;) deselect() resetFormat()

  svo.me.shippromptn = getLineCount()
end

-- shows memory use by Lua objects only
registerAnonymousEventHandler(&quot;svo system loaded&quot;, function()
  svo.adddefinition(&quot;@mem&quot;, &quot;string.format('%0.2f', collectgarbage('count')/1024)&quot;)
end)

function svo.doubleRunToSend(...)
  local doubleClick = .4
  if not DoubleRunTimer then
    DoubleRunTimer = tempTimer(doubleClick,[[killTimer(DoubleRunTimer)
      DoubleRunTimer = nil
      DoubleRunCounter = nil
    ]])
  end
  if DoubleRunCounter then
    DoubleRunCounter = DoubleRunCounter + 1
  else
    DoubleRunCounter = 0
  end
  if DoubleRunCounter == 1 then
    sendAll({...})
  end
end

-- returns a list of affs that focus can get
function svo.getfocusableaffs()
  return table.n_intersection(svo.keystolist(svo.affl), svo.focuscurables)
end

-- starts the stopwatch which measures how long a balance was missing for
function svo.startbalancewatch(balance)
  svo.watch[&quot;bal_&quot;..balance] = svo.watch[&quot;bal_&quot;..balance] or createStopWatch()
  startStopWatch(svo.watch[&quot;bal_&quot;..balance])
end

function svo.endbalancewatch(balance, sameline)
  if svo.watch[&quot;bal_&quot;..balance] then
    local s = stopStopWatch(svo.watch[&quot;bal_&quot;..balance])
    svo.stats[&quot;last&quot;..balance] = s
    if svo.conf.showbaltimes then svo.echotime(s, sameline) end
  end
end

function svo.countbrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm then c = c + 1 end
  if affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm then c = c + 1 end
  if affs.crippledleftleg or affs.mangledleftleg or affs.mutilatedleftleg then c = c + 1 end
  if affs.crippledrightleg or affs.mangledrightleg or affs.mutilatedrightleg then c = c + 1 end

  return c
end

function svo.countonlybrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm then c = c + 1 end
  if affs.crippledrightarm then c = c + 1 end
  if affs.crippledleftleg then c = c + 1 end
  if affs.crippledrightleg then c = c + 1 end
  return c
end

function svo.havefractures()
  local affs = svo.affl

  return affs.crackedribs or affs.skullfractures or affs.torntendons or affs.wristfractures
end</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>Tree curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.tree = svo.tree or {}

svo.tree.blackout = {
  desc = &quot;Use tree to cure blackout&quot;,

  function () return svo.affl.blackout and not svo.ignore.blackout end
}

svo.tree.aeon = {
  desc = &quot;Use tree to cure aeon when we have asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.tree.hardlock = {
  desc = &quot;Use tree to cure hard locks (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()

    return svo.me.locks.hard
  end
}

-- touch tree if we have 3+ limbs damaged and at least one of them is curable with tree
svo.tree.maybevivi = {
  desc = &quot;Use tree in a situation when you might get vivisected&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}

svo.tree.crippledandprone = {
  desc = &quot;Use tree if prone and both legs are crippled&quot;,

  function ()
    local affs = svo.affl

    return (affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      and (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg)) and (affs.prone or not svo.bals.salve)
  end
}

svo.tree.getupfaster = {
  desc = &quot;Use tree if prone, off salve balance, and a leg is crippled&quot;,

  function ()
    local affs = svo.affl

    return ((affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      or (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg))) and affs.prone and not svo.bals.salve
  end
}

svo.tree.curearmsfaster = {
  desc = &quot;Use tree if both arms are crippled and you're off salve balance&quot;,

  function ()
    local affs = svo.affl

    return ((affs.crippledleftarm and not (affs.mangledleftarm or affs.mutilatedleftarm)) or (affs.crippledrightarm and not (affs.mangledrightarm or affs.mutilatedrightarm))) and not svo.bals.salve
  end
}

svo.tree.novoyriacure = {
  desc = &quot;Use tree when you have voyria and no immunity/antigen for it&quot;,

  function ()
    return (svo.affl.voyria and ((svo.es_potions.elixir and svo.es_potions.elixir[&quot;an elixir of immunity&quot;] and svo.es_potions.elixir[&quot;an elixir of immunity&quot;].sips &lt;= 1)
      and (svo.es_potions.tonic and svo.es_potions.tonic[&quot;a tonic of antigen&quot;] and svo.es_potions.tonic[&quot;a tonic of antigen&quot;].sips &lt;= 1))
    )
  end
}

svo.tree.any2affs = {
  desc = &quot;Use tree when we've got at least two tree-curable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.tree.any3affs = {
  desc = &quot;Use tree when we've got at least three tree-curable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

svo.tree.fractures = {
  desc = &quot;Use tree you're got a fracture and are off sip balance&quot;,

  function ()
    return not svo.bals.sip and svo.havefractures()
  end
}</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Restore curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

--[[svo.restore.anylimb = {
  desc = &quot;Use restore if any limb is crippled (useful for bashing without mending, for example)&quot;,
  function () return svo.affl.crippledleftleg or svo.affl.crippledrightleg
    or svo.affl.crippledrightarm or svo.affl.crippledleftarm
  end
}]]

svo.restore = svo.restore or {}

svo.restore.anyoneortwolimbs = {
  desc = &quot;Use restore if one or two limbs are crippled (and no more), and you're off salve/tree balance&quot;,

  function ()
    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}


svo.restore.anyoneortwolimbsprone = {
  desc = &quot;Use restore if one or two limbs are crippled (and no more), prone, and you're off salve/tree balance&quot;,

  function ()
    if not svo.affl.prone then return false end

    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}

svo.restore.riftlock = {
  desc = &quot;Use restore on riftlocks&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}


svo.restore.stainlock = {
  desc = &quot;Use restore to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()
    return svo.me.locks.stain and (affs.crippledleftarm or affs.crippledrightarm) -- don't restore if we can't restore anything useful.
  end
}

-- restore if we have 3+ limbs damaged and at least one of them is curable with restore
svo.restore.maybevivi = {
  desc = &quot;Use restore if you have 3+ limbs damaged and at least one of them is curable with restore&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}
</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Dragonheal curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.dragonheal = svo.dragonheal or {}

svo.dragonheal.riftlock = {
  desc = &quot;Use dragonheal on riftlocks&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.dragonheal.aeon = {
  desc = &quot;Use dragonheal to cure aeon when we have asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.dragonheal.hardlock = {
  desc = &quot;Use dragonheal to cure hard locks (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()

    return svo.me.locks.hard
  end
}

svo.dragonheal.stainlock = {
  desc = &quot;Use dragonheal to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()

    return svo.me.locks.stain
  end
}

-- dragonheal if we have 3+ limbs damaged and at least one of them is curable with dragonheal
svo.dragonheal.maybevivi = {
  desc = &quot;Use dragonheal in a situation when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with dragonheal&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Shrugging curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.shrugging = svo.shrugging or {}

-- desc should should assume it starts with 'Scenarios to use shrugging in:'
svo.shrugging.riftlock = {
  desc = &quot;when you're riftlocked&quot;,

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.shrugging.aeon = {
  desc = &quot;when we have aeon with asthma or mucous&quot;,

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.shrugging.hardlock = {
  desc = &quot;when we have a hard lock (asthma, anorexia, slickness, and can't focus)&quot;,

  function ()
    return svo.me.locks.hard
  end
}

svo.shrugging.stainlock = {
  desc = &quot;when we have a stain lock (stain, slickness, broken arm and empty valerian/realgar pipe)&quot;,

  function ()
    return svo.me.locks.stain
  end
}

svo.shrugging.any2affs = {
  desc = &quot;when we've got at least two shruggable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.shrugging.any3affs = {
  desc = &quot;when we've got at least three shruggable afflictions&quot;,

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

-- shrugging if we have 3+ limbs damaged and at least one of them is curable with shrugging
svo.shrugging.maybevivi = {
  desc = &quot;when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with shrugging&quot;,

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Rage curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.rage = svo.rage or {}

svo.rage.any2affs = {
  desc = &quot;Use rage when we've got at least two afflictions and one of them is rage-curable&quot;,

  function ()
    return table.size(svo.affl) &gt;= 2
  end
}

svo.rage.any3affs = {
  desc = &quot;Use rage when we've got at least three afflictions and one of them is rage-curable&quot;,

  function ()
    return table.size(svo.affl) &gt;= 3
  end
}</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Fitness curing strats</name>
                <packageName></packageName>
                <script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.fitness = svo.fitness or {}

svo.fitness.anylock = {
  desc = &quot;Use fitness if we've got any locks we can use fitness to cure out of&quot;,

  function ()
    return (svo.me.locks.soft and not svo.doing&quot;focus&quot;) or svo.me.locks.venom or svo.me.locks.hard or
            svo.me.locks.rift or svo.me.locks[&quot;rift 2&quot;] or svo.me.locks.slow or svo.me.locks[&quot;true&quot;]
  end
}

svo.fitness.asthmainaeon = {
  desc = &quot;Use fitness if we've got asthma in aeon&quot;,

  function ()
    return svo.affl.asthma and svo.affl.aeon
  end
}

svo.fitness.hellsightconc = {
  desc = &quot;Use fitness if we've got hellsight and a concussion&quot;,

  function ()
    return svo.affl.hellsight and (svo.affl.mildconcussion or svo.affl.seriousconcussion)
  end
}</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo.isenemy</name>
                <packageName></packageName>
                <script>function svo.isenemy(name)
  return (target and target:lower():starts(name:lower())) or ndb.isenemy(name)
end</script>
                <eventHandlerList/>
            </Script>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Custom prompt tags</name>
                <packageName></packageName>
                <script></script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>@affs</name>
                    <packageName></packageName>
                    <script>--[[ Iocuns prompt aff thingy from http://forums.achaea.com/index.php?showtopic=39543&amp;view=findpost&amp;p=1283964, taken with permission ]]
--[[ to use in a custom prompt, use the @paracelsus_affs_customtag tag ]]
--[[ this is now used by default in Svo ]]
local aff_abbrev = {
  ablaze              = &quot;abl&quot;,
  addiction           = &quot;add&quot;,
  aeon                = &quot;ae&quot;,
  agoraphobia         = &quot;agor&quot;,
  airdisrupt          = &quot;adsr&quot;,
  anorexia            = &quot;ano&quot;,
  asleep              = &quot;asl&quot;,
  asthma              = &quot;ast&quot;,
  blackout            = &quot;&quot;,
  bleeding            = &quot;bld&quot;,
  blindaff            = &quot;blind&quot;,
  bound               = &quot;bound&quot;,
  burning             = &quot;burn&quot;,
  charredburn         = &quot;4burn&quot;,
  cholerichumour      = &quot;choH&quot;,
  claustrophobia      = &quot;clau&quot;,
  clumsiness          = &quot;cl&quot;,
  confusion           = &quot;con&quot;,
  corrupted           = &quot;corr&quot;,
  crackedribs         = &quot;cr&quot;,
  crippledleftarm     = &quot;la1&quot;,
  crippledleftleg     = &quot;ll1&quot;,
  crippledrightarm    = &quot;ra1&quot;,
  crippledrightleg    = &quot;rl1&quot;,
  darkshade           = &quot;dark&quot;,
  deadening           = &quot;dea&quot;,
  deafaff             = &quot;deaf&quot;,
  degenerate          = &quot;deg&quot;,
  dehydrated          = &quot;deh&quot;,
  dementia            = &quot;dem&quot;,
  depression          = &quot;dep&quot;,
  deteriorate         = &quot;det&quot;,
  disloyalty          = &quot;disl&quot;,
  disrupt             = &quot;disr&quot;,
  dissonance          = &quot;disso&quot;,
  dizziness           = &quot;diz&quot;,
  earthdisrupt        = &quot;edsr&quot;,
  epilepsy            = &quot;epi&quot;,
  extremeburn         = &quot;3burn&quot;,
  fear                = &quot;fear&quot;,
  firedisrupt         = &quot;fdsr&quot;,
  frozen              = &quot;frz&quot;,
  generosity          = &quot;gen&quot;,
  haemophilia         = &quot;haem&quot;,
  hallucinations      = &quot;hall&quot;,
  hamstring           = &quot;hms&quot;,
  hatred              = &quot;htr&quot;,
  healthleech         = &quot;hthl&quot;,
  heartseed           = &quot;heart&quot;,
  hellsight           = &quot;hell&quot;,
  hypersomnia         = &quot;hypers&quot;,
  hypochondria        = &quot;hypoch&quot;,
  icing               = &quot;ice&quot;,
  illness             = &quot;ill&quot;,
  impaled             = &quot;impale&quot;,
  impatience          = &quot;impat&quot;,
  justice             = &quot;just&quot;,
  laceratedthroat     = &quot;lac2&quot;,
  lethargy            = &quot;let&quot;,
  loneliness          = &quot;lon&quot;,
  lovers              = &quot;lust&quot;,
  madness             = &quot;mad&quot;,
  mangledleftarm      = &quot;la2&quot;,
  mangledleftleg      = &quot;ll2&quot;,
  mangledrightarm     = &quot;ra2&quot;,
  mangledrightleg     = &quot;rl2&quot;,
  masochism           = &quot;maso&quot;,
  melancholichumour   = &quot;melaH&quot;,
  meltingburn         = &quot;5burn&quot;,
  mildconcussion      = &quot;h1&quot;,
  mildtrauma          = &quot;t1&quot;,
  mutilatedleftarm    = &quot;la3&quot;,
  mutilatedleftleg    = &quot;ll3&quot;,
  mutilatedrightarm   = &quot;ra3&quot;,
  mutilatedrightleg   = &quot;rl3&quot;,
  nausea              = &quot;nau&quot;,
  ninkharsag          = &quot;nkh&quot;,
  numbedleftarm       = &quot;nbla&quot;,
  numbedrightarm      = &quot;nbra&quot;,
  pacifism            = &quot;pac&quot;,
  paradox             = &quot;para&quot;,
  paralysis           = &quot;par&quot;,
  paranoia            = &quot;prn&quot;,
  parasite            = &quot;prs&quot;,
  peace               = &quot;pea&quot;,
  phlegmatichumour    = &quot;phleH&quot;,
  phlogistication     = &quot;phlog&quot;,
  pinshot             = &quot;psh&quot;,
  prone               = &quot;pr&quot;,
  recklessness        = &quot;reck&quot;,
  relapsing           = &quot;scy&quot;,
  retardation         = &quot;ret&quot;,
  retribution         = &quot;reb&quot;,
  roped               = &quot;rop&quot;,
  sanguinehumour      = &quot;sanH&quot;,
  selarnia            = &quot;sel&quot;,
  sensitivity         = &quot;sen&quot;,
  seriousconcussion   = &quot;h2&quot;,
  serioustrauma       = &quot;t2&quot;,
  severeburn          = &quot;2burn&quot;,
  shadowmadness       = &quot;sham&quot;,
  shivering           = &quot;shiv&quot;,
  shyness             = &quot;shy&quot;,
  skullfractures      = &quot;sf&quot;,
  slashedthroat       = &quot;lac1&quot;,
  slickness           = &quot;sli&quot;,
  spiritdisrupt       = &quot;sdsr&quot;,
  stain               = &quot;sta&quot;,
  stupidity           = &quot;st&quot;,
  stuttering          = &quot;stut&quot;,
  swellskin           = &quot;swsk&quot;,
  timeflux            = &quot;tfx&quot;,
  timeloop            = &quot;tlp&quot;,
  torntendons         = &quot;tt&quot;,
  transfixed          = &quot;transf&quot;,
  unconsciousness     = &quot;unconc&quot;,
  unknownany          = &quot;?&quot;,
  unknowncrippledarm  = &quot;uwna&quot;,
  unknowncrippledleg  = &quot;uwnl&quot;,
  unknowncrippledlimb = &quot;uwcrip&quot;,
  unknowncure         = &quot;uc&quot;,
  unknownmental       = &quot;?&quot;,
  vertigo             = &quot;vert&quot;,
  vitrification       = &quot;vitri&quot;,
  voided              = &quot;void&quot;,
  voyria              = &quot;voy&quot;,
  waterdisrupt        = &quot;wdsr&quot;,
  weakness            = &quot;wea&quot;,
  webbed              = &quot;web&quot;,
  wristfractures      = &quot;wf&quot;,
}

-- recoded, it's quicker by a third
function paracelsus_affs_customtag2()
  if next(svo.affl) then
    local s, type = {}, type
    for k,v in pairs(svo.affl) do
        if (k == &quot;unknownany&quot; or k == &quot;unknownmental&quot;) and (type(v) == 'table') then
          s[#s+1] = (&quot;?&quot;):rep(v.count)
        elseif k == &quot;bleeding&quot; and type(v) == 'table' then
          if v.count &gt;= svo.conf.bleedamount then
            s[#s+1] = string.format(&quot;bld(%d)&quot;, v.count)
          end
       elseif k == &quot;lovers&quot; and type(v) == 'table' then
          s[#s+1] = string.format(&quot;lust(%s)&quot;, svo.oneconcat(svo.affl.lovers.names))
        elseif type(v) == 'table' and v.count then
          s[#s+1] = (aff_abbrev[k] or k)..'('..v.count..')'
        else
          s[#s+1] = (aff_abbrev[k] or k)
        end
    end
    return #s &gt; 0 and (&quot;&lt;IndianRed&gt;[&quot;..table.concat(s, &quot; &quot;)..&quot;]&quot;) or &quot;&quot; -- don't display just [] b/c of bleeding
  else
    return &quot;&quot;
  end
end

registerAnonymousEventHandler(&quot;svo system loaded&quot;, function()
  svo.adddefinition(&quot;@paracelsus_affs_customtag&quot;, &quot;paracelsus_affs_customtag2()&quot;)
  svo.adddefinition(&quot;@affs&quot;, &quot;paracelsus_affs_customtag2()&quot;)
  
  svo.adddefinition(&quot;@target&quot;, &quot;target&quot;)
end)</script>
                    <eventHandlerList/>
                </Script>
                <Script isActive="yes" isFolder="no">
                    <name>@exits</name>
                    <packageName></packageName>
                    <script>svo.cpp = svo.cpp or {}

function svo.cpp.show_exits()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return &quot;&quot; end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, &quot;|&quot;)
end


function svo.cpp.show_exits_caps()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return &quot;&quot; end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, &quot;|&quot;):upper()
end

registerAnonymousEventHandler(&quot;svo system loaded&quot;, function()
  svo.adddefinition(&quot;@exits&quot;, &quot;svo.cpp.show_exits()&quot;)
  svo.adddefinition(&quot;@EXITS&quot;, &quot;svo.cpp.show_exits_caps()&quot;)
end)</script>
                    <eventHandlerList/>
                </Script>
            </ScriptGroup>
            <Script isActive="yes" isFolder="no">
                <name>svo_autoslickprio</name>
                <packageName></packageName>
                <script>function svo_autoslickprio(_, balance)
  if not svo.conf.autoslick then return end
  if balance ~= 'herb' then return end
  if not (svo.affl.slickness and svo.affl.asthma) and not svo.swapped_asthma then return end

  -- see if we need to swap it back
  if svo.swapped_asthma then
    if not svo.affl.slickness or not svo.affl.asthma then
      -- all good now? undo change
      svo.prio_swap(&quot;asthma&quot;, &quot;herb&quot;, svo.swapped_asthma)
      svo.swapped_asthma = nil
      echo'\n' svo.echof(&quot;Swapped asthma priority back down.&quot;)
      return
    end
  end

  -- don't have any more affs than this? Then asthma will get cured, so we're fine
  if table.size(svo.affl) &lt;= 2 then return end

  local asthma_prio = svo.prio.getnumber(&quot;asthma&quot;, &quot;herb&quot;)
  local paralysis_prio = svo.prio.getnumber(&quot;paralysis&quot;, &quot;herb&quot;)
  local impatience_prio = svo.prio.getnumber(&quot;impatience&quot;, &quot;herb&quot;)

  -- see if it's not highest
  if asthma_prio &gt; paralysis_prio and asthma_prio &gt; impatience_prio then return end

  local currentmax = svo.prio.gethighest(&quot;herb&quot;)

  svo.prio_swap(&quot;asthma&quot;, &quot;herb&quot;, currentmax+1)
  svo.swapped_asthma = asthma_prio
  echo'\n' svo.echof(&quot;emergency - have asthma+slickness and paralysis/impatience prio is before asthma: swapping asthma to be cured first.&quot;)
end</script>
                <eventHandlerList>
                    <string>svo got balance</string>
                    <string>svo lost aff</string>
                    <string>svo got aff</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo_onimportant_aff</name>
                <packageName></packageName>
                <script>local bigboxaffs = {&quot;serioustrauma&quot;, &quot;mildtrauma&quot;, &quot;mildconcussion&quot;, &quot;seriousconcussion&quot;, &quot;mutilatedleftarm&quot;, &quot;mutilatedleftleg&quot;, &quot;mutilatedrightarm&quot;, &quot;mutilatedrightleg&quot;, &quot;mangledleftarm&quot;, &quot;mangledleftleg&quot;, &quot;mangledrightarm&quot;, &quot;mangledrightleg&quot;}
local bigboxaffs_t = {}; for i = 1, #bigboxaffs do bigboxaffs_t[bigboxaffs[i]] = true end

function svo_onimportant_aff(_, which)
  if bigboxaffs_t[which] then
    svo.boxDisplay(&quot;afflicted w/ &quot;..which, &quot;black:DarkOrange&quot;)
  end
end</script>
                <eventHandlerList>
                    <string>svo got aff</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo.autopause_on_def</name>
                <packageName></packageName>
                <script>function svo.autopause_on_def(event, def)
  if (def == &quot;blackwind&quot; or def == &quot;astralform&quot;) and event == &quot;svo got def&quot; then
    if svo.conf.paused then svo.dont_unpause_for_bw = true
    else svo.app(&quot;on&quot;) end
  elseif (def == &quot;blackwind&quot; or def == &quot;astralform&quot;) and event == &quot;svo lost def&quot; then
    if not svo.dont_unpause_for_bw then svo.app(&quot;off&quot;) end
    svo.dont_unpause_for_bw = nil
  end
end</script>
                <eventHandlerList>
                    <string>svo got def</string>
                    <string>svo lost def</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo.sitting</name>
                <packageName></packageName>
                <script>-- handles getting up after a manual sit
function svo.sitting(_, aff)
  if aff ~= &quot;prone&quot; then return end

  if svo.ignore.prone and svo.ignore.prone.because and svo.ignore.prone.because == &quot;you sat down&quot; then
    svo.ignore.prone = nil
    raiseEvent(&quot;svo ignore changed&quot;, &quot;prone&quot;)
  end
end</script>
                <eventHandlerList>
                    <string>svo lost aff</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo.sleeping</name>
                <packageName></packageName>
                <script>-- handles unignoring sleeping after waking up
function svo.sleeping(_, aff)
  if aff ~= &quot;sleep&quot; then return end

  if svo.ignore.sleep and svo.ignore.sleep.because and svo.ignore.sleep.because == &quot;you wanted to sleep&quot; then
    svo.ignore.sleep = nil
  end
end</script>
                <eventHandlerList>
                    <string>svo lost aff</string>
                </eventHandlerList>
            </Script>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>svo Meteor Compress</name>
                <packageName></packageName>
                <script>function svo.updatemeteors()
  deleteLine()
  svo.prompttrigger(&quot;compress meteors&quot;, svo.showmeteors)
end

local function concatmap(tbl)
  local t = {}
  for k,v in pairs(tbl) do
    t[#t+1] = v..&quot; on &quot;..k
  end
  return svo.concatand(t)
end

function svo.showmeteors()
  local t = {}
  if svo.meteors.justlaunched then
    t[#t+1] = string.format(&quot;%d launched&quot;, svo.meteors.justlaunched)
  end
  if svo.meteors.justlaunchedmine then
    t[#t+1] = &quot;plus your meteor&quot;
  end
  if svo.meteors.headingin then
    t[#t+1] = string.format(&quot;%d heading to you&quot;, svo.meteors.headingin)
  end
  if svo.meteors.headingout then
    t[#t+1] = string.format(&quot;%d going elsewhere&quot;, svo.meteors.headingout)
  end
  if svo.meteors.brokeshield then
    t[#t+1] = svo.meteors.brokeshield.. &quot; broke your shield&quot;
  end
  if svo.meteors.hityou then
    t[#t+1] = string.format(&quot;%s hit you&quot;, svo.concatand(svo.meteors.hityou))
  end
  if svo.meteors.brokeshieldother then
    t[#t+1] = string.format(&quot;shield broke on: %s&quot;, concatmap(svo.meteors.brokeshieldother))
  end
  if svo.meteors.hitanother then
    t[#t+1] = string.format(&quot;meteors hit: %s&quot;, concatmap(svo.meteors.hitanother))
  end
  if svo.meteors.fellelsewhere then
    t[#t+1] = string.format(&quot;%d hit no-one&quot;, svo.meteors.fellelsewhere)
  end

  svo.echof(&quot;&lt;255,0,0&gt;meteors%s: %s&quot;, svo.getDefaultColor(), svo.concatand(t))
  svo.meteors = nil
end</script>
                <eventHandlerList/>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>commandTracker</name>
                <packageName></packageName>
                <script>lastCommands = lastCommands or {}

function commandTracker(_,what)
   local howMany = 5
   what = what:lower():gsub(&quot;^%s+&quot;,&quot;&quot;)
   table.insert(lastCommands, 1, what)
   table.remove(lastCommands, howMany+1)
end

function commandCheck(what)
   local found = false
   for k,v in ipairs(lastCommands) do
      if v:find(stupidityCheckTable[what]) then
         found = true
      end
   end
   return found
end

stupidityCheckTable = {
	[&quot;You waggle your eyebrows comically.&quot;]                                                                             = &quot;^waggle&quot;,
	[&quot;You blink.&quot;]                                                                                                      = &quot;^blink&quot;,
	[&quot;You twitch spasmodically.&quot;]                                                                                       = &quot;^twitch&quot;,
	[&quot;As horrible thoughts fill your mind, you begin to sob uncontrollably.&quot;]                                           = &quot;^sob&quot;,
	[&quot;You hug yourself compassionately.&quot;]                                                                               = &quot;^hug&quot;,
	[&quot;My friend, clearly you know little of the sultry tango, if you think that you can perform it without a partner.&quot;] = &quot;^tango&quot;,
	[&quot;Your mind is whirling with thoughts - you cannot settle down to sleep.&quot;]                                          = &quot;^sleep&quot;,
	[&quot;You get down on one knee and serenade the world.&quot;]                                                                = &quot;^serenade&quot;,
	[&quot;You make a strangled meowing noise and quickly shut up in embarrassment.&quot;]                                        = &quot;^meow&quot;,
	[&quot;You burp obscenely.&quot;]                                                                                             = &quot;^burp&quot;,
	[&quot;You flap your arms madly.&quot;]                                                                                       = &quot;^flap&quot;,
	[&quot;You wouldn't want to drink a salve. It would not be tasty at all.&quot;]                                               = &quot;^sip&quot;,
	[&quot;Tears fill your eyes and begin to slowly run down your face.&quot;]                                                    = &quot;^cry&quot;,
	[&quot;You drop to one knee, demonstrating your humility and respect.&quot;]                                                  = &quot;^kneel&quot;,
	[&quot;You pick your nose absently.&quot;]                                                                                    = &quot;^picknose&quot;,
	[&quot;You wail like an old woman.&quot;]                                                                                     = &quot;^wail&quot;,
	[ [[You grunt a bit and then let out a loud &quot;OINK!&quot;]] ]                                                             = &quot;^oink&quot;,
	[ [[You let out a loud, long &quot;MOOOOOOOOOOO!&quot;]] ]                                                                    = &quot;^moo&quot;,
	[ [[&quot;The voices! The voices! Get them out of my head!!&quot; you moan, holding your head in pain.]] ]                    = &quot;^voices&quot;,
	[&quot;You stumble and poke yourself in the eye.&quot;]                                                                       = &quot;^poke&quot;,
	[&quot;Your mind is whirling with thoughts - you cannot settle down to sleep.&quot;]                                          = &quot;^sleep&quot;,
}</script>
                <eventHandlerList>
                    <string>sysDataSendRequest</string>
                </eventHandlerList>
            </ScriptGroup>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Check for system updates</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>svo_downloaded_file</name>
                <packageName></packageName>
                <script>function svo_downloaded_file(_, filename)
  -- is the file that downloaded our oursystem?

  if filename == tostring(svo.versionfile) then
    svo.checkingupdates = false

    local s = io.open(filename):read(&quot;*a&quot;)
    if svo.version == s:trim() then
      if svo.announceupdates == &quot;checking&quot; then
        svo.announceupdates = nil
        svo.echof(&quot;You're all good! Latest version is %s and you're on it.&quot;, svo.version)
      end
      return
    end

    -- new version? See if we've already downloaded it, if not, do so
    local f = io.open(getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;)

    local writtenversion

    -- new version file can not exist if we didn't download a system previously
    if f then
      writtenversion = f:read(&quot;*a&quot;)
    end

    if not writtenversion or writtenversion:trim() ~= s:trim() or not lfs.attributes(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)) then
      if svo.announceupdates == &quot;checking&quot; then svo.echof(&quot;A new Svof is available! You're on %s, latest is %s. I'll download it for you.&quot;, svo.version, s:trim()) end
      svo.downloadnewsystem(s:trim())
    else
      if svo.announceupdates == &quot;checking&quot; then svo.echof(&quot;A new Svof is available and has been downloaded for you! You're on %s, latest is %s.&quot;, svo.version, s:trim()) end
      svo.showupdatereminder(writtenversion)
    end

  elseif filename == tostring(svo.downloadedsystem) then
    svo.checkingupdates = false

    -- got new zip? make sure it's valid, Dropbox likes to mess with us.
    local f = io.open(filename)
    if not f or f:read(&quot;*a&quot;):find(&quot;302 Found&quot;) then
      -- don't loop downloading forever
      if not svo.downloadretries or svo.downloadretries &lt;= (svo.maxdownloadretries or 5) then
        svo.downloadnewsystem(svo.newdownloadedversion)
        svo.downloadretries = (svo.downloadretries or 0) + 1
        svo.echof(&quot;Bah. I downloaded the new system, but Dropbox wigged out and didn't actually send us a new zip but an error message. Going to try downloading it again%s.&quot;,
          (svo.downloadretries == 1 and &quot;&quot; or &quot; (attempt &quot;..svo.downloadretries..&quot; out of &quot;..(svo.maxdownloadretries or 5)..&quot;)&quot;))
      else
        svo.echof(&quot;Giving up. Dropbox keeps refusing to give us a working zip. Try downloading and upgrading manually; uninstall Svo in the Package Manager and install the new zip from there.&quot;)
      end

      if f then f:close() end
      return
    end

    -- cleanup
    if f then f:close() end
    if svo.downloadretries then
      svo.downloadretries = nil
      svo.echof(&quot;OK, got a working zip now that we can install!&quot;)
    end

    -- downloaded a new system zip? Save its version in a file, so on restart if the person hasn't updated, we can poke them about it
    local f,err = io.open(getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;, &quot;w&quot;)
    if not f then return svo.echof(&quot;Couldn't write to the new version file, because: &quot;..err) end
    f:write(svo.newdownloadedversion)
    f:close()

    svo.showupdatereminder(svo.newdownloadedversion)
  end
end</script>
                <eventHandlerList>
                    <string>sysDownloadDone</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Check for updates</name>
                <packageName></packageName>
                <script>local downloadfolder = getMudletHomeDir()..&quot;/svo/downloads/&quot;

-- this should get called at start and every hour after that
function svo.checkforupdate(type)
  local baseUrl = string.format(&quot;http://svof.github.io/svof/%s/&quot;, svo.conf.releasechannel)
  
	if svo.checkingupdates then return end
  svo.versionfile = downloadfolder..&quot;svo_version&quot;

  if not downloadFile then
    svo.echof(&quot;Your version of Mudlet doesn't support downloading files - please upgrade to 2.0+&quot;)
  else
    if not lfs.attributes(downloadfolder) then
      if lfs and lfs.mkdir then
         local t,s = lfs.mkdir(downloadfolder)
         if not t and s ~= &quot;File exists&quot; then svo.echof(&quot;Couldn't make the '&quot;..downloadfolder..&quot;' folder; &quot;..s) return end
      else
        svo.echof(&quot;Sorry, but you need LuaFileSystem (lfs) installed, or have the '&quot;..downloadfolder..&quot;' folder exist.&quot;)
        return
      end
    end

    svo.checkingupdates = true
    downloadFile(svo.versionfile, baseUrl .. &quot;current_version.txt&quot;)

    if type == &quot;checking&quot; then
      svo.echof(&quot;Checking for updates...&quot;)
      svo.announceupdates = &quot;checking&quot;
    elseif type == &quot;force&quot; then
      svo.echof(&quot;(re)downloading latest system...&quot;)
      svo.announceupdates = &quot;force&quot;
      svo.version = 0


      local location = getMudletHomeDir()..&quot;/svo/downloads/available_version&quot;
      if io.exists(location) then
        local s,m = os.remove(location)
        if not s then svo.echof(&quot;Couldn't remove the %s file (error was: %s) - this might be a problem.&quot;, location, m) end
      end

      location = downloadfolder..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)
      if io.exists(location) then
        local s,m = os.remove(location)
        if not s then svo.echof(&quot;Couldn't delete the old svo zip (located at %s), because of: %s. This might be a problem.&quot;, location, m) end
      end
    else
      svo.announceupdates = nil
    end
  end
end

-- downloads the system &amp; updates the system version saved
function svo.downloadnewsystem(newversion)
  local baseUrl = string.format(&quot;http://svof.github.io/svof/%s/&quot;, svo.conf.releasechannel)
  
	svo.downloadedsystem = downloadfolder..string.format(&quot;%s.Svof.current.zip&quot;, svo.me.class)
  local downloadurl = baseUrl..svo.me.class..[[.Svof.v]]..newversion..[[.zip]]

  downloadFile(svo.downloadedsystem, downloadurl)
  svo.newdownloadedversion = newversion
end</script>
                <eventHandlerList/>
                <Script isActive="yes" isFolder="no">
                    <name>svo_checkupdatestart</name>
                    <packageName></packageName>
                    <script>function svo_checkupdatestart()
  svo.checkforupdate()
end</script>
                    <eventHandlerList>
                        <string>svo system loaded</string>
                    </eventHandlerList>
                </Script>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Update UI</name>
                <packageName></packageName>
                <script>function svo.showupdatereminder(newversion)
  svo.announceupdates = nil

  svo.updatelabel = svo.updatelabel or Geyser.Label:new({
    name = &quot;svo.updatelabel&quot;,
    x = &quot;-340px&quot;, y = &quot;-115px&quot;,
    width = &quot;320px&quot;, height = &quot;110px&quot;,
  })

  svo.doupdatelabel = svo.doupdatelabel or Geyser.Label:new({
    name = &quot;svo.doupdatelabel&quot;,
    x = &quot;25%&quot;, y = &quot;-30px&quot;,
    width = &quot;20%&quot;, height = &quot;20px&quot;,
  }, svo.updatelabel)

  svo.dontupdatelabel = svo.dontupdatelabel or Geyser.Label:new({
    name = &quot;svo.dontupdatelabel&quot;,
    x = &quot;55%&quot;, y = &quot;-30px&quot;,
    width = &quot;20%&quot;, height = &quot;20px&quot;,
  }, svo.updatelabel)

  -- grey to black shade, top to bottom
  svo.updatelabel:setStyleSheet([[
      margin: 0px;
      padding: 2px;

      /* Vertical gradient */
      background: qlineargradient(
          x1: 0, y1: 0, x2: 0, y2: 1,
          stop: 0 #3c3c3c, stop: 1 #232323
      );

      border: none;
      border-radius: 4px;

      color: #ffffff;

    qproperty-alignment: 'AlignTop | AlignHCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  svo.doupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: green;
    font-family: monospace;
  ]])

  svo.dontupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: grey;
    font-family: monospace;
  ]])

  svo.updatelabel:echo(string.format([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Hey, a new Svo (%s) has been downloaded and is available for install.&lt;br&gt;&lt;br&gt;Install and restart now, or install later?&lt;p&gt;]], newversion))

  svo.doupdatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Restart&lt;/p]])

  svo.dontupdatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Later&lt;/p]])

  svo.updatelabel:show()
  svo.doupdatelabel:show()
  svo.dontupdatelabel:show()

  svo.doupdatelabel:setClickCallback(&quot;svo_doupdate_click&quot;)
  svo.dontupdatelabel:setClickCallback(&quot;svo_dontupdate_click&quot;)
end

function svo_dontupdate_click()
  svo.updatelabel:hide()
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()
end

function svo_doupdate_click()
  svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Updating Svo...&lt;p&gt;]])
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()

  local class = svo.me.class

  if not (uninstallPackage and installPackage) then
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Can't update your Svo. You didn't update to Mudlet 2.1, and your current Mudlet lacks the features necessary. Go update first please.&lt;p&gt;]])
    return
  end

  if not io.exists(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class)) then
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Hm, can't update Svo - seems the new system we downloaded dissapeared. Do 'vupdate force' to download it again.&lt;p&gt;]])
    return
  end

  function svo_update_system()
    svo_updating_system = &quot;uninstalling&quot;
    uninstallPackage(class..&quot; svo&quot;)

    svo_updating_system = &quot;installing&quot;
    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Uninstalled the old Svo, installing the new one now...&lt;p&gt;]])
    installPackage(getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class))

    svo_updating_system = nil
    svo.echof(&quot;Svo updated! Restart Mudlet, and you'll be all done. You can find the changelog on svof.pathurs.com/changelog.php&quot;)

    svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:10pt; color:white&quot;&gt;Svo updated!&lt;br&gt;&lt;br&gt;Restart Mudlet, and you'll be all done.&lt;p&gt;]])
    svo.updatelabel:setStyleSheet([[
        margin: 0px;
        padding: 2px;

        /* Vertical gradient */
        background: qlineargradient(
            x1: 0, y1: 0, x2: 0, y2: 1,
            stop: 0 #3c3c3c, stop: 1 #232323
        );

        border: none;
        border-radius: 4px;

        color: #ffffff;

      qproperty-alignment: 'AlignVCenter | AlignHCenter';
      qproperty-wordWrap: true;
      font-family: 'Ubuntu','Calibri',serif;
    ]])
  end

  svo_updating_system = &quot;started&quot;
  tempTimer(10, function()
    if not svo_updating_system then return end

    if svo_updating_system == &quot;uninstalling&quot; then
      svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Hm, seems the update got stuck on the uninstallPackage() function. Try uninstalling Svo from the Package Manager and then installing it from the zip (found in ]].. getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class) ..[[) to upgrade now.&lt;p&gt;]])
    elseif svo_updating_system == &quot;installing&quot; then
      svo.updatelabel:echo([[&lt;p align=&quot;center&quot; style=&quot;font-size:8pt; color:white&quot;&gt;Hm, seems the update got stuck on the installPackage() function. Old Svo is uninstalled, but it the new one didn't get installed - install your Svo zip (found in ]].. getMudletHomeDir()..&quot;/svo/downloads/&quot;..string.format(&quot;%s.Svof.current.zip&quot;, class) ..[[ via the Package Manager.&lt;p&gt;]])
    end
  end)
  svo_update_system()
end</script>
                <eventHandlerList/>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>Examples</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Use of got/lost aff/def events</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="no" isFolder="no">
                    <name>svo_example_affs</name>
                    <packageName></packageName>
                    <script>-- Act on lost/gained affs
-- can be used, for example, to stop an instakill if you've gotten hindered - unpause system, unpause offense, etc.
-- must have vconfig eventaffs on
function svo_example_affs(eventname, data)
	svo.echof(&quot;Event: %s, data: %s&quot;, eventname, data)
--	tempTimer(0, function() svo.echof(&quot;Event: %s, data: %s&quot;, eventname, data) end)
end</script>
                    <eventHandlerList>
                        <string>svo got aff</string>
                        <string>svo lost aff</string>
                        <string>svo got def</string>
                        <string>svo lost def</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>affs display window</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="no" isFolder="no">
                    <name>svo_update_window</name>
                    <packageName></packageName>
                    <script>-- delete the line below and enable vconfig eventaffs plus this script for this demo to work!
if true or not Geyser then return end

local affslabel

local main = Geyser.Container:new({x=0,y=0,width=&quot;100%&quot;,height=&quot;100%&quot;,name=&quot;affslabelcontainer&quot;})

affslabel = Geyser.Label:new({  name = &quot;affslabel&quot;,
                               x = &quot;87%&quot;, y = &quot;80%&quot;,
                               width = &quot;11%&quot;, height = &quot;17%&quot;},
                               main)
-- this sets the colour of the whole label to greenish
affslabel:setColor(100,155,0,127)

local function highlight(name)
	if not svo.ignore[name] then return name else
	return string.format([[&lt;span style=&quot;color:yellowgreen&quot;&gt;%s&lt;/span&gt;]], name) end
end

function svo_update_window()
local s = {}
	if not affslabel then return end

	for name, namet in pairs(svo.affl) do
		if name ~= &quot;deaf&quot; and name ~= &quot;blind&quot; then
			if type(namet) == &quot;table&quot; and namet.count then
				s[#s+1] = string.format(&quot;%s (%d)&quot;, highlight(name), namet.count)
			else
				s[#s+1] = highlight(name)
			end
		end
	end
	affslabel:echo([[&lt;span style=&quot;color:white&quot;&gt;]].. table.concat(s, &quot;&lt;br&gt;&quot;) ..&quot;&lt;/span&gt;&quot;)
end</script>
                    <eventHandlerList>
                        <string>svo got aff</string>
                        <string>svo lost aff</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <Script isActive="no" isFolder="no">
                <name>Customize_systems_echos</name>
                <packageName></packageName>
                <script>-- sample custom echo! Feel free to change the 'demo' name, so you can do 'vconfig echotype &lt;name&gt;'.

-- to edit this, mode this script outside of Svo - doesn't matter if it's before or after Svo scripts
-- then do 'vshow colors' to select your new colour scheme

-- this does take #'s for colours, not words - http://colorschemedesigner.com might help you in
-- selecting the hex colour code and then use http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
-- to convert it to the 3 RGB colours
function Customize_systems_echos()
if not (svo and svo.echos) then return end

-- this does the (svo): blah-style echoes
function svo.echos.demo(newline, what)
  decho(&quot;&lt;80,66,80&gt;(&lt;107,79,125&gt;svo&lt;80,66,80&gt;)&lt;87,85,89&gt;: &lt;159,128,180&gt;&quot; .. what)
  if newline then echo&quot;\n&quot; end
end

-- this is the default color of the text in (svo): &lt;this colour here&gt;, so keep it consistent
-- with the last colour used above
function svo.echosd.demo()
  return &quot;&lt;159,128,180&gt;&quot;
end

end

-- this is so editing the scheme after loading works
Customize_systems_echos()</script>
                <eventHandlerList>
                    <string>svo system loaded</string>
                </eventHandlerList>
            </Script>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Display afflictions on prompt demo</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="no" isFolder="no">
                    <name>mm_display_affs</name>
                    <packageName></packageName>
                    <script>-- just shows how to suffix affs to the prompt so you know

function mm_display_affs()
	-- put two dashes before the line below so this function will work!
	if true then return end

	-- this if/elseif chain will append one aff at a time only
	if svo.affl.prone then
		echo(&quot;[[PRONE]] &quot;)
	elseif svo.affl.paralysis then
		echo(&quot;[[PARALYSIS]] &quot;)
	elseif svo.affl.crippledleftleg then
		echo(&quot;[[CRIPPLED LEFTLEG]] &quot;)
	end

	-- these stand-alone ifs will allow for several affs to be suffixed
	if svo.affl.crippledrightleg then
		echo(&quot;[[CRIPPLED RIGHT LEG]] &quot;)
	end

	if svo.affl.tangled then
		echo(&quot;[[TANGLED]] &quot;)
	end
end</script>
                    <eventHandlerList>
                        <string>svo done with prompt</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
            <ScriptGroup isActive="yes" isFolder="yes">
                <name>Show which affs you got/lost w/ times and count (by Lynara)</name>
                <packageName></packageName>
                <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
                <eventHandlerList/>
                <Script isActive="no" isFolder="no">
                    <name>MyAffs</name>
                    <packageName></packageName>
                    <script>-- made by Lynara

svo.stopWatches = svo.stopWatches or {}
function MyAffs(eventname, data)
   local default = svo.getDefaultColor()
   if eventname == &quot;svo got aff&quot; then
      svo.stopWatches[data] = svo.affl[data] and svo.affl[data].sw or 0
      svo.echof(&quot;Got aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;170,0,0&gt;%s%s affs&lt;210,210,210&gt;)&quot;, data, table.size(svo.affl), default )
   else
      svo.echof([[Lost aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;0,210,0&gt;%s%ssec&lt;210,210,210&gt;) (&lt;170,0,0&gt;%s%s left&lt;210,210,210&gt;)]],
 data, getStopWatchTime(svo.stopWatches[data]), default, table.size(svo.affl), default)
   end
end</script>
                    <eventHandlerList>
                        <string>svo got aff</string>
                        <string>svo lost aff</string>
                    </eventHandlerList>
                </Script>
            </ScriptGroup>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>svo Time Tracking</name>
            <packageName></packageName>
            <script>svo.me = svo.me or {}
svo.me.time = svo.me.time or {
  h = 0, m = 0,
  tictimer = false,
  min2s = 2.5
}

function svo.sync_time(hour)
  svo.me.time.h, svo.me.time.m = hour, 0
  if svo.me.time.tictimer then killTimer(svo.me.time.tictimer) end

  svo.me.time.tictimer = tempTimer(svo.me.time.min2s - getNetworkLatency(), svo.tic_time)
end

function svo.tic_time()
  svo.me.time.m = svo.me.time.m + 1
  if svo.me.time.m &gt;= 60 then
    svo.me.time.h = svo.me.time.h + 1
    if svo.me.time.h &gt;= 24 then svo.me.time.h = 0 end

    svo.me.time.m = 0
  end

  svo.echof(&quot;It is now %.0d:%1d&quot;, svo.me.time.h, svo.me.time.m)
  svo.me.time.tictimer = tempTimer(svo.me.time.min2s, svo.tic_time)
end</script>
            <eventHandlerList/>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>svo Class Management</name>
            <packageName></packageName>
            <script>--[[ start of a class management (tn class/tn classonly) + class-specifics tricks ]]

svo.classes = {
  alchemist    = {fighting = false, skills = {&quot;transmutation&quot;, &quot;physiology&quot;, &quot;alchemy&quot;}},
  apostate     = {fighting = false, skills = {&quot;evileye&quot;, &quot;necromancy&quot;, &quot;apostasy&quot;}},
  bard         = {fighting = false, skills = {&quot;voicecraft&quot;, &quot;swashbuckling&quot;, &quot;harmonics&quot;}},
  blademaster  = {fighting = false, skills = {&quot;twoarts&quot;, &quot;striking&quot;, &quot;shindo&quot;}},
  depthswalker = {fighting = false, skills = {&quot;shadowmancy&quot;, &quot;aeonics&quot;, &quot;terminus&quot;}},
  dragon       = {fighting = false, skills = {&quot;dragoncraft&quot;}},
  druid        = {fighting = false, skills = {&quot;groves&quot;, &quot;metamorphosis&quot;, &quot;concoctions&quot;}},
  infernal     = {fighting = false, skills = {&quot;necromancy&quot;, &quot;chivalry&quot;, &quot;forging&quot;}},
  jester       = {fighting = false, skills = {&quot;tarot&quot;, &quot;pranks&quot;, &quot;puppetry&quot;}},
  magi         = {fighting = false, skills = {&quot;elementalism&quot;, &quot;crystalism&quot;, &quot;enchantment&quot;}},
  monk         = {fighting = false, skills = {&quot;tekura&quot;, &quot;kaido&quot;, &quot;telepathy&quot;}},
  occultist    = {fighting = false, skills = {&quot;occultism&quot;, &quot;tarot&quot;, &quot;domination&quot;}},
  paladin      = {fighting = false, skills = {&quot;chivalry&quot;, &quot;devotion&quot;, &quot;forging&quot;}},
  priest       = {fighting = false, skills = {&quot;spirituality&quot;, &quot;devotion&quot;, &quot;healing&quot;}},
  runewarden   = {fighting = false, skills = {&quot;runelore&quot;, &quot;chivalry&quot;, &quot;forging&quot;}},
  sentinel     = {fighting = false, skills = {&quot;metamorphosis&quot;, &quot;woodlore&quot;, &quot;concoctions&quot;}},
  serpent      = {fighting = false, skills = {&quot;subterfuge&quot;, &quot;venom&quot;, &quot;hypnosis&quot;}},
  shaman       = {fighting = false, skills = {&quot;spiritlore&quot;, &quot;curses&quot;, &quot;vodun&quot;}},
  sylvan       = {fighting = false, skills = {&quot;elementalism&quot;, &quot;groves&quot;, &quot;concoctions&quot;}},
}
-- keeps track of what skills are actually enabled
svo.enabledskills, svo.enabledclasses = svo.enabledskills or {}, svo.enabledclasses or {}

-- this is used before we're actually sure that we're fighting a class and not illusions
svo.maybefighting = svo.maybefighting or {}

function svo.enableclass(class)
  if not svo.classes[class] or svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) + 1
  end

  svo.enabledclasses[class] = true
  raiseEvent(&quot;svo enabled class&quot;, class)
end

function svo.disableclass(class)
  if not svo.classes[class] or not svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) - 1
    if svo.enabledskills[skill] &lt;= 0 then svo.enabledskills[skill] = nil end
  end

  svo.enabledclasses[class] = nil
  raiseEvent(&quot;svo disabled class&quot;, class)
end

function svo.enableallclasses()
  for class in pairs(svo.classes) do
    svo.enableclass(class)
  end
end

function svo.disableallclasses()
  for class in pairs(svo.classes) do
    svo.disableclass(class)
  end
end

-- once a class is enabled, maybefighting shouldn't be added, but the timer renewed
function svo.startedfighting(class, name)
  svo.valid.gothit(class, name) -- check for **ILLUSION**s
end</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>svo_show_classes</name>
                <packageName></packageName>
                <script>function svo_show_classes()
  if not next(svo.enabledclasses) then svo.echof(&quot;No class tricks are enabled.&quot;) return end

  local l = svo.keystolist(svo.enabledclasses)
  table.sort(l)
  svo.echof(&quot;Enabled tricks for: %s&quot;, svo.concatand(l))
end</script>
                <eventHandlerList>
                    <string>svo onshow</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo.registerhit</name>
                <packageName></packageName>
                <script>function svo.registerhit(_, class, name)
  if not svo.classes[class] or not svo.conf.autoclasses then return end

  if not svo.enabledclasses[class] then
    svo.maybefighting[class] = (svo.maybefighting[class] or 0) + 1

    tempTimer(svo.conf.classattackswithin, function()
      if svo.maybefighting[class] then
        svo.maybefighting[class] = svo.maybefighting[class] - 1
        if svo.maybefighting[class] &lt;= 0 then
          svo.maybefighting[class] = nil
        end
      end
    end)
  end

  -- enable if we got attacked enough
  if svo.maybefighting[class] and svo.maybefighting[class] &gt;= svo.conf.classattacksamount and not svo.enabledclasses[class] then
    svo.enableclass(class)
    svo.prompttrigger(&quot;enabled &quot;..class, function() svo.echof(&quot;Seems that we're fighting with %s - enabled class tricks.&quot;, string.title(class)) end)
  end

  -- start/renew timer
  if svo.classes[class].fighting then killTimer(svo.classes[class].fighting) end
  svo.classes[class].fighting = tempTimer(60*svo.conf.enableclassesfor, function()
    svo.classes[class].fighting = nil
    if not svo.enabledclasses[class] then return end

    svo.disableclass(class)
    if svo.stats.currenthealth ~= 0 then echo'\n' svo.echof(&quot;Don't think we're fighting with class %s anymore, disabled tricks.&quot;, string.title(class)) end
    svo.showprompt()
  end)
end</script>
                <eventHandlerList>
                    <string>svo got hit by</string>
                </eventHandlerList>
            </Script>
        </ScriptGroup>
        <ScriptGroup isActive="yes" isFolder="yes">
            <name>svo UI Experiments</name>
            <packageName></packageName>
            <script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
            <eventHandlerList/>
            <Script isActive="yes" isFolder="no">
                <name>Enable Comm</name>
                <packageName></packageName>
                <script>function svo_enableCommChannel()
	-- register after GMCP is enabled. gmod doesn't re-register atm on restart
    sendGMCP([[Core.Supports.Add [&quot;Comm.Channel 1&quot;] ]])
end</script>
                <eventHandlerList/>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>svo_captureChats</name>
                <packageName></packageName>
                <script>-- magical chat capture that doesn't require any triggers!
-- made for Svo
svo.ui = svo.ui or {}

function svo_captureChats()
    if not svo.ui.chat then return end

    tempLineTrigger(0,1,[[
        if isPrompt() then return end
		selectCurrentLine()
		copy()

		if string.starts(line, &quot;(Party)&quot;) then svo.ui.chat:Append(&quot;Party&quot;)
		else svo.ui.chat:Append(&quot;All&quot;) end
]])
end</script>
                <eventHandlerList>
                    <string>gmcp.Comm.Channel.Start</string>
                </eventHandlerList>
            </Script>
            <Script isActive="yes" isFolder="no">
                <name>Rift label dimensions</name>
                <packageName></packageName>
                <script>-- after editing this, do vshow herbstat to make it appear. To adjust the font size used, use vconfig herbstatsize #

-- if you'd like your changes to stay between Svo updates, move this script out of Svo's folder,
-- and make sure it is *after* Svo's folder after an update


svo.riftlabel = Geyser.Label:new({  name = &quot;svo.riftlabel&quot;,
                               x = -360, y = -166,
                               width = 355, height = 166})

if not svo.conf.riftlabel then svo.riftlabel:hide() end</script>
                <eventHandlerList/>
            </Script>
        </ScriptGroup>
        <Script isActive="yes" isFolder="no">
            <name>Load externals</name>
            <packageName></packageName>
            <script>--[[ svo system loader, made by Vadi ]]

if true then return end

local _sep
if string.char(getMudletHomeDir():byte()) == &quot;/&quot; then _sep = &quot;/&quot; else  _sep = &quot;\\&quot; end
require &quot;lfs&quot;

function svo_load()
  svo_load = function () end
  if package.loaded[&quot;svo&quot;] then return end

  -- loader for packages
  local foldername
  for item in lfs.dir(getMudletHomeDir()) do
    foldername = item:match(&quot;(%w+) svo&quot;)
    if foldername and lfs.attributes(getMudletHomeDir()..&quot;/&quot;..foldername..&quot; svo/svo&quot;) then
      local oldpath = package.path
      local system_path = getMudletHomeDir()..&quot;/&quot;..foldername..&quot; svo/&quot;
      package.path = system_path .. &quot;?;&quot; .. system_path .. &quot;?.lua;&quot; .. system_path .. &quot;?.dll;&quot; .. system_path .. &quot;?.so;&quot;

      local s,m = pcall(require, &quot;svo&quot;)
      package.path = oldpath

      if not s then display(m) return end

      svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
      echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.github.io/svof/&quot;', &quot;Svof homepage&quot;)
      decho(svo.getDefaultColor()..&quot;)\n&quot;)
      return
    end
  end

--[[  tempTimer(5, function()
    cecho(&quot;\n\n&lt;red&gt;Warning: &lt;cyan&gt;Svof couldn't be located. Please only install 'Character svo.zip', not anything renamed!\n\n&quot;)
  end)]]

  -- or a non-package... [depreciated]

  local svo_location = getMudletHomeDir() .. _sep .. &quot;svo_location&quot;
  local system_path -- location of the system's folder with a trailing slash
  local f,msg

  if not lfs.attributes(svo_location) then
    system_path = svo_whereisit()
    if not system_path then return end
  else
    f,msg = io.open(svo_location, &quot;r+&quot;)
    assert(f, msg)

    -- this should give us the folder it's in
    system_path = f:read(&quot;*l&quot;)

    if string.sub(system_path, -1) == &quot;/&quot; or string.sub(system_path, -1) == [[\]] then
      system_path = string.sub(system_path, 1, -2)
    end

    -- if we had an invalid path stored
    if not lfs.attributes(system_path) then
      system_path = svo_whereisit()
      if not system_path then return end
    end
  end

  -- re-add the suffix that we might have had to strip earlier for lfs.attributes to work on Windows
  if not (string.sub(system_path, -1) == &quot;/&quot; or string.sub(system_path, -1) == [[\]]) then
    system_path = system_path .. &quot;/&quot;
  end

  local oldpath = package.path
  package.path = system_path .. &quot;?;&quot; .. system_path .. &quot;?.lua;&quot; .. system_path .. &quot;?.dll;&quot; .. system_path .. &quot;?.so;&quot;

  local s,m = pcall(require, &quot;svo&quot;)
  package.path = oldpath

  if not s then display(m) return end

  svo.echofn(&quot;Loaded &amp; ready to go, version %s (&quot;, tostring(svo.version))
  echoLink(&quot;homepage&quot;, '(openUrl or openURL)&quot;http://svof.github.io/svof/&quot;', &quot;Svof homepage&quot;)
  decho(svo.getDefaultColor()..&quot;)\n&quot;)

  -- update file
  if not f then
    f,msg = io.open(svo_location, &quot;w&quot;)
    if not f then display(msg) return end
  else
    f:seek(&quot;set&quot;,0)
  end

  f:write(system_path)
  f:close()
end

-- find the folder
function svo_whereisit()
  local path = invokeFileDialog(false, &quot;Where is the svo folder? Select it and click Open&quot;)

  if path == &quot;&quot; then return nil else return path .. _sep end
end

--load system
svo_load()</script>
            <eventHandlerList/>
        </Script>
    </ScriptPackage>
    <KeyPackage/>
    <HelpPackage>
        <helpURL></helpURL>
    </HelpPackage>
</MudletPackage>
